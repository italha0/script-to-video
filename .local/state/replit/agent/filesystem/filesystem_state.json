{"file_contents":{"middleware.ts":{"content":"import { updateSession } from \"@/lib/supabase/middleware\"\nimport type { NextRequest } from \"next/server\"\nimport { NextResponse } from \"next/server\"\nimport { createServerClient } from \"@supabase/ssr\"\n\n// Extend middleware to preserve original destination when redirecting to login\nexport async function middleware(request: NextRequest) {\n  const response = await updateSession(request)\n\n  // After updateSession we can inspect auth cookie presence via response (no direct user exposed here),\n  // so we rely on the redirect logic already inside updateSession for unauthenticated protected routes.\n  // We only enhance that logic here for auth pages (avoid showing them when already signed in) because\n  // updateSession intentionally doesn't redirect authenticated users away from /auth/*.\n\n  // If user is already authenticated and visits an auth route, redirect to editor.\n  // Use server-validated auth check instead of cookie heuristics to prevent loops with expired tokens\n  if (request.nextUrl.pathname.startsWith(\"/auth\")) {\n    const supabase = createServerClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n      {\n        cookies: {\n          getAll() {\n            return request.cookies.getAll()\n          },\n          setAll() {\n            // No-op for middleware validation check\n          },\n        },\n      },\n    )\n    \n    const { data: { user } } = await supabase.auth.getUser()\n    if (user) {\n      const url = request.nextUrl.clone()\n      url.pathname = \"/editor\"\n      url.search = \"\"\n      return NextResponse.redirect(url)\n    }\n  }\n\n  return response\n}\n\nexport const config = {\n  matcher: [\"/editor/:path*\", \"/auth/:path*\"],\n}\n","size_bytes":1707},"pnpm-lock.yaml":{"content":"lockfileVersion: '9.0'\n\nsettings:\n  autoInstallPeers: true\n  excludeLinksFromLockfile: false","size_bytes":92},"remotion.config.ts":{"content":"import { Config } from '@remotion/cli/config';\n// Add this import\nimport chromium from '@sparticuz/chromium';\n\nConfig.setVideoImageFormat('jpeg');\nConfig.setOverwriteOutput(true);\nConfig.setPixelFormat('yuv420p');\nConfig.setCodec('h264');\n\n// This is the important change\n(async () => {\n  const executablePath = await chromium.executablePath();\n  Config.setBrowserExecutable(executablePath);\n\n  Config.setChromiumDisableWebSecurity(true);\n})();","size_bytes":444},"app/globals.css":{"content":"@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@import \"tw-animate-css\";\n\n/*\n  ClipGoat Light Theme / Pink Accent Design System\n  Light-themed UI with vibrant pink/magenta accent color\n*/\n:root {\n  /* Core surfaces */\n  --background: #f9f9fb;              /* Light lavender background */\n  --background-light: #f9f9fb;        /* Same as background */\n  --card: #ffffff;                    /* Pure white cards */\n  --popover: #ffffff;                 /* Popovers */\n\n  /* Text */\n  --foreground: #1f2937;              /* Dark charcoal gray for primary text */\n  --foreground-muted: #6b7280;        /* Medium gray for secondary text */\n  --card-foreground: #1f2937;\n  --popover-foreground: #1f2937;\n\n  /* Brand / accent */\n  --primary: #e83d84;                 /* Vibrant pink/magenta */\n  --primary-hover: #c12b6d;           /* Slightly darker pink */\n  --primary-foreground: #ffffff;      /* White text on primary */\n  --accent: #f3f4f6;                  /* Light gray accent */\n  --accent-foreground: #1f2937;\n  --secondary: #f3f4f6;               /* Light gray secondary */\n  --secondary-foreground: #1f2937;\n\n  /* UI States */\n  --muted: #f3f4f6;                   /* Light gray muted surface */\n  --muted-foreground: #6b7280;        /* Medium gray muted text */\n  --destructive: #dc2626;             /* Standard red */\n  --destructive-foreground: #ffffff;\n\n  /* Borders & Inputs */\n  --border: #e5e7eb;                  /* Light gray border */\n  --input: #f3f4f6;                   /* Light gray input background */\n  --ring: #e83d84;                    /* Pink focus ring */\n\n  /* Data viz placeholders */\n  --chart-1: #e83d84;\n  --chart-2: #6366f1;\n  --chart-3: #ec4899;\n  --chart-4: #10b981;\n  --chart-5: #f59e0b;\n\n  /* Radius scale */\n  --radius: 0.5rem; /* 8px base (md) */\n\n  /* Sidebar */\n  --sidebar: #ffffff;\n  --sidebar-foreground: #1f2937;\n  --sidebar-primary: #e83d84;\n  --sidebar-primary-foreground: #ffffff;\n  --sidebar-accent: #f3f4f6;\n  --sidebar-accent-foreground: #1f2937;\n  --sidebar-border: #e5e7eb;\n  --sidebar-ring: #e83d84;\n}\n\n@theme inline {\n  --font-sans: var(--font-geist-sans);\n  --font-mono: var(--font-geist-mono);\n  --color-background: var(--background);\n  --color-foreground: var(--foreground);\n  --color-card: var(--card);\n  --color-card-foreground: var(--card-foreground);\n  --color-popover: var(--popover);\n  --color-popover-foreground: var(--popover-foreground);\n  --color-primary: var(--primary);\n  --color-primary-foreground: var(--primary-foreground);\n  --color-secondary: var(--secondary);\n  --color-secondary-foreground: var(--secondary-foreground);\n  --color-muted: var(--muted);\n  --color-muted-foreground: var(--muted-foreground);\n  --color-accent: var(--accent);\n  --color-accent-foreground: var(--accent-foreground);\n  --color-foreground-muted: var(--foreground-muted);\n  --color-primary-hover: var(--primary-hover);\n  --color-destructive: var(--destructive);\n  --color-destructive-foreground: var(--destructive-foreground);\n  --color-border: var(--border);\n  --color-input: var(--input);\n  --color-ring: var(--ring);\n  --color-chart-1: var(--chart-1);\n  --color-chart-2: var(--chart-2);\n  --color-chart-3: var(--chart-3);\n  --color-chart-4: var(--chart-4);\n  --color-chart-5: var(--chart-5);\n  --radius-sm: calc(var(--radius) - 4px);\n  --radius-md: calc(var(--radius) - 2px);\n  --radius-lg: var(--radius);\n  --radius-xl: calc(var(--radius) + 4px);\n  --color-sidebar: var(--sidebar);\n  --color-sidebar-foreground: var(--sidebar-foreground);\n  --color-sidebar-primary: var(--sidebar-primary);\n  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);\n  --color-sidebar-accent: var(--sidebar-accent);\n  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);\n  --color-sidebar-border: var(--sidebar-border);\n  --color-sidebar-ring: var(--sidebar-ring);\n}\n\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  * {\n    @apply border-border;\n  }\n  *:focus {\n    @apply outline-2 outline-ring;\n  }\n  body {\n    @apply bg-background text-foreground;\n    background-color: #f9f9fb;\n  }\n}\n","size_bytes":4093},"app/layout.tsx":{"content":"import type React from \"react\"\nimport type { Metadata } from \"next\"\nimport { Suspense } from \"react\"\nimport { ThemeProvider } from \"@/components/theme-provider\"\nimport { Toaster } from \"@/components/ui/toaster\"\nimport { Analytics } from \"@vercel/analytics/next\"\nimport \"./globals.css\"\nimport Script from \"next/script\"\n\nexport const metadata: Metadata = {\n  title: \"ChatVideo - Turn Chat Scripts into Viral Videos\", icons: {\n    icon: '/favicon.png',   // points to /public/favicon.ico\n  },\n  description:\n    \"Create engaging TikTok, Instagram Reels, and YouTube Shorts from chat conversations. No video editing skills required.\",\n  generator: \"v0.app\",\n}\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode\n}>) {\n  return (\n    <html lang=\"en\" suppressHydrationWarning>\n   \n        \n      <body className=\"font-sans antialiased\">\n        <Script\n          async\n          src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2892825507816139\"\n          crossOrigin=\"anonymous\"\n          strategy=\"afterInteractive\"\n        />\n\n        {/* Google Analytics */}\n        <Script\n          async\n          src=\"https://www.googletagmanager.com/gtag/js?id=G-5Y77DDK7X4\"\n          strategy=\"afterInteractive\"\n        />\n        <Script id=\"gtag-init\" strategy=\"afterInteractive\">\n          {`\n            window.dataLayer = window.dataLayer || [];\n            function gtag(){dataLayer.push(arguments);}\n            gtag('js', new Date());\n            gtag('config', 'G-5Y77DDK7X4');\n          `}\n        </Script>\n        <ThemeProvider attribute=\"class\" defaultTheme=\"light\" forcedTheme=\"light\" enableSystem={false}>\n          <Suspense fallback={null}>{children}</Suspense>\n          <Toaster />\n          <Analytics/>\n        </ThemeProvider>\n      </body>\n    </html>\n  )\n}\n","size_bytes":1843},"app/page.tsx":{"content":"import Link from \"next/link\"\nimport Image from \"next/image\"\nimport { Navbar } from \"@/components/layout/Navbar\"\nimport { HomeSidebar } from \"@/components/landing/HomeSidebar\"\nimport { HomeCard } from \"@/components/landing/HomeCard\"\nimport { MessageSquare, Bookmark, Quote, Calendar, Mic2, PanelRight } from \"lucide-react\"\n\nexport default function HomePage() {\n  return (\n    <div className=\"min-h-screen bg-background text-foreground\">\n      <Navbar />\n      <div className=\"flex h-[calc(100vh-4rem)]\">\n        <HomeSidebar />\n        <main className=\"flex-1 overflow-auto pb-24 md:pb-8\">\n          <div className=\"mx-auto w-full max-w-6xl px-6 md:px-10 py-6 md:py-8\">\n            <div className=\"mb-6 md:mb-8\">\n              <h2 className=\"text-3xl md:text-5xl font-bold\">Hello, <span className=\"text-primary\">Creator</span></h2>\n              <p className=\"text-muted-foreground mt-2\">What are you creating today?</p>\n            </div>\n\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6\">\n            \n              <HomeCard\n                title=\"Fake Text Messages\"\n                description=\"Use AI Text to Speech to bring text messages to life\"\n                href=\"/editor\"\n                gradient=\"bg-gradient-to-r from-cyan-200 to-cyan-300/70\"\n                icon={<MessageSquare className=\"w-4 h-4\" />}\n                imageSrc=\"/text.jpg\"\n              />\n             \n            </div>\n          </div>\n        </main>\n      </div>\n    </div>\n  )\n}\n","size_bytes":1495},"components/VideoPreview.tsx":{"content":"","size_bytes":0},"components/theme-provider.tsx":{"content":"'use client'\n\nimport * as React from 'react'\nimport {\n  ThemeProvider as NextThemesProvider,\n  type ThemeProviderProps,\n} from 'next-themes'\n\nexport function ThemeProvider({ children, ...props }: ThemeProviderProps) {\n  return <NextThemesProvider {...props}>{children}</NextThemesProvider>\n}\n","size_bytes":292},"hooks/use-toast.ts":{"content":"\"use client\"\n\n// Inspired by react-hot-toast library\nimport * as React from \"react\"\n\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 1000000\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\n      // but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n      onOpenChange: (open) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }\n","size_bytes":3948},"lib/azure-blob.ts":{"content":"// Import JS module without TypeScript types (ambient declarations added)\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst { BlobServiceClient, generateBlobSASQueryParameters, BlobSASPermissions, SASProtocol, StorageSharedKeyCredential } = require('@azure/storage-blob');\nimport { extname } from 'path';\nimport { createReadStream } from 'fs';\n\nlet blobServiceClient: any = null;\n\nfunction parseConnectionString(connStr: string): { accountName: string; accountKey: string } {\n  const parts = Object.fromEntries(\n    connStr.split(';')\n      .map((kv) => kv.trim())\n      .filter(Boolean)\n      .map((kv) => {\n        const idx = kv.indexOf('=');\n        return idx === -1 ? [kv, ''] : [kv.slice(0, idx), kv.slice(idx + 1)];\n      })\n  ) as any;\n  const accountName = parts.AccountName || parts.accountname;\n  const accountKey = parts.AccountKey || parts.accountkey;\n  if (!accountName || !accountKey) throw new Error('Invalid AZURE_STORAGE_CONNECTION_STRING: missing AccountName/AccountKey');\n  return { accountName, accountKey };\n}\n\nfunction getBlobServiceClient() {\n  if (blobServiceClient) return blobServiceClient;\n  const connStr = process.env.AZURE_STORAGE_CONNECTION_STRING;\n  if (!connStr) throw new Error('AZURE_STORAGE_CONNECTION_STRING env var required');\n  blobServiceClient = BlobServiceClient.fromConnectionString(connStr);\n  return blobServiceClient;\n}\n\nexport async function uploadToAzureBlob(\n  filePath: string,\n  blobName: string,\n  containerName = 'videos',\n  downloadFilename?: string\n): Promise<string> {\n  const client = getBlobServiceClient();\n  const container = client.getContainerClient(containerName);\n  await container.createIfNotExists();\n  if (!blobName.includes('.')) {\n    // naive ensure extension\n    blobName += extname(filePath) || '.mp4';\n  }\n  const contentDisposition = downloadFilename ? `attachment; filename=\"${downloadFilename}\"` : undefined;\n  const blockBlob = container.getBlockBlobClient(blobName);\n  const stream = createReadStream(filePath);\n  await blockBlob.uploadStream(stream, 4 * 1024 * 1024, 5, {\n    blobHTTPHeaders: { blobContentType: 'video/mp4', contentDisposition },\n  });\n  return blockBlob.name; // return just the blob name; caller can build SAS URL\n}\n\nexport function generateSASUrl(blobName: string, expiryMinutes = 60, containerName = 'videos'): string {\n  const SAS_VERSION = '2023-11-03';\n  // Prefer deriving creds from the same connection string used for upload to avoid mismatches\n  const connStr = process.env.AZURE_STORAGE_CONNECTION_STRING;\n  let accountName = process.env.AZURE_STORAGE_ACCOUNT_NAME;\n  let accountKey = process.env.AZURE_STORAGE_ACCOUNT_KEY;\n  if (connStr) {\n    try {\n      const parsed = parseConnectionString(connStr);\n      accountName = parsed.accountName;\n      accountKey = parsed.accountKey;\n    } catch (e) {\n      // Fall back to explicit envs if parsing fails\n    }\n  }\n  if (!accountName || !accountKey) throw new Error('AZURE storage credentials required (set AZURE_STORAGE_CONNECTION_STRING or AZURE_STORAGE_ACCOUNT_NAME/AZURE_STORAGE_ACCOUNT_KEY)');\n  const sharedKeyCredential = new StorageSharedKeyCredential(accountName, accountKey);\n  const expiresOn = new Date(Date.now() + expiryMinutes * 60 * 1000);\n  const sas = generateBlobSASQueryParameters({\n    containerName,\n    blobName,\n    permissions: BlobSASPermissions.parse('r'),\n    startsOn: new Date(Date.now() - 5 * 60 * 1000),\n    expiresOn,\n    protocol: SASProtocol.Https,\n    version: SAS_VERSION,\n  }, sharedKeyCredential).toString();\n  return `https://${accountName}.blob.core.windows.net/${containerName}/${encodeURIComponent(blobName)}?${sas}`;\n}\n","size_bytes":3640},"lib/queue.ts":{"content":"// Using any types due to missing type declarations in ambient for bullmq\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst { Queue } = require('bullmq');\n\n// Single queue instance used by API routes to enqueue render jobs.\n// Worker side will create a Worker on the same queue name.\nexport const RENDER_QUEUE_NAME = 'video-render-jobs';\n\nlet queue: any = null;\n\nexport function getRenderQueue() {\n  if (!queue) {\n    if (!process.env.REDIS_URL) {\n      throw new Error('REDIS_URL env var required for queue');\n    }\n    queue = new Queue(RENDER_QUEUE_NAME, {\n      // Make Redis fail fast so API routes don't hang and cause 504s\n      connection: {\n        url: process.env.REDIS_URL,\n        connectTimeout: 2000,\n        maxRetriesPerRequest: 1,\n        // enableReadyCheck keeps initial handshake short; with TLS via rediss:// it's auto-negotiated\n        enableReadyCheck: true,\n        keepAlive: 0,\n      },\n      defaultJobOptions: {\n        removeOnComplete: 1000,\n        removeOnFail: 1000,\n        attempts: 3,\n        backoff: { type: 'exponential', delay: 5000 }\n      }\n    });\n  }\n  return queue;\n}\n","size_bytes":1134},"lib/utils.ts":{"content":"import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n","size_bytes":166},"remotion/MessageConversation.tsx":{"content":"import React from 'react';\nimport { AbsoluteFill, useCurrentFrame, useVideoConfig, spring, interpolate } from 'remotion';\nimport { getTheme, ChatTheme } from './themes';\nimport { renderEmojiHTML } from './emoji';\n\ninterface Message { id: number; text: string; sent: boolean; time: string; }\ninterface MessageConversationProps {\n  messages: Message[];\n  typingBeforeIndices?: number[];\n  /** Name shown in the navigation header (receiver / contact). */\n  contactName?: string;\n  /** Battery level 0-100 for status bar icon (defaults to 100). */\n  batteryLevel?: number;\n  /** Theme for the chat interface: 'imessage', 'whatsapp', or 'snapchat' */\n  theme?: string;\n  /** Force the on-screen keyboard to remain visible for the whole preview */\n  alwaysShowKeyboard?: boolean;\n}\n\n// CONFIG\nconst GAP_SECONDS = 2; // base gap inserted after each message (before next starts)\nconst TYPING_DURATION = 1.2; // total lead time allocated for an incoming typing bubble (indicator length + gap before bubble pops to message)\nconst TYPING_GAP = 0.15; // gap between typing indicator end and bubble appear\nconst DELIVERED_DELAY = 0.6; // seconds after last outgoing message finishes typing\n// Keyboard + typing effect configuration\nconst KEYBOARD_HEIGHT = 320; \nconst ACCESSORY_HEIGHT = 56; // taller to support 2-line input without overlap\nconst KEYBOARD_DISAPPEAR_FRAMES = 12; // frames for slide out animation\nconst KEYBOARD_LEAD = 0.8; // seconds keyboard appears before first outgoing message typing begins\nconst KEYBOARD_TRAIL = 0.3; // seconds keyboard stays after last outgoing finishes\nconst TYPE_SPEED = 11; // characters per second (sender typing speed)\nconst SEND_GAP = 0.18; // gap between finish typing and bubble appearing (press send)\nconst SAFE_TOP_INSET = 18; // extra spacing below header to avoid any overlap\n\nconst MessageBubble: React.FC<{ msg: Message; appearSec: number; first: boolean; last: boolean; theme: ChatTheme; }>= ({ msg, appearSec, first, last, theme }) => {\n  const frame = useCurrentFrame();\n  const { fps } = useVideoConfig();\n  const appearFrame = Math.round(appearSec * fps);\n  if (frame < appearFrame) return null;\n  const progress = spring({ frame: frame - appearFrame, fps, config:{ damping: 12, mass:0.9, stiffness:170 } });\n  const translateY = interpolate(progress, [0,1],[24,0]);\n  const scale = interpolate(progress, [0,1],[0.8,1]);\n  \n  const displayText = msg.text;\n  const borderRadius = msg.sent ? theme.bubble.borderRadius.sent : theme.bubble.borderRadius.received;\n  \n  const bubbleStyle: React.CSSProperties = {\n    maxWidth: theme.bubble.maxWidth,\n    padding: theme.bubble.padding,\n    backgroundColor: msg.sent ? theme.colors.sent : theme.colors.received,\n    color: msg.sent ? theme.colors.sentText : theme.colors.receivedText,\n    fontSize: theme.bubble.fontSize,\n    lineHeight: theme.bubble.lineHeight,\n    fontFamily: theme.bubble.fontFamily,\n    wordWrap: 'break-word',\n    whiteSpace: 'pre-wrap',\n    overflowWrap: 'anywhere',\n    borderTopLeftRadius: borderRadius.topLeft(first),\n    borderTopRightRadius: borderRadius.topRight(first),\n    borderBottomLeftRadius: borderRadius.bottomLeft(last),\n    borderBottomRightRadius: borderRadius.bottomRight(last),\n    boxShadow: msg.sent ? theme.bubble.shadow.sent : theme.bubble.shadow.received,\n    letterSpacing: theme.bubble.letterSpacing,\n  };\n  \n  return (\n    <div style={{ display:'flex', justifyContent: msg.sent ? 'flex-end':'flex-start', marginBottom: theme.bubble.marginBottom, transform:`translateY(${translateY}px) scale(${scale})`, opacity: progress }}>\n      <div style={bubbleStyle} dangerouslySetInnerHTML={{ __html: renderEmojiHTML(displayText) }} />\n    </div>\n  );\n};\n\nconst TypingBubble: React.FC<{ startSec: number; endSec: number; sent: boolean; theme: ChatTheme }> = ({ startSec, endSec, sent, theme }) => {\n  const frame = useCurrentFrame();\n  const { fps } = useVideoConfig();\n  const startFrame = Math.round(startSec * fps);\n  const endFrame = Math.round(endSec * fps);\n  if (frame < startFrame || frame > endFrame) return null;\n  const local = frame - startFrame;\n  const progress = spring({ frame: local, fps, config:{ damping:14, mass:0.8, stiffness:140 } });\n  const translateY = interpolate(progress, [0,1],[15,0]);\n  const dot = (i: number) => {\n    const cycle = (local + i * 6) % 45;\n    const scale = interpolate(cycle, [0,15,30,45],[0.4,1,0.4,0.4]);\n    return <div key={i} style={{ width:6, height:6, borderRadius:3, background: sent ? theme.colors.typingDotSent : theme.colors.typingDotReceived, transform:`scale(${scale})`, transition:'transform 0.15s linear' }} />;\n  };\n  return (\n    <div style={{ display:'flex', justifyContent: sent? 'flex-end':'flex-start', marginBottom: theme.bubble.marginBottom, transform:`translateY(${translateY}px)`, opacity:progress }}>\n      <div style={{ display:'flex', gap:6, background: sent ? theme.colors.typingBubbleSent : theme.colors.typingBubbleReceived, padding: theme.bubble.padding, borderRadius:18 }}>\n        {[0,1,2].map(dot)}\n      </div>\n    </div>\n  );\n};\n\nconst Keyboard: React.FC<{ startSec: number; endSec?: number; currentInputText?: string; activeChar?: string; theme: ChatTheme }> = ({ startSec, endSec, currentInputText, activeChar, theme }) => {\n  const frame = useCurrentFrame();\n  const { fps } = useVideoConfig();\n  const startFrame = Math.round(startSec * fps);\n  const endFrame = endSec != null ? Math.round(endSec * fps) : undefined;\n  if (frame < startFrame) return null;\n  if (endFrame !== undefined && frame > endFrame) return null;\n\n  const appearFrames = 12; // frames for slide in\n  const disappearFrames = 12; // frames for slide out\n  const sinceStart = frame - startFrame;\n  const untilEnd = endFrame !== undefined ? endFrame - frame : Infinity;\n\n  const appearProgress = spring({ frame: sinceStart, fps, config:{ damping:16, mass:1, stiffness:180 } });\n  const slideIn = interpolate(appearProgress, [0,1],[KEYBOARD_HEIGHT,0]);\n  let translateY = slideIn;\n  let opacity = appearProgress;\n\n  if (endFrame !== undefined && untilEnd <= disappearFrames) {\n    // animate out\n    const outProgress = 1 - untilEnd / disappearFrames; // 0 -> 1\n    const eased = spring({ frame: Math.round(outProgress * disappearFrames), fps, config:{ damping:18, mass:0.9, stiffness:140 } });\n    const slideOut = interpolate(eased, [0,1],[0, KEYBOARD_HEIGHT]);\n    translateY = slideOut;\n    opacity = 1 - eased * 0.4; // slight fade\n  }\n  const keyRows = [ ['Q','W','E','R','T','Y','U','I','O','P'], ['A','S','D','F','G','H','J','K','L'], ['â‡§','Z','X','C','V','B','N','M','âŒ«'], ['123',':)','space','return'] ];\n  const renderKey = (k: string) => {\n    const isSpace = k==='space';\n    const normalizedActive = (activeChar || '').toLowerCase();\n    const keyChar = isSpace ? ' ' : k.toLowerCase();\n    const isActive = normalizedActive === keyChar && normalizedActive !== '';\n    const baseStyle: React.CSSProperties = {\n      flex: isSpace?4:1,\n      background: isActive ? theme.colors.keyboardKeyActive : theme.colors.keyboardKey,\n      color: isActive ? '#FFFFFF' : '#000',\n      borderRadius: theme.keyboard.keyBorderRadius,\n      padding:'10px 6px',\n      textAlign:'center',\n      fontSize: theme.keyboard.keyFontSize,\n      fontWeight: theme.keyboard.keyFontWeight,\n      boxShadow:'0 1px 0 rgba(0,0,0,0.25)',\n      margin:'0 3px',\n      transform: isActive ? 'translateY(1px)' : 'translateY(0)',\n      transition:'background 80ms ease, color 80ms ease, transform 80ms ease'\n    };\n    return <div key={k} style={baseStyle}>{isSpace? '' : k}</div>;\n  };\n  const caretBlink = (frame / fps) % 1 < 0.5;\n  const showCaret = true;\n  const baseInputText = currentInputText && currentInputText.length>0 ? currentInputText : 'Type a message';\n  const inputHTMLCore = renderEmojiHTML(baseInputText);\n  const caretHTML = showCaret && caretBlink ? `<span style=\"border-left: 2px solid ${theme.colors.sent}; margin-left:2px\"></span>` : '';\n  const inputHTML = (currentInputText && currentInputText.length>0) ? `${inputHTMLCore}${caretHTML}` : `<span style=\"opacity:0.4\">${inputHTMLCore}${caretHTML}</span>`;\n  return (\n    <div style={{ position:'absolute', left:0, right:0, bottom:2, transform:`translateY(${translateY}px)`, background: theme.colors.keyboardBackground, borderTop: `1px solid ${theme.colors.keyboardBorder}`, fontFamily: theme.bubble.fontFamily }}>\n      <div style={{ display:'flex', alignItems:'center', padding:'8px 10px', gap:8, background: theme.colors.headerBackground, minHeight: ACCESSORY_HEIGHT, boxSizing:'border-box' }}>\n        <div style={{ width:32, height:32, borderRadius:16, background: theme.colors.keyboardKeyActive, display:'flex', alignItems:'center', justifyContent:'center' }}>\n          <svg viewBox=\"0 0 24 24\" width={16} height={16} fill=\"#fff\" aria-hidden>\n            <path d=\"M4 7h3l1-2h8l1 2h3a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2zm8 10a4 4 0 1 0 0-8 4 4 0 0 0 0 8z\"/>\n          </svg>\n        </div>\n  <div style={{ flex:1, background: theme.colors.inputBackground, borderRadius:16, padding:'8px 12px', color: theme.colors.inputText, fontSize:16, minHeight:36, maxHeight:72, overflow:'hidden', display:'flex', alignItems:'center', lineHeight:1.25, whiteSpace:'pre-wrap', wordBreak:'break-word' }} dangerouslySetInnerHTML={{ __html: inputHTML }} />\n        <div style={{ width:32, height:32, borderRadius:16, background: theme.colors.sent, display:'flex', alignItems:'center', justifyContent:'center' }}>\n          <svg viewBox=\"0 0 24 24\" width={14} height={14} fill=\"#fff\" aria-hidden>\n            <path d=\"M3 12l18-9-9 18-1.5-6L3 12z\"/>\n          </svg>\n        </div>\n      </div>\n      <div style={{ padding:'6px 6px 6px' }}>\n        {keyRows.map((row,i)=>(<div key={i} style={{ display:'flex', justifyContent:'center', marginBottom:i===keyRows.length-1?0:6 }}>{row.map(renderKey)}</div>))}\n      </div>\n    </div>\n  );\n};\n\nconst StatusBar: React.FC<{ batteryLevel?: number; theme: ChatTheme }> = ({ batteryLevel = 100, theme }) => {\n  const clamped = Math.min(100, Math.max(0, batteryLevel));\n  return (\n  <div style={{ position:'absolute', top:0, left:0, right:0, height: theme.statusBar.height, display:'flex', alignItems:'center', justifyContent:'space-between', padding:'0 18px', fontSize: theme.statusBar.fontSize, fontWeight: theme.statusBar.fontWeight, fontFamily: theme.bubble.fontFamily, color: theme.colors.statusBar, zIndex:1000, background:'#FFFFFF' }}>\n      <div>9:41</div>\n      <div style={{ display:'flex', alignItems:'center', gap:8 }}>\n        {/* Signal Bars */}\n        <div style={{ display:'flex', alignItems:'flex-end', gap:2 }}>\n          {[4,7,10,13].map((h,i)=>(<div key={i} style={{ width:3, height:h, background: theme.colors.statusBar, borderRadius:1 }} />))}\n        </div>\n        {/* Wi-Fi (simple) */}\n        <div style={{ position:'relative', width:18, height:14 }}>\n          <svg viewBox=\"0 0 20 14\" width={18} height={14}>\n            <path d=\"M10 13c.9 0 1.6-.7 1.6-1.6S10.9 9.8 10 9.8 8.4 10.5 8.4 11.4 9.1 13 10 13Z\" fill={theme.colors.statusBar} />\n            <path d=\"M3.3 6.6a9.2 9.2 0 0 1 13.4 0l-1.2 1.2a7.5 7.5 0 0 0-11 0L3.3 6.6Z\" fill={theme.colors.statusBar} />\n            <path d=\"M6.2 9.3a5.3 5.3 0 0 1 7.6 0l-1.2 1.2a3.6 3.6 0 0 0-5.2 0l-1.2-1.2Z\" fill={theme.colors.statusBar} />\n          </svg>\n        </div>\n        {/* Battery */}\n        <div style={{ position:'relative', width:28, height:14, border: `2px solid ${theme.colors.statusBar}`, borderRadius:4, display:'flex', alignItems:'center', padding:'0 3px', boxSizing:'border-box' }}>\n          <div style={{ position:'absolute', top:3, right:-5, width:3, height:8, background: theme.colors.statusBar, borderRadius:1 }} />\n          <div style={{ width:`${clamped}%`, height:6, background: clamped < 20 ? '#FF3B30' : theme.colors.statusBar, borderRadius:2, transition:'width 0.3s' }} />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nconst NavigationHeader: React.FC<{ contactName?: string; theme: ChatTheme }> = ({ contactName, theme }) => (\n  <div style={{ position:'absolute', top: theme.statusBar.height, left:0, right:0, height: theme.header.height, background: theme.colors.headerBackground, borderBottom: `1px solid ${theme.colors.headerBorder}`, display:'flex', alignItems:'center', padding:'0 12px', fontFamily: theme.bubble.fontFamily, zIndex:900 }}>\n    <div style={{ fontSize: theme.header.fontSize, color: theme.colors.headerText }}>Back</div>\n    <div style={{ position:'absolute', left:'50%', transform:'translateX(-50%)', fontSize: theme.header.fontSize, fontWeight: theme.header.fontWeight, color: theme.colors.headerText }}>{contactName || 'Contact'}</div>\n  </div>\n);\n\n// Inline delivered label component\nconst DeliveredBelow: React.FC<{ startSec: number; theme: ChatTheme }> = ({ startSec, theme }) => {\n  const frame = useCurrentFrame();\n  const { fps } = useVideoConfig();\n  const startFrame = Math.round(startSec * fps);\n  if (frame < startFrame) return null;\n  const progress = spring({ frame: frame - startFrame, fps, config:{ damping:20, stiffness:170, mass:0.8 } });\n  const opacity = interpolate(progress, [0,1],[0,1]);\n  const translateY = interpolate(progress, [0,1],[6,0]);\n  return (\n    <div style={{ display:'flex', justifyContent:'flex-end', marginTop:4, transform:`translateY(${translateY}px)`, opacity }}>\n      <div style={{ fontSize:12, color: theme.colors.deliveredText, fontFamily: theme.bubble.fontFamily }}>Delivered</div>\n    </div>\n  );\n};\n\nexport const MessageConversation: React.FC<MessageConversationProps> = ({ messages, typingBeforeIndices, contactName, batteryLevel, theme: themeName = 'imessage', alwaysShowKeyboard }) => {\n  const theme = getTheme(themeName);\n  const frame = useCurrentFrame();\n  const { fps } = useVideoConfig();\n  // Precompute a dynamic timeline for all messages.\n  type TimelineEntry = {\n    idx: number;\n    msg: Message;\n  appearSec: number; // when bubble mounts (after typing for outgoing)\n  typingStart?: number;\n  typingEnd?: number;\n  typingDuration: number; // only for outgoing\n  endSec: number; // timeline anchor (bubble appear)\n    typingIndicatorStart?: number; // for incoming typing indicator\n    typingIndicatorEnd?: number;   // end of indicator (before gap)\n  };\n\n  const entries: TimelineEntry[] = [];\n  let prevEnd = 0; // end time of previous sequence\n  for (let i=0;i<messages.length;i++) {\n    const m = messages[i];\n    // Should we show a typing indicator before this message (incoming after an outgoing)?\n    const indicatorForced = typingBeforeIndices?.includes(i);\n    const autoIndicator = !m.sent && i>0 && messages[i-1].sent;\n    const showIndicator = indicatorForced || autoIndicator;\n\n    const base = i===0 ? 0 : prevEnd + GAP_SECONDS; // base time before any typing indicator or bubble\n    let typingIndicatorStart: number | undefined;\n    let typingIndicatorEnd: number | undefined;\n    let appearSec: number;\n    let typingStart: number | undefined;\n    let typingEnd: number | undefined;\n    let typingDuration = 0;\n    if (m.sent) {\n      typingDuration = m.text.length / TYPE_SPEED;\n      typingStart = base;\n      typingEnd = typingStart + typingDuration;\n      appearSec = typingEnd + SEND_GAP; // bubble after send\n    } else {\n      if (showIndicator) {\n        typingIndicatorStart = base;\n        typingIndicatorEnd = typingIndicatorStart + (TYPING_DURATION - TYPING_GAP);\n        appearSec = base + TYPING_DURATION;\n      } else {\n        appearSec = base;\n      }\n    }\n    const endSec = appearSec;\n    entries.push({ idx:i, msg:m, appearSec, typingStart, typingEnd, typingDuration, endSec, typingIndicatorStart, typingIndicatorEnd });\n    prevEnd = endSec;\n  }\n\n  // Keyboard timings: from just before first outgoing begins to shortly after last outgoing finished\n  const firstSent = entries.find(e=> e.msg.sent);\n  const lastSent = [...entries].reverse().find(e=> e.msg.sent);\n  const keyboardStart = alwaysShowKeyboard ? 0 : (firstSent ? Math.max(0, (firstSent.typingStart ?? firstSent.appearSec) - KEYBOARD_LEAD) : null);\n  const keyboardEnd = alwaysShowKeyboard ? undefined : (lastSent ? (lastSent.typingEnd ?? lastSent.appearSec) + KEYBOARD_TRAIL : undefined);\n  const deliveredStartSec = lastSent ? lastSent.appearSec + DELIVERED_DELAY : null;\n\n  // Derive current input text\n  const currentSec = frame / fps;\n  let currentInputText = '';\n  let activeChar = '';\n  if (keyboardStart != null && currentSec >= keyboardStart && (!keyboardEnd || currentSec <= keyboardEnd)) {\n    const active = entries.find(e => e.msg.sent && e.typingStart !== undefined && e.typingEnd !== undefined && currentSec >= e.typingStart && currentSec < e.typingEnd);\n    if (active && active.typingStart !== undefined) {\n      const elapsed = currentSec - active.typingStart;\n      const chars = Math.min(active.msg.text.length, Math.floor(elapsed * TYPE_SPEED));\n      currentInputText = active.msg.text.slice(0, chars);\n      if (chars < active.msg.text.length) {\n        // character currently being typed (next char appearing)\n        activeChar = active.msg.text.charAt(chars).toLowerCase();\n      }\n    } else {\n      const sending = entries.find(e => e.msg.sent && e.typingEnd !== undefined && currentSec >= e.typingEnd && currentSec < e.appearSec);\n      if (sending) currentInputText = sending.msg.text;\n    }\n  }\n\n  // Compute dynamic bottom padding based on keyboard slide animation\n  let keyboardVisibleHeight = 0;\n  if (keyboardStart != null) {\n    const ks = Math.round(keyboardStart * fps);\n    if (frame >= ks) {\n      if (keyboardEnd == null || frame < Math.round(keyboardEnd * fps) - KEYBOARD_DISAPPEAR_FRAMES) {\n        // Appearing or steady\n        const sinceStart = frame - ks;\n        const appearProgress = spring({ frame: sinceStart, fps, config:{ damping:16, mass:1, stiffness:180 } });\n        const slideIn = interpolate(appearProgress, [0,1],[KEYBOARD_HEIGHT,0]);\n        keyboardVisibleHeight = KEYBOARD_HEIGHT - slideIn;\n      } else {\n        // Disappearing\n        const ke = Math.round((keyboardEnd as number) * fps);\n        const untilEnd = ke - frame;\n        const outProgress = 1 - untilEnd / KEYBOARD_DISAPPEAR_FRAMES;\n        const eased = spring({ frame: Math.round(outProgress * KEYBOARD_DISAPPEAR_FRAMES), fps, config:{ damping:18, mass:0.9, stiffness:140 } });\n        const slideOut = interpolate(eased, [0,1],[0, KEYBOARD_HEIGHT]);\n        keyboardVisibleHeight = KEYBOARD_HEIGHT - slideOut;\n      }\n    }\n  }\n\n  const headerHeight = theme.statusBar.height + theme.header.height;\n  return (\n    <AbsoluteFill style={{ background:'transparent', fontFamily: theme.bubble.fontFamily, display:'flex', alignItems:'center', justifyContent:'center' }}>\n      <div style={{ width:360, height:780, background: theme.colors.background, borderRadius:48, position:'relative', overflow:'hidden', boxShadow:'0 8px 24px rgba(0,0,0,0.25)', border:'0px solid transparent', isolation:'isolate' }}>\n        <StatusBar batteryLevel={batteryLevel} theme={theme} />\n        <NavigationHeader contactName={contactName} theme={theme} />\n  <div style={{ position:'absolute', top: headerHeight + SAFE_TOP_INSET, left:0, right:0, bottom:0, padding:'8px 12px 0', paddingBottom: Math.max(0, keyboardVisibleHeight - ACCESSORY_HEIGHT), display:'flex', flexDirection:'column', justifyContent:'flex-end', boxSizing:'border-box', zIndex:100 }}>\n          {entries.map(entry=>{\n            const { msg, idx, appearSec, typingIndicatorStart, typingIndicatorEnd } = entry;\n            const prev = entries[idx-1]?.msg;\n            const next = entries[idx+1]?.msg;\n            const first = !prev || prev.sent !== msg.sent;\n            const last = !next || next.sent !== msg.sent;\n            return (\n              <React.Fragment key={msg.id}>\n                {typingIndicatorStart !== undefined && typingIndicatorEnd !== undefined && (\n                  <TypingBubble startSec={typingIndicatorStart} endSec={typingIndicatorEnd} sent={false} theme={theme} />\n                )}\n                <MessageBubble msg={msg} appearSec={appearSec} first={first} last={last} theme={theme} />\n                {deliveredStartSec != null && lastSent && lastSent.idx === idx && (\n                  <DeliveredBelow startSec={deliveredStartSec} theme={theme} />\n                )}\n              </React.Fragment>\n            );\n          })}\n        </div>\n        {keyboardStart != null && (\n          <div style={{ position:'absolute', left:0, right:0, bottom:0, zIndex:25 }}>\n            <Keyboard startSec={keyboardStart} endSec={keyboardEnd} currentInputText={currentInputText} activeChar={activeChar} theme={theme} />\n          </div>\n        )}\n      </div>\n    </AbsoluteFill>\n  );\n};\n","size_bytes":20679},"remotion/Root.tsx":{"content":"import React from 'react';\nimport { Composition } from 'remotion';\nimport { MessageConversation } from './MessageConversation';\n\nexport const RemotionRoot: React.FC = () => {\n  return (\n    <>\n      <Composition\n        id=\"MessageConversation\"\n        component={MessageConversation as any}\n        durationInFrames={600} // 20 seconds at 30fps\n        fps={30}\n        width={390}\n        height={844}\n        defaultProps={{\n          contactName: 'Alex',\n          theme: 'imessage',\n          alwaysShowKeyboard: true,\n          messages: [\n            { id: 1, text: \"oh no.\", sent: false, time: \"0:00\" },\n            { id: 2, text: \"i thought you meant.\", sent: false, time: \"0:02\" },\n            { id: 3, text: \"wow this is awkward\", sent: false, time: \"0:04\" },\n            { id: 4, text: \"i thought you liked me too.\", sent: false, time: \"0:06\" },\n            { id: 5, text: \"HAHAHA\", sent: true, time: \"0:08\" },\n            { id: 6, text: \"I'M JUST KIDDING\", sent: true, time: \"0:10\" },\n            { id: 7, text: \"I LIKE YOU TOO\", sent: true, time: \"0:12\" },\n            { id: 8, text: \"you do?! ðŸ˜Š\", sent: false, time: \"0:14\" },\n          ]\n        }}\n      />\n    </>\n  );\n};\n","size_bytes":1192},"remotion/index.ts":{"content":"import { registerRoot } from 'remotion';\nimport { RemotionRoot } from './Root';\nexport { RemotionRoot } from './Root';\nexport { MessageConversation } from './MessageConversation';\n\n// Register root for Remotion bundler programmatic usage\nregisterRoot(RemotionRoot);\n","size_bytes":266},"styles/globals.css":{"content":"@import 'tailwindcss';\n@import 'tw-animate-css';\n\n@custom-variant dark (&:is(.dark *));\n\n:root {\n  --background: oklch(1 0 0);\n  --foreground: oklch(0.145 0 0);\n  --card: oklch(1 0 0);\n  --card-foreground: oklch(0.145 0 0);\n  --popover: oklch(1 0 0);\n  --popover-foreground: oklch(0.145 0 0);\n  --primary: oklch(0.205 0 0);\n  --primary-foreground: oklch(0.985 0 0);\n  --secondary: oklch(0.97 0 0);\n  --secondary-foreground: oklch(0.205 0 0);\n  --muted: oklch(0.97 0 0);\n  --muted-foreground: oklch(0.556 0 0);\n  --accent: oklch(0.97 0 0);\n  --accent-foreground: oklch(0.205 0 0);\n  --destructive: oklch(0.577 0.245 27.325);\n  --destructive-foreground: oklch(0.577 0.245 27.325);\n  --border: oklch(0.922 0 0);\n  --input: oklch(0.922 0 0);\n  --ring: oklch(0.708 0 0);\n  --chart-1: oklch(0.646 0.222 41.116);\n  --chart-2: oklch(0.6 0.118 184.704);\n  --chart-3: oklch(0.398 0.07 227.392);\n  --chart-4: oklch(0.828 0.189 84.429);\n  --chart-5: oklch(0.769 0.188 70.08);\n  --radius: 0.625rem;\n  --sidebar: oklch(0.985 0 0);\n  --sidebar-foreground: oklch(0.145 0 0);\n  --sidebar-primary: oklch(0.205 0 0);\n  --sidebar-primary-foreground: oklch(0.985 0 0);\n  --sidebar-accent: oklch(0.97 0 0);\n  --sidebar-accent-foreground: oklch(0.205 0 0);\n  --sidebar-border: oklch(0.922 0 0);\n  --sidebar-ring: oklch(0.708 0 0);\n}\n\n.dark {\n  --background: oklch(0.145 0 0);\n  --foreground: oklch(0.985 0 0);\n  --card: oklch(0.145 0 0);\n  --card-foreground: oklch(0.985 0 0);\n  --popover: oklch(0.145 0 0);\n  --popover-foreground: oklch(0.985 0 0);\n  --primary: oklch(0.985 0 0);\n  --primary-foreground: oklch(0.205 0 0);\n  --secondary: oklch(0.269 0 0);\n  --secondary-foreground: oklch(0.985 0 0);\n  --muted: oklch(0.269 0 0);\n  --muted-foreground: oklch(0.708 0 0);\n  --accent: oklch(0.269 0 0);\n  --accent-foreground: oklch(0.985 0 0);\n  --destructive: oklch(0.396 0.141 25.723);\n  --destructive-foreground: oklch(0.637 0.237 25.331);\n  --border: oklch(0.269 0 0);\n  --input: oklch(0.269 0 0);\n  --ring: oklch(0.439 0 0);\n  --chart-1: oklch(0.488 0.243 264.376);\n  --chart-2: oklch(0.696 0.17 162.48);\n  --chart-3: oklch(0.769 0.188 70.08);\n  --chart-4: oklch(0.627 0.265 303.9);\n  --chart-5: oklch(0.645 0.246 16.439);\n  --sidebar: oklch(0.205 0 0);\n  --sidebar-foreground: oklch(0.985 0 0);\n  --sidebar-primary: oklch(0.488 0.243 264.376);\n  --sidebar-primary-foreground: oklch(0.985 0 0);\n  --sidebar-accent: oklch(0.269 0 0);\n  --sidebar-accent-foreground: oklch(0.985 0 0);\n  --sidebar-border: oklch(0.269 0 0);\n  --sidebar-ring: oklch(0.439 0 0);\n}\n\n@theme inline {\n  --font-sans: var(--font-geist-sans);\n  --font-mono: var(--font-geist-mono);\n  --color-background: var(--background);\n  --color-foreground: var(--foreground);\n  --color-card: var(--card);\n  --color-card-foreground: var(--card-foreground);\n  --color-popover: var(--popover);\n  --color-popover-foreground: var(--popover-foreground);\n  --color-primary: var(--primary);\n  --color-primary-foreground: var(--primary-foreground);\n  --color-secondary: var(--secondary);\n  --color-secondary-foreground: var(--secondary-foreground);\n  --color-muted: var(--muted);\n  --color-muted-foreground: var(--muted-foreground);\n  --color-accent: var(--accent);\n  --color-accent-foreground: var(--accent-foreground);\n  --color-destructive: var(--destructive);\n  --color-destructive-foreground: var(--destructive-foreground);\n  --color-border: var(--border);\n  --color-input: var(--input);\n  --color-ring: var(--ring);\n  --color-chart-1: var(--chart-1);\n  --color-chart-2: var(--chart-2);\n  --color-chart-3: var(--chart-3);\n  --color-chart-4: var(--chart-4);\n  --color-chart-5: var(--chart-5);\n  --radius-sm: calc(var(--radius) - 4px);\n  --radius-md: calc(var(--radius) - 2px);\n  --radius-lg: var(--radius);\n  --radius-xl: calc(var(--radius) + 4px);\n  --color-sidebar: var(--sidebar);\n  --color-sidebar-foreground: var(--sidebar-foreground);\n  --color-sidebar-primary: var(--sidebar-primary);\n  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);\n  --color-sidebar-accent: var(--sidebar-accent);\n  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);\n  --color-sidebar-border: var(--sidebar-border);\n  --color-sidebar-ring: var(--sidebar-ring);\n}\n\n@layer base {\n  * {\n    @apply border-border outline-ring/50;\n  }\n  body {\n    @apply bg-background text-foreground;\n  }\n}\n","size_bytes":4337},"types/ambient.d.ts":{"content":"declare module 'bullmq';\ndeclare module '@azure/storage-blob';","size_bytes":62},"worker/README.md":{"content":"# Worker (no Docker quickstart)\n\n1) Create a `.env` file in the project root (same folder as package.json) with:\n\n```\nNEXT_PUBLIC_SUPABASE_URL=...\nSUPABASE_SERVICE_ROLE_KEY=...\nAZURE_STORAGE_CONNECTION_STRING=...\nAZURE_STORAGE_ACCOUNT_NAME=...\nAZURE_STORAGE_ACCOUNT_KEY=...\n# Optional when not using Redis from API\nRENDER_QUEUE_ENABLED=false\n# Optional temp dir\nWORK_DIR=%TEMP%\n```\n\n2) Install deps:\n\n```\npnpm install\n```\n\n3) Run the worker directly:\n\n```\nnode worker/worker.cjs\n```\n\nNotes:\n- With `RENDER_QUEUE_ENABLED=false`, the worker will poll Supabase every ~15s for recent `pending` jobs and process them.\n- If you enable queueing, set `RENDER_QUEUE_ENABLED=true` and provide `REDIS_URL` (TLS: `rediss://...:6380`).\n- Ensure the API host has the same Supabase and Azure envs so it can insert jobs.\n\n## Deploying the worker (production)\n\nYou need a long-running process in production to consume jobs and upload to Azure. Two simple options:\n\n### Option A: Azure Container Apps\n1. Build and push the worker image:\n\t```cmd\n\tdocker build -f Dockerfile.worker -t <your-registry>/script-to-video-worker:latest .\n\tdocker push <your-registry>/script-to-video-worker:latest\n\t```\n2. Create an Azure Container App pointing to the image. Configure env vars (same as your API):\n\t- `NEXT_PUBLIC_SUPABASE_URL`\n\t- `SUPABASE_SERVICE_ROLE_KEY`\n\t- `AZURE_STORAGE_CONNECTION_STRING`\n\t- `AZURE_STORAGE_ACCOUNT_NAME`\n\t- `AZURE_STORAGE_ACCOUNT_KEY`\n\t- Optional queue: `RENDER_QUEUE_ENABLED=true`, `REDIS_URL=rediss://:<pwd>@<host>:6380`\n3. Set CPU/memory (e.g., 1 vCPU / 2 GB) and min replicas â‰¥ 1.\n4. Verify logs show \"Polling fallback active\" or \"Queue worker started\" and that jobs move to `done`.\n\n### Option B: Render.com (or Railway/Fly.io)\n1. Create a new \"Background Worker\" service from your GitHub repo.\n2. Start command: `node worker/worker.cjs`\n3. Env vars: same list as above. Leave Redis unset for polling mode, or set for queue mode.\n4. Deploy and monitor logs. Scale instances if needed.\n\n### Notes\n- Polling mode (no Redis) is fine for most small/medium workloads.\n- Queue mode (Redis) is recommended for higher throughput or when you need backpressure and retries. Ensure `REDIS_URL` is valid to avoid WRONGPASS errors.\n- Make sure the worker Supabase envs point to the same project as the API. Otherwise it wonâ€™t see the jobs your API inserted.\n","size_bytes":2352},"app/editor/page.tsx":{"content":"import { redirect } from \"next/navigation\"\nimport { MainLayout } from \"@/components/layout/MainLayout\"\nimport { createClient } from \"@/lib/supabase/server\"\n\nexport default async function EditorPage() {\n  const supabase = await createClient()\n  const { data: { user } } = await supabase.auth.getUser()\n\n  if (!user) {\n    redirect(`/auth/login?redirect=${encodeURIComponent('/editor')}`)\n  }\n\n  return <MainLayout />\n}","size_bytes":417},"app/pricing/page.tsx":{"content":"\"use client\"\n\nimport { useState } from \"react\"\nimport { Button } from \"@/components/ui/button\"\nimport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from \"@/components/ui/card\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { Check, Sparkles, Video, Palette, Download } from \"lucide-react\"\nimport Link from \"next/link\"\n\nconst plans = [\n  {\n    name: \"Free\",\n    price: \"$0\",\n    period: \"forever\",\n    description: \"Perfect for trying out ChatVideo\",\n    features: [\n      \"Create unlimited chat scripts\",\n      \"720p video exports\",\n      \"Basic themes\",\n      \"Watermarked videos\",\n      \"Up to 5 saved scripts\",\n    ],\n    limitations: [\"Watermarked videos\", \"Limited themes\", \"720p quality only\"],\n    cta: \"Get Started\",\n    popular: false,\n    href: \"/auth/signup\",\n  },\n  {\n    name: \"Pro\",\n    price: \"$9.99\",\n    period: \"month\",\n    description: \"For creators who want the best quality\",\n    features: [\n      \"Everything in Free\",\n      \"1080p HD video exports\",\n      \"No watermarks\",\n      \"Premium themes & styles\",\n      \"Unlimited saved scripts\",\n      \"Priority support\",\n      \"Custom avatars\",\n      \"Advanced animations\",\n    ],\n    cta: \"Upgrade to Pro\",\n    popular: true,\n    href: \"/auth/signup?plan=pro\",\n  },\n]\n\nexport default function PricingPage() {\n  const [isYearly, setIsYearly] = useState(false)\n\n  return (\n    <div className=\"min-h-screen bg-background\">\n      <div className=\"max-w-6xl mx-auto px-4 py-20\">\n        {/* Header */}\n        <div className=\"text-center mb-20\">\n          <Badge variant=\"secondary\" className=\"mb-5 bg-primary/15 text-primary border-primary/30\">\n            <Sparkles className=\"w-3 h-3 mr-1\" /> Pricing\n          </Badge>\n          <h1 className=\"text-4xl md:text-5xl font-extrabold leading-tight mb-6\">\n            <span className=\"block bg-gradient-to-r from-primary via-primary-hover to-primary/70 bg-clip-text text-transparent\">Choose Your Plan</span>\n          </h1>\n          <p className=\"text-lg md:text-xl text-foreground-muted max-w-2xl mx-auto\">Start free and upgrade when you're ready for more power.</p>\n        </div>\n\n        {/* Billing Toggle */}\n        <div className=\"flex items-center justify-center mb-16\">\n          <span className={`mr-3 text-sm ${!isYearly ? \"text-foreground\" : \"text-foreground-muted\"}`}>Monthly</span>\n          <button\n            onClick={() => setIsYearly(!isYearly)}\n            className={`relative inline-flex h-7 w-12 items-center rounded-full transition-colors ${isYearly ? \"bg-primary\" : \"bg-background-light\"} border border-border`}\n          >\n            <span\n              className={`flex h-5 w-5 transform rounded-full bg-white text-[10px] font-medium items-center justify-center transition-transform ${isYearly ? \"translate-x-6\" : \"translate-x-1\"}`}\n            >{isYearly?\"Y\":\"M\"}</span>\n          </button>\n          <span className={`ml-3 text-sm ${isYearly ? \"text-foreground\" : \"text-foreground-muted\"}`}>\n            Yearly\n            <Badge variant=\"secondary\" className=\"ml-2 bg-primary/15 text-primary border-primary/30\">Save 20%</Badge>\n          </span>\n        </div>\n\n        {/* Pricing Cards */}\n        <div className=\"grid md:grid-cols-2 gap-10 max-w-4xl mx-auto\">\n          {plans.map((plan) => (\n            <Card key={plan.name} className={`relative bg-background-light/80 backdrop-blur-sm border-border/70 ${plan.popular ? \"shadow-[0_8px_32px_-10px_rgba(138,43,226,0.5)] border-primary\" : \"\"}`}>\n              {plan.popular && (\n                <Badge className=\"absolute -top-3 left-1/2 -translate-x-1/2 bg-primary/20 text-primary border-primary/40\">Most Popular</Badge>\n              )}\n\n              <CardHeader className=\"text-center pb-8\">\n                <CardTitle className=\"text-2xl\">{plan.name}</CardTitle>\n                <CardDescription className=\"text-base text-foreground-muted\">{plan.description}</CardDescription>\n                <div className=\"mt-4\">\n                  <span className=\"text-4xl font-bold\">{plan.name === \"Pro\" && isYearly ? \"$7.99\" : plan.price}</span>\n                  {plan.period !== \"forever\" && (<span className=\"text-foreground-muted\">/{isYearly ? \"month\" : plan.period}</span>)}\n                  {plan.name === \"Pro\" && isYearly && (<div className=\"text-xs text-foreground-muted mt-1\">Billed annually ($95.88/yr)</div>)}\n                </div>\n              </CardHeader>\n\n              <CardContent className=\"space-y-4\">\n                {plan.features.map((feature) => (\n                  <div key={feature} className=\"flex items-start gap-3\">\n                    <Check className=\"w-5 h-5 text-primary mt-0.5 flex-shrink-0\" />\n                    <span className=\"text-sm text-foreground-muted\">{feature}</span>\n                  </div>\n                ))}\n              </CardContent>\n\n              <CardFooter>\n                <Button asChild className=\"w-full\" variant={plan.popular ? \"default\" : \"outline\"} size=\"lg\">\n                  <Link href={plan.href}>{plan.cta}</Link>\n                </Button>\n              </CardFooter>\n            </Card>\n          ))}\n        </div>\n\n        {/* Feature Comparison */}\n  <div className=\"mt-24\">\n    <h2 className=\"text-3xl font-bold text-center mb-12\">Feature Comparison</h2>\n    <div className=\"grid md:grid-cols-3 gap-8 max-w-4xl mx-auto\">\n            <Card>\n              <CardHeader className=\"text-center\">\n                <Video className=\"w-8 h-8 mx-auto mb-2 text-primary\" />\n                <CardTitle>Video Quality</CardTitle>\n              </CardHeader>\n              <CardContent className=\"space-y-3\">\n                <div className=\"flex justify-between\">\n                  <span>Free</span>\n      <span className=\"text-foreground-muted\">720p</span>\n                </div>\n                <div className=\"flex justify-between\">\n                  <span>Pro</span>\n      <span className=\"text-primary font-semibold\">1080p HD</span>\n                </div>\n              </CardContent>\n            </Card>\n\n    <Card>\n              <CardHeader className=\"text-center\">\n                <Palette className=\"w-8 h-8 mx-auto mb-2 text-primary\" />\n                <CardTitle>Themes & Styles</CardTitle>\n              </CardHeader>\n              <CardContent className=\"space-y-3\">\n                <div className=\"flex justify-between\">\n                  <span>Free</span>\n      <span className=\"text-foreground-muted\">3 basic themes</span>\n                </div>\n                <div className=\"flex justify-between\">\n                  <span>Pro</span>\n      <span className=\"text-primary font-semibold\">20+ premium themes</span>\n                </div>\n              </CardContent>\n            </Card>\n\n    <Card>\n              <CardHeader className=\"text-center\">\n                <Download className=\"w-8 h-8 mx-auto mb-2 text-primary\" />\n                <CardTitle>Exports</CardTitle>\n              </CardHeader>\n              <CardContent className=\"space-y-3\">\n                <div className=\"flex justify-between\">\n                  <span>Free</span>\n      <span className=\"text-foreground-muted\">With watermark</span>\n                </div>\n                <div className=\"flex justify-between\">\n                  <span>Pro</span>\n      <span className=\"text-primary font-semibold\">No watermark</span>\n                </div>\n              </CardContent>\n            </Card>\n          </div>\n        </div>\n\n        {/* FAQ */}\n        <div className=\"mt-24 max-w-2xl mx-auto\">\n          <h2 className=\"text-3xl font-bold text-center mb-12\">Frequently Asked Questions</h2>\n          <div className=\"space-y-6\">\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"text-lg\">Can I cancel anytime?</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <p className=\"text-foreground-muted\">\n                  Yes! You can cancel your Pro subscription at any time. You'll continue to have access to Pro features\n                  until the end of your billing period.\n                </p>\n              </CardContent>\n            </Card>\n\n      <Card>\n              <CardHeader>\n                <CardTitle className=\"text-lg\">What happens to my videos if I downgrade?</CardTitle>\n              </CardHeader>\n              <CardContent>\n        <p className=\"text-foreground-muted\">\n                  All videos you've already created will remain yours forever. However, new videos will include\n                  watermarks and be limited to 720p quality.\n                </p>\n              </CardContent>\n            </Card>\n\n      <Card>\n              <CardHeader>\n                <CardTitle className=\"text-lg\">Do you offer refunds?</CardTitle>\n              </CardHeader>\n              <CardContent>\n        <p className=\"text-foreground-muted\">\n                  We offer a 30-day money-back guarantee. If you're not satisfied with ChatVideo Pro, contact us for a\n                  full refund.\n                </p>\n              </CardContent>\n            </Card>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n","size_bytes":9078},"components/ui/badge.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90\",\n        destructive:\n          \"border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nfunction Badge({\n  className,\n  variant,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"span\"> &\n  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : \"span\"\n\n  return (\n    <Comp\n      data-slot=\"badge\"\n      className={cn(badgeVariants({ variant }), className)}\n      {...props}\n    />\n  )\n}\n\nexport { Badge, badgeVariants }\n","size_bytes":1631},"components/ui/button.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\n// Clipgoat-style variants (dark-first, purple accent, subtle depth)\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:ring-ring/60 focus-visible:ring-[3px] focus-visible:border-transparent aria-invalid:ring-destructive/30 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        // Primary: solid purple, hover lighter purple, subtle glow\n        default: \"bg-primary text-primary-foreground shadow-[0_2px_8px_-2px_rgba(138,43,226,0.55)] hover:bg-primary-hover hover:shadow-[0_4px_18px_-4px_rgba(138,43,226,0.65)]\",\n        destructive: \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n        // Outline: muted text, border, hover card surface + foreground text\n        outline: \"border border-border bg-transparent text-foreground-muted hover:bg-card hover:text-foreground shadow-[0_0_0_1px_var(--border)]\",\n        secondary: \"bg-background-light text-foreground hover:bg-background/70\",\n        // Ghost: transparent, muted text, hover card surface\n        ghost: \"text-foreground-muted hover:text-foreground hover:bg-card\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant,\n  size,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"button\"> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n  }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      className={cn(buttonVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n","size_bytes":2291},"components/ui/card.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Card({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card\"\n      className={cn(\n        \"bg-card text-card-foreground flex flex-col gap-6 rounded-lg border border-border/80 py-6 shadow-[0_4px_16px_-4px_rgba(0,0,0,0.4),0_0_0_1px_rgba(255,255,255,0.02)]\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction CardHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-header\"\n      className={cn(\n        \"@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction CardTitle({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-title\"\n  className={cn(\"leading-none font-semibold text-foreground\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction CardDescription({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-description\"\n  className={cn(\"text-foreground-muted text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction CardAction({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-action\"\n      className={cn(\n        \"col-start-2 row-span-2 row-start-1 self-start justify-self-end\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction CardContent({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-content\"\n      className={cn(\"px-6\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction CardFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-footer\"\n      className={cn(\"flex items-center px-6 [.border-t]:pt-6\", className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Card,\n  CardHeader,\n  CardFooter,\n  CardTitle,\n  CardAction,\n  CardDescription,\n  CardContent,\n}\n","size_bytes":2078},"components/ui/dialog.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className,\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className,\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\n  <div className={cn(\"flex flex-col space-y-1.5 text-center sm:text-left\", className)} {...props} />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\n  <div className={cn(\"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\", className)} {...props} />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold leading-none tracking-tight\", className)}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogClose,\n  DialogTrigger,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}\n","size_bytes":3755},"components/ui/input.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n  return (\n    <input\n      type={type}\n      data-slot=\"input\"\n      className={cn(\n        // Base\n        \"flex h-9 w-full min-w-0 rounded-md border border-border bg-input px-3 py-1 text-sm md:text-sm text-foreground placeholder:text-foreground-muted selection:bg-primary selection:text-primary-foreground\",\n        // Transitions & disabled\n        \"transition-colors disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50\",\n        // Focus state\n        \"focus-visible:outline-none focus-visible:ring-ring/60 focus-visible:ring-[3px] focus-visible:border-ring\",\n        // Error state\n        \"aria-invalid:border-destructive aria-invalid:ring-destructive/30\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Input }\n","size_bytes":909},"components/ui/label.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Label({\n  className,\n  ...props\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\n  return (\n    <LabelPrimitive.Root\n      data-slot=\"label\"\n      className={cn(\n        \"flex items-center gap-2 text-sm leading-none font-medium text-foreground-muted select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Label }\n","size_bytes":633},"components/ui/separator.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as SeparatorPrimitive from \"@radix-ui/react-separator\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Separator({\n  className,\n  orientation = \"horizontal\",\n  decorative = true,\n  ...props\n}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {\n  return (\n    <SeparatorPrimitive.Root\n      data-slot=\"separator\"\n      decorative={decorative}\n      orientation={orientation}\n      className={cn(\n        \"bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Separator }\n","size_bytes":699},"components/ui/sheet.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as SheetPrimitive from \"@radix-ui/react-dialog\"\nimport { XIcon } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {\n  return <SheetPrimitive.Root data-slot=\"sheet\" {...props} />\n}\n\nfunction SheetTrigger({\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {\n  return <SheetPrimitive.Trigger data-slot=\"sheet-trigger\" {...props} />\n}\n\nfunction SheetClose({\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Close>) {\n  return <SheetPrimitive.Close data-slot=\"sheet-close\" {...props} />\n}\n\nfunction SheetPortal({\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Portal>) {\n  return <SheetPrimitive.Portal data-slot=\"sheet-portal\" {...props} />\n}\n\nfunction SheetOverlay({\n  className,\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {\n  return (\n    <SheetPrimitive.Overlay\n      data-slot=\"sheet-overlay\"\n      className={cn(\n        \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SheetContent({\n  className,\n  children,\n  side = \"right\",\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Content> & {\n  side?: \"top\" | \"right\" | \"bottom\" | \"left\"\n}) {\n  return (\n    <SheetPortal>\n      <SheetOverlay />\n      <SheetPrimitive.Content\n        data-slot=\"sheet-content\"\n        className={cn(\n          \"bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500\",\n          side === \"right\" &&\n            \"data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm\",\n          side === \"left\" &&\n            \"data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm\",\n          side === \"top\" &&\n            \"data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b\",\n          side === \"bottom\" &&\n            \"data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n        <SheetPrimitive.Close className=\"ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none\">\n          <XIcon className=\"size-4\" />\n          <span className=\"sr-only\">Close</span>\n        </SheetPrimitive.Close>\n      </SheetPrimitive.Content>\n    </SheetPortal>\n  )\n}\n\nfunction SheetHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sheet-header\"\n      className={cn(\"flex flex-col gap-1.5 p-4\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SheetFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sheet-footer\"\n      className={cn(\"mt-auto flex flex-col gap-2 p-4\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SheetTitle({\n  className,\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Title>) {\n  return (\n    <SheetPrimitive.Title\n      data-slot=\"sheet-title\"\n      className={cn(\"text-foreground font-semibold\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SheetDescription({\n  className,\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Description>) {\n  return (\n    <SheetPrimitive.Description\n      data-slot=\"sheet-description\"\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Sheet,\n  SheetTrigger,\n  SheetClose,\n  SheetContent,\n  SheetHeader,\n  SheetFooter,\n  SheetTitle,\n  SheetDescription,\n}\n","size_bytes":4090},"components/ui/skeleton.tsx":{"content":"import { cn } from \"@/lib/utils\"\n\nfunction Skeleton({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"skeleton\"\n      className={cn(\"bg-accent animate-pulse rounded-md\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Skeleton }\n","size_bytes":276},"components/ui/textarea.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\n\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(({ className, ...props }, ref) => {\n  return (\n    <textarea\n      className={cn(\n        \"flex min-h-[90px] w-full rounded-md border border-border bg-input px-3 py-2 text-sm text-foreground placeholder:text-foreground-muted\",\n        \"focus-visible:outline-none focus-visible:ring-ring/60 focus-visible:ring-[3px] focus-visible:border-ring\",\n        \"disabled:cursor-not-allowed disabled:opacity-50 transition-colors\",\n        \"aria-invalid:border-destructive aria-invalid:ring-destructive/30\",\n        className,\n      )}\n      ref={ref}\n      {...props}\n    />\n  )\n})\nTextarea.displayName = \"Textarea\"\n\nexport { Textarea }\n","size_bytes":855},"components/ui/toast.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Viewport\n    ref={ref}\n    className={cn(\n      \"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n      className,\n    )}\n    {...props}\n  />\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst toastVariants = cva(\n  \"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border bg-background text-foreground\",\n        destructive: \"destructive border-destructive bg-destructive text-destructive-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  },\n)\n\nconst Toast = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> & VariantProps<typeof toastVariants>\n>(({ className, variant, ...props }, ref) => {\n  return <ToastPrimitives.Root ref={ref} className={cn(toastVariants({ variant }), className)} {...props} />\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Action>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Action\n    ref={ref}\n    className={cn(\n      \"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive\",\n      className,\n    )}\n    {...props}\n  />\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Close>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Close\n    ref={ref}\n    className={cn(\n      \"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600\",\n      className,\n    )}\n    toast-close=\"\"\n    {...props}\n  >\n    <X className=\"h-4 w-4\" />\n  </ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Title>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Title ref={ref} className={cn(\"text-sm font-semibold\", className)} {...props} />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Description>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Description ref={ref} className={cn(\"text-sm opacity-90\", className)} {...props} />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n  type ToastProps,\n  type ToastActionElement,\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastClose,\n  ToastAction,\n}\n","size_bytes":4783},"components/ui/toaster.tsx":{"content":"\"use client\"\n\nimport { Toast, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport } from \"@/components/ui/toast\"\nimport { useToast } from \"@/hooks/use-toast\"\n\nexport function Toaster() {\n  const { toasts } = useToast()\n\n  return (\n    <ToastProvider>\n      {toasts.map(({ id, title, description, action, ...props }) => (\n        <Toast key={id} {...props}>\n          <div className=\"grid gap-1\">\n            {title && <ToastTitle>{title}</ToastTitle>}\n            {description && <ToastDescription>{description}</ToastDescription>}\n          </div>\n          {action}\n          <ToastClose />\n        </Toast>\n      ))}\n      <ToastViewport />\n    </ToastProvider>\n  )\n}\n","size_bytes":690},"components/ui/toggle.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as TogglePrimitive from \"@radix-ui/react-toggle\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst toggleVariants = cva(\n  \"inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium hover:bg-muted hover:text-muted-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] outline-none transition-[color,box-shadow] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive whitespace-nowrap\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-transparent\",\n        outline:\n          \"border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground\",\n      },\n      size: {\n        default: \"h-9 px-2 min-w-9\",\n        sm: \"h-8 px-1.5 min-w-8\",\n        lg: \"h-10 px-2.5 min-w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Toggle({\n  className,\n  variant,\n  size,\n  ...props\n}: React.ComponentProps<typeof TogglePrimitive.Root> &\n  VariantProps<typeof toggleVariants>) {\n  return (\n    <TogglePrimitive.Root\n      data-slot=\"toggle\"\n      className={cn(toggleVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nexport { Toggle, toggleVariants }\n","size_bytes":1570},"components/ui/tooltip.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as TooltipPrimitive from \"@radix-ui/react-tooltip\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction TooltipProvider({\n  delayDuration = 0,\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {\n  return (\n    <TooltipPrimitive.Provider\n      data-slot=\"tooltip-provider\"\n      delayDuration={delayDuration}\n      {...props}\n    />\n  )\n}\n\nfunction Tooltip({\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Root>) {\n  return (\n    <TooltipProvider>\n      <TooltipPrimitive.Root data-slot=\"tooltip\" {...props} />\n    </TooltipProvider>\n  )\n}\n\nfunction TooltipTrigger({\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {\n  return <TooltipPrimitive.Trigger data-slot=\"tooltip-trigger\" {...props} />\n}\n\nfunction TooltipContent({\n  className,\n  sideOffset = 0,\n  children,\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Content>) {\n  return (\n    <TooltipPrimitive.Portal>\n      <TooltipPrimitive.Content\n        data-slot=\"tooltip-content\"\n        sideOffset={sideOffset}\n        className={cn(\n          \"bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n        <TooltipPrimitive.Arrow className=\"bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]\" />\n      </TooltipPrimitive.Content>\n    </TooltipPrimitive.Portal>\n  )\n}\n\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\n","size_bytes":1891},"components/ui/use-toast.ts":{"content":"\"use client\"\n\n// Inspired by react-hot-toast library\nimport * as React from \"react\"\n\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 1000000\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\n      // but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n      onOpenChange: (open) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }\n","size_bytes":3948},"lib/supabase/client.ts":{"content":"import { createBrowserClient } from \"@supabase/ssr\"\n\nexport function createClient() {\n  return createBrowserClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!)\n}\n","size_bytes":200},"lib/supabase/middleware.ts":{"content":"import { createServerClient } from \"@supabase/ssr\"\nimport { NextResponse, type NextRequest } from \"next/server\"\n\nexport async function updateSession(request: NextRequest) {\n  let supabaseResponse = NextResponse.next({\n    request,\n  })\n\n  const supabase = createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return request.cookies.getAll()\n        },\n        setAll(cookiesToSet) {\n          cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))\n          supabaseResponse = NextResponse.next({\n            request,\n          })\n          cookiesToSet.forEach(({ name, value, options }) => supabaseResponse.cookies.set(name, value, options))\n        },\n      },\n    },\n  )\n\n  // Try to get user - this properly validates the session server-side\n  const {\n    data: { user },\n    error,\n  } = await supabase.auth.getUser()\n\n  // Redirect unauthenticated users from protected pages and preserve original destination\n  const isProtectedPage = request.nextUrl.pathname.startsWith(\"/editor\") || request.nextUrl.pathname.startsWith(\"/dashboard\")\n  if (!user && isProtectedPage) {\n    const url = request.nextUrl.clone()\n    const redirect = request.nextUrl.pathname + (request.nextUrl.search || \"\")\n    // Validate redirect parameter to ensure it's an internal path\n    const safeRedirect = redirect.startsWith(\"/\") && !redirect.startsWith(\"//\") ? redirect : \"/editor\"\n    url.pathname = \"/auth/login\"\n    url.search = `redirect=${encodeURIComponent(safeRedirect)}`\n    return NextResponse.redirect(url)\n  }\n\n  return supabaseResponse\n}\n","size_bytes":1664},"lib/supabase/server.ts":{"content":"import { createServerClient } from \"@supabase/ssr\"\nimport { cookies } from \"next/headers\"\n\nexport async function createClient() {\n  const cookieStore = await cookies()\n\n  return createServerClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!, {\n    cookies: {\n      getAll() {\n        return cookieStore.getAll()\n      },\n      setAll(cookiesToSet) {\n        try {\n          cookiesToSet.forEach(({ name, value, options }) => cookieStore.set(name, value, options))\n        } catch {\n          // The \"setAll\" method was called from a Server Component.\n          // This can be ignored if you have middleware refreshing\n          // user sessions.\n        }\n      },\n    },\n  })\n}\n\nexport { createServerClient }\n","size_bytes":748},"prebundled/bundle/810.bundle.js":{"content":"\"use strict\";\n(self[\"webpackChunkmy_v0_project\"] = self[\"webpackChunkmy_v0_project\"] || []).push([[810],{\n\n/***/ 4810:\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BRAND: () => (/* binding */ BRAND),\n/* harmony export */   DIRTY: () => (/* binding */ DIRTY),\n/* harmony export */   EMPTY_PATH: () => (/* binding */ EMPTY_PATH),\n/* harmony export */   INVALID: () => (/* binding */ INVALID),\n/* harmony export */   NEVER: () => (/* binding */ NEVER),\n/* harmony export */   OK: () => (/* binding */ OK),\n/* harmony export */   ParseStatus: () => (/* binding */ ParseStatus),\n/* harmony export */   Schema: () => (/* binding */ ZodType),\n/* harmony export */   ZodAny: () => (/* binding */ ZodAny),\n/* harmony export */   ZodArray: () => (/* binding */ ZodArray),\n/* harmony export */   ZodBigInt: () => (/* binding */ ZodBigInt),\n/* harmony export */   ZodBoolean: () => (/* binding */ ZodBoolean),\n/* harmony export */   ZodBranded: () => (/* binding */ ZodBranded),\n/* harmony export */   ZodCatch: () => (/* binding */ ZodCatch),\n/* harmony export */   ZodDate: () => (/* binding */ ZodDate),\n/* harmony export */   ZodDefault: () => (/* binding */ ZodDefault),\n/* harmony export */   ZodDiscriminatedUnion: () => (/* binding */ ZodDiscriminatedUnion),\n/* harmony export */   ZodEffects: () => (/* binding */ ZodEffects),\n/* harmony export */   ZodEnum: () => (/* binding */ ZodEnum),\n/* harmony export */   ZodError: () => (/* binding */ ZodError),\n/* harmony export */   ZodFirstPartyTypeKind: () => (/* binding */ ZodFirstPartyTypeKind),\n/* harmony export */   ZodFunction: () => (/* binding */ ZodFunction),\n/* harmony export */   ZodIntersection: () => (/* binding */ ZodIntersection),\n/* harmony export */   ZodIssueCode: () => (/* binding */ ZodIssueCode),\n/* harmony export */   ZodLazy: () => (/* binding */ ZodLazy),\n/* harmony export */   ZodLiteral: () => (/* binding */ ZodLiteral),\n/* harmony export */   ZodMap: () => (/* binding */ ZodMap),\n/* harmony export */   ZodNaN: () => (/* binding */ ZodNaN),\n/* harmony export */   ZodNativeEnum: () => (/* binding */ ZodNativeEnum),\n/* harmony export */   ZodNever: () => (/* binding */ ZodNever),\n/* harmony export */   ZodNull: () => (/* binding */ ZodNull),\n/* harmony export */   ZodNullable: () => (/* binding */ ZodNullable),\n/* harmony export */   ZodNumber: () => (/* binding */ ZodNumber),\n/* harmony export */   ZodObject: () => (/* binding */ ZodObject),\n/* harmony export */   ZodOptional: () => (/* binding */ ZodOptional),\n/* harmony export */   ZodParsedType: () => (/* binding */ ZodParsedType),\n/* harmony export */   ZodPipeline: () => (/* binding */ ZodPipeline),\n/* harmony export */   ZodPromise: () => (/* binding */ ZodPromise),\n/* harmony export */   ZodReadonly: () => (/* binding */ ZodReadonly),\n/* harmony export */   ZodRecord: () => (/* binding */ ZodRecord),\n/* harmony export */   ZodSchema: () => (/* binding */ ZodType),\n/* harmony export */   ZodSet: () => (/* binding */ ZodSet),\n/* harmony export */   ZodString: () => (/* binding */ ZodString),\n/* harmony export */   ZodSymbol: () => (/* binding */ ZodSymbol),\n/* harmony export */   ZodTransformer: () => (/* binding */ ZodEffects),\n/* harmony export */   ZodTuple: () => (/* binding */ ZodTuple),\n/* harmony export */   ZodType: () => (/* binding */ ZodType),\n/* harmony export */   ZodUndefined: () => (/* binding */ ZodUndefined),\n/* harmony export */   ZodUnion: () => (/* binding */ ZodUnion),\n/* harmony export */   ZodUnknown: () => (/* binding */ ZodUnknown),\n/* harmony export */   ZodVoid: () => (/* binding */ ZodVoid),\n/* harmony export */   addIssueToContext: () => (/* binding */ addIssueToContext),\n/* harmony export */   any: () => (/* binding */ anyType),\n/* harmony export */   array: () => (/* binding */ arrayType),\n/* harmony export */   bigint: () => (/* binding */ bigIntType),\n/* harmony export */   boolean: () => (/* binding */ booleanType),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   date: () => (/* binding */ dateType),\n/* harmony export */   \"default\": () => (/* binding */ z),\n/* harmony export */   defaultErrorMap: () => (/* binding */ errorMap),\n/* harmony export */   discriminatedUnion: () => (/* binding */ discriminatedUnionType),\n/* harmony export */   effect: () => (/* binding */ effectsType),\n/* harmony export */   \"enum\": () => (/* binding */ enumType),\n/* harmony export */   \"function\": () => (/* binding */ functionType),\n/* harmony export */   getErrorMap: () => (/* binding */ getErrorMap),\n/* harmony export */   getParsedType: () => (/* binding */ getParsedType),\n/* harmony export */   \"instanceof\": () => (/* binding */ instanceOfType),\n/* harmony export */   intersection: () => (/* binding */ intersectionType),\n/* harmony export */   isAborted: () => (/* binding */ isAborted),\n/* harmony export */   isAsync: () => (/* binding */ isAsync),\n/* harmony export */   isDirty: () => (/* binding */ isDirty),\n/* harmony export */   isValid: () => (/* binding */ isValid),\n/* harmony export */   late: () => (/* binding */ late),\n/* harmony export */   lazy: () => (/* binding */ lazyType),\n/* harmony export */   literal: () => (/* binding */ literalType),\n/* harmony export */   makeIssue: () => (/* binding */ makeIssue),\n/* harmony export */   map: () => (/* binding */ mapType),\n/* harmony export */   nan: () => (/* binding */ nanType),\n/* harmony export */   nativeEnum: () => (/* binding */ nativeEnumType),\n/* harmony export */   never: () => (/* binding */ neverType),\n/* harmony export */   \"null\": () => (/* binding */ nullType),\n/* harmony export */   nullable: () => (/* binding */ nullableType),\n/* harmony export */   number: () => (/* binding */ numberType),\n/* harmony export */   object: () => (/* binding */ objectType),\n/* harmony export */   objectUtil: () => (/* binding */ objectUtil),\n/* harmony export */   oboolean: () => (/* binding */ oboolean),\n/* harmony export */   onumber: () => (/* binding */ onumber),\n/* harmony export */   optional: () => (/* binding */ optionalType),\n/* harmony export */   ostring: () => (/* binding */ ostring),\n/* harmony export */   pipeline: () => (/* binding */ pipelineType),\n/* harmony export */   preprocess: () => (/* binding */ preprocessType),\n/* harmony export */   promise: () => (/* binding */ promiseType),\n/* harmony export */   quotelessJson: () => (/* binding */ quotelessJson),\n/* harmony export */   record: () => (/* binding */ recordType),\n/* harmony export */   set: () => (/* binding */ setType),\n/* harmony export */   setErrorMap: () => (/* binding */ setErrorMap),\n/* harmony export */   strictObject: () => (/* binding */ strictObjectType),\n/* harmony export */   string: () => (/* binding */ stringType),\n/* harmony export */   symbol: () => (/* binding */ symbolType),\n/* harmony export */   transformer: () => (/* binding */ effectsType),\n/* harmony export */   tuple: () => (/* binding */ tupleType),\n/* harmony export */   undefined: () => (/* binding */ undefinedType),\n/* harmony export */   union: () => (/* binding */ unionType),\n/* harmony export */   unknown: () => (/* binding */ unknownType),\n/* harmony export */   util: () => (/* binding */ util),\n/* harmony export */   \"void\": () => (/* binding */ voidType),\n/* harmony export */   z: () => (/* binding */ z)\n/* harmony export */ });\nvar util;\n(function (util) {\n    util.assertEqual = (val) => val;\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array\n            .map((val) => (typeof val === \"string\" ? `'${val}'` : val))\n            .join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nvar objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nconst ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nconst getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then &&\n                typeof data.then === \"function\" &&\n                data.catch &&\n                typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n\nconst ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nconst quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nclass ZodError extends Error {\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    get errors() {\n        return this.issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `smaller than or equal to`\n                        : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\n\nlet overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\n\nconst makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: issueData.message || errorMessage,\n    };\n};\nconst EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            getErrorMap(),\n            errorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            syncPairs.push({\n                key: await pair.key,\n                value: await pair.value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" &&\n                (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nconst INVALID = Object.freeze({\n    status: \"aborted\",\n});\nconst DIRTY = (value) => ({ status: \"dirty\", value });\nconst OK = (value) => ({ status: \"valid\", value });\nconst isAborted = (x) => x.status === \"aborted\";\nconst isDirty = (x) => x.status === \"dirty\";\nconst isValid = (x) => x.status === \"valid\";\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n\nvar errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\n\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (this._key instanceof Array) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        if (typeof ctx.data === \"undefined\") {\n            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };\n        }\n        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nclass ZodType {\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n    }\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult)\n            ? maybeAsyncResult\n            : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\"\n                    ? refinementData(val, ctx)\n                    : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this, this._def);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[a-z][a-z0-9]*$/;\nconst ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_+-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&â€™*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst emojiRegex = /^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$/u;\nconst ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;\nconst ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\n// Adapted from https://stackoverflow.com/a/3143231\nconst datetimeRegex = (args) => {\n    if (args.precision) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}Z$`);\n        }\n    }\n    else if (args.precision === 0) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}Z$`);\n        }\n    }\n    else {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?Z$`);\n        }\n    }\n};\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n        /**\n         * @deprecated Use z.string().min(1) instead.\n         * @see {@link ZodString.min}\n         */\n        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));\n        this.trim = () => new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n        this.toLowerCase = () => new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n        this.toUpperCase = () => new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            }\n            //\n            );\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        var _a;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options === null || options === void 0 ? void 0 : options.position,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / Math.pow(10, decCount);\n}\nclass ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" ||\n            (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null, min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" ||\n                ch.kind === \"int\" ||\n                ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = BigInt(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.bigint,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    var _a;\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nclass ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        return (this._cached = { shape, keys });\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever &&\n            this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") ;\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    syncPairs.push({\n                        key,\n                        value: await pair.value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        var _a, _b, _c, _d;\n                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util.objectKeys(mask).forEach((key) => {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return Object.keys(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else {\n        return null;\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util\n            .objectKeys(a)\n            .filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date &&\n        bType === ZodParsedType.date &&\n        +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nclass ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args\n                    .parseAsync(args, params)\n                    .catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args\n                ? args\n                : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nclass ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (this._def.values.indexOf(input.data) === -1) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values) {\n        return ZodEnum.create(values);\n    }\n    exclude(values) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));\n    }\n}\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string &&\n            ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (nativeEnumValues.indexOf(input.data) === -1) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise &&\n            ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise\n            ? ctx.data\n            : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.issues.length) {\n                return {\n                    status: \"dirty\",\n                    value: ctx.data,\n                };\n            }\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then((processed) => {\n                    return this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                });\n            }\n            else {\n                return this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc\n            // effect: RefinementEffect<any>\n            ) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((base) => {\n                    if (!isValid(base))\n                        return base;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\"\n            ? params.default\n            : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nconst BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nclass ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        if (isValid(result)) {\n            result.value = Object.freeze(result.value);\n        }\n        return result;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\nconst custom = (check, params = {}, \n/*\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) => {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            var _a, _b;\n            if (!check(data)) {\n                const p = typeof params === \"function\"\n                    ? params(data)\n                    : typeof params === \"string\"\n                        ? { message: params }\n                        : params;\n                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n                const p2 = typeof p === \"string\" ? { message: p } : p;\n                ctx.addIssue({ code: \"custom\", ...p2, fatal: _fatal });\n            }\n        });\n    return ZodAny.create();\n};\nconst late = {\n    object: ZodObject.lazycreate,\n};\nvar ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nconst coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nconst NEVER = INVALID;\n\nvar z = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    defaultErrorMap: errorMap,\n    setErrorMap: setErrorMap,\n    getErrorMap: getErrorMap,\n    makeIssue: makeIssue,\n    EMPTY_PATH: EMPTY_PATH,\n    addIssueToContext: addIssueToContext,\n    ParseStatus: ParseStatus,\n    INVALID: INVALID,\n    DIRTY: DIRTY,\n    OK: OK,\n    isAborted: isAborted,\n    isDirty: isDirty,\n    isValid: isValid,\n    isAsync: isAsync,\n    get util () { return util; },\n    get objectUtil () { return objectUtil; },\n    ZodParsedType: ZodParsedType,\n    getParsedType: getParsedType,\n    ZodType: ZodType,\n    ZodString: ZodString,\n    ZodNumber: ZodNumber,\n    ZodBigInt: ZodBigInt,\n    ZodBoolean: ZodBoolean,\n    ZodDate: ZodDate,\n    ZodSymbol: ZodSymbol,\n    ZodUndefined: ZodUndefined,\n    ZodNull: ZodNull,\n    ZodAny: ZodAny,\n    ZodUnknown: ZodUnknown,\n    ZodNever: ZodNever,\n    ZodVoid: ZodVoid,\n    ZodArray: ZodArray,\n    ZodObject: ZodObject,\n    ZodUnion: ZodUnion,\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\n    ZodIntersection: ZodIntersection,\n    ZodTuple: ZodTuple,\n    ZodRecord: ZodRecord,\n    ZodMap: ZodMap,\n    ZodSet: ZodSet,\n    ZodFunction: ZodFunction,\n    ZodLazy: ZodLazy,\n    ZodLiteral: ZodLiteral,\n    ZodEnum: ZodEnum,\n    ZodNativeEnum: ZodNativeEnum,\n    ZodPromise: ZodPromise,\n    ZodEffects: ZodEffects,\n    ZodTransformer: ZodEffects,\n    ZodOptional: ZodOptional,\n    ZodNullable: ZodNullable,\n    ZodDefault: ZodDefault,\n    ZodCatch: ZodCatch,\n    ZodNaN: ZodNaN,\n    BRAND: BRAND,\n    ZodBranded: ZodBranded,\n    ZodPipeline: ZodPipeline,\n    ZodReadonly: ZodReadonly,\n    custom: custom,\n    Schema: ZodType,\n    ZodSchema: ZodType,\n    late: late,\n    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },\n    coerce: coerce,\n    any: anyType,\n    array: arrayType,\n    bigint: bigIntType,\n    boolean: booleanType,\n    date: dateType,\n    discriminatedUnion: discriminatedUnionType,\n    effect: effectsType,\n    'enum': enumType,\n    'function': functionType,\n    'instanceof': instanceOfType,\n    intersection: intersectionType,\n    lazy: lazyType,\n    literal: literalType,\n    map: mapType,\n    nan: nanType,\n    nativeEnum: nativeEnumType,\n    never: neverType,\n    'null': nullType,\n    nullable: nullableType,\n    number: numberType,\n    object: objectType,\n    oboolean: oboolean,\n    onumber: onumber,\n    optional: optionalType,\n    ostring: ostring,\n    pipeline: pipelineType,\n    preprocess: preprocessType,\n    promise: promiseType,\n    record: recordType,\n    set: setType,\n    strictObject: strictObjectType,\n    string: stringType,\n    symbol: symbolType,\n    transformer: effectsType,\n    tuple: tupleType,\n    'undefined': undefinedType,\n    union: unionType,\n    unknown: unknownType,\n    'void': voidType,\n    NEVER: NEVER,\n    ZodIssueCode: ZodIssueCode,\n    quotelessJson: quotelessJson,\n    ZodError: ZodError\n});\n\n\n\n\n/***/ })\n\n}]);\n//# sourceMappingURL=810.bundle.js.map","size_bytes":145351},"prebundled/bundle/843.bundle.js":{"content":"\"use strict\";\n(self[\"webpackChunkmy_v0_project\"] = self[\"webpackChunkmy_v0_project\"] || []).push([[843],{\n\n/***/ 5843:\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZodZypesInternals: () => (/* binding */ ZodZypesInternals),\n/* harmony export */   zColor: () => (/* binding */ zColor),\n/* harmony export */   zMatrix: () => (/* binding */ zMatrix),\n/* harmony export */   zTextarea: () => (/* binding */ zTextarea)\n/* harmony export */ });\n/* harmony import */ var remotion_no_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9382);\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4810);\n// src/z-color.ts\n\n\nvar REMOTION_COLOR_BRAND = \"__remotion-color\";\nvar parseColor = (value) => {\n  const colored = remotion_no_react__WEBPACK_IMPORTED_MODULE_0__.NoReactInternals.processColor(value).toString(16).padStart(8, \"0\");\n  const opacity = parseInt(colored.slice(0, 2), 16);\n  const r = parseInt(colored.slice(2, 4), 16);\n  const g = parseInt(colored.slice(4, 6), 16);\n  const b = parseInt(colored.slice(6, 8), 16);\n  return { a: opacity, r, g, b };\n};\nvar zColor = () => zod__WEBPACK_IMPORTED_MODULE_1__.z.string().refine((value) => {\n  try {\n    parseColor(value);\n    return true;\n  } catch {\n    return false;\n  }\n}, { message: \"Invalid color\" }).describe(REMOTION_COLOR_BRAND);\n\n// src/z-matrix.ts\n\nvar REMOTION_MATRIX_BRAND = \"__remotion-matrix\";\nvar zMatrix = () => zod__WEBPACK_IMPORTED_MODULE_1__.z.array(zod__WEBPACK_IMPORTED_MODULE_1__.z.number().step(0.01)).refine((value) => {\n  const count = value.length;\n  const root = Math.sqrt(count);\n  return Number.isInteger(root) && root > 0;\n}, { message: \"Invalid matrix, must be a square matrix\" }).describe(REMOTION_MATRIX_BRAND);\n\n// src/z-textarea.ts\n\nvar REMOTION_TEXTAREA_BRAND = \"__remotion-textarea\";\nvar zTextarea = () => zod__WEBPACK_IMPORTED_MODULE_1__.z.string().describe(REMOTION_TEXTAREA_BRAND);\n\n// src/index.ts\nvar ZodZypesInternals = {\n  parseColor,\n  REMOTION_COLOR_BRAND,\n  REMOTION_TEXTAREA_BRAND,\n  REMOTION_MATRIX_BRAND\n};\n\n\n\n/***/ })\n\n}]);\n//# sourceMappingURL=843.bundle.js.map","size_bytes":2274},"prebundled/bundle/974.bundle.js":{"content":"(self[\"webpackChunkmy_v0_project\"] = self[\"webpackChunkmy_v0_project\"] || []).push([[974],{\n\n/***/ 3638:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\n/**\n * Inlined from https://github.com/Jam3/audiobuffer-to-wav/commit/2272eb09bd46a05e50a6d684d908aa6f13c58f63#diff-e727e4bdf3657fd1d798edcd6b099d6e092f8573cba266154583a746bba0f346\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.audioBufferToWav = audioBufferToWav;\nfunction interleave(inputL, inputR) {\n    const length = inputL.length + inputR.length;\n    const result = new Float32Array(length);\n    let index = 0;\n    let inputIndex = 0;\n    while (index < length) {\n        result[index++] = inputL[inputIndex];\n        result[index++] = inputR[inputIndex];\n        inputIndex++;\n    }\n    return result;\n}\nfunction writeFloat32(output, offset, input) {\n    for (let i = 0; i < input.length; i++, offset += 4) {\n        output.setFloat32(offset, input[i], true);\n    }\n}\nfunction floatTo16BitPCM(output, offset, input) {\n    for (let i = 0; i < input.length; i++, offset += 2) {\n        const s = Math.max(-1, Math.min(1, input[i]));\n        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n}\nfunction writeString(view, offset, string) {\n    for (let i = 0; i < string.length; i++) {\n        view.setUint8(offset + i, string.charCodeAt(i));\n    }\n}\nfunction encodeWAV({ samples, format, sampleRate, numChannels, bitDepth, }) {\n    const bytesPerSample = bitDepth / 8;\n    const blockAlign = numChannels * bytesPerSample;\n    const buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);\n    const view = new DataView(buffer);\n    /* RIFF identifier */\n    writeString(view, 0, 'RIFF');\n    /* RIFF chunk length */\n    view.setUint32(4, 36 + samples.length * bytesPerSample, true);\n    /* RIFF type */\n    writeString(view, 8, 'WAVE');\n    /* format chunk identifier */\n    writeString(view, 12, 'fmt ');\n    /* format chunk length */\n    view.setUint32(16, 16, true);\n    /* sample format (raw) */\n    view.setUint16(20, format, true);\n    /* channel count */\n    view.setUint16(22, numChannels, true);\n    /* sample rate */\n    view.setUint32(24, sampleRate, true);\n    /* byte rate (sample rate * block align) */\n    view.setUint32(28, sampleRate * blockAlign, true);\n    /* block align (channel count * bytes per sample) */\n    view.setUint16(32, blockAlign, true);\n    /* bits per sample */\n    view.setUint16(34, bitDepth, true);\n    /* data chunk identifier */\n    writeString(view, 36, 'data');\n    /* data chunk length */\n    view.setUint32(40, samples.length * bytesPerSample, true);\n    if (format === 1) {\n        // Raw PCM\n        floatTo16BitPCM(view, 44, samples);\n    }\n    else {\n        writeFloat32(view, 44, samples);\n    }\n    return buffer;\n}\nfunction audioBufferToWav(buffer, opt) {\n    const numChannels = buffer.numberOfChannels;\n    const { sampleRate } = buffer;\n    const format = opt.float32 ? 3 : 1;\n    const bitDepth = format === 3 ? 32 : 16;\n    let result;\n    if (numChannels === 2) {\n        result = interleave(buffer.getChannelData(0), buffer.getChannelData(1));\n    }\n    else {\n        result = buffer.getChannelData(0);\n    }\n    return encodeWAV({\n        samples: result,\n        format,\n        sampleRate,\n        numChannels,\n        bitDepth,\n    });\n}\n\n\n/***/ }),\n\n/***/ 7996:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.audioBufferToDataUrl = void 0;\nconst audio_buffer_to_wav_1 = __webpack_require__(3638);\n/*\n * @description Takes an AudioBuffer instance and converts it to a Base 64 Data URL so it can be passed to an <Audio /> tag.\n * @see [Documentation](https://remotion.dev/docs/audio-buffer-to-data-url)\n */\nconst audioBufferToDataUrl = (buffer) => {\n    const wavAsArrayBuffer = (0, audio_buffer_to_wav_1.audioBufferToWav)(buffer, {\n        float32: true,\n    });\n    let binary = '';\n    const bytes = new Uint8Array(wavAsArrayBuffer);\n    const len = bytes.byteLength;\n    for (let i = 0; i < len; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return 'data:audio/wav;base64,' + window.btoa(binary);\n};\nexports.audioBufferToDataUrl = audioBufferToDataUrl;\n\n\n/***/ }),\n\n/***/ 1546:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.combineFloat32Arrays = void 0;\nconst combineFloat32Arrays = (arrays) => {\n    if (arrays.length === 0) {\n        return new Float32Array([]);\n    }\n    if (arrays.length === 1) {\n        return arrays[0];\n    }\n    let totalLength = 0;\n    for (const array of arrays) {\n        totalLength += array.length;\n    }\n    const result = new Float32Array(totalLength);\n    let offset = 0;\n    for (const array of arrays) {\n        result.set(array, offset);\n        offset += array.length;\n    }\n    return result;\n};\nexports.combineFloat32Arrays = combineFloat32Arrays;\n\n\n/***/ }),\n\n/***/ 9144:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createSmoothSvgPath = void 0;\nconst line = (pointA, pointB) => {\n    const lengthX = pointB.x - pointA.x;\n    const lengthY = pointB.y - pointA.y;\n    return {\n        length: Math.sqrt(lengthX ** 2 + lengthY ** 2),\n        angle: Math.atan2(lengthY, lengthX),\n    };\n};\nconst controlPoint = ({ current, previous, next, reverse, }) => {\n    const p = previous || current;\n    const n = next || current;\n    // The smoothing ratio\n    const smoothing = 0.2;\n    // Properties of the opposed-line\n    const o = line(p, n);\n    const angle = o.angle + (reverse ? Math.PI : 0);\n    const length = o.length * smoothing;\n    const x = current.x + Math.cos(angle) * length;\n    const y = current.y + Math.sin(angle) * length;\n    return { x, y };\n};\nconst createSmoothSvgPath = ({ points }) => {\n    return points.reduce((acc, current, i, a) => {\n        if (i === 0) {\n            return `M ${current.x},${current.y}`;\n        }\n        const { x, y } = current;\n        const previous = a[i - 1];\n        const twoPrevious = a[i - 2];\n        const next = a[i + 1];\n        const { x: cp1x, y: cp1y } = controlPoint({\n            current: previous,\n            previous: twoPrevious,\n            next: current,\n            reverse: false,\n        });\n        const { x: cp2x, y: cp2y } = controlPoint({\n            current,\n            previous,\n            next,\n            reverse: true,\n        });\n        return `${acc} C ${cp1x},${cp1y} ${cp2x},${cp2y} ${x},${y}`;\n    }, '');\n};\nexports.createSmoothSvgPath = createSmoothSvgPath;\n\n\n/***/ }),\n\n/***/ 5633:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fetchWithCorsCatch = void 0;\nconst fetchWithCorsCatch = async (src, init) => {\n    try {\n        const response = await fetch(src, {\n            mode: 'cors',\n            referrerPolicy: 'no-referrer-when-downgrade',\n            ...init,\n        });\n        return response;\n    }\n    catch (err) {\n        const error = err;\n        if (\n        // Chrome\n        error.message.includes('Failed to fetch') ||\n            // Safari\n            error.message.includes('Load failed') ||\n            // Firefox\n            error.message.includes('NetworkError when attempting to fetch resource')) {\n            throw new TypeError(`Failed to read from ${src}: ${error.message}. Does the resource support CORS?`);\n        }\n        throw err;\n    }\n};\nexports.fetchWithCorsCatch = fetchWithCorsCatch;\n\n\n/***/ }),\n\n/***/ 1603:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\n// Adapted from node-fft project by Joshua Wong and Ben Bryan\n// https://github.com/vail-systems/node-fft\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.complexMagnitude = exports.complexMultiply = exports.complexSubtract = exports.complexAdd = void 0;\nconst complexAdd = function (a, b) {\n    return [a[0] + b[0], a[1] + b[1]];\n};\nexports.complexAdd = complexAdd;\nconst complexSubtract = function (a, b) {\n    return [a[0] - b[0], a[1] - b[1]];\n};\nexports.complexSubtract = complexSubtract;\nconst complexMultiply = function (a, b) {\n    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n};\nexports.complexMultiply = complexMultiply;\nconst complexMagnitude = function (c) {\n    return Math.sqrt(c[0] * c[0] + c[1] * c[1]);\n};\nexports.complexMagnitude = complexMagnitude;\n\n\n/***/ }),\n\n/***/ 5372:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\n// Adapted from node-fft project by Joshua Wong and Ben Bryan\n// https://github.com/vail-systems/node-fft\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.exponent = void 0;\nconst mapExponent = {};\nconst exponent = function (k, N) {\n    const x = -2 * Math.PI * (k / N);\n    mapExponent[N] = mapExponent[N] || {};\n    mapExponent[N][k] = mapExponent[N][k] || [Math.cos(x), Math.sin(x)]; // [Real, Imaginary]\n    return mapExponent[N][k];\n};\nexports.exponent = exponent;\n\n\n/***/ }),\n\n/***/ 4750:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\n// Adapted from node-fft project by Joshua Wong and Ben Bryan\n// https://github.com/vail-systems/node-fft\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fftAccurate = void 0;\nconst complex_1 = __webpack_require__(1603);\nconst exponent_1 = __webpack_require__(5372);\nconst fftAccurate = function (vector) {\n    const X = [];\n    const N = vector.length;\n    // Base case is X = x + 0i since our input is assumed to be real only.\n    if (N === 1) {\n        if (Array.isArray(vector[0])) {\n            // If input vector contains complex numbers\n            return [[vector[0][0], vector[0][1]]];\n        }\n        return [[vector[0], 0]];\n    }\n    // Recurse: all even samples\n    const X_evens = (0, exports.fftAccurate)(vector.filter((_, ix) => ix % 2 === 0));\n    // Recurse: all odd samples\n    const X_odds = (0, exports.fftAccurate)(vector.filter((__, ix) => ix % 2 === 1));\n    // Now, perform N/2 operations!\n    for (let k = 0; k < N / 2; k++) {\n        // t is a complex number!\n        const t = X_evens[k];\n        const e = (0, complex_1.complexMultiply)((0, exponent_1.exponent)(k, N), X_odds[k]);\n        X[k] = (0, complex_1.complexAdd)(t, e);\n        X[k + N / 2] = (0, complex_1.complexSubtract)(t, e);\n    }\n    return X;\n};\nexports.fftAccurate = fftAccurate;\n\n\n/***/ }),\n\n/***/ 5226:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\n// https://pastebin.com/raw/D42RbPe5\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fftFast = void 0;\n// Function to reverse bits in an integer\nfunction reverseBits(num, numBits) {\n    let result = 0;\n    for (let i = 0; i < numBits; i++) {\n        result = (result << 1) | ((num >> i) & 1);\n    }\n    return result;\n}\n// Hamming window function\nfunction hammingWindow(N) {\n    const win = new Array(N);\n    for (let i = 0; i < N; i++) {\n        win[i] = 0.8 - 0.46 * Math.cos((2 * Math.PI * i) / (N - 1));\n    }\n    return win;\n}\n// Function to calculate the bit-reversed permutation indices\nfunction bitReversePermutation(N) {\n    const bitReversed = new Array(N);\n    for (let i = 0; i < N; i++) {\n        bitReversed[i] = reverseBits(i, Math.log2(N));\n    }\n    return bitReversed;\n}\nconst fftFast = function (vector) {\n    const N = vector.length;\n    const X = new Array(N);\n    if (N <= 1) {\n        for (let i = 0; i < vector.length; i++) {\n            const value = vector[i];\n            X[i] = [value * 2, 0];\n        }\n        return X;\n    }\n    // Apply a windowing function to the input data\n    const window = hammingWindow(N); // You can choose a different window function if needed\n    for (let i = 0; i < N; i++) {\n        X[i] = [vector[i] * window[i], 0];\n    }\n    // Bit-Reversal Permutation\n    const bitReversed = bitReversePermutation(N);\n    for (let i = 0; i < N; i++) {\n        X[i] = [vector[bitReversed[i]], 0];\n    }\n    // Cooley-Tukey FFT\n    for (let s = 1; s <= Math.log2(N); s++) {\n        const m = 1 << s; // Number of elements in each subarray\n        const mHalf = m / 2; // Half the number of elements in each subarray\n        const angleIncrement = (2 * Math.PI) / m;\n        for (let k = 0; k < N; k += m) {\n            let omegaReal = 1.0;\n            let omegaImag = 0.0;\n            for (let j = 0; j < mHalf; j++) {\n                const tReal = omegaReal * X[k + j + mHalf][0] - omegaImag * X[k + j + mHalf][1];\n                const tImag = omegaReal * X[k + j + mHalf][1] + omegaImag * X[k + j + mHalf][0];\n                const uReal = X[k + j][0];\n                const uImag = X[k + j][1];\n                X[k + j] = [uReal + tReal, uImag + tImag];\n                X[k + j + mHalf] = [uReal - tReal, uImag - tImag];\n                // Twiddle factor update\n                const tempReal = omegaReal * Math.cos(angleIncrement) -\n                    omegaImag * Math.sin(angleIncrement);\n                omegaImag =\n                    omegaReal * Math.sin(angleIncrement) +\n                        omegaImag * Math.cos(angleIncrement);\n                omegaReal = tempReal;\n            }\n        }\n    }\n    return X;\n};\nexports.fftFast = fftFast;\n\n\n/***/ }),\n\n/***/ 9894:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\n// Adapted from node-fft project by Joshua Wong and Ben Bryan\n// https://github.com/vail-systems/node-fft\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getVisualization = void 0;\nconst fft_accurate_1 = __webpack_require__(4750);\nconst fft_fast_1 = __webpack_require__(5226);\nconst mag_1 = __webpack_require__(8764);\nconst smoothing_1 = __webpack_require__(7557);\nconst to_int_16_1 = __webpack_require__(1868);\nconst getVisualization = ({ sampleSize, data, sampleRate, frame, fps, maxInt, optimizeFor, dataOffsetInSeconds, }) => {\n    const isPowerOfTwo = sampleSize > 0 && (sampleSize & (sampleSize - 1)) === 0;\n    if (!isPowerOfTwo) {\n        throw new TypeError(`The argument \"bars\" must be a power of two. For example: 64, 128. Got instead: ${sampleSize}`);\n    }\n    if (!fps) {\n        throw new TypeError('The argument \"fps\" was not provided');\n    }\n    if (data.length < sampleSize) {\n        throw new TypeError('Audio data is not big enough to provide ' + sampleSize + ' bars.');\n    }\n    const start = Math.floor((frame / fps - dataOffsetInSeconds) * sampleRate);\n    const actualStart = Math.max(0, start - sampleSize / 2);\n    const ints = new Int16Array({\n        length: sampleSize,\n    });\n    ints.set(data.subarray(actualStart, actualStart + sampleSize).map((x) => (0, to_int_16_1.toInt16)(x)));\n    const alg = optimizeFor === 'accuracy' ? fft_accurate_1.fftAccurate : fft_fast_1.fftFast;\n    const phasors = alg(ints);\n    const magnitudes = (0, mag_1.fftMag)(phasors).map((p) => p);\n    return (0, smoothing_1.smoothen)(magnitudes).map((m) => m / (sampleSize / 2) / maxInt);\n};\nexports.getVisualization = getVisualization;\n\n\n/***/ }),\n\n/***/ 8764:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\n// Adapted from node-fft project by Joshua Wong and Ben Bryan\n// https://github.com/vail-systems/node-fft\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fftMag = void 0;\nconst complex_1 = __webpack_require__(1603);\nconst fftMag = function (fftBins) {\n    const ret = fftBins.map((f) => (0, complex_1.complexMagnitude)(f));\n    return ret.slice(0, ret.length / 2);\n};\nexports.fftMag = fftMag;\n\n\n/***/ }),\n\n/***/ 2268:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\n// Adapted from node-fft project by Joshua Wong and Ben Bryan\n// https://github.com/vail-systems/node-fft\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getMaxPossibleMagnitude = void 0;\nconst to_int_16_1 = __webpack_require__(1868);\nconst getMax = (array) => {\n    let max = 0;\n    for (let i = 0; i < array.length; i++) {\n        const val = array[i];\n        if (val > max) {\n            max = val;\n        }\n    }\n    return max;\n};\nconst cache = {};\nconst getMaxPossibleMagnitude = (metadata) => {\n    if (cache[metadata.resultId]) {\n        return cache[metadata.resultId];\n    }\n    const result = (0, to_int_16_1.toInt16)(getMax(metadata.channelWaveforms[0]));\n    cache[metadata.resultId] = result;\n    return result;\n};\nexports.getMaxPossibleMagnitude = getMaxPossibleMagnitude;\n\n\n/***/ }),\n\n/***/ 7557:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\n// Adapted from node-fft project by Joshua Wong and Ben Bryan\n// https://github.com/vail-systems/node-fft\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.smoothen = void 0;\nconst smoothingPasses = 3;\nconst smoothingPoints = 3;\nconst smoothen = function (array) {\n    let lastArray = array;\n    const newArr = [];\n    for (let pass = 0; pass < smoothingPasses; pass++) {\n        const sidePoints = Math.floor(smoothingPoints / 2); // our window is centered so this is both nL and nR\n        const cn = 1 / (2 * sidePoints + 1); // constant\n        for (let i = 0; i < sidePoints; i++) {\n            newArr[i] = lastArray[i];\n            newArr[lastArray.length - i - 1] = lastArray[lastArray.length - i - 1];\n        }\n        for (let i = sidePoints; i < lastArray.length - sidePoints; i++) {\n            let sum = 0;\n            for (let n = -sidePoints; n <= sidePoints; n++) {\n                sum += cn * lastArray[i + n] + n;\n            }\n            newArr[i] = sum;\n        }\n        lastArray = newArr;\n    }\n    return newArr;\n};\nexports.smoothen = smoothen;\n\n\n/***/ }),\n\n/***/ 1868:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toInt16 = void 0;\nconst toInt16 = (x) => (x > 0 ? x * 0x7fff : x * 0x8000);\nexports.toInt16 = toInt16;\n\n\n/***/ }),\n\n/***/ 5576:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAudioData = void 0;\nconst fetch_with_cors_catch_1 = __webpack_require__(5633);\nconst is_remote_asset_1 = __webpack_require__(5448);\nconst p_limit_1 = __webpack_require__(1082);\nconst metadataCache = {};\nconst limit = (0, p_limit_1.pLimit)(3);\nconst fn = async (src, options) => {\n    var _a;\n    if (metadataCache[src]) {\n        return metadataCache[src];\n    }\n    if (typeof document === 'undefined') {\n        throw new Error('getAudioData() is only available in the browser.');\n    }\n    const audioContext = new AudioContext({\n        sampleRate: (_a = options === null || options === void 0 ? void 0 : options.sampleRate) !== null && _a !== void 0 ? _a : 48000,\n    });\n    const response = await (0, fetch_with_cors_catch_1.fetchWithCorsCatch)(src);\n    const arrayBuffer = await response.arrayBuffer();\n    const wave = await audioContext.decodeAudioData(arrayBuffer);\n    const channelWaveforms = new Array(wave.numberOfChannels)\n        .fill(true)\n        .map((_, channel) => {\n        return wave.getChannelData(channel);\n    });\n    const metadata = {\n        channelWaveforms,\n        sampleRate: wave.sampleRate,\n        durationInSeconds: wave.duration,\n        numberOfChannels: wave.numberOfChannels,\n        resultId: String(Math.random()),\n        isRemote: (0, is_remote_asset_1.isRemoteAsset)(src),\n    };\n    metadataCache[src] = metadata;\n    return metadata;\n};\n/*\n * @description Takes an audio or video src, loads it and returns data and metadata for the specified source.\n * @see [Documentation](https://remotion.dev/docs/get-audio-data)\n */\nconst getAudioData = (src, options) => {\n    return limit(fn, src, options);\n};\nexports.getAudioData = getAudioData;\n\n\n/***/ }),\n\n/***/ 7970:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAudioDuration = exports.getAudioDurationInSeconds = void 0;\n/* eslint-disable @typescript-eslint/no-use-before-define */\nconst media_tag_error_handling_1 = __webpack_require__(4970);\nconst p_limit_1 = __webpack_require__(1082);\nconst limit = (0, p_limit_1.pLimit)(3);\nconst metadataCache = {};\nconst fn = (src) => {\n    if (metadataCache[src]) {\n        return Promise.resolve(metadataCache[src]);\n    }\n    if (typeof document === 'undefined') {\n        throw new Error('getAudioDuration() is only available in the browser.');\n    }\n    const audio = document.createElement('audio');\n    audio.src = src;\n    return new Promise((resolve, reject) => {\n        const onError = () => {\n            (0, media_tag_error_handling_1.onMediaError)({\n                error: audio.error,\n                src,\n                cleanup,\n                reject,\n                api: 'getAudioDurationInSeconds()',\n            });\n        };\n        const onLoadedMetadata = () => {\n            metadataCache[src] = audio.duration;\n            resolve(audio.duration);\n            cleanup();\n        };\n        const cleanup = () => {\n            audio.removeEventListener('loadedmetadata', onLoadedMetadata);\n            audio.removeEventListener('error', onError);\n            audio.remove();\n        };\n        audio.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });\n        audio.addEventListener('error', onError, { once: true });\n    });\n};\n/**\n * @description Gets the duration in seconds of an audio source by creating an invisible `<audio>` tag, loading the audio, and returning the duration.\n * @see [Documentation](https://remotion.dev/docs/get-audio-duration-in-seconds)\n * @deprecated Use `parseMedia()` instead: https://www.remotion.dev/docs/media-parser/parse-media\n */\nconst getAudioDurationInSeconds = (src) => {\n    return limit(fn, src);\n};\nexports.getAudioDurationInSeconds = getAudioDurationInSeconds;\n/**\n * @deprecated Renamed to `getAudioDurationInSeconds`\n */\nconst getAudioDuration = (src) => (0, exports.getAudioDurationInSeconds)(src);\nexports.getAudioDuration = getAudioDuration;\n\n\n/***/ }),\n\n/***/ 9196:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getImageDimensions = getImageDimensions;\nconst p_limit_1 = __webpack_require__(1082);\nconst imageDimensionsCache = {};\nconst limit = (0, p_limit_1.pLimit)(3);\nconst fn = async (src) => {\n    if (imageDimensionsCache[src]) {\n        return imageDimensionsCache[src];\n    }\n    if (typeof document === 'undefined') {\n        throw new Error('getImageDimensions() is only available in the browser.');\n    }\n    const imageDimensions = await new Promise((resolved, reject) => {\n        const image = new Image();\n        image.onload = () => {\n            const { width, height } = image;\n            resolved({ width, height });\n        };\n        image.onerror = reject;\n        image.src = src;\n    });\n    imageDimensionsCache[src] = imageDimensions;\n    return imageDimensions;\n};\n/*\n * @description Takes an image src, retrieves the dimensions of an image.\n * @see [Documentation](https://remotion.dev/docs/get-image-dimensions)\n */\nfunction getImageDimensions(src) {\n    return limit(fn, src);\n}\n\n\n/***/ }),\n\n/***/ 5773:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getPartialWaveData = void 0;\nconst fetch_with_cors_catch_1 = __webpack_require__(5633);\nconst probe_wave_file_1 = __webpack_require__(7589);\nconst getPartialWaveData = async ({ dataOffset, src, bitsPerSample, channelIndex, sampleRate, fromSeconds, toSeconds, blockAlign, fileSize, signal, }) => {\n    const startByte = dataOffset + Math.floor(fromSeconds * sampleRate) * blockAlign;\n    const endByte = Math.min(fileSize, (dataOffset + Math.floor(toSeconds * sampleRate)) * blockAlign) - 1;\n    const response = await (0, fetch_with_cors_catch_1.fetchWithCorsCatch)(src, {\n        headers: {\n            range: `bytes=${startByte}-${endByte}`,\n        },\n        signal,\n    });\n    if (response.status === 416) {\n        throw new Error(`Tried to read bytes ${startByte}-${endByte} from ${src}, but the response status code was 416 \"Range Not Satisfiable\". Were too many bytes requested? The file is ${fileSize} bytes long.`);\n    }\n    if (response.status !== 206) {\n        throw new Error(`Tried to read bytes ${startByte}-${endByte} from ${src}, but the response status code was ${response.status} (expected was 206). This means the server might not support returning a partial response.`);\n    }\n    const arrayBuffer = await response.arrayBuffer();\n    const uintArray = new Uint8Array(arrayBuffer);\n    const samples = new Float32Array(uintArray.length / blockAlign);\n    for (let i = 0; i < uintArray.length; i += blockAlign) {\n        const sampleStart = i + channelIndex * (bitsPerSample / 8);\n        let sample;\n        if (bitsPerSample === 16) {\n            sample = (0, probe_wave_file_1.getInt16AsFloat)(uintArray, sampleStart);\n        }\n        else if (bitsPerSample === 8) {\n            sample = (0, probe_wave_file_1.getInt8AsFloat)(uintArray, sampleStart);\n        }\n        else {\n            throw new Error(`Unsupported bits per sample: ${bitsPerSample}`);\n        }\n        samples[i / blockAlign] = sample;\n    }\n    return samples;\n};\nexports.getPartialWaveData = getPartialWaveData;\n\n\n/***/ }),\n\n/***/ 1994:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getVideoMetadata = void 0;\n/* eslint-disable @typescript-eslint/no-use-before-define */\nconst is_remote_asset_1 = __webpack_require__(5448);\nconst media_tag_error_handling_1 = __webpack_require__(4970);\nconst p_limit_1 = __webpack_require__(1082);\nconst cache = {};\nconst limit = (0, p_limit_1.pLimit)(3);\nconst fn = (src) => {\n    if (cache[src]) {\n        return Promise.resolve(cache[src]);\n    }\n    if (typeof document === 'undefined') {\n        throw new Error('getVideoMetadata() is only available in the browser.');\n    }\n    const video = document.createElement('video');\n    video.src = src;\n    return new Promise((resolve, reject) => {\n        const onError = () => {\n            (0, media_tag_error_handling_1.onMediaError)({\n                error: video.error,\n                src,\n                cleanup,\n                reject,\n                api: 'getVideoMetadata()',\n            });\n        };\n        const onLoadedMetadata = () => {\n            const pixels = video.videoHeight * video.videoWidth;\n            if (pixels === 0) {\n                reject(new Error(`Unable to determine video metadata for ${src}`));\n                return;\n            }\n            if (!Number.isFinite(video.duration)) {\n                reject(new Error(`Unable to determine video duration for ${src} - got Infinity. Re-encoding this video may fix this issue.`));\n                return;\n            }\n            const metadata = {\n                durationInSeconds: video.duration,\n                width: video.videoWidth,\n                height: video.videoHeight,\n                aspectRatio: video.videoWidth / video.videoHeight,\n                isRemote: (0, is_remote_asset_1.isRemoteAsset)(src),\n            };\n            resolve(metadata);\n            cache[src] = metadata;\n            cleanup();\n        };\n        const cleanup = () => {\n            video.removeEventListener('loadedmetadata', onLoadedMetadata);\n            video.removeEventListener('error', onError);\n            video.remove();\n        };\n        video.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });\n        video.addEventListener('error', onError, { once: true });\n    });\n};\n/**\n * @description Takes a src to a video, loads it and returns metadata for the specified source.\n * @see [Documentation](https://remotion.dev/docs/get-video-metadata)\n * @deprecated Use `parseMedia()` instead: https://www.remotion.dev/docs/miscellaneous/parse-media-vs-get-video-metadata\n */\nconst getVideoMetadata = (src) => {\n    return limit(fn, src);\n};\nexports.getVideoMetadata = getVideoMetadata;\n\n\n/***/ }),\n\n/***/ 7761:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getWaveformSamples = void 0;\nconst normalize_data_1 = __webpack_require__(5332);\nconst getWaveformSamples = ({ audioBuffer, numberOfSamples, outputRange, normalize, }) => {\n    const blockSize = Math.floor(audioBuffer.length / numberOfSamples); // the number of samples in each subdivision\n    if (blockSize === 0) {\n        return [];\n    }\n    const filteredData = [];\n    for (let i = 0; i < numberOfSamples; i++) {\n        const blockStart = blockSize * i; // the location of the first sample in the block\n        let sum = 0;\n        for (let j = 0; j < blockSize; j++) {\n            sum += Math.abs(audioBuffer[blockStart + j]); // find the sum of all the samples in the block\n        }\n        filteredData.push(sum / blockSize); // divide the sum by the block size to get the average\n    }\n    if (normalize) {\n        if (outputRange === 'minus-one-to-one') {\n            return (0, normalize_data_1.normalizeData)(filteredData).map((n, i) => {\n                if (i % 2 === 0) {\n                    return n * -1;\n                }\n                return n;\n            });\n        }\n        return (0, normalize_data_1.normalizeData)(filteredData);\n    }\n    if (outputRange === 'minus-one-to-one') {\n        return filteredData.map((n, i) => {\n            if (i % 2 === 0) {\n                return n * -1;\n            }\n            return n;\n        });\n    }\n    return filteredData;\n};\nexports.getWaveformSamples = getWaveformSamples;\n\n\n/***/ }),\n\n/***/ 3616:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getWaveformPortion = void 0;\nconst no_react_1 = __webpack_require__(9382);\nconst get_wave_form_samples_1 = __webpack_require__(7761);\nconst validate_channel_1 = __webpack_require__(6746);\nconst concatArrays = (arrays) => {\n    // sum of individual array lengths\n    const totalLength = arrays.reduce((acc, value) => acc + value.length, 0);\n    const result = new Float32Array(totalLength);\n    // for each array - copy it over result\n    // next array is copied right after the previous one\n    let length = 0;\n    for (const array of arrays) {\n        result.set(array, length);\n        length += array.length;\n    }\n    return result;\n};\n/*\n * @description Takes bulky waveform data (for example fetched by getAudioData()) and returns a trimmed and simplified version of it, for simpler visualization\n * @see [Documentation](https://remotion.dev/docs/get-waveform-portion)\n */\nconst getWaveformPortion = ({ audioData, startTimeInSeconds, durationInSeconds, numberOfSamples, channel = 0, outputRange = 'zero-to-one', dataOffsetInSeconds, normalize = true, }) => {\n    (0, validate_channel_1.validateChannel)(channel, audioData.numberOfChannels);\n    const waveform = audioData.channelWaveforms[channel];\n    const startSample = Math.floor((startTimeInSeconds - (dataOffsetInSeconds !== null && dataOffsetInSeconds !== void 0 ? dataOffsetInSeconds : 0)) * audioData.sampleRate);\n    const endSample = Math.floor((startTimeInSeconds - (dataOffsetInSeconds !== null && dataOffsetInSeconds !== void 0 ? dataOffsetInSeconds : 0) + durationInSeconds) *\n        audioData.sampleRate);\n    const samplesBeforeStart = 0 - startSample;\n    const samplesAfterEnd = endSample - waveform.length;\n    const clampedStart = Math.max(startSample, 0);\n    const clampedEnd = Math.min(waveform.length, endSample);\n    const padStart = samplesBeforeStart > 0\n        ? new Float32Array(samplesBeforeStart).fill(0)\n        : null;\n    const padEnd = samplesAfterEnd > 0 ? new Float32Array(samplesAfterEnd).fill(0) : null;\n    const arrs = [\n        padStart,\n        waveform.slice(clampedStart, clampedEnd),\n        padEnd,\n    ].filter(no_react_1.NoReactInternals.truthy);\n    const audioBuffer = arrs.length === 1 ? arrs[0] : concatArrays(arrs);\n    return (0, get_wave_form_samples_1.getWaveformSamples)({\n        audioBuffer,\n        numberOfSamples,\n        outputRange,\n        normalize,\n    }).map((w, i) => {\n        return {\n            index: i,\n            amplitude: w,\n        };\n    });\n};\nexports.getWaveformPortion = getWaveformPortion;\n\n\n/***/ }),\n\n/***/ 6996:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.visualizeAudioWaveform = exports.visualizeAudio = exports.useWindowedAudioData = exports.useAudioData = exports.probeWaveFile = exports.getWaveformPortion = exports.getVideoMetadata = exports.getPartialWaveData = exports.getImageDimensions = exports.getAudioDurationInSeconds = exports.getAudioDuration = exports.getAudioData = exports.createSmoothSvgPath = exports.audioBufferToDataUrl = void 0;\nvar audio_url_helpers_1 = __webpack_require__(7996);\nObject.defineProperty(exports, \"audioBufferToDataUrl\", ({ enumerable: true, get: function () { return audio_url_helpers_1.audioBufferToDataUrl; } }));\nvar create_smooth_svg_path_1 = __webpack_require__(9144);\nObject.defineProperty(exports, \"createSmoothSvgPath\", ({ enumerable: true, get: function () { return create_smooth_svg_path_1.createSmoothSvgPath; } }));\nvar get_audio_data_1 = __webpack_require__(5576);\nObject.defineProperty(exports, \"getAudioData\", ({ enumerable: true, get: function () { return get_audio_data_1.getAudioData; } }));\nvar get_audio_duration_in_seconds_1 = __webpack_require__(7970);\nObject.defineProperty(exports, \"getAudioDuration\", ({ enumerable: true, get: function () { return get_audio_duration_in_seconds_1.getAudioDuration; } }));\nObject.defineProperty(exports, \"getAudioDurationInSeconds\", ({ enumerable: true, get: function () { return get_audio_duration_in_seconds_1.getAudioDurationInSeconds; } }));\nvar get_image_dimensions_1 = __webpack_require__(9196);\nObject.defineProperty(exports, \"getImageDimensions\", ({ enumerable: true, get: function () { return get_image_dimensions_1.getImageDimensions; } }));\nvar get_partial_wave_data_1 = __webpack_require__(5773);\nObject.defineProperty(exports, \"getPartialWaveData\", ({ enumerable: true, get: function () { return get_partial_wave_data_1.getPartialWaveData; } }));\nvar get_video_metadata_1 = __webpack_require__(1994);\nObject.defineProperty(exports, \"getVideoMetadata\", ({ enumerable: true, get: function () { return get_video_metadata_1.getVideoMetadata; } }));\nvar get_waveform_portion_1 = __webpack_require__(3616);\nObject.defineProperty(exports, \"getWaveformPortion\", ({ enumerable: true, get: function () { return get_waveform_portion_1.getWaveformPortion; } }));\nvar probe_wave_file_1 = __webpack_require__(7589);\nObject.defineProperty(exports, \"probeWaveFile\", ({ enumerable: true, get: function () { return probe_wave_file_1.probeWaveFile; } }));\n__exportStar(__webpack_require__(5169), exports);\nvar use_audio_data_1 = __webpack_require__(205);\nObject.defineProperty(exports, \"useAudioData\", ({ enumerable: true, get: function () { return use_audio_data_1.useAudioData; } }));\nvar use_windowed_audio_data_1 = __webpack_require__(1447);\nObject.defineProperty(exports, \"useWindowedAudioData\", ({ enumerable: true, get: function () { return use_windowed_audio_data_1.useWindowedAudioData; } }));\nvar visualize_audio_1 = __webpack_require__(8717);\nObject.defineProperty(exports, \"visualizeAudio\", ({ enumerable: true, get: function () { return visualize_audio_1.visualizeAudio; } }));\nvar visualize_audio_waveform_1 = __webpack_require__(4853);\nObject.defineProperty(exports, \"visualizeAudioWaveform\", ({ enumerable: true, get: function () { return visualize_audio_waveform_1.visualizeAudioWaveform; } }));\n\n\n/***/ }),\n\n/***/ 5448:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isRemoteAsset = void 0;\nconst isRemoteAsset = (asset) => !asset.startsWith(window.origin) && !asset.startsWith('data');\nexports.isRemoteAsset = isRemoteAsset;\n\n\n/***/ }),\n\n/***/ 4970:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.onMediaError = void 0;\nasync function fetchWithTimeout(url, options, timeout = 3000) {\n    const controller = new AbortController();\n    const id = setTimeout(() => controller.abort(), timeout);\n    options.signal = controller.signal;\n    try {\n        const response = await fetch(url, options);\n        clearTimeout(id);\n        return response;\n    }\n    catch (_a) {\n        clearTimeout(id);\n        throw new Error(`Fetch timed out after ${timeout}ms`);\n    }\n}\nconst checkFor404 = (src) => {\n    return fetchWithTimeout(src, {\n        method: 'HEAD',\n        mode: 'no-cors',\n    }).then((res) => res.status);\n};\nconst checkFor404OrSkip = async ({ suspecting404, sameOrigin, src, }) => {\n    if (!suspecting404) {\n        return Promise.resolve(null);\n    }\n    if (!sameOrigin) {\n        return Promise.resolve(null);\n    }\n    try {\n        return await checkFor404(src);\n    }\n    catch (_a) {\n        return Promise.resolve(null);\n    }\n};\nconst onMediaError = ({ error, src, reject, cleanup, api, }) => {\n    const suspecting404 = error.MEDIA_ERR_SRC_NOT_SUPPORTED === error.code;\n    const isSrcSameOriginAsCurrent = new URL(src, window.location.origin)\n        .toString()\n        .startsWith(window.location.origin);\n    checkFor404OrSkip({\n        suspecting404,\n        sameOrigin: isSrcSameOriginAsCurrent,\n        src,\n    })\n        .then((status) => {\n        const err = status === 404\n            ? new Error([\n                `Failed to execute ${api}: Received a 404 error loading \"${src}\".`,\n                'Correct the URL of the file.',\n            ].join(' '))\n            : new Error([\n                `Failed to execute ${api}, Received a MediaError loading \"${src}\". Consider using parseMedia() instead which supports more codecs: https://www.remotion.dev/docs/miscellaneous/parse-media-vs-get-video-metadata`,\n                status === null\n                    ? null\n                    : `HTTP Status code of the file: ${status}.`,\n                error.message\n                    ? `Browser error message: ${error.message}`\n                    : null,\n                'Check the path of the file and if it is a valid video.',\n            ]\n                .filter(Boolean)\n                .join(' '));\n        reject(err);\n        cleanup();\n    })\n        .catch((e) => {\n        reject(e);\n        cleanup();\n    });\n};\nexports.onMediaError = onMediaError;\n\n\n/***/ }),\n\n/***/ 5332:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.normalizeData = void 0;\nconst normalizeData = (filteredData) => {\n    const max = Math.max(...filteredData);\n    const multiplier = max === 0 ? 0 : max ** -1;\n    return filteredData.map((n) => n * multiplier);\n};\nexports.normalizeData = normalizeData;\n\n\n/***/ }),\n\n/***/ 1082:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pLimit = void 0;\nconst pLimit = (concurrency) => {\n    const queue = [];\n    let activeCount = 0;\n    const next = () => {\n        var _a;\n        activeCount--;\n        if (queue.length > 0) {\n            (_a = queue.shift()) === null || _a === void 0 ? void 0 : _a();\n        }\n    };\n    const run = async (fn, resolve, ...args) => {\n        activeCount++;\n        // eslint-disable-next-line require-await\n        const result = (async () => fn(...args))();\n        resolve(result);\n        try {\n            await result;\n        }\n        catch (_a) { }\n        next();\n    };\n    const enqueue = (fn, resolve, ...args) => {\n        queue.push(() => run(fn, resolve, ...args));\n        (async () => {\n            var _a;\n            // This function needs to wait until the next microtask before comparing\n            // `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n            // when the run function is dequeued and called. The comparison in the if-statement\n            // needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n            await Promise.resolve();\n            if (activeCount < concurrency && queue.length > 0) {\n                (_a = queue.shift()) === null || _a === void 0 ? void 0 : _a();\n            }\n        })();\n    };\n    const generator = (fn, ...args) => new Promise((resolve) => {\n        enqueue(fn, resolve, ...args);\n    });\n    Object.defineProperties(generator, {\n        activeCount: {\n            get: () => activeCount,\n        },\n        pendingCount: {\n            get: () => queue.length,\n        },\n        clearQueue: {\n            value: () => {\n                queue.length = 0;\n            },\n        },\n    });\n    return generator;\n};\nexports.pLimit = pLimit;\n\n\n/***/ }),\n\n/***/ 7589:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.probeWaveFile = exports.getInt8AsFloat = exports.getInt16AsFloat = void 0;\nconst fetch_with_cors_catch_1 = __webpack_require__(5633);\nconst getUint32 = (bytes, offset) => {\n    const val1 = bytes[offset + 3];\n    const val2 = bytes[offset + 2];\n    const val3 = bytes[offset + 1];\n    const val4 = bytes[offset];\n    return (val1 << 24) | (val2 << 16) | (val3 << 8) | val4;\n};\nconst getUint16 = (bytes, offset) => {\n    const val1 = bytes[offset + 1];\n    const val2 = bytes[offset];\n    return (val1 << 8) | val2;\n};\nconst getInt16AsFloat = (bytes, offset) => {\n    if (offset >= bytes.length) {\n        throw new Error(`Tried to read a 16-bit integer from offset ${offset} but the array length is ${bytes.length}`);\n    }\n    const val1 = bytes[offset + 1];\n    const val2 = bytes[offset];\n    const int16 = (val1 << 8) | val2;\n    return ((int16 << 16) >> 16) / 32768;\n};\nexports.getInt16AsFloat = getInt16AsFloat;\nconst getInt8AsFloat = (bytes, offset) => {\n    if (offset >= bytes.length) {\n        throw new Error(`Tried to read an 8-bit integer from offset ${offset} but the array length is ${bytes.length}`);\n    }\n    return bytes[offset] / 128;\n};\nexports.getInt8AsFloat = getInt8AsFloat;\nconst probeWaveFile = async (src, probeSize = 1024) => {\n    const response = await (0, fetch_with_cors_catch_1.fetchWithCorsCatch)(src, {\n        headers: {\n            range: `bytes=0-${probeSize - 1}`,\n        },\n    });\n    if (response.status === 416) {\n        throw new Error(`Tried to read bytes 0-1024 from ${src}, but the response status code was 416 \"Range Not Satisfiable\". Is the file at least 256 bytes long?`);\n    }\n    if (response.status !== 206) {\n        throw new Error(`Tried to read bytes 0-1024 from ${src}, but the response status code was ${response.status} (expected was 206). This means the server might not support returning a partial response.`);\n    }\n    const buffer = await response.arrayBuffer();\n    const uintArray = new Uint8Array(buffer);\n    const shouldBeRiff = new TextDecoder().decode(uintArray.slice(0, 4));\n    if (shouldBeRiff !== 'RIFF') {\n        throw new Error('getPartialAudioData() requires a WAVE file, but the first bytes are not RIFF. ');\n    }\n    const size = getUint32(uintArray, 4);\n    const shouldBeWAVE = new TextDecoder().decode(uintArray.slice(8, 12));\n    if (shouldBeWAVE !== 'WAVE') {\n        throw new Error('getPartialAudioData() requires a WAVE file, but the bytes 8-11 are not \"WAVE\". ');\n    }\n    const shouldBeFmt = new TextDecoder().decode(uintArray.slice(12, 16));\n    if (shouldBeFmt !== 'fmt ') {\n        throw new Error('getPartialAudioData() requires a WAVE file, but the bytes 12-15 are not \"fmt \". ');\n    }\n    // const chunkSize = toUint32(uintArray.slice(16, 20));\n    const audioFormat = getUint16(uintArray, 20);\n    if (audioFormat !== 1) {\n        throw new Error('getPartialAudioData() supports only a WAVE file with PCM audio format, but the audio format is not PCM. ');\n    }\n    const numberOfChannels = getUint16(uintArray, 22);\n    const sampleRate = getUint32(uintArray, 24);\n    const blockAlign = getUint16(uintArray, 32);\n    const bitsPerSample = getUint16(uintArray, 34);\n    let offset = 36;\n    const shouldBeDataOrList = new TextDecoder().decode(uintArray.slice(offset, offset + 4));\n    if (shouldBeDataOrList === 'LIST') {\n        const listSize = getUint32(uintArray, 40);\n        offset += listSize;\n        offset += 8;\n    }\n    if (offset + 4 > probeSize) {\n        return (0, exports.probeWaveFile)(src, offset + 4);\n    }\n    const shouldBeData = new TextDecoder().decode(uintArray.slice(offset, offset + 4));\n    if (shouldBeData !== 'data') {\n        throw new Error(`getPartialAudioData() requires a WAVE file, but the bytes ${offset}-${offset + 4} are not \"data\". `);\n    }\n    const dataSize = getUint32(uintArray, offset + 4);\n    return {\n        dataOffset: offset + 8,\n        bitsPerSample,\n        numberOfChannels,\n        sampleRate,\n        blockAlign,\n        fileSize: size,\n        durationInSeconds: dataSize / (sampleRate * blockAlign),\n    };\n};\nexports.probeWaveFile = probeWaveFile;\n\n\n/***/ }),\n\n/***/ 5169:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n/***/ }),\n\n/***/ 205:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.useAudioData = void 0;\nconst react_1 = __webpack_require__(6540);\nconst remotion_1 = __webpack_require__(3947);\nconst get_audio_data_1 = __webpack_require__(5576);\n/*\n * @description Wraps the getAudioData() function into a hook and does three things: keeps the audio data in a state, wraps the function in a delayRender() / continueRender() pattern, and handles the case where the component gets unmounted while fetching is in progress to prevent React errors.\n * @see [Documentation](https://www.remotion.dev/docs/use-audio-data)\n */\nconst useAudioData = (src) => {\n    if (!src) {\n        throw new TypeError(\"useAudioData requires a 'src' parameter\");\n    }\n    const mountState = (0, react_1.useRef)({ isMounted: true });\n    (0, react_1.useEffect)(() => {\n        const { current } = mountState;\n        current.isMounted = true;\n        return () => {\n            current.isMounted = false;\n        };\n    }, []);\n    const [metadata, setMetadata] = (0, react_1.useState)(null);\n    const { delayRender, continueRender } = (0, remotion_1.useDelayRender)();\n    const fetchMetadata = (0, react_1.useCallback)(async () => {\n        const handle = delayRender(`Waiting for audio metadata with src=\"${src}\" to be loaded`);\n        try {\n            const data = await (0, get_audio_data_1.getAudioData)(src);\n            if (mountState.current.isMounted) {\n                setMetadata(data);\n            }\n        }\n        catch (err) {\n            (0, remotion_1.cancelRender)(err);\n        }\n        continueRender(handle);\n    }, [src, delayRender, continueRender]);\n    (0, react_1.useLayoutEffect)(() => {\n        fetchMetadata();\n    }, [fetchMetadata]);\n    return metadata;\n};\nexports.useAudioData = useAudioData;\n\n\n/***/ }),\n\n/***/ 1447:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.useWindowedAudioData = void 0;\nconst react_1 = __webpack_require__(6540);\nconst remotion_1 = __webpack_require__(3947);\nconst combine_float32_arrays_1 = __webpack_require__(1546);\nconst get_partial_wave_data_1 = __webpack_require__(5773);\nconst is_remote_asset_1 = __webpack_require__(5448);\nconst probe_wave_file_1 = __webpack_require__(7589);\nconst useWindowedAudioData = ({ src, frame, fps, windowInSeconds, channelIndex = 0, }) => {\n    const isMounted = (0, react_1.useRef)(true);\n    const [waveProbe, setWaveProbe] = (0, react_1.useState)(null);\n    const [waveFormMap, setWaveformMap] = (0, react_1.useState)({});\n    const requests = (0, react_1.useRef)({});\n    const [initialWindowInSeconds] = (0, react_1.useState)(windowInSeconds);\n    if (windowInSeconds !== initialWindowInSeconds) {\n        throw new Error('windowInSeconds cannot be changed dynamically');\n    }\n    (0, react_1.useEffect)(() => {\n        isMounted.current = true;\n        return () => {\n            isMounted.current = false;\n        };\n    }, []);\n    const { delayRender, continueRender } = (0, remotion_1.useDelayRender)();\n    const fetchMetadata = (0, react_1.useCallback)(async (signal) => {\n        const handle = delayRender(`Waiting for audio metadata with src=\"${src}\" to be loaded`);\n        const cont = () => {\n            continueRender(handle);\n        };\n        signal.addEventListener('abort', cont, { once: true });\n        try {\n            const data = await (0, probe_wave_file_1.probeWaveFile)(src);\n            if (isMounted.current) {\n                setWaveProbe(data);\n            }\n            continueRender(handle);\n        }\n        catch (err) {\n            (0, remotion_1.cancelRender)(err);\n        }\n        finally {\n            signal.removeEventListener('abort', cont);\n        }\n    }, [src, delayRender, continueRender]);\n    (0, react_1.useLayoutEffect)(() => {\n        const controller = new AbortController();\n        fetchMetadata(controller.signal);\n        return () => {\n            controller.abort();\n        };\n    }, [fetchMetadata]);\n    const currentTime = frame / fps;\n    const currentWindowIndex = Math.floor(currentTime / windowInSeconds);\n    const windowsToFetch = (0, react_1.useMemo)(() => {\n        if (!waveProbe) {\n            return [];\n        }\n        const maxWindowIndex = Math.floor(\n        // If an audio is exactly divisible by windowInSeconds, we need to\n        // subtract 0.000000000001 to avoid fetching an extra window.\n        waveProbe.durationInSeconds / windowInSeconds - 0.000000000001);\n        // needs to be in order because we rely on the concatenation below\n        return [\n            currentWindowIndex === 0 ? null : currentWindowIndex - 1,\n            currentWindowIndex,\n            currentWindowIndex + 1 > maxWindowIndex ? null : currentWindowIndex + 1,\n        ]\n            .filter((i) => i !== null)\n            .filter((i) => i >= 0);\n    }, [currentWindowIndex, waveProbe, windowInSeconds]);\n    const fetchAndSetWaveformData = (0, react_1.useCallback)(async (windowIndex) => {\n        if (!waveProbe) {\n            throw new Error('Wave probe is not loaded yet');\n        }\n        const controller = new AbortController();\n        requests.current[windowIndex] = controller;\n        const partialWaveData = await (0, get_partial_wave_data_1.getPartialWaveData)({\n            bitsPerSample: waveProbe.bitsPerSample,\n            blockAlign: waveProbe.blockAlign,\n            channelIndex,\n            dataOffset: waveProbe.dataOffset,\n            fileSize: waveProbe.fileSize,\n            fromSeconds: windowIndex * windowInSeconds,\n            sampleRate: waveProbe.sampleRate,\n            src,\n            toSeconds: (windowIndex + 1) * windowInSeconds,\n            signal: controller.signal,\n        });\n        requests.current[windowIndex] = null;\n        setWaveformMap((prev) => {\n            const entries = Object.keys(prev);\n            const windowsToClear = entries.filter((entry) => !windowsToFetch.includes(Number(entry)));\n            return {\n                ...prev,\n                // Delete windows that are not needed anymore\n                ...windowsToClear.reduce((acc, key) => {\n                    acc[key] = null;\n                    return acc;\n                }, {}),\n                // Add the new window\n                [windowIndex]: partialWaveData,\n            };\n        });\n    }, [channelIndex, src, waveProbe, windowInSeconds, windowsToFetch]);\n    (0, react_1.useEffect)(() => {\n        if (!waveProbe) {\n            return;\n        }\n        const windowsToClear = Object.keys(requests.current).filter((entry) => !windowsToFetch.includes(Number(entry)));\n        for (const windowIndex of windowsToClear) {\n            const controller = requests.current[windowIndex];\n            if (controller) {\n                controller.abort();\n                requests.current[windowIndex] = null;\n            }\n        }\n        Promise.all(windowsToFetch.map((windowIndex) => {\n            return fetchAndSetWaveformData(windowIndex);\n        })).catch((err) => {\n            var _a, _b, _c, _d, _e;\n            if ((_a = err.stack) === null || _a === void 0 ? void 0 : _a.includes('Cancelled')) {\n                return;\n            }\n            if ((_c = (_b = err.stack) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === null || _c === void 0 ? void 0 : _c.includes('aborted')) {\n                return;\n            }\n            // firefox\n            if ((_e = (_d = err.message) === null || _d === void 0 ? void 0 : _d.toLowerCase()) === null || _e === void 0 ? void 0 : _e.includes('aborted')) {\n                return;\n            }\n            (0, remotion_1.cancelRender)(err);\n        });\n    }, [fetchAndSetWaveformData, waveProbe, windowsToFetch]);\n    const currentAudioData = (0, react_1.useMemo)(() => {\n        if (!waveProbe) {\n            return null;\n        }\n        if (windowsToFetch.some((i) => !waveFormMap[i])) {\n            return null;\n        }\n        const windows = windowsToFetch.map((i) => waveFormMap[i]);\n        const data = (0, combine_float32_arrays_1.combineFloat32Arrays)(windows);\n        return {\n            channelWaveforms: [data],\n            durationInSeconds: waveProbe.durationInSeconds,\n            isRemote: (0, is_remote_asset_1.isRemoteAsset)(src),\n            numberOfChannels: 1,\n            resultId: String(Math.random()),\n            sampleRate: waveProbe.sampleRate,\n        };\n    }, [src, waveFormMap, waveProbe, windowsToFetch]);\n    (0, react_1.useLayoutEffect)(() => {\n        if (currentAudioData) {\n            return;\n        }\n        const handle = delayRender(`Waiting for audio data with src=\"${src}\" to be loaded`);\n        return () => {\n            continueRender(handle);\n        };\n    }, [currentAudioData, src, delayRender, continueRender]);\n    return {\n        audioData: currentAudioData,\n        dataOffsetInSeconds: windowsToFetch[0] * windowInSeconds,\n    };\n};\nexports.useWindowedAudioData = useWindowedAudioData;\n\n\n/***/ }),\n\n/***/ 6746:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateChannel = void 0;\nconst validateChannel = (channel, numberOfChannels) => {\n    if (typeof channel !== 'number') {\n        throw new TypeError(`\"channel\" must be a number`);\n    }\n    if (channel % 1 !== 0) {\n        throw new TypeError(`\"channel\" must an integer, got ${channel}`);\n    }\n    if (Number.isNaN(channel)) {\n        throw new TypeError(`The channel parameter is NaN.`);\n    }\n    if (channel < 0) {\n        throw new TypeError('\"channel\" cannot be negative');\n    }\n    if (channel > numberOfChannels - 1) {\n        throw new TypeError(`\"channel\" must be ${numberOfChannels - 1} or lower. The audio has ${numberOfChannels} channels`);\n    }\n};\nexports.validateChannel = validateChannel;\n\n\n/***/ }),\n\n/***/ 4853:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.visualizeAudioWaveform = void 0;\nconst get_waveform_portion_1 = __webpack_require__(3616);\nconst cache = {};\nconst visualizeAudioWaveformFrame = ({ audioData, frame, fps, numberOfSamples, windowInSeconds, channel, dataOffsetInSeconds, normalize = false, }) => {\n    if (windowInSeconds * audioData.sampleRate < numberOfSamples) {\n        throw new TypeError(windowInSeconds +\n            's audiodata does not have ' +\n            numberOfSamples +\n            ' bars. Increase windowInSeconds or decrease numberOfSamples');\n    }\n    const cacheKey = audioData.resultId +\n        frame +\n        fps +\n        numberOfSamples +\n        'waveform' +\n        dataOffsetInSeconds;\n    if (cache[cacheKey]) {\n        return cache[cacheKey];\n    }\n    const time = frame / fps;\n    const startTimeInSeconds = time - windowInSeconds / 2;\n    return (0, get_waveform_portion_1.getWaveformPortion)({\n        audioData,\n        startTimeInSeconds,\n        durationInSeconds: windowInSeconds,\n        numberOfSamples,\n        outputRange: 'minus-one-to-one',\n        channel,\n        dataOffsetInSeconds,\n        normalize,\n    });\n};\nconst visualizeAudioWaveform = (parameters) => {\n    const data = visualizeAudioWaveformFrame(parameters);\n    return data.map((value) => value.amplitude);\n};\nexports.visualizeAudioWaveform = visualizeAudioWaveform;\n\n\n/***/ }),\n\n/***/ 8717:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.visualizeAudio = void 0;\nconst no_react_1 = __webpack_require__(9382);\nconst get_visualization_1 = __webpack_require__(9894);\nconst max_value_cached_1 = __webpack_require__(2268);\nconst cache = {};\n/**\n * @description Takes in AudioData (preferably fetched by the useAudioData() hook) and processes it in a way that makes visualizing the audio that is playing at the current frame easy.\n * @description part of @remotion/media-utils\n * @see [Documentation](https://www.remotion.dev/docs/visualize-audio)\n */\nconst visualizeAudioFrame = ({ audioData, frame, fps, numberOfSamples, optimizeFor, dataOffsetInSeconds, }) => {\n    const cacheKey = audioData.resultId + frame + fps + numberOfSamples;\n    if (cache[cacheKey]) {\n        return cache[cacheKey];\n    }\n    const maxInt = (0, max_value_cached_1.getMaxPossibleMagnitude)(audioData);\n    return (0, get_visualization_1.getVisualization)({\n        sampleSize: numberOfSamples * 2,\n        data: audioData.channelWaveforms[0],\n        frame,\n        fps,\n        sampleRate: audioData.sampleRate,\n        maxInt,\n        optimizeFor,\n        dataOffsetInSeconds,\n    });\n};\nconst visualizeAudio = ({ smoothing = true, optimizeFor = no_react_1.NoReactInternals.ENABLE_V5_BREAKING_CHANGES\n    ? 'speed'\n    : 'accuracy', dataOffsetInSeconds = 0, ...parameters }) => {\n    if (!smoothing) {\n        return visualizeAudioFrame({\n            ...parameters,\n            optimizeFor,\n            dataOffsetInSeconds,\n            smoothing,\n        });\n    }\n    const toSmooth = [\n        parameters.frame - 1,\n        parameters.frame,\n        parameters.frame + 1,\n    ];\n    const all = toSmooth.map((s) => {\n        return visualizeAudioFrame({\n            ...parameters,\n            frame: s,\n            dataOffsetInSeconds,\n            optimizeFor,\n            smoothing,\n        });\n    });\n    return new Array(parameters.numberOfSamples).fill(true).map((_x, i) => {\n        return (new Array(toSmooth.length)\n            .fill(true)\n            .map((_, j) => {\n            return all[j][i];\n        })\n            .reduce((a, b) => a + b, 0) / toSmooth.length);\n    });\n};\nexports.visualizeAudio = visualizeAudio;\n\n\n/***/ }),\n\n/***/ 9057:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stripAnsi = void 0;\nexports.splitAnsi = splitAnsi;\nconst ansiRegex = () => {\n    const pattern = [\n        '[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n        '(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))',\n    ].join('|');\n    return new RegExp(pattern, 'g');\n};\nfunction splitAnsi(str) {\n    const parts = str.match(ansiRegex());\n    if (!parts)\n        return [str];\n    const result = [];\n    let offset = 0;\n    let ptr = 0;\n    for (let i = 0; i < parts.length; i++) {\n        offset = str.indexOf(parts[i], offset);\n        if (offset === -1)\n            throw new Error('Could not split string');\n        if (ptr !== offset)\n            result.push(str.slice(ptr, offset));\n        if (ptr === offset && result.length) {\n            result[result.length - 1] += parts[i];\n        }\n        else {\n            if (offset === 0)\n                result.push('');\n            result.push(parts[i]);\n        }\n        ptr = offset + parts[i].length;\n    }\n    result.push(str.slice(ptr));\n    return result;\n}\nconst stripAnsi = (str) => {\n    if (typeof str !== 'string') {\n        throw new TypeError(`Expected a \\`string\\`, got \\`${typeof str}\\``);\n    }\n    return str.replace(ansiRegex(), '');\n};\nexports.stripAnsi = stripAnsi;\n\n\n/***/ }),\n\n/***/ 3507:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_BUFFER_STATE_DELAY_IN_MILLISECONDS = void 0;\nexports.DEFAULT_BUFFER_STATE_DELAY_IN_MILLISECONDS = 300;\n\n\n/***/ }),\n\n/***/ 9567:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.formatBytes = void 0;\nconst BYTE_UNITS = ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\nconst BIBYTE_UNITS = [\n    'B',\n    'kiB',\n    'MiB',\n    'GiB',\n    'TiB',\n    'PiB',\n    'EiB',\n    'ZiB',\n    'YiB',\n];\nconst BIT_UNITS = [\n    'b',\n    'kbit',\n    'Mbit',\n    'Gbit',\n    'Tbit',\n    'Pbit',\n    'Ebit',\n    'Zbit',\n    'Ybit',\n];\nconst BIBIT_UNITS = [\n    'b',\n    'kibit',\n    'Mibit',\n    'Gibit',\n    'Tibit',\n    'Pibit',\n    'Eibit',\n    'Zibit',\n    'Yibit',\n];\n/*\nFormats the given number using `Number#toLocaleString`.\n- If locale is a string, the value is expected to be a locale-key (for example: `de`).\n- If locale is true, the system default locale is used for translation.\n- If no value for locale is specified, the number is returned unmodified.\n*/\nconst toLocaleString = (number, locale, options) => {\n    if (typeof locale === 'string' || Array.isArray(locale)) {\n        return number.toLocaleString(locale, options);\n    }\n    if (locale === true || options !== undefined) {\n        return number.toLocaleString(undefined, options);\n    }\n    return String(number);\n};\nconst formatBytes = (number, options = {\n    locale: 'en-US',\n    signed: false,\n    maximumFractionDigits: 1,\n}) => {\n    if (!Number.isFinite(number)) {\n        throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);\n    }\n    options = { bits: false, binary: false, ...options };\n    const UNITS = options.bits\n        ? options.binary\n            ? BIBIT_UNITS\n            : BIT_UNITS\n        : options.binary\n            ? BIBYTE_UNITS\n            : BYTE_UNITS;\n    if (options.signed && number === 0) {\n        return `0 $ {\n            UNITS[0]\n        }`;\n    }\n    const isNegative = number < 0;\n    const prefix = isNegative ? '-' : options.signed ? '+' : '';\n    if (isNegative) {\n        number = -number;\n    }\n    let localeOptions;\n    if (options.minimumFractionDigits !== undefined) {\n        localeOptions = {\n            minimumFractionDigits: options.minimumFractionDigits,\n        };\n    }\n    if (options.maximumFractionDigits !== undefined) {\n        localeOptions = {\n            maximumFractionDigits: options.maximumFractionDigits,\n            ...localeOptions,\n        };\n    }\n    if (number < 1) {\n        const numString = toLocaleString(number, options.locale, localeOptions);\n        return prefix + numString + ' ' + UNITS[0];\n    }\n    const exponent = Math.min(Math.floor(options.binary\n        ? Math.log(number) / Math.log(1024)\n        : Math.log10(number) / 3), UNITS.length - 1);\n    number /= (options.binary ? 1024 : 1000) ** exponent;\n    const numberString = toLocaleString(Number(number), options.locale, localeOptions);\n    const unit = UNITS[exponent];\n    return prefix + numberString + ' ' + unit;\n};\nexports.formatBytes = formatBytes;\n\n\n/***/ }),\n\n/***/ 3953:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getDefaultOutLocation = void 0;\nconst getDefaultOutLocation = ({ compositionName, defaultExtension, type, compositionDefaultOutName, }) => {\n    const nameToUse = compositionDefaultOutName !== null && compositionDefaultOutName !== void 0 ? compositionDefaultOutName : compositionName;\n    if (type === 'sequence') {\n        return `out/${nameToUse}`;\n    }\n    return `out/${nameToUse}.${defaultExtension}`;\n};\nexports.getDefaultOutLocation = getDefaultOutLocation;\n\n\n/***/ }),\n\n/***/ 885:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getLocationFromBuildError = void 0;\nconst no_react_1 = __webpack_require__(9382);\nconst getLocationFromBuildError = (err) => {\n    var _a;\n    if (!err.stack) {\n        return null;\n    }\n    if (!err.stack.startsWith('Error: Module build failed') &&\n        !err.stack.startsWith('Error: Cannot find module')) {\n        return null;\n    }\n    const split = err.stack.split('\\n');\n    return ((_a = split\n        .map((s) => {\n        if (s.startsWith('Error')) {\n            return null;\n        }\n        const matchWebpackOrEsbuild = s.match(/(.*):([0-9]+):([0-9]+): (.*)/);\n        if (matchWebpackOrEsbuild) {\n            return {\n                fileName: matchWebpackOrEsbuild[1],\n                lineNumber: Number(matchWebpackOrEsbuild[2]),\n                columnNumber: Number(matchWebpackOrEsbuild[3]),\n                message: matchWebpackOrEsbuild[4],\n            };\n        }\n        const matchMissingModule = s.match(/\\s+at(.*)\\s\\((.*)\\)/);\n        if (!matchMissingModule) {\n            return null;\n        }\n        if (s.includes('webpackMissingModule')) {\n            return null;\n        }\n        const [, filename] = matchMissingModule;\n        return {\n            columnNumber: 0,\n            lineNumber: 1,\n            message: split[0],\n            fileName: filename.trim(),\n        };\n    })\n        .filter(no_react_1.NoReactInternals.truthy)[0]) !== null && _a !== void 0 ? _a : null);\n};\nexports.getLocationFromBuildError = getLocationFromBuildError;\n\n\n/***/ }),\n\n/***/ 2754:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getProjectName = void 0;\nconst getProjectName = ({ gitSource, resolvedRemotionRoot, basename, }) => {\n    // Directory name\n    if (!gitSource) {\n        return basename(resolvedRemotionRoot);\n    }\n    // Subfolder name of a Git repo, e.g `example`\n    if (gitSource.relativeFromGitRoot.trim()) {\n        return basename(gitSource.relativeFromGitRoot.trim());\n    }\n    // Name of the repo\n    return gitSource.name;\n};\nexports.getProjectName = getProjectName;\n\n\n/***/ }),\n\n/***/ 3356:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hotMiddlewareOptions = void 0;\nexports.hotMiddlewareOptions = {\n    path: '/__webpack_hmr',\n    timeout: 20 * 1000,\n    reload: true,\n    warn: true,\n    heartbeat: 10 * 1000,\n};\n\n\n/***/ }),\n\n/***/ 6588:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\nvar __webpack_unused_export__;\n\n__webpack_unused_export__ = ({ value: true });\n__webpack_unused_export__ = exports.fC = __webpack_unused_export__ = exports.W3 = exports.eH = exports.aO = exports.n3 = __webpack_unused_export__ = __webpack_unused_export__ = exports.Ug = exports.LE = exports.z3 = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = void 0;\nvar ansi_1 = __webpack_require__(9057);\n__webpack_unused_export__ = ({ enumerable: true, get: function () { return ansi_1.splitAnsi; } });\n__webpack_unused_export__ = ({ enumerable: true, get: function () { return ansi_1.stripAnsi; } });\nvar default_buffer_state_delay_in_milliseconds_1 = __webpack_require__(3507);\n__webpack_unused_export__ = ({ enumerable: true, get: function () { return default_buffer_state_delay_in_milliseconds_1.DEFAULT_BUFFER_STATE_DELAY_IN_MILLISECONDS; } });\nvar format_bytes_1 = __webpack_require__(9567);\nObject.defineProperty(exports, \"z3\", ({ enumerable: true, get: function () { return format_bytes_1.formatBytes; } }));\nvar get_default_out_name_1 = __webpack_require__(3953);\nObject.defineProperty(exports, \"LE\", ({ enumerable: true, get: function () { return get_default_out_name_1.getDefaultOutLocation; } }));\nvar get_location_from_build_error_1 = __webpack_require__(885);\nObject.defineProperty(exports, \"Ug\", ({ enumerable: true, get: function () { return get_location_from_build_error_1.getLocationFromBuildError; } }));\nvar get_project_name_1 = __webpack_require__(2754);\n__webpack_unused_export__ = ({ enumerable: true, get: function () { return get_project_name_1.getProjectName; } });\nvar hot_middleware_1 = __webpack_require__(3356);\n__webpack_unused_export__ = ({ enumerable: true, get: function () { return hot_middleware_1.hotMiddlewareOptions; } });\nvar max_timeline_tracks_1 = __webpack_require__(8769);\nObject.defineProperty(exports, \"n3\", ({ enumerable: true, get: function () { return max_timeline_tracks_1.DEFAULT_TIMELINE_TRACKS; } }));\nvar package_info_1 = __webpack_require__(1337);\nObject.defineProperty(exports, \"aO\", ({ enumerable: true, get: function () { return package_info_1.apiDocs; } }));\nObject.defineProperty(exports, \"eH\", ({ enumerable: true, get: function () { return package_info_1.descriptions; } }));\nObject.defineProperty(exports, \"W3\", ({ enumerable: true, get: function () { return package_info_1.installableMap; } }));\n__webpack_unused_export__ = ({ enumerable: true, get: function () { return package_info_1.packages; } });\nvar source_map_endpoint_1 = __webpack_require__(8188);\nObject.defineProperty(exports, \"fC\", ({ enumerable: true, get: function () { return source_map_endpoint_1.SOURCE_MAP_ENDPOINT; } }));\nvar stringify_default_props_1 = __webpack_require__(6266);\n__webpack_unused_export__ = ({ enumerable: true, get: function () { return stringify_default_props_1.stringifyDefaultProps; } });\n\n\n/***/ }),\n\n/***/ 8769:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_TIMELINE_TRACKS = void 0;\nexports.DEFAULT_TIMELINE_TRACKS = 90;\n\n\n/***/ }),\n\n/***/ 1337:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.apiDocs = exports.installableMap = exports.descriptions = exports.packages = void 0;\nexports.packages = [\n    'svg-3d-engine',\n    'ai-improvements',\n    'animation-utils',\n    'animated-emoji',\n    'astro-example',\n    'babel-loader',\n    'bugs',\n    'bundler',\n    'cli',\n    'cloudrun',\n    'compositor-darwin-arm64',\n    'compositor-darwin-x64',\n    'compositor-linux-arm64-gnu',\n    'compositor-linux-arm64-musl',\n    'compositor-linux-x64-gnu',\n    'compositor-linux-x64-musl',\n    'compositor-win32-x64-msvc',\n    'core',\n    'create-video',\n    'discord-poster',\n    'docusaurus-plugin',\n    'docs',\n    'enable-scss',\n    'eslint-config',\n    'eslint-config-flat',\n    'eslint-config-internal',\n    'eslint-plugin',\n    'example-without-zod',\n    'example',\n    'fonts',\n    'gif',\n    'google-fonts',\n    'install-whisper-cpp',\n    'it-tests',\n    'lambda-go-example',\n    'lambda-go',\n    'lambda-php',\n    'lambda-ruby',\n    'lambda-python',\n    'lambda',\n    'lambda-client',\n    'layout-utils',\n    'licensing',\n    'lottie',\n    'mcp',\n    'media-utils',\n    'motion-blur',\n    'noise',\n    'paths',\n    'player-example',\n    'player',\n    'preload',\n    'renderer',\n    'rive',\n    'shapes',\n    'skia',\n    'promo-pages',\n    'streaming',\n    'serverless',\n    'serverless-client',\n    'studio-server',\n    'studio-shared',\n    'studio',\n    'tailwind',\n    'tailwind-v4',\n    'test-utils',\n    'three',\n    'transitions',\n    'media-parser',\n    'zod-types',\n    'webcodecs',\n    'convert',\n    'captions',\n    'openai-whisper',\n    'compositor',\n    'example-videos',\n    'whisper-web',\n    'video',\n    'web-renderer',\n];\nexports.descriptions = {\n    compositor: 'Rust binary for Remotion',\n    player: 'React component for embedding a Remotion preview into your app',\n    cloudrun: 'Render Remotion videos on Google Cloud Run',\n    renderer: 'Render Remotion videos using Node.js or Bun',\n    cli: 'Control Remotion features using the `npx remotion` command',\n    core: 'Make videos programmatically',\n    lambda: 'Render Remotion videos on AWS Lambda',\n    bundler: 'Bundle Remotion compositions using Webpack',\n    'studio-server': 'Run a Remotion Studio with a server backend',\n    'install-whisper-cpp': 'Helpers for installing and using Whisper.cpp',\n    'whisper-web': 'Helpers for using Whisper.cpp in browser using WASM',\n    'google-fonts': 'Use Google Fonts in Remotion',\n    mcp: \"Remotion's Model Context Protocol\",\n    'media-utils': 'Utilities for working with media files',\n    lottie: 'Include Lottie animations in Remotion',\n    licensing: 'Manage your Remotion.pro license',\n    'layout-utils': 'Utilities for working with layouts',\n    noise: 'Noise generation functions',\n    'motion-blur': 'Motion blur effect for Remotion',\n    preload: 'Preloads assets for use in Remotion',\n    shapes: 'Generate SVG shapes',\n    'zod-types': 'Zod types for Remotion',\n    gif: 'Embed GIFs in a Remotion video',\n    'eslint-plugin': 'Rules for writing Remotion code',\n    'eslint-config': 'Default configuration for Remotion templates (ESLint <= 8)',\n    'eslint-config-flat': 'Default configuration for Remotion templates (ESLint >= 9)',\n    'compositor-linux-x64-gnu': 'Linux x64 binary for the Remotion Rust code',\n    'compositor-linux-x64-musl': 'Linux x64 binary for the Remotion Rust code',\n    'compositor-darwin-x64': 'MacOS x64 binary for the Remotion Rust code',\n    'compositor-darwin-arm64': 'MacOS Apple Silicon binary for the Remotion Rust code',\n    'compositor-linux-arm64-gnu': 'Linux ARM64 binary for the Remotion Rust code',\n    'compositor-linux-arm64-musl': 'Linux ARM64 binary for the Remotion Rust code',\n    'babel-loader': 'Babel loader for Remotion',\n    fonts: 'Helpers for loading local fonts into Remotion',\n    transitions: 'Library for creating transitions in Remotion',\n    'enable-scss': 'Enable SCSS support in Remotion',\n    'create-video': 'Create a new Remotion project',\n    'studio-shared': 'Internal package for shared objects between the Studio backend and frontend',\n    tailwind: 'Enable TailwindCSS support in Remotion (TailwindCSS v3)',\n    'tailwind-v4': 'Enable TailwindCSS support in Remotion (TailwindCSS v4)',\n    streaming: 'Utilities for streaming data between programs',\n    'media-parser': 'A pure JavaScript library for parsing video files',\n    rive: 'Embed Rive animations in a Remotion video',\n    paths: 'Utilities for working with SVG paths',\n    studio: 'APIs for interacting with the Remotion Studio',\n    skia: 'Include React Native Skia components in a Remotion video',\n    three: 'Include React Three Fiber components in a Remotion video',\n    'astro-example': null,\n    'lambda-go-example': null,\n    'compositor-win32-x64-msvc': null,\n    'animation-utils': 'Helpers for animating CSS properties',\n    'test-utils': null,\n    'example-without-zod': null,\n    'lambda-go': null,\n    example: null,\n    'lambda-php': null,\n    'lambda-client': null,\n    bugs: null,\n    docs: null,\n    'it-tests': null,\n    'lambda-python': null,\n    'lambda-ruby': null,\n    'player-example': null,\n    'ai-improvements': null,\n    'discord-poster': null,\n    'docusaurus-plugin': null,\n    'animated-emoji': 'Google Fonts Animated Emojis as Remotion components',\n    serverless: 'A runtime for distributed rendering',\n    webcodecs: 'Media conversion in the browser',\n    convert: 'Video conversion tool - convert.remotion.dev',\n    captions: 'Primitives for dealing with captions',\n    'openai-whisper': 'Work with the output of the OpenAI Whisper API',\n    'eslint-config-internal': \"ESLint condig for Remotion's internal packages\",\n    'example-videos': null,\n    'promo-pages': null,\n    'svg-3d-engine': '3D SVG extrusion effects',\n    'serverless-client': null,\n    video: 'Experimental tag for reliable and accurate video embedding',\n    'web-renderer': 'Render videos in the browser (not yet released)',\n};\nexports.installableMap = {\n    'svg-3d-engine': false,\n    'ai-improvements': false,\n    'animation-utils': true,\n    'animated-emoji': true,\n    'astro-example': false,\n    'babel-loader': false,\n    bugs: false,\n    bundler: false,\n    cli: false,\n    cloudrun: true,\n    'lambda-client': false,\n    'serverless-client': false,\n    'compositor-darwin-arm64': false,\n    'compositor-darwin-x64': false,\n    'compositor-linux-arm64-gnu': false,\n    'compositor-linux-arm64-musl': false,\n    'compositor-linux-x64-gnu': false,\n    'compositor-linux-x64-musl': false,\n    'compositor-win32-x64-msvc': false,\n    core: false,\n    'create-video': false,\n    'discord-poster': false,\n    'docusaurus-plugin': false,\n    docs: false,\n    'enable-scss': true,\n    'eslint-config': false,\n    'eslint-config-flat': false,\n    'eslint-config-internal': false,\n    'eslint-plugin': false,\n    'example-without-zod': false,\n    example: false,\n    fonts: true,\n    gif: true,\n    'google-fonts': true,\n    'install-whisper-cpp': true,\n    'whisper-web': true,\n    'it-tests': false,\n    'lambda-go-example': false,\n    'lambda-go': false,\n    'lambda-php': false,\n    'lambda-ruby': false,\n    'lambda-python': false,\n    lambda: true,\n    mcp: true,\n    'layout-utils': true,\n    licensing: true,\n    lottie: true,\n    'media-utils': true,\n    'motion-blur': true,\n    noise: true,\n    paths: true,\n    'player-example': false,\n    player: true,\n    preload: true,\n    renderer: true,\n    rive: true,\n    shapes: true,\n    skia: true,\n    'promo-pages': false,\n    streaming: false,\n    serverless: false,\n    'studio-server': false,\n    'studio-shared': false,\n    studio: true,\n    tailwind: true,\n    'tailwind-v4': true,\n    'test-utils': false,\n    three: true,\n    transitions: true,\n    'media-parser': true,\n    'zod-types': true,\n    webcodecs: true,\n    convert: false,\n    captions: true,\n    'openai-whisper': true,\n    compositor: false,\n    'example-videos': false,\n    video: false,\n    'web-renderer': false,\n};\nexports.apiDocs = {\n    player: 'https://www.remotion.dev/docs/player',\n    cloudrun: 'https://www.remotion.dev/docs/cloudrun',\n    renderer: 'https://www.remotion.dev/docs/renderer',\n    cli: 'https://www.remotion.dev/docs/cli',\n    core: 'https://www.remotion.dev/docs/remotion',\n    lambda: 'https://www.remotion.dev/docs/lambda',\n    bundler: 'https://www.remotion.dev/docs/bundler',\n    'lambda-client': null,\n    'serverless-client': null,\n    'studio-server': null,\n    'install-whisper-cpp': 'https://www.remotion.dev/docs/install-whisper-cpp',\n    'whisper-web': 'https://www.remotion.dev/docs/whisper-web',\n    'google-fonts': 'https://www.remotion.dev/docs/google-fonts',\n    'media-utils': 'https://www.remotion.dev/docs/media-utils',\n    lottie: 'https://www.remotion.dev/docs/lottie',\n    licensing: 'https://www.remotion.dev/docs/licensing',\n    'layout-utils': 'https://www.remotion.dev/docs/layout-utils',\n    noise: 'https://www.remotion.dev/docs/noise',\n    mcp: 'https://www.remotion.dev/docs/ai/mcp',\n    'motion-blur': 'https://www.remotion.dev/docs/motion-blur',\n    preload: 'https://www.remotion.dev/docs/preload',\n    shapes: 'https://www.remotion.dev/docs/shapes',\n    'zod-types': 'https://www.remotion.dev/docs/zod-types',\n    gif: 'https://www.remotion.dev/docs/gif',\n    'eslint-plugin': 'https://www.remotion.dev/docs/brownfield#install-the-eslint-plugin',\n    'eslint-config': 'https://www.remotion.dev/docs/brownfield#install-the-eslint-plugin',\n    'eslint-config-flat': 'https://www.remotion.dev/docs/brownfield#install-the-eslint-plugin',\n    'compositor-linux-x64-gnu': null,\n    'compositor-linux-x64-musl': null,\n    'compositor-darwin-x64': null,\n    'ai-improvements': null,\n    'discord-poster': null,\n    'docusaurus-plugin': null,\n    'animation-utils': 'https://www.remotion.dev/docs/animation-utils/',\n    'example-without-zod': null,\n    'lambda-go': null,\n    example: null,\n    'lambda-php': null,\n    bugs: null,\n    docs: null,\n    'it-tests': null,\n    'lambda-python': null,\n    'lambda-ruby': 'https://www.remotion.dev/docs/lambda/ruby',\n    'player-example': null,\n    'astro-example': null,\n    'lambda-go-example': null,\n    'test-utils': null,\n    'babel-loader': 'https://www.remotion.dev/docs/legacy-babel',\n    'compositor-darwin-arm64': null,\n    'compositor-linux-arm64-gnu': null,\n    'compositor-linux-arm64-musl': null,\n    'compositor-win32-x64-msvc': null,\n    'enable-scss': 'https://www.remotion.dev/docs/enable-scss/overview',\n    'create-video': 'https://remotion.dev/templates',\n    'studio-shared': null,\n    'media-parser': 'https://www.remotion.dev/docs/media-parser',\n    fonts: 'https://www.remotion.dev/docs/fonts-api',\n    paths: 'https://www.remotion.dev/paths',\n    rive: 'https://www.remotion.dev/docs/rive',\n    tailwind: 'https://www.remotion.dev/docs/tailwind/tailwind',\n    'tailwind-v4': 'https://www.remotion.dev/docs/tailwind/tailwind',\n    skia: 'https://www.remotion.dev/docs/skia',\n    three: 'https://www.remotion.dev/docs/three',\n    streaming: null,\n    serverless: null,\n    studio: 'https://www.remotion.dev/docs/studio/api',\n    transitions: 'https://www.remotion.dev/transitions',\n    'animated-emoji': 'https://www.remotion.dev/docs/animated-emoji',\n    webcodecs: 'https://remotion.dev/webcodecs',\n    convert: 'https://convert.remotion.dev',\n    captions: 'https://remotion.dev/docs/captions',\n    'openai-whisper': 'https://www.remotion.dev/docs/openai-whisper',\n    'eslint-config-internal': null,\n    compositor: null,\n    'example-videos': null,\n    'promo-pages': null,\n    'svg-3d-engine': null,\n    video: null,\n    // TODO: Add docs\n    'web-renderer': null,\n};\n\n\n/***/ }),\n\n/***/ 8188:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SOURCE_MAP_ENDPOINT = void 0;\nexports.SOURCE_MAP_ENDPOINT = '/source-map-helper.wasm';\n\n\n/***/ }),\n\n/***/ 6266:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringifyDefaultProps = void 0;\nconst no_react_1 = __webpack_require__(9382);\nfunction replacerWithPath(replacer) {\n    const m = new Map();\n    return function (field, value) {\n        const path = [m.get(this), field].flat(1);\n        if (value === Object(value)) {\n            m.set(value, path);\n        }\n        return replacer.call(this, field, value, path.filter((item) => typeof item !== 'undefined' && item !== ''));\n    };\n}\nconst doesMatchPath = (path1, enumPaths) => {\n    return enumPaths.some((p) => \n    // especially 0 for root!\n    path1.length === p.length &&\n        path1.every((item, index) => {\n            if (p[index] === '[]' && !Number.isNaN(Number(item))) {\n                return true;\n            }\n            if (p[index] === '{}' && typeof item === 'string') {\n                return true;\n            }\n            return item === p[index];\n        }));\n};\nconst stringifyDefaultProps = ({ props, enumPaths, }) => {\n    return JSON.stringify(props, replacerWithPath(function (key, value, path) {\n        /* Don't replace with arrow function! This function uses `this` */\n        const item = this[key];\n        if (typeof item === 'string' && doesMatchPath(path, enumPaths)) {\n            return `${item}__ADD_AS_CONST__`;\n        }\n        // For zMatrix()\n        if (doesMatchPath(path, enumPaths)) {\n            return `__REMOVEQUOTE__${JSON.stringify(item)}__ADD_AS_LITERAL_CONST__`;\n        }\n        if (typeof item === 'string' &&\n            item.startsWith(no_react_1.NoReactInternals.FILE_TOKEN)) {\n            return `__REMOVEQUOTE____WRAP_IN_STATIC_FILE_START__${decodeURIComponent(item.replace(no_react_1.NoReactInternals.FILE_TOKEN, ''))}__WRAP_IN_STATIC_FILE_END____REMOVEQUOTE__`;\n        }\n        if (typeof item === 'string' &&\n            item.startsWith(no_react_1.NoReactInternals.DATE_TOKEN)) {\n            return `__REMOVEQUOTE____WRAP_IN_DATE_START__${decodeURIComponent(item.replace(no_react_1.NoReactInternals.DATE_TOKEN, ''))}__WRAP_IN_DATE_END____REMOVEQUOTE__`;\n        }\n        return value;\n    }))\n        .replace(/\"__REMOVEQUOTE__/g, '')\n        .replace(/__REMOVEQUOTE__\"/g, '')\n        .replace(/__ADD_AS_CONST__\"/g, '\" as const')\n        .replace(/__ADD_AS_LITERAL_CONST__\"/g, ' as const')\n        .replace(/__WRAP_IN_STATIC_FILE_START__/g, 'staticFile(\"')\n        .replace(/__WRAP_IN_STATIC_FILE_END__/g, '\")')\n        .replace(/__WRAP_IN_DATE_START__/g, 'new Date(\"')\n        .replace(/__WRAP_IN_DATE_END__/g, '\")');\n};\nexports.stringifyDefaultProps = stringifyDefaultProps;\n\n\n/***/ }),\n\n/***/ 4974:\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  StudioInternals: () => (/* binding */ StudioInternals)\n});\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(6540);\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(961);\n// EXTERNAL MODULE: ./node_modules/remotion/dist/esm/index.mjs\nvar esm = __webpack_require__(3947);\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__(4848);\n// EXTERNAL MODULE: ./node_modules/remotion/dist/esm/no-react.mjs\nvar no_react = __webpack_require__(9382);\n;// ./node_modules/@remotion/player/dist/esm/index.mjs\n\"use client\";\n// src/icons.tsx\n\nvar ICON_SIZE = 25;\nvar fullscreenIconSize = 16;\nvar PlayIcon = () => {\n  return /* @__PURE__ */ (0,jsx_runtime.jsx)(\"svg\", {\n    width: ICON_SIZE,\n    height: ICON_SIZE,\n    viewBox: \"0 0 25 25\",\n    fill: \"none\",\n    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(\"path\", {\n      d: \"M8 6.375C7.40904 8.17576 7.06921 10.2486 7.01438 12.3871C6.95955 14.5255 7.19163 16.6547 7.6875 18.5625C9.95364 18.2995 12.116 17.6164 14.009 16.5655C15.902 15.5147 17.4755 14.124 18.6088 12.5C17.5158 10.8949 15.9949 9.51103 14.1585 8.45082C12.3222 7.3906 10.2174 6.68116 8 6.375Z\",\n      fill: \"white\",\n      stroke: \"white\",\n      strokeWidth: \"6.25\",\n      strokeLinejoin: \"round\"\n    })\n  });\n};\nvar PauseIcon = () => {\n  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"svg\", {\n    viewBox: \"0 0 100 100\",\n    width: ICON_SIZE,\n    height: ICON_SIZE,\n    children: [\n      /* @__PURE__ */ (0,jsx_runtime.jsx)(\"rect\", {\n        x: \"25\",\n        y: \"20\",\n        width: \"20\",\n        height: \"60\",\n        fill: \"#fff\",\n        ry: \"5\",\n        rx: \"5\"\n      }),\n      /* @__PURE__ */ (0,jsx_runtime.jsx)(\"rect\", {\n        x: \"55\",\n        y: \"20\",\n        width: \"20\",\n        height: \"60\",\n        fill: \"#fff\",\n        ry: \"5\",\n        rx: \"5\"\n      })\n    ]\n  });\n};\nvar FullscreenIcon = ({\n  isFullscreen\n}) => {\n  const strokeWidth = 6;\n  const viewSize = 32;\n  const out = isFullscreen ? 0 : strokeWidth / 2;\n  const middleInset = isFullscreen ? strokeWidth * 1.6 : strokeWidth / 2;\n  const inset = isFullscreen ? strokeWidth * 1.6 : strokeWidth * 2;\n  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"svg\", {\n    viewBox: `0 0 ${viewSize} ${viewSize}`,\n    height: fullscreenIconSize,\n    width: fullscreenIconSize,\n    children: [\n      /* @__PURE__ */ (0,jsx_runtime.jsx)(\"path\", {\n        d: `\n\t\t\t\tM ${out} ${inset}\n\t\t\t\tL ${middleInset} ${middleInset}\n\t\t\t\tL ${inset} ${out}\n\t\t\t\t`,\n        stroke: \"#fff\",\n        strokeWidth,\n        fill: \"none\"\n      }),\n      /* @__PURE__ */ (0,jsx_runtime.jsx)(\"path\", {\n        d: `\n\t\t\t\tM ${viewSize - out} ${inset}\n\t\t\t\tL ${viewSize - middleInset} ${middleInset}\n\t\t\t\tL ${viewSize - inset} ${out}\n\t\t\t\t`,\n        stroke: \"#fff\",\n        strokeWidth,\n        fill: \"none\"\n      }),\n      /* @__PURE__ */ (0,jsx_runtime.jsx)(\"path\", {\n        d: `\n\t\t\t\tM ${out} ${viewSize - inset}\n\t\t\t\tL ${middleInset} ${viewSize - middleInset}\n\t\t\t\tL ${inset} ${viewSize - out}\n\t\t\t\t`,\n        stroke: \"#fff\",\n        strokeWidth,\n        fill: \"none\"\n      }),\n      /* @__PURE__ */ (0,jsx_runtime.jsx)(\"path\", {\n        d: `\n\t\t\t\tM ${viewSize - out} ${viewSize - inset}\n\t\t\t\tL ${viewSize - middleInset} ${viewSize - middleInset}\n\t\t\t\tL ${viewSize - inset} ${viewSize - out}\n\t\t\t\t`,\n        stroke: \"#fff\",\n        strokeWidth,\n        fill: \"none\"\n      })\n    ]\n  });\n};\nvar VolumeOffIcon = () => {\n  return /* @__PURE__ */ (0,jsx_runtime.jsx)(\"svg\", {\n    width: ICON_SIZE,\n    height: ICON_SIZE,\n    viewBox: \"0 0 24 24\",\n    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(\"path\", {\n      d: \"M3.63 3.63a.996.996 0 000 1.41L7.29 8.7 7 9H4c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h3l3.29 3.29c.63.63 1.71.18 1.71-.71v-4.17l4.18 4.18c-.49.37-1.02.68-1.6.91-.36.15-.58.53-.58.92 0 .72.73 1.18 1.39.91.8-.33 1.55-.77 2.22-1.31l1.34 1.34a.996.996 0 101.41-1.41L5.05 3.63c-.39-.39-1.02-.39-1.42 0zM19 12c0 .82-.15 1.61-.41 2.34l1.53 1.53c.56-1.17.88-2.48.88-3.87 0-3.83-2.4-7.11-5.78-8.4-.59-.23-1.22.23-1.22.86v.19c0 .38.25.71.61.85C17.18 6.54 19 9.06 19 12zm-8.71-6.29l-.17.17L12 7.76V6.41c0-.89-1.08-1.33-1.71-.7zM16.5 12A4.5 4.5 0 0014 7.97v1.79l2.48 2.48c.01-.08.02-.16.02-.24z\",\n      fill: \"#fff\"\n    })\n  });\n};\nvar VolumeOnIcon = () => {\n  return /* @__PURE__ */ (0,jsx_runtime.jsx)(\"svg\", {\n    width: ICON_SIZE,\n    height: ICON_SIZE,\n    viewBox: \"0 0 24 24\",\n    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(\"path\", {\n      d: \"M3 10v4c0 .55.45 1 1 1h3l3.29 3.29c.63.63 1.71.18 1.71-.71V6.41c0-.89-1.08-1.34-1.71-.71L7 9H4c-.55 0-1 .45-1 1zm13.5 2A4.5 4.5 0 0014 7.97v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 4.45v.2c0 .38.25.71.6.85C17.18 6.53 19 9.06 19 12s-1.82 5.47-4.4 6.5c-.36.14-.6.47-.6.85v.2c0 .63.63 1.07 1.21.85C18.6 19.11 21 15.84 21 12s-2.4-7.11-5.79-8.4c-.58-.23-1.21.22-1.21.85z\",\n      fill: \"#fff\"\n    })\n  });\n};\n\n// src/BufferingIndicator.tsx\n\nvar className = \"__remotion_buffering_indicator\";\nvar remotionBufferingAnimation = \"__remotion_buffering_animation\";\nvar playerStyle = {\n  width: ICON_SIZE,\n  height: ICON_SIZE,\n  overflow: \"hidden\",\n  lineHeight: \"normal\",\n  fontSize: \"inherit\"\n};\nvar studioStyle = {\n  width: 14,\n  height: 14,\n  overflow: \"hidden\",\n  lineHeight: \"normal\",\n  fontSize: \"inherit\"\n};\nvar BufferingIndicator = ({ type }) => {\n  const style = type === \"player\" ? playerStyle : studioStyle;\n  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [\n      /* @__PURE__ */ (0,jsx_runtime.jsx)(\"style\", {\n        type: \"text/css\",\n        children: `\n\t\t\t\t@keyframes ${remotionBufferingAnimation} {\n          0% {\n            rotate: 0deg;\n          }\n          100% {\n            rotate: 360deg;\n          }\n        }\n        \n        .${className} {\n            animation: ${remotionBufferingAnimation} 1s linear infinite;\n        }        \n\t\t\t`\n      }),\n      /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n        style,\n        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(\"svg\", {\n          viewBox: type === \"player\" ? \"0 0 22 22\" : \"0 0 18 18\",\n          style,\n          className,\n          children: /* @__PURE__ */ (0,jsx_runtime.jsx)(\"path\", {\n            d: type === \"player\" ? \"M 11 4 A 7 7 0 0 1 15.1145 16.66312\" : \"M 9 2 A 7 7 0 0 1 13.1145 14.66312\",\n            stroke: \"white\",\n            strokeLinecap: \"round\",\n            fill: \"none\",\n            strokeWidth: 3\n          })\n        })\n      })\n    ]\n  });\n};\n\n// src/calculate-scale.ts\n\n\n// src/utils/calculate-player-size.ts\nvar calculatePlayerSize = ({\n  currentSize,\n  width,\n  height,\n  compositionWidth,\n  compositionHeight\n}) => {\n  if (width !== undefined && height === undefined) {\n    return {\n      aspectRatio: [compositionWidth, compositionHeight].join(\"/\")\n    };\n  }\n  if (height !== undefined && width === undefined) {\n    return {\n      aspectRatio: [compositionWidth, compositionHeight].join(\"/\")\n    };\n  }\n  if (!currentSize) {\n    return {\n      width: compositionWidth,\n      height: compositionHeight\n    };\n  }\n  return {\n    width: compositionWidth,\n    height: compositionHeight\n  };\n};\n\n// src/calculate-scale.ts\nvar calculateCanvasTransformation = ({\n  previewSize,\n  compositionWidth,\n  compositionHeight,\n  canvasSize\n}) => {\n  const scale = esm.Internals.calculateScale({\n    canvasSize,\n    compositionHeight,\n    compositionWidth,\n    previewSize\n  });\n  const correction = 0 - (1 - scale) / 2;\n  const xCorrection = correction * compositionWidth;\n  const yCorrection = correction * compositionHeight;\n  const width = compositionWidth * scale;\n  const height = compositionHeight * scale;\n  const centerX = canvasSize.width / 2 - width / 2;\n  const centerY = canvasSize.height / 2 - height / 2;\n  return {\n    centerX,\n    centerY,\n    xCorrection,\n    yCorrection,\n    scale\n  };\n};\nvar calculateOuterStyle = ({\n  config,\n  style,\n  canvasSize,\n  overflowVisible,\n  layout\n}) => {\n  if (!config) {\n    return {};\n  }\n  return {\n    position: \"relative\",\n    overflow: overflowVisible ? \"visible\" : \"hidden\",\n    ...calculatePlayerSize({\n      compositionHeight: config.height,\n      compositionWidth: config.width,\n      currentSize: canvasSize,\n      height: style?.height,\n      width: style?.width\n    }),\n    opacity: layout ? 1 : 0,\n    ...style\n  };\n};\nvar calculateContainerStyle = ({\n  config,\n  layout,\n  scale,\n  overflowVisible\n}) => {\n  if (!config) {\n    return {};\n  }\n  if (!layout) {\n    return {\n      position: \"absolute\",\n      width: config.width,\n      height: config.height,\n      display: \"flex\",\n      transform: `scale(${scale})`,\n      overflow: overflowVisible ? \"visible\" : \"hidden\"\n    };\n  }\n  return {\n    position: \"absolute\",\n    width: config.width,\n    height: config.height,\n    display: \"flex\",\n    transform: `scale(${scale})`,\n    marginLeft: layout.xCorrection,\n    marginTop: layout.yCorrection,\n    overflow: overflowVisible ? \"visible\" : \"hidden\"\n  };\n};\nvar calculateOuter = ({\n  layout,\n  scale,\n  config,\n  overflowVisible\n}) => {\n  if (!config) {\n    return {};\n  }\n  if (!layout) {\n    return {\n      width: config.width * scale,\n      height: config.height * scale,\n      display: \"flex\",\n      flexDirection: \"column\",\n      position: \"absolute\",\n      overflow: overflowVisible ? \"visible\" : \"hidden\"\n    };\n  }\n  const { centerX, centerY } = layout;\n  return {\n    width: config.width * scale,\n    height: config.height * scale,\n    display: \"flex\",\n    flexDirection: \"column\",\n    position: \"absolute\",\n    left: centerX,\n    top: centerY,\n    overflow: overflowVisible ? \"visible\" : \"hidden\"\n  };\n};\n\n// src/emitter-context.ts\n\nvar PlayerEventEmitterContext = react.createContext(undefined);\nvar ThumbnailEmitterContext = react.createContext(undefined);\n\n// src/EmitterProvider.tsx\n\n\n\n// src/event-emitter.ts\nclass PlayerEmitter {\n  listeners = {\n    ended: [],\n    error: [],\n    pause: [],\n    play: [],\n    ratechange: [],\n    scalechange: [],\n    seeked: [],\n    timeupdate: [],\n    frameupdate: [],\n    fullscreenchange: [],\n    volumechange: [],\n    mutechange: [],\n    waiting: [],\n    resume: []\n  };\n  addEventListener(name, callback) {\n    this.listeners[name].push(callback);\n  }\n  removeEventListener(name, callback) {\n    this.listeners[name] = this.listeners[name].filter((l) => l !== callback);\n  }\n  dispatchEvent(dispatchName, context) {\n    this.listeners[dispatchName].forEach((callback) => {\n      callback({ detail: context });\n    });\n  }\n  dispatchSeek = (frame) => {\n    this.dispatchEvent(\"seeked\", {\n      frame\n    });\n  };\n  dispatchVolumeChange = (volume) => {\n    this.dispatchEvent(\"volumechange\", {\n      volume\n    });\n  };\n  dispatchPause = () => {\n    this.dispatchEvent(\"pause\", undefined);\n  };\n  dispatchPlay = () => {\n    this.dispatchEvent(\"play\", undefined);\n  };\n  dispatchEnded = () => {\n    this.dispatchEvent(\"ended\", undefined);\n  };\n  dispatchRateChange = (playbackRate) => {\n    this.dispatchEvent(\"ratechange\", {\n      playbackRate\n    });\n  };\n  dispatchScaleChange = (scale) => {\n    this.dispatchEvent(\"scalechange\", {\n      scale\n    });\n  };\n  dispatchError = (error) => {\n    this.dispatchEvent(\"error\", {\n      error\n    });\n  };\n  dispatchTimeUpdate = (event) => {\n    this.dispatchEvent(\"timeupdate\", event);\n  };\n  dispatchFrameUpdate = (event) => {\n    this.dispatchEvent(\"frameupdate\", event);\n  };\n  dispatchFullscreenChange = (event) => {\n    this.dispatchEvent(\"fullscreenchange\", event);\n  };\n  dispatchMuteChange = (event) => {\n    this.dispatchEvent(\"mutechange\", event);\n  };\n  dispatchWaiting = (event) => {\n    this.dispatchEvent(\"waiting\", event);\n  };\n  dispatchResume = (event) => {\n    this.dispatchEvent(\"resume\", event);\n  };\n}\n\nclass ThumbnailEmitter {\n  listeners = {\n    error: [],\n    waiting: [],\n    resume: []\n  };\n  addEventListener(name, callback) {\n    this.listeners[name].push(callback);\n  }\n  removeEventListener(name, callback) {\n    this.listeners[name] = this.listeners[name].filter((l) => l !== callback);\n  }\n  dispatchEvent(dispatchName, context) {\n    this.listeners[dispatchName].forEach((callback) => {\n      callback({ detail: context });\n    });\n  }\n  dispatchError = (error) => {\n    this.dispatchEvent(\"error\", {\n      error\n    });\n  };\n  dispatchWaiting = (event) => {\n    this.dispatchEvent(\"waiting\", event);\n  };\n  dispatchResume = (event) => {\n    this.dispatchEvent(\"resume\", event);\n  };\n}\n\n// src/use-buffer-state-emitter.ts\n\n\nvar useBufferStateEmitter = (emitter) => {\n  const bufferManager = (0,react.useContext)(esm.Internals.BufferingContextReact);\n  if (!bufferManager) {\n    throw new Error(\"BufferingContextReact not found\");\n  }\n  (0,react.useEffect)(() => {\n    const clear1 = bufferManager.listenForBuffering(() => {\n      bufferManager.buffering.current = true;\n      emitter.dispatchWaiting({});\n    });\n    const clear2 = bufferManager.listenForResume(() => {\n      bufferManager.buffering.current = false;\n      emitter.dispatchResume({});\n    });\n    return () => {\n      clear1.remove();\n      clear2.remove();\n    };\n  }, [bufferManager, emitter]);\n};\n\n// src/EmitterProvider.tsx\n\nvar PlayerEmitterProvider = ({ children, currentPlaybackRate }) => {\n  const [emitter] = (0,react.useState)(() => new PlayerEmitter);\n  const bufferManager = (0,react.useContext)(esm.Internals.BufferingContextReact);\n  if (!bufferManager) {\n    throw new Error(\"BufferingContextReact not found\");\n  }\n  (0,react.useEffect)(() => {\n    if (currentPlaybackRate) {\n      emitter.dispatchRateChange(currentPlaybackRate);\n    }\n  }, [emitter, currentPlaybackRate]);\n  useBufferStateEmitter(emitter);\n  return /* @__PURE__ */ (0,jsx_runtime.jsx)(PlayerEventEmitterContext.Provider, {\n    value: emitter,\n    children\n  });\n};\n\n// src/use-frame-imperative.ts\n\n\nvar useFrameImperative = () => {\n  const frame = esm.Internals.Timeline.useTimelinePosition();\n  const frameRef = (0,react.useRef)(frame);\n  frameRef.current = frame;\n  const getCurrentFrame = (0,react.useCallback)(() => {\n    return frameRef.current;\n  }, []);\n  return getCurrentFrame;\n};\n\n// src/use-hover-state.ts\n\nvar useHoverState = (ref, hideControlsWhenPointerDoesntMove) => {\n  const [hovered, setHovered] = (0,react.useState)(false);\n  (0,react.useEffect)(() => {\n    const { current } = ref;\n    if (!current) {\n      return;\n    }\n    let hoverTimeout;\n    const addHoverTimeout = () => {\n      if (hideControlsWhenPointerDoesntMove) {\n        clearTimeout(hoverTimeout);\n        hoverTimeout = setTimeout(() => {\n          setHovered(false);\n        }, hideControlsWhenPointerDoesntMove === true ? 3000 : hideControlsWhenPointerDoesntMove);\n      }\n    };\n    const onHover = () => {\n      setHovered(true);\n      addHoverTimeout();\n    };\n    const onLeave = () => {\n      setHovered(false);\n      clearTimeout(hoverTimeout);\n    };\n    const onMove = () => {\n      setHovered(true);\n      addHoverTimeout();\n    };\n    current.addEventListener(\"mouseenter\", onHover);\n    current.addEventListener(\"mouseleave\", onLeave);\n    current.addEventListener(\"mousemove\", onMove);\n    return () => {\n      current.removeEventListener(\"mouseenter\", onHover);\n      current.removeEventListener(\"mouseleave\", onLeave);\n      current.removeEventListener(\"mousemove\", onMove);\n      clearTimeout(hoverTimeout);\n    };\n  }, [hideControlsWhenPointerDoesntMove, ref]);\n  return hovered;\n};\n\n// src/use-playback.ts\n\n\n\n// src/browser-mediasession.ts\n\n\n// src/use-player.ts\n\n\nvar usePlayer = () => {\n  const [playing, setPlaying, imperativePlaying] = esm.Internals.Timeline.usePlayingState();\n  const [hasPlayed, setHasPlayed] = (0,react.useState)(false);\n  const frame = esm.Internals.Timeline.useTimelinePosition();\n  const playStart = (0,react.useRef)(frame);\n  const setFrame = esm.Internals.Timeline.useTimelineSetFrame();\n  const setTimelinePosition = esm.Internals.Timeline.useTimelineSetFrame();\n  const audioContext = (0,react.useContext)(esm.Internals.SharedAudioContext);\n  const { audioAndVideoTags } = (0,react.useContext)(esm.Internals.Timeline.TimelineContext);\n  const frameRef = (0,react.useRef)(frame);\n  frameRef.current = frame;\n  const video = esm.Internals.useVideo();\n  const config = esm.Internals.useUnsafeVideoConfig();\n  const emitter = (0,react.useContext)(PlayerEventEmitterContext);\n  const lastFrame = (config?.durationInFrames ?? 1) - 1;\n  const isLastFrame = frame === lastFrame;\n  const isFirstFrame = frame === 0;\n  if (!emitter) {\n    throw new TypeError(\"Expected Player event emitter context\");\n  }\n  const bufferingContext = (0,react.useContext)(esm.Internals.BufferingContextReact);\n  if (!bufferingContext) {\n    throw new Error(\"Missing the buffering context. Most likely you have a Remotion version mismatch.\");\n  }\n  const { buffering } = bufferingContext;\n  const seek = (0,react.useCallback)((newFrame) => {\n    if (video?.id) {\n      setTimelinePosition((c) => ({ ...c, [video.id]: newFrame }));\n    }\n    frameRef.current = newFrame;\n    emitter.dispatchSeek(newFrame);\n  }, [emitter, setTimelinePosition, video?.id]);\n  const play = (0,react.useCallback)((e) => {\n    if (imperativePlaying.current) {\n      return;\n    }\n    setHasPlayed(true);\n    if (isLastFrame) {\n      seek(0);\n    }\n    audioContext?.audioContext?.resume();\n    if (audioContext && audioContext.numberOfAudioTags > 0 && e) {\n      audioContext.playAllAudios();\n    }\n    audioAndVideoTags.current.forEach((a) => a.play(\"player play() was called and playing audio from a click\"));\n    imperativePlaying.current = true;\n    setPlaying(true);\n    playStart.current = frameRef.current;\n    emitter.dispatchPlay();\n  }, [\n    imperativePlaying,\n    isLastFrame,\n    audioContext,\n    setPlaying,\n    emitter,\n    seek,\n    audioAndVideoTags\n  ]);\n  const pause = (0,react.useCallback)(() => {\n    if (imperativePlaying.current) {\n      imperativePlaying.current = false;\n      setPlaying(false);\n      emitter.dispatchPause();\n      audioContext?.audioContext?.suspend();\n    }\n  }, [emitter, imperativePlaying, setPlaying, audioContext]);\n  const pauseAndReturnToPlayStart = (0,react.useCallback)(() => {\n    if (imperativePlaying.current) {\n      imperativePlaying.current = false;\n      frameRef.current = playStart.current;\n      if (config) {\n        setTimelinePosition((c) => ({\n          ...c,\n          [config.id]: playStart.current\n        }));\n        setPlaying(false);\n        emitter.dispatchPause();\n      }\n    }\n  }, [config, emitter, imperativePlaying, setPlaying, setTimelinePosition]);\n  const videoId = video?.id;\n  const frameBack = (0,react.useCallback)((frames) => {\n    if (!videoId) {\n      return null;\n    }\n    if (imperativePlaying.current) {\n      return;\n    }\n    setFrame((c) => {\n      const prevFrame = c[videoId] ?? window.remotion_initialFrame ?? 0;\n      const newFrame = Math.max(0, prevFrame - frames);\n      if (prevFrame === newFrame) {\n        return c;\n      }\n      return {\n        ...c,\n        [videoId]: newFrame\n      };\n    });\n  }, [imperativePlaying, setFrame, videoId]);\n  const frameForward = (0,react.useCallback)((frames) => {\n    if (!videoId) {\n      return null;\n    }\n    if (imperativePlaying.current) {\n      return;\n    }\n    setFrame((c) => {\n      const prevFrame = c[videoId] ?? window.remotion_initialFrame ?? 0;\n      const newFrame = Math.min(lastFrame, prevFrame + frames);\n      if (prevFrame === newFrame) {\n        return c;\n      }\n      return {\n        ...c,\n        [videoId]: newFrame\n      };\n    });\n  }, [videoId, imperativePlaying, lastFrame, setFrame]);\n  const toggle = (0,react.useCallback)((e) => {\n    if (imperativePlaying.current) {\n      pause();\n    } else {\n      play(e);\n    }\n  }, [imperativePlaying, pause, play]);\n  const returnValue = (0,react.useMemo)(() => {\n    return {\n      frameBack,\n      frameForward,\n      isLastFrame,\n      emitter,\n      playing,\n      play,\n      pause,\n      seek,\n      isFirstFrame,\n      getCurrentFrame: () => frameRef.current,\n      isPlaying: () => imperativePlaying.current,\n      isBuffering: () => buffering.current,\n      pauseAndReturnToPlayStart,\n      hasPlayed,\n      toggle\n    };\n  }, [\n    buffering,\n    emitter,\n    frameBack,\n    frameForward,\n    hasPlayed,\n    imperativePlaying,\n    isFirstFrame,\n    isLastFrame,\n    pause,\n    pauseAndReturnToPlayStart,\n    play,\n    playing,\n    seek,\n    toggle\n  ]);\n  return returnValue;\n};\n\n// src/browser-mediasession.ts\nvar useBrowserMediaSession = ({\n  browserMediaControlsBehavior,\n  videoConfig,\n  playbackRate\n}) => {\n  const { playing, pause, play, emitter, getCurrentFrame, seek } = usePlayer();\n  (0,react.useEffect)(() => {\n    if (!navigator.mediaSession) {\n      return;\n    }\n    if (browserMediaControlsBehavior.mode === \"do-nothing\") {\n      return;\n    }\n    if (playing) {\n      navigator.mediaSession.playbackState = \"playing\";\n    } else {\n      navigator.mediaSession.playbackState = \"paused\";\n    }\n  }, [browserMediaControlsBehavior.mode, playing]);\n  (0,react.useEffect)(() => {\n    if (!navigator.mediaSession) {\n      return;\n    }\n    if (browserMediaControlsBehavior.mode === \"do-nothing\") {\n      return;\n    }\n    const onTimeUpdate = () => {\n      if (!videoConfig) {\n        return;\n      }\n      if (navigator.mediaSession) {\n        navigator.mediaSession.setPositionState({\n          duration: videoConfig.durationInFrames / videoConfig.fps,\n          playbackRate,\n          position: getCurrentFrame() / videoConfig.fps\n        });\n      }\n    };\n    emitter.addEventListener(\"timeupdate\", onTimeUpdate);\n    return () => {\n      emitter.removeEventListener(\"timeupdate\", onTimeUpdate);\n    };\n  }, [\n    browserMediaControlsBehavior.mode,\n    emitter,\n    getCurrentFrame,\n    playbackRate,\n    videoConfig\n  ]);\n  (0,react.useEffect)(() => {\n    if (!navigator.mediaSession) {\n      return;\n    }\n    if (browserMediaControlsBehavior.mode === \"do-nothing\") {\n      return;\n    }\n    navigator.mediaSession.setActionHandler(\"play\", () => {\n      if (browserMediaControlsBehavior.mode === \"register-media-session\") {\n        play();\n      }\n    });\n    navigator.mediaSession.setActionHandler(\"pause\", () => {\n      if (browserMediaControlsBehavior.mode === \"register-media-session\") {\n        pause();\n      }\n    });\n    navigator.mediaSession.setActionHandler(\"seekto\", (event) => {\n      if (browserMediaControlsBehavior.mode === \"register-media-session\" && event.seekTime !== undefined && videoConfig) {\n        seek(Math.round(event.seekTime * videoConfig.fps));\n      }\n    });\n    navigator.mediaSession.setActionHandler(\"seekbackward\", () => {\n      if (browserMediaControlsBehavior.mode === \"register-media-session\" && videoConfig) {\n        seek(Math.max(0, Math.round((getCurrentFrame() - 10) * videoConfig.fps)));\n      }\n    });\n    navigator.mediaSession.setActionHandler(\"seekforward\", () => {\n      if (browserMediaControlsBehavior.mode === \"register-media-session\" && videoConfig) {\n        seek(Math.max(videoConfig.durationInFrames - 1, Math.round((getCurrentFrame() + 10) * videoConfig.fps)));\n      }\n    });\n    navigator.mediaSession.setActionHandler(\"previoustrack\", () => {\n      if (browserMediaControlsBehavior.mode === \"register-media-session\") {\n        seek(0);\n      }\n    });\n    return () => {\n      navigator.mediaSession.metadata = null;\n      navigator.mediaSession.setActionHandler(\"play\", null);\n      navigator.mediaSession.setActionHandler(\"pause\", null);\n      navigator.mediaSession.setActionHandler(\"seekto\", null);\n      navigator.mediaSession.setActionHandler(\"seekbackward\", null);\n      navigator.mediaSession.setActionHandler(\"seekforward\", null);\n      navigator.mediaSession.setActionHandler(\"previoustrack\", null);\n    };\n  }, [\n    browserMediaControlsBehavior.mode,\n    getCurrentFrame,\n    pause,\n    play,\n    seek,\n    videoConfig\n  ]);\n};\n\n// src/calculate-next-frame.ts\nvar calculateNextFrame = ({\n  time,\n  currentFrame: startFrame,\n  playbackSpeed,\n  fps,\n  actualLastFrame,\n  actualFirstFrame,\n  framesAdvanced,\n  shouldLoop\n}) => {\n  const op = playbackSpeed < 0 ? Math.ceil : Math.floor;\n  const framesToAdvance = op(time * playbackSpeed / (1000 / fps)) - framesAdvanced;\n  const nextFrame = framesToAdvance + startFrame;\n  const isCurrentFrameOutside = startFrame > actualLastFrame || startFrame < actualFirstFrame;\n  const isNextFrameOutside = nextFrame > actualLastFrame || nextFrame < actualFirstFrame;\n  const hasEnded = !shouldLoop && isNextFrameOutside && !isCurrentFrameOutside;\n  if (playbackSpeed > 0) {\n    if (isNextFrameOutside) {\n      return {\n        nextFrame: actualFirstFrame,\n        framesToAdvance,\n        hasEnded\n      };\n    }\n    return { nextFrame, framesToAdvance, hasEnded };\n  }\n  if (isNextFrameOutside) {\n    return { nextFrame: actualLastFrame, framesToAdvance, hasEnded };\n  }\n  return { nextFrame, framesToAdvance, hasEnded };\n};\n\n// src/is-backgrounded.ts\n\nvar getIsBackgrounded = () => {\n  if (typeof document === \"undefined\") {\n    return false;\n  }\n  return document.visibilityState === \"hidden\";\n};\nvar useIsBackgrounded = () => {\n  const isBackgrounded = (0,react.useRef)(getIsBackgrounded());\n  (0,react.useEffect)(() => {\n    const onVisibilityChange = () => {\n      isBackgrounded.current = getIsBackgrounded();\n    };\n    document.addEventListener(\"visibilitychange\", onVisibilityChange);\n    return () => {\n      document.removeEventListener(\"visibilitychange\", onVisibilityChange);\n    };\n  }, []);\n  return isBackgrounded;\n};\n\n// src/use-playback.ts\nvar usePlayback = ({\n  loop,\n  playbackRate,\n  moveToBeginningWhenEnded,\n  inFrame,\n  outFrame,\n  browserMediaControlsBehavior,\n  getCurrentFrame\n}) => {\n  const config = esm.Internals.useUnsafeVideoConfig();\n  const frame = esm.Internals.Timeline.useTimelinePosition();\n  const { playing, pause, emitter } = usePlayer();\n  const setFrame = esm.Internals.Timeline.useTimelineSetFrame();\n  const isBackgroundedRef = useIsBackgrounded();\n  const lastTimeUpdateEvent = (0,react.useRef)(null);\n  const context = (0,react.useContext)(esm.Internals.BufferingContextReact);\n  if (!context) {\n    throw new Error(\"Missing the buffering context. Most likely you have a Remotion version mismatch.\");\n  }\n  useBrowserMediaSession({\n    browserMediaControlsBehavior,\n    playbackRate,\n    videoConfig: config\n  });\n  (0,react.useEffect)(() => {\n    if (!config) {\n      return;\n    }\n    if (!playing) {\n      return;\n    }\n    let hasBeenStopped = false;\n    let reqAnimFrameCall = null;\n    let startedTime = performance.now();\n    let framesAdvanced = 0;\n    const cancelQueuedFrame = () => {\n      if (reqAnimFrameCall !== null) {\n        if (reqAnimFrameCall.type === \"raf\") {\n          cancelAnimationFrame(reqAnimFrameCall.id);\n        } else {\n          clearTimeout(reqAnimFrameCall.id);\n        }\n      }\n    };\n    const stop = () => {\n      hasBeenStopped = true;\n      cancelQueuedFrame();\n    };\n    const callback = () => {\n      if (hasBeenStopped) {\n        return;\n      }\n      const time = performance.now() - startedTime;\n      const actualLastFrame = outFrame ?? config.durationInFrames - 1;\n      const actualFirstFrame = inFrame ?? 0;\n      const currentFrame = getCurrentFrame();\n      const { nextFrame, framesToAdvance, hasEnded } = calculateNextFrame({\n        time,\n        currentFrame,\n        playbackSpeed: playbackRate,\n        fps: config.fps,\n        actualFirstFrame,\n        actualLastFrame,\n        framesAdvanced,\n        shouldLoop: loop\n      });\n      framesAdvanced += framesToAdvance;\n      if (nextFrame !== getCurrentFrame() && (!hasEnded || moveToBeginningWhenEnded)) {\n        setFrame((c) => ({ ...c, [config.id]: nextFrame }));\n      }\n      if (hasEnded) {\n        stop();\n        pause();\n        emitter.dispatchEnded();\n        return;\n      }\n      queueNextFrame();\n    };\n    const queueNextFrame = () => {\n      if (context.buffering.current) {\n        const stopListening = context.listenForResume(() => {\n          stopListening.remove();\n          startedTime = performance.now();\n          framesAdvanced = 0;\n          queueNextFrame();\n        });\n        return;\n      }\n      if (isBackgroundedRef.current) {\n        reqAnimFrameCall = {\n          type: \"timeout\",\n          id: setTimeout(callback, 1000 / config.fps)\n        };\n        return;\n      }\n      reqAnimFrameCall = { type: \"raf\", id: requestAnimationFrame(callback) };\n    };\n    queueNextFrame();\n    const onVisibilityChange = () => {\n      if (document.visibilityState === \"visible\") {\n        return;\n      }\n      cancelQueuedFrame();\n      callback();\n    };\n    window.addEventListener(\"visibilitychange\", onVisibilityChange);\n    return () => {\n      window.removeEventListener(\"visibilitychange\", onVisibilityChange);\n      stop();\n    };\n  }, [\n    config,\n    loop,\n    pause,\n    playing,\n    setFrame,\n    emitter,\n    playbackRate,\n    inFrame,\n    outFrame,\n    moveToBeginningWhenEnded,\n    isBackgroundedRef,\n    getCurrentFrame,\n    context\n  ]);\n  (0,react.useEffect)(() => {\n    const interval = setInterval(() => {\n      if (lastTimeUpdateEvent.current === getCurrentFrame()) {\n        return;\n      }\n      emitter.dispatchTimeUpdate({ frame: getCurrentFrame() });\n      lastTimeUpdateEvent.current = getCurrentFrame();\n    }, 250);\n    return () => clearInterval(interval);\n  }, [emitter, getCurrentFrame]);\n  (0,react.useEffect)(() => {\n    emitter.dispatchFrameUpdate({ frame });\n  }, [emitter, frame]);\n};\n\n// src/utils/use-element-size.ts\n\nvar elementSizeHooks = [];\nvar updateAllElementsSizes = () => {\n  for (const listener of elementSizeHooks) {\n    listener();\n  }\n};\nvar useElementSize = (ref, options) => {\n  const [size, setSize] = (0,react.useState)(() => {\n    if (!ref.current) {\n      return null;\n    }\n    const rect = ref.current.getClientRects();\n    if (!rect[0]) {\n      return null;\n    }\n    return {\n      width: rect[0].width,\n      height: rect[0].height,\n      left: rect[0].x,\n      top: rect[0].y,\n      windowSize: {\n        height: window.innerHeight,\n        width: window.innerWidth\n      }\n    };\n  });\n  const observer = (0,react.useMemo)(() => {\n    if (typeof ResizeObserver === \"undefined\") {\n      return null;\n    }\n    return new ResizeObserver((entries) => {\n      const { contentRect, target } = entries[0];\n      const newSize = target.getClientRects();\n      if (!newSize?.[0]) {\n        setSize(null);\n        return;\n      }\n      const probableCssParentScale = contentRect.width === 0 ? 1 : newSize[0].width / contentRect.width;\n      const width = options.shouldApplyCssTransforms || probableCssParentScale === 0 ? newSize[0].width : newSize[0].width * (1 / probableCssParentScale);\n      const height = options.shouldApplyCssTransforms || probableCssParentScale === 0 ? newSize[0].height : newSize[0].height * (1 / probableCssParentScale);\n      setSize((prevState) => {\n        const isSame = prevState && prevState.width === width && prevState.height === height && prevState.left === newSize[0].x && prevState.top === newSize[0].y && prevState.windowSize.height === window.innerHeight && prevState.windowSize.width === window.innerWidth;\n        if (isSame) {\n          return prevState;\n        }\n        return {\n          width,\n          height,\n          left: newSize[0].x,\n          top: newSize[0].y,\n          windowSize: {\n            height: window.innerHeight,\n            width: window.innerWidth\n          }\n        };\n      });\n    });\n  }, [options.shouldApplyCssTransforms]);\n  const updateSize = (0,react.useCallback)(() => {\n    if (!ref.current) {\n      return;\n    }\n    const rect = ref.current.getClientRects();\n    if (!rect[0]) {\n      setSize(null);\n      return;\n    }\n    setSize((prevState) => {\n      const isSame = prevState && prevState.width === rect[0].width && prevState.height === rect[0].height && prevState.left === rect[0].x && prevState.top === rect[0].y && prevState.windowSize.height === window.innerHeight && prevState.windowSize.width === window.innerWidth;\n      if (isSame) {\n        return prevState;\n      }\n      return {\n        width: rect[0].width,\n        height: rect[0].height,\n        left: rect[0].x,\n        top: rect[0].y,\n        windowSize: {\n          height: window.innerHeight,\n          width: window.innerWidth\n        }\n      };\n    });\n  }, [ref]);\n  (0,react.useEffect)(() => {\n    if (!observer) {\n      return;\n    }\n    const { current } = ref;\n    if (current) {\n      observer.observe(current);\n    }\n    return () => {\n      if (current) {\n        observer.unobserve(current);\n      }\n    };\n  }, [observer, ref, updateSize]);\n  (0,react.useEffect)(() => {\n    if (!options.triggerOnWindowResize) {\n      return;\n    }\n    window.addEventListener(\"resize\", updateSize);\n    return () => {\n      window.removeEventListener(\"resize\", updateSize);\n    };\n  }, [options.triggerOnWindowResize, updateSize]);\n  (0,react.useEffect)(() => {\n    elementSizeHooks.push(updateSize);\n    return () => {\n      elementSizeHooks = elementSizeHooks.filter((e) => e !== updateSize);\n    };\n  }, [updateSize]);\n  return (0,react.useMemo)(() => {\n    if (!size) {\n      return null;\n    }\n    return { ...size, refresh: updateSize };\n  }, [size, updateSize]);\n};\n\n// src/Player.tsx\n\n\n\n// src/PlayerUI.tsx\n\n\n\n// src/PlayerControls.tsx\n\n\n// src/DefaultPlayPauseButton.tsx\n\nvar DefaultPlayPauseButton = ({ playing, buffering }) => {\n  if (playing && buffering) {\n    return /* @__PURE__ */ (0,jsx_runtime.jsx)(BufferingIndicator, {\n      type: \"player\"\n    });\n  }\n  if (playing) {\n    return /* @__PURE__ */ (0,jsx_runtime.jsx)(PauseIcon, {});\n  }\n  return /* @__PURE__ */ (0,jsx_runtime.jsx)(PlayIcon, {});\n};\n\n// src/MediaVolumeSlider.tsx\n\n\n\n// src/render-volume-slider.tsx\n\n\n\nvar KNOB_SIZE = 12;\nvar BAR_HEIGHT = 5;\nvar DefaultVolumeSlider = ({\n  volume,\n  isVertical,\n  onBlur,\n  inputRef,\n  setVolume\n}) => {\n  const sliderContainer = (0,react.useMemo)(() => {\n    const paddingLeft = 5;\n    const common = {\n      paddingLeft,\n      height: ICON_SIZE,\n      width: VOLUME_SLIDER_WIDTH,\n      display: \"inline-flex\",\n      alignItems: \"center\"\n    };\n    if (isVertical) {\n      return {\n        ...common,\n        position: \"absolute\",\n        transform: `rotate(-90deg) translateX(${VOLUME_SLIDER_WIDTH / 2 + ICON_SIZE / 2}px)`\n      };\n    }\n    return {\n      ...common\n    };\n  }, [isVertical]);\n  const randomId = typeof react.useId === \"undefined\" ? \"volume-slider\" : react.useId();\n  const [randomClass] = (0,react.useState)(() => `__remotion-volume-slider-${(0,esm.random)(randomId)}`.replace(\".\", \"\"));\n  const onVolumeChange = (0,react.useCallback)((e) => {\n    setVolume(parseFloat(e.target.value));\n  }, [setVolume]);\n  const inputStyle = (0,react.useMemo)(() => {\n    const commonStyle = {\n      WebkitAppearance: \"none\",\n      backgroundColor: \"rgba(255, 255, 255, 0.5)\",\n      borderRadius: BAR_HEIGHT / 2,\n      cursor: \"pointer\",\n      height: BAR_HEIGHT,\n      width: VOLUME_SLIDER_WIDTH,\n      backgroundImage: `linear-gradient(\n\t\t\t\tto right,\n\t\t\t\twhite ${volume * 100}%, rgba(255, 255, 255, 0) ${volume * 100}%\n\t\t\t)`\n    };\n    if (isVertical) {\n      return {\n        ...commonStyle,\n        bottom: ICON_SIZE + VOLUME_SLIDER_WIDTH / 2\n      };\n    }\n    return commonStyle;\n  }, [isVertical, volume]);\n  const sliderStyle = `\n\t.${randomClass}::-webkit-slider-thumb {\n\t\t-webkit-appearance: none;\n\t\tbackground-color: white;\n\t\tborder-radius: ${KNOB_SIZE / 2}px;\n\t\tbox-shadow: 0 0 2px black;\n\t\theight: ${KNOB_SIZE}px;\n\t\twidth: ${KNOB_SIZE}px;\n\t}\n\n\t.${randomClass}::-moz-range-thumb {\n\t\t-webkit-appearance: none;\n\t\tbackground-color: white;\n\t\tborder-radius: ${KNOB_SIZE / 2}px;\n\t\tbox-shadow: 0 0 2px black;\n\t\theight: ${KNOB_SIZE}px;\n\t\twidth: ${KNOB_SIZE}px;\n\t}\n`;\n  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"div\", {\n    style: sliderContainer,\n    children: [\n      /* @__PURE__ */ (0,jsx_runtime.jsx)(\"style\", {\n        dangerouslySetInnerHTML: {\n          __html: sliderStyle\n        }\n      }),\n      /* @__PURE__ */ (0,jsx_runtime.jsx)(\"input\", {\n        ref: inputRef,\n        \"aria-label\": \"Change volume\",\n        className: randomClass,\n        max: 1,\n        min: 0,\n        onBlur,\n        onChange: onVolumeChange,\n        step: 0.01,\n        type: \"range\",\n        value: volume,\n        style: inputStyle\n      })\n    ]\n  });\n};\nvar renderDefaultVolumeSlider = (props) => {\n  return /* @__PURE__ */ (0,jsx_runtime.jsx)(DefaultVolumeSlider, {\n    ...props\n  });\n};\n\n// src/MediaVolumeSlider.tsx\n\nvar VOLUME_SLIDER_WIDTH = 100;\nvar MediaVolumeSlider = ({ displayVerticalVolumeSlider, renderMuteButton, renderVolumeSlider }) => {\n  const [mediaMuted, setMediaMuted] = esm.Internals.useMediaMutedState();\n  const [mediaVolume, setMediaVolume] = esm.Internals.useMediaVolumeState();\n  const [focused, setFocused] = (0,react.useState)(false);\n  const parentDivRef = (0,react.useRef)(null);\n  const inputRef = (0,react.useRef)(null);\n  const hover = useHoverState(parentDivRef, false);\n  const onBlur = (0,react.useCallback)(() => {\n    setTimeout(() => {\n      if (inputRef.current && document.activeElement !== inputRef.current) {\n        setFocused(false);\n      }\n    }, 10);\n  }, []);\n  const isVolume0 = mediaVolume === 0;\n  const onClick = (0,react.useCallback)(() => {\n    if (isVolume0) {\n      setMediaVolume(1);\n      setMediaMuted(false);\n      return;\n    }\n    setMediaMuted((mute) => !mute);\n  }, [isVolume0, setMediaMuted, setMediaVolume]);\n  const parentDivStyle = (0,react.useMemo)(() => {\n    return {\n      display: \"inline-flex\",\n      background: \"none\",\n      border: \"none\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      touchAction: \"none\",\n      ...displayVerticalVolumeSlider && { position: \"relative\" }\n    };\n  }, [displayVerticalVolumeSlider]);\n  const volumeContainer = (0,react.useMemo)(() => {\n    return {\n      display: \"inline\",\n      width: ICON_SIZE,\n      height: ICON_SIZE,\n      cursor: \"pointer\",\n      appearance: \"none\",\n      background: \"none\",\n      border: \"none\",\n      padding: 0\n    };\n  }, []);\n  const renderDefaultMuteButton = (0,react.useCallback)(({ muted, volume }) => {\n    const isMutedOrZero = muted || volume === 0;\n    return /* @__PURE__ */ (0,jsx_runtime.jsx)(\"button\", {\n      \"aria-label\": isMutedOrZero ? \"Unmute sound\" : \"Mute sound\",\n      title: isMutedOrZero ? \"Unmute sound\" : \"Mute sound\",\n      onClick,\n      onBlur,\n      onFocus: () => setFocused(true),\n      style: volumeContainer,\n      type: \"button\",\n      children: isMutedOrZero ? /* @__PURE__ */ (0,jsx_runtime.jsx)(VolumeOffIcon, {}) : /* @__PURE__ */ (0,jsx_runtime.jsx)(VolumeOnIcon, {})\n    });\n  }, [onBlur, onClick, volumeContainer]);\n  const muteButton = (0,react.useMemo)(() => {\n    return renderMuteButton ? renderMuteButton({ muted: mediaMuted, volume: mediaVolume }) : renderDefaultMuteButton({ muted: mediaMuted, volume: mediaVolume });\n  }, [mediaMuted, mediaVolume, renderDefaultMuteButton, renderMuteButton]);\n  const volumeSlider = (0,react.useMemo)(() => {\n    return (focused || hover) && !mediaMuted && !esm.Internals.isIosSafari() ? (renderVolumeSlider ?? renderDefaultVolumeSlider)({\n      isVertical: displayVerticalVolumeSlider,\n      volume: mediaVolume,\n      onBlur: () => setFocused(false),\n      inputRef,\n      setVolume: setMediaVolume\n    }) : null;\n  }, [\n    displayVerticalVolumeSlider,\n    focused,\n    hover,\n    mediaMuted,\n    mediaVolume,\n    renderVolumeSlider,\n    setMediaVolume\n  ]);\n  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"div\", {\n    ref: parentDivRef,\n    style: parentDivStyle,\n    children: [\n      muteButton,\n      volumeSlider\n    ]\n  });\n};\n\n// src/PlaybackrateControl.tsx\n\n\n\n// src/utils/use-component-visible.ts\n\nfunction useComponentVisible(initialIsVisible) {\n  const [isComponentVisible, setIsComponentVisible] = (0,react.useState)(initialIsVisible);\n  const ref = (0,react.useRef)(null);\n  (0,react.useEffect)(() => {\n    const handleClickOutside = (event) => {\n      if (ref.current && !ref.current.contains(event.target)) {\n        setIsComponentVisible(false);\n      }\n    };\n    document.addEventListener(\"pointerup\", handleClickOutside, true);\n    return () => {\n      document.removeEventListener(\"pointerup\", handleClickOutside, true);\n    };\n  }, []);\n  return { ref, isComponentVisible, setIsComponentVisible };\n}\n\n// src/PlaybackrateControl.tsx\n\nvar BOTTOM = 35;\nvar THRESHOLD = 70;\nvar rateDiv = {\n  height: 30,\n  paddingRight: 15,\n  paddingLeft: 12,\n  display: \"flex\",\n  flexDirection: \"row\",\n  alignItems: \"center\"\n};\nvar checkmarkContainer = {\n  width: 22,\n  display: \"flex\",\n  alignItems: \"center\"\n};\nvar checkmarkStyle = {\n  width: 14,\n  height: 14,\n  color: \"black\"\n};\nvar Checkmark = () => /* @__PURE__ */ (0,jsx_runtime.jsx)(\"svg\", {\n  viewBox: \"0 0 512 512\",\n  style: checkmarkStyle,\n  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(\"path\", {\n    fill: \"currentColor\",\n    d: \"M435.848 83.466L172.804 346.51l-96.652-96.652c-4.686-4.686-12.284-4.686-16.971 0l-28.284 28.284c-4.686 4.686-4.686 12.284 0 16.971l133.421 133.421c4.686 4.686 12.284 4.686 16.971 0l299.813-299.813c4.686-4.686 4.686-12.284 0-16.971l-28.284-28.284c-4.686-4.686-12.284-4.686-16.97 0z\"\n  })\n});\nvar formatPlaybackRate = (rate) => {\n  const str = rate.toString();\n  return str.includes(\".\") ? str : str + \".0\";\n};\nvar PlaybackrateOption = ({ rate, onSelect, selectedRate, keyboardSelectedRate }) => {\n  const onClick = (0,react.useCallback)((e) => {\n    e.stopPropagation();\n    e.preventDefault();\n    onSelect(rate);\n  }, [onSelect, rate]);\n  const [hovered, setHovered] = (0,react.useState)(false);\n  const onMouseEnter = (0,react.useCallback)(() => {\n    setHovered(true);\n  }, []);\n  const onMouseLeave = (0,react.useCallback)(() => {\n    setHovered(false);\n  }, []);\n  const isFocused = keyboardSelectedRate === rate;\n  const actualStyle = (0,react.useMemo)(() => {\n    return {\n      ...rateDiv,\n      backgroundColor: hovered || isFocused ? \"#eee\" : \"transparent\"\n    };\n  }, [hovered, isFocused]);\n  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"div\", {\n    onMouseEnter,\n    onMouseLeave,\n    tabIndex: 0,\n    style: actualStyle,\n    onClick,\n    children: [\n      /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n        style: checkmarkContainer,\n        children: rate === selectedRate ? /* @__PURE__ */ (0,jsx_runtime.jsx)(Checkmark, {}) : null\n      }),\n      formatPlaybackRate(rate),\n      \"x\"\n    ]\n  }, rate);\n};\nvar PlaybackPopup = ({ setIsComponentVisible, playbackRates, canvasSize }) => {\n  const { setPlaybackRate, playbackRate } = (0,react.useContext)(esm.Internals.Timeline.TimelineContext);\n  const [keyboardSelectedRate, setKeyboardSelectedRate] = (0,react.useState)(playbackRate);\n  (0,react.useEffect)(() => {\n    const listener = (e) => {\n      e.preventDefault();\n      if (e.key === \"ArrowUp\") {\n        const currentIndex = playbackRates.findIndex((rate) => rate === keyboardSelectedRate);\n        if (currentIndex === 0) {\n          return;\n        }\n        if (currentIndex === -1) {\n          setKeyboardSelectedRate(playbackRates[0]);\n        } else {\n          setKeyboardSelectedRate(playbackRates[currentIndex - 1]);\n        }\n      } else if (e.key === \"ArrowDown\") {\n        const currentIndex = playbackRates.findIndex((rate) => rate === keyboardSelectedRate);\n        if (currentIndex === playbackRates.length - 1) {\n          return;\n        }\n        if (currentIndex === -1) {\n          setKeyboardSelectedRate(playbackRates[playbackRates.length - 1]);\n        } else {\n          setKeyboardSelectedRate(playbackRates[currentIndex + 1]);\n        }\n      } else if (e.key === \"Enter\") {\n        setPlaybackRate(keyboardSelectedRate);\n        setIsComponentVisible(false);\n      }\n    };\n    window.addEventListener(\"keydown\", listener);\n    return () => {\n      window.removeEventListener(\"keydown\", listener);\n    };\n  }, [\n    playbackRates,\n    keyboardSelectedRate,\n    setPlaybackRate,\n    setIsComponentVisible\n  ]);\n  const onSelect = (0,react.useCallback)((rate) => {\n    setPlaybackRate(rate);\n    setIsComponentVisible(false);\n  }, [setIsComponentVisible, setPlaybackRate]);\n  const playbackPopup = (0,react.useMemo)(() => {\n    return {\n      position: \"absolute\",\n      right: 0,\n      width: 125,\n      maxHeight: canvasSize.height - THRESHOLD - BOTTOM,\n      bottom: 35,\n      background: \"#fff\",\n      borderRadius: 4,\n      overflow: \"auto\",\n      color: \"black\",\n      textAlign: \"left\"\n    };\n  }, [canvasSize.height]);\n  return /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n    style: playbackPopup,\n    children: playbackRates.map((rate) => {\n      return /* @__PURE__ */ (0,jsx_runtime.jsx)(PlaybackrateOption, {\n        selectedRate: playbackRate,\n        onSelect,\n        rate,\n        keyboardSelectedRate\n      }, rate);\n    })\n  });\n};\nvar label = {\n  fontSize: 13,\n  fontWeight: \"bold\",\n  color: \"white\",\n  border: \"2px solid white\",\n  borderRadius: 20,\n  paddingLeft: 8,\n  paddingRight: 8,\n  paddingTop: 2,\n  paddingBottom: 2\n};\nvar playerButtonStyle = {\n  appearance: \"none\",\n  backgroundColor: \"transparent\",\n  border: \"none\",\n  cursor: \"pointer\",\n  paddingLeft: 0,\n  paddingRight: 0,\n  paddingTop: 6,\n  paddingBottom: 6,\n  height: 37,\n  display: \"inline-flex\",\n  marginBottom: 0,\n  marginTop: 0,\n  alignItems: \"center\"\n};\nvar esm_button = {\n  ...playerButtonStyle,\n  position: \"relative\"\n};\nvar PlaybackrateControl = ({ playbackRates, canvasSize }) => {\n  const { ref, isComponentVisible, setIsComponentVisible } = useComponentVisible(false);\n  const { playbackRate } = (0,react.useContext)(esm.Internals.Timeline.TimelineContext);\n  const onClick = (0,react.useCallback)((e) => {\n    e.stopPropagation();\n    e.preventDefault();\n    setIsComponentVisible((prevIsComponentVisible) => !prevIsComponentVisible);\n  }, [setIsComponentVisible]);\n  return /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n    ref,\n    children: /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"button\", {\n      type: \"button\",\n      \"aria-label\": \"Change playback rate\",\n      style: esm_button,\n      onClick,\n      children: [\n        /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"div\", {\n          style: label,\n          children: [\n            playbackRate,\n            \"x\"\n          ]\n        }),\n        isComponentVisible && /* @__PURE__ */ (0,jsx_runtime.jsx)(PlaybackPopup, {\n          canvasSize,\n          playbackRates,\n          setIsComponentVisible\n        })\n      ]\n    })\n  });\n};\n\n// src/PlayerSeekBar.tsx\n\n\n\nvar getFrameFromX = (clientX, durationInFrames, width) => {\n  const pos = clientX;\n  const frame = Math.round((0,esm.interpolate)(pos, [0, width], [0, durationInFrames - 1], {\n    extrapolateLeft: \"clamp\",\n    extrapolateRight: \"clamp\"\n  }));\n  return frame;\n};\nvar BAR_HEIGHT2 = 5;\nvar KNOB_SIZE2 = 12;\nvar VERTICAL_PADDING = 4;\nvar containerStyle = {\n  userSelect: \"none\",\n  WebkitUserSelect: \"none\",\n  paddingTop: VERTICAL_PADDING,\n  paddingBottom: VERTICAL_PADDING,\n  boxSizing: \"border-box\",\n  cursor: \"pointer\",\n  position: \"relative\",\n  touchAction: \"none\"\n};\nvar barBackground = {\n  height: BAR_HEIGHT2,\n  backgroundColor: \"rgba(255, 255, 255, 0.25)\",\n  width: \"100%\",\n  borderRadius: BAR_HEIGHT2 / 2\n};\nvar findBodyInWhichDivIsLocated = (div) => {\n  let current = div;\n  while (current.parentElement) {\n    current = current.parentElement;\n  }\n  return current;\n};\nvar PlayerSeekBar = ({ durationInFrames, onSeekEnd, onSeekStart, inFrame, outFrame }) => {\n  const containerRef = (0,react.useRef)(null);\n  const barHovered = useHoverState(containerRef, false);\n  const size = useElementSize(containerRef, {\n    triggerOnWindowResize: true,\n    shouldApplyCssTransforms: true\n  });\n  const { seek, play, pause, playing } = usePlayer();\n  const frame = esm.Internals.Timeline.useTimelinePosition();\n  const [dragging, setDragging] = (0,react.useState)({\n    dragging: false\n  });\n  const width = size?.width ?? 0;\n  const onPointerDown = (0,react.useCallback)((e) => {\n    if (e.button !== 0) {\n      return;\n    }\n    const posLeft = containerRef.current?.getBoundingClientRect().left;\n    const _frame = getFrameFromX(e.clientX - posLeft, durationInFrames, width);\n    pause();\n    seek(_frame);\n    setDragging({\n      dragging: true,\n      wasPlaying: playing\n    });\n    onSeekStart();\n  }, [durationInFrames, width, pause, seek, playing, onSeekStart]);\n  const onPointerMove = (0,react.useCallback)((e) => {\n    if (!size) {\n      throw new Error(\"Player has no size\");\n    }\n    if (!dragging.dragging) {\n      return;\n    }\n    const posLeft = containerRef.current?.getBoundingClientRect().left;\n    const _frame = getFrameFromX(e.clientX - posLeft, durationInFrames, size.width);\n    seek(_frame);\n  }, [dragging.dragging, durationInFrames, seek, size]);\n  const onPointerUp = (0,react.useCallback)(() => {\n    setDragging({\n      dragging: false\n    });\n    if (!dragging.dragging) {\n      return;\n    }\n    if (dragging.wasPlaying) {\n      play();\n    } else {\n      pause();\n    }\n    onSeekEnd();\n  }, [dragging, onSeekEnd, pause, play]);\n  (0,react.useEffect)(() => {\n    if (!dragging.dragging) {\n      return;\n    }\n    const body = findBodyInWhichDivIsLocated(containerRef.current);\n    body.addEventListener(\"pointermove\", onPointerMove);\n    body.addEventListener(\"pointerup\", onPointerUp);\n    return () => {\n      body.removeEventListener(\"pointermove\", onPointerMove);\n      body.removeEventListener(\"pointerup\", onPointerUp);\n    };\n  }, [dragging.dragging, onPointerMove, onPointerUp]);\n  const knobStyle = (0,react.useMemo)(() => {\n    return {\n      height: KNOB_SIZE2,\n      width: KNOB_SIZE2,\n      borderRadius: KNOB_SIZE2 / 2,\n      position: \"absolute\",\n      top: VERTICAL_PADDING - KNOB_SIZE2 / 2 + 5 / 2,\n      backgroundColor: \"white\",\n      left: Math.max(0, frame / Math.max(1, durationInFrames - 1) * width - KNOB_SIZE2 / 2),\n      boxShadow: \"0 0 2px black\",\n      opacity: Number(barHovered || dragging.dragging)\n    };\n  }, [barHovered, dragging.dragging, durationInFrames, frame, width]);\n  const fillStyle = (0,react.useMemo)(() => {\n    return {\n      height: BAR_HEIGHT2,\n      backgroundColor: \"rgba(255, 255, 255, 1)\",\n      width: (frame - (inFrame ?? 0)) / (durationInFrames - 1) * width,\n      marginLeft: (inFrame ?? 0) / (durationInFrames - 1) * width,\n      borderRadius: BAR_HEIGHT2 / 2\n    };\n  }, [durationInFrames, frame, inFrame, width]);\n  const active = (0,react.useMemo)(() => {\n    return {\n      height: BAR_HEIGHT2,\n      backgroundColor: \"rgba(255, 255, 255, 0.25)\",\n      width: ((outFrame ?? durationInFrames - 1) - (inFrame ?? 0)) / (durationInFrames - 1) * 100 + \"%\",\n      marginLeft: (inFrame ?? 0) / (durationInFrames - 1) * 100 + \"%\",\n      borderRadius: BAR_HEIGHT2 / 2,\n      position: \"absolute\"\n    };\n  }, [durationInFrames, inFrame, outFrame]);\n  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"div\", {\n    ref: containerRef,\n    onPointerDown,\n    style: containerStyle,\n    children: [\n      /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"div\", {\n        style: barBackground,\n        children: [\n          /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n            style: active\n          }),\n          /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n            style: fillStyle\n          })\n        ]\n      }),\n      /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n        style: knobStyle\n      })\n    ]\n  });\n};\n\n// src/PlayerTimeLabel.tsx\n\n\n\n// src/format-time.ts\nvar formatTime = (timeInSeconds) => {\n  const minutes = Math.floor(timeInSeconds / 60);\n  const seconds = Math.floor(timeInSeconds - minutes * 60);\n  return `${String(minutes)}:${String(seconds).padStart(2, \"0\")}`;\n};\n\n// src/PlayerTimeLabel.tsx\n\nvar PlayerTimeLabel = ({ durationInFrames, maxTimeLabelWidth, fps }) => {\n  const frame = esm.Internals.Timeline.useTimelinePosition();\n  const timeLabel = (0,react.useMemo)(() => {\n    return {\n      color: \"white\",\n      fontFamily: \"sans-serif\",\n      fontSize: 14,\n      maxWidth: maxTimeLabelWidth === null ? undefined : maxTimeLabelWidth,\n      overflow: \"hidden\",\n      textOverflow: \"ellipsis\"\n    };\n  }, [maxTimeLabelWidth]);\n  const isLastFrame = frame === durationInFrames - 1;\n  const frameToDisplay = isLastFrame ? frame + 1 : frame;\n  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"div\", {\n    style: timeLabel,\n    children: [\n      formatTime(frameToDisplay / fps),\n      \" / \",\n      formatTime(durationInFrames / fps)\n    ]\n  });\n};\n\n// src/use-video-controls-resize.ts\n\nvar X_SPACER = 10;\nvar X_PADDING = 12;\nvar useVideoControlsResize = ({\n  allowFullscreen: allowFullScreen,\n  playerWidth\n}) => {\n  const resizeInfo = (0,react.useMemo)(() => {\n    const playPauseIconSize = ICON_SIZE;\n    const volumeIconSize = ICON_SIZE;\n    const _fullscreenIconSize = allowFullScreen ? fullscreenIconSize : 0;\n    const elementsSize = volumeIconSize + playPauseIconSize + _fullscreenIconSize + X_PADDING * 2 + X_SPACER * 2;\n    const maxTimeLabelWidth = playerWidth - elementsSize;\n    const maxTimeLabelWidthWithoutNegativeValue = Math.max(maxTimeLabelWidth, 0);\n    const availableTimeLabelWidthIfVolumeOpen = maxTimeLabelWidthWithoutNegativeValue - VOLUME_SLIDER_WIDTH;\n    const computedLabelWidth = availableTimeLabelWidthIfVolumeOpen < VOLUME_SLIDER_WIDTH ? maxTimeLabelWidthWithoutNegativeValue : availableTimeLabelWidthIfVolumeOpen;\n    const minWidthForHorizontalDisplay = computedLabelWidth + elementsSize + VOLUME_SLIDER_WIDTH;\n    const displayVerticalVolumeSlider = playerWidth < minWidthForHorizontalDisplay;\n    return {\n      maxTimeLabelWidth: maxTimeLabelWidthWithoutNegativeValue === 0 ? null : maxTimeLabelWidthWithoutNegativeValue,\n      displayVerticalVolumeSlider\n    };\n  }, [allowFullScreen, playerWidth]);\n  return resizeInfo;\n};\n\n// src/PlayerControls.tsx\n\nvar gradientSteps = [\n  0,\n  0.013,\n  0.049,\n  0.104,\n  0.175,\n  0.259,\n  0.352,\n  0.45,\n  0.55,\n  0.648,\n  0.741,\n  0.825,\n  0.896,\n  0.951,\n  0.987\n];\nvar gradientOpacities = [\n  0,\n  8.1,\n  15.5,\n  22.5,\n  29,\n  35.3,\n  41.2,\n  47.1,\n  52.9,\n  58.8,\n  64.7,\n  71,\n  77.5,\n  84.5,\n  91.9\n];\nvar globalGradientOpacity = 1 / 0.7;\nvar containerStyle2 = {\n  boxSizing: \"border-box\",\n  position: \"absolute\",\n  bottom: 0,\n  width: \"100%\",\n  paddingTop: 40,\n  paddingBottom: 10,\n  backgroundImage: `linear-gradient(to bottom,${gradientSteps.map((g, i) => {\n    return `hsla(0, 0%, 0%, ${g}) ${gradientOpacities[i] * globalGradientOpacity}%`;\n  }).join(\", \")}, hsl(0, 0%, 0%) 100%)`,\n  backgroundSize: \"auto 145px\",\n  display: \"flex\",\n  paddingRight: X_PADDING,\n  paddingLeft: X_PADDING,\n  flexDirection: \"column\",\n  transition: \"opacity 0.3s\"\n};\nvar controlsRow = {\n  display: \"flex\",\n  flexDirection: \"row\",\n  width: \"100%\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  userSelect: \"none\",\n  WebkitUserSelect: \"none\"\n};\nvar leftPartStyle = {\n  display: \"flex\",\n  flexDirection: \"row\",\n  userSelect: \"none\",\n  WebkitUserSelect: \"none\",\n  alignItems: \"center\"\n};\nvar xSpacer = {\n  width: 12\n};\nvar ySpacer = {\n  height: 8\n};\nvar flex1 = {\n  flex: 1\n};\nvar fullscreen = {};\nvar Controls = ({\n  durationInFrames,\n  isFullscreen,\n  fps,\n  showVolumeControls,\n  onFullscreenButtonClick,\n  allowFullscreen,\n  onExitFullscreenButtonClick,\n  spaceKeyToPlayOrPause,\n  onSeekEnd,\n  onSeekStart,\n  inFrame,\n  outFrame,\n  initiallyShowControls,\n  canvasSize,\n  renderPlayPauseButton,\n  renderFullscreenButton,\n  alwaysShowControls,\n  showPlaybackRateControl,\n  containerRef,\n  buffering,\n  hideControlsWhenPointerDoesntMove,\n  onPointerDown,\n  onDoubleClick,\n  renderMuteButton,\n  renderVolumeSlider,\n  playing,\n  toggle\n}) => {\n  const playButtonRef = (0,react.useRef)(null);\n  const [supportsFullscreen, setSupportsFullscreen] = (0,react.useState)(false);\n  const hovered = useHoverState(containerRef, hideControlsWhenPointerDoesntMove);\n  const { maxTimeLabelWidth, displayVerticalVolumeSlider } = useVideoControlsResize({\n    allowFullscreen,\n    playerWidth: canvasSize?.width ?? 0\n  });\n  const [shouldShowInitially, setInitiallyShowControls] = (0,react.useState)(() => {\n    if (typeof initiallyShowControls === \"boolean\") {\n      return initiallyShowControls;\n    }\n    if (typeof initiallyShowControls === \"number\") {\n      if (initiallyShowControls % 1 !== 0) {\n        throw new Error(\"initiallyShowControls must be an integer or a boolean\");\n      }\n      if (Number.isNaN(initiallyShowControls)) {\n        throw new Error(\"initiallyShowControls must not be NaN\");\n      }\n      if (!Number.isFinite(initiallyShowControls)) {\n        throw new Error(\"initiallyShowControls must be finite\");\n      }\n      if (initiallyShowControls <= 0) {\n        throw new Error(\"initiallyShowControls must be a positive integer\");\n      }\n      return initiallyShowControls;\n    }\n    throw new TypeError(\"initiallyShowControls must be a number or a boolean\");\n  });\n  const containerCss = (0,react.useMemo)(() => {\n    const shouldShow = hovered || !playing || shouldShowInitially || alwaysShowControls;\n    return {\n      ...containerStyle2,\n      opacity: Number(shouldShow)\n    };\n  }, [hovered, shouldShowInitially, playing, alwaysShowControls]);\n  (0,react.useEffect)(() => {\n    if (playButtonRef.current && spaceKeyToPlayOrPause) {\n      playButtonRef.current.focus({\n        preventScroll: true\n      });\n    }\n  }, [playing, spaceKeyToPlayOrPause]);\n  (0,react.useEffect)(() => {\n    setSupportsFullscreen((typeof document !== \"undefined\" && (document.fullscreenEnabled || document.webkitFullscreenEnabled)) ?? false);\n  }, []);\n  (0,react.useEffect)(() => {\n    if (shouldShowInitially === false) {\n      return;\n    }\n    const time = shouldShowInitially === true ? 2000 : shouldShowInitially;\n    const timeout = setTimeout(() => {\n      setInitiallyShowControls(false);\n    }, time);\n    return () => {\n      clearInterval(timeout);\n    };\n  }, [shouldShowInitially]);\n  const playbackRates = (0,react.useMemo)(() => {\n    if (showPlaybackRateControl === true) {\n      return [0.5, 0.8, 1, 1.2, 1.5, 1.8, 2, 2.5, 3];\n    }\n    if (Array.isArray(showPlaybackRateControl)) {\n      for (const rate of showPlaybackRateControl) {\n        if (typeof rate !== \"number\") {\n          throw new Error(\"Every item in showPlaybackRateControl must be a number\");\n        }\n        if (rate <= 0) {\n          throw new Error(\"Every item in showPlaybackRateControl must be positive\");\n        }\n      }\n      return showPlaybackRateControl;\n    }\n    return null;\n  }, [showPlaybackRateControl]);\n  const ref = (0,react.useRef)(null);\n  const flexRef = (0,react.useRef)(null);\n  const onPointerDownIfContainer = (0,react.useCallback)((e) => {\n    if (e.target === ref.current || e.target === flexRef.current) {\n      onPointerDown?.(e);\n    }\n  }, [onPointerDown]);\n  const onDoubleClickIfContainer = (0,react.useCallback)((e) => {\n    if (e.target === ref.current || e.target === flexRef.current) {\n      onDoubleClick?.(e);\n    }\n  }, [onDoubleClick]);\n  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"div\", {\n    ref,\n    style: containerCss,\n    onPointerDown: onPointerDownIfContainer,\n    onDoubleClick: onDoubleClickIfContainer,\n    children: [\n      /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"div\", {\n        ref: flexRef,\n        style: controlsRow,\n        children: [\n          /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"div\", {\n            style: leftPartStyle,\n            children: [\n              /* @__PURE__ */ (0,jsx_runtime.jsx)(\"button\", {\n                ref: playButtonRef,\n                type: \"button\",\n                style: playerButtonStyle,\n                onClick: toggle,\n                \"aria-label\": playing ? \"Pause video\" : \"Play video\",\n                title: playing ? \"Pause video\" : \"Play video\",\n                children: renderPlayPauseButton === null ? /* @__PURE__ */ (0,jsx_runtime.jsx)(DefaultPlayPauseButton, {\n                  buffering,\n                  playing\n                }) : renderPlayPauseButton({\n                  playing,\n                  isBuffering: buffering\n                }) ?? /* @__PURE__ */ (0,jsx_runtime.jsx)(DefaultPlayPauseButton, {\n                  buffering,\n                  playing\n                })\n              }),\n              showVolumeControls ? /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n                children: [\n                  /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n                    style: xSpacer\n                  }),\n                  /* @__PURE__ */ (0,jsx_runtime.jsx)(MediaVolumeSlider, {\n                    renderMuteButton,\n                    renderVolumeSlider,\n                    displayVerticalVolumeSlider\n                  })\n                ]\n              }) : null,\n              /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n                style: xSpacer\n              }),\n              /* @__PURE__ */ (0,jsx_runtime.jsx)(PlayerTimeLabel, {\n                durationInFrames,\n                fps,\n                maxTimeLabelWidth\n              }),\n              /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n                style: xSpacer\n              })\n            ]\n          }),\n          /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n            style: flex1\n          }),\n          playbackRates && canvasSize && /* @__PURE__ */ (0,jsx_runtime.jsx)(PlaybackrateControl, {\n            canvasSize,\n            playbackRates\n          }),\n          playbackRates && supportsFullscreen && allowFullscreen ? /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n            style: xSpacer\n          }) : null,\n          /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n            style: fullscreen,\n            children: supportsFullscreen && allowFullscreen ? /* @__PURE__ */ (0,jsx_runtime.jsx)(\"button\", {\n              type: \"button\",\n              \"aria-label\": isFullscreen ? \"Exit fullscreen\" : \"Enter Fullscreen\",\n              title: isFullscreen ? \"Exit fullscreen\" : \"Enter Fullscreen\",\n              style: playerButtonStyle,\n              onClick: isFullscreen ? onExitFullscreenButtonClick : onFullscreenButtonClick,\n              children: renderFullscreenButton === null ? /* @__PURE__ */ (0,jsx_runtime.jsx)(FullscreenIcon, {\n                isFullscreen\n              }) : renderFullscreenButton({ isFullscreen })\n            }) : null\n          })\n        ]\n      }),\n      /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n        style: ySpacer\n      }),\n      /* @__PURE__ */ (0,jsx_runtime.jsx)(PlayerSeekBar, {\n        onSeekEnd,\n        onSeekStart,\n        durationInFrames,\n        inFrame,\n        outFrame\n      })\n    ]\n  });\n};\n\n// src/error-boundary.tsx\n\n\nvar errorStyle = {\n  display: \"flex\",\n  justifyContent: \"center\",\n  alignItems: \"center\",\n  flex: 1,\n  height: \"100%\",\n  width: \"100%\"\n};\n\nclass ErrorBoundary extends react.Component {\n  state = { hasError: null };\n  static getDerivedStateFromError(error) {\n    return { hasError: error };\n  }\n  componentDidCatch(error) {\n    this.props.onError(error);\n  }\n  render() {\n    if (this.state.hasError) {\n      return /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n        style: errorStyle,\n        children: this.props.errorFallback({\n          error: this.state.hasError\n        })\n      });\n    }\n    return this.props.children;\n  }\n}\n\n// src/license-blacklist.tsx\n\n\nvar getHashOfDomain = async () => {\n  if (typeof window === \"undefined\") {\n    return null;\n  }\n  if (typeof window.crypto === \"undefined\") {\n    return null;\n  }\n  if (typeof window.crypto.subtle === \"undefined\") {\n    return null;\n  }\n  try {\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode(window.location.hostname));\n    return Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  } catch {\n    return null;\n  }\n};\nvar style = {\n  backgroundColor: \"red\",\n  position: \"absolute\",\n  padding: 12,\n  fontFamily: \"Arial\"\n};\nvar DOMAIN_BLACKLIST = [\n  \"28d262b44cc61fa750f1686b16ad0604dabfe193fbc263eec05c89b7ad4c2cd6\",\n  \"4db1b0a94be33165dfefcb3ba03d04c7a2666dd27c496d3dc9fa41858e94925e\",\n  \"fbc48530bbf245da790f63675e84e06bab38c3b114fab07eb350025119922bdc\",\n  \"7baf10a8932757b1b3a22b3fce10a048747ac2f8eaf638603487e3705b07eb83\",\n  \"8a6c21a598d8c667272b5207c051b85997bf5b45d5fb712378be3f27cd72c6a6\",\n  \"a2f7aaac9c50a9255e7fc376110c4e0bfe153722dc66ed3c5d3bf2a135f65518\"\n];\nvar ran = false;\nvar RenderWarningIfBlacklist = () => {\n  const [unlicensed, setUnlicensed] = react.useState(false);\n  (0,react.useEffect)(() => {\n    if (ran) {\n      return;\n    }\n    ran = true;\n    getHashOfDomain().then((hash) => {\n      if (hash && DOMAIN_BLACKLIST.includes(hash)) {\n        setUnlicensed(true);\n      }\n    }).catch(() => {});\n  }, []);\n  (0,react.useEffect)(() => {\n    if (!unlicensed) {\n      return;\n    }\n    const ensureBanner = () => {\n      const banner = document.querySelector(\".warning-banner\");\n      if (!banner) {\n        const div = document.createElement(\"div\");\n        div.className = \"warning-banner\";\n        Object.assign(div.style, style, {\n          zIndex: \"9999\",\n          cssText: `${style.cssText} !important;`\n        });\n        div.innerHTML = `\n\t        <a href=\"https://github.com/remotion-dev/remotion/pull/4589\" style=\"color: white;\">\n\t          Remotion Unlicensed â€“ Contact hi@remotion.dev\n\t        </a>\n\t      `;\n        document.body.appendChild(div);\n      }\n    };\n    const observer = new MutationObserver(() => ensureBanner());\n    observer.observe(document.body, { childList: true, subtree: true });\n    return () => {\n      observer.disconnect();\n    };\n  }, [unlicensed]);\n  if (!unlicensed) {\n    return null;\n  }\n  return /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n    style,\n    className: \"warning-banner\",\n    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(\"a\", {\n      style: { color: \"white\" },\n      href: \"https://github.com/remotion-dev/remotion/pull/4589\",\n      children: \"Remotion Unlicensed â€“ Contact hi@remotion.dev\"\n    })\n  });\n};\n\n// src/player-css-classname.ts\nvar playerCssClassname = (override) => {\n  return override ?? \"__remotion-player\";\n};\n\n// src/utils/is-node.ts\nvar IS_NODE = typeof document === \"undefined\";\n\n// src/utils/use-click-prevention-on-double-click.ts\n\n\n// src/utils/cancellable-promise.ts\nvar cancellablePromise = (promise) => {\n  let isCanceled = false;\n  const wrappedPromise = new Promise((resolve, reject) => {\n    promise.then((value) => {\n      if (isCanceled) {\n        reject({ isCanceled, value });\n        return;\n      }\n      resolve(value);\n    }).catch((error) => {\n      reject({ isCanceled, error });\n    });\n  });\n  return {\n    promise: wrappedPromise,\n    cancel: () => {\n      isCanceled = true;\n    }\n  };\n};\n\n// src/utils/delay.ts\nvar delay = (n) => new Promise((resolve) => setTimeout(resolve, n));\n\n// src/utils/use-cancellable-promises.ts\n\nvar useCancellablePromises = () => {\n  const pendingPromises = (0,react.useRef)([]);\n  const appendPendingPromise = (0,react.useCallback)((promise) => {\n    pendingPromises.current = [...pendingPromises.current, promise];\n  }, []);\n  const removePendingPromise = (0,react.useCallback)((promise) => {\n    pendingPromises.current = pendingPromises.current.filter((p) => p !== promise);\n  }, []);\n  const clearPendingPromises = (0,react.useCallback)(() => pendingPromises.current.map((p) => p.cancel()), []);\n  const api = (0,react.useMemo)(() => ({\n    appendPendingPromise,\n    removePendingPromise,\n    clearPendingPromises\n  }), [appendPendingPromise, clearPendingPromises, removePendingPromise]);\n  return api;\n};\n\n// src/utils/use-click-prevention-on-double-click.ts\nvar useClickPreventionOnDoubleClick = (onClick, onDoubleClick, doubleClickToFullscreen) => {\n  const api = useCancellablePromises();\n  const handleClick = (0,react.useCallback)(async (e) => {\n    if (e instanceof PointerEvent ? e.pointerType === \"touch\" : e.nativeEvent.pointerType === \"touch\") {\n      onClick(e);\n      return;\n    }\n    api.clearPendingPromises();\n    const waitForClick = cancellablePromise(delay(200));\n    api.appendPendingPromise(waitForClick);\n    try {\n      await waitForClick.promise;\n      api.removePendingPromise(waitForClick);\n      onClick(e);\n    } catch (errorInfo) {\n      const info = errorInfo;\n      api.removePendingPromise(waitForClick);\n      if (!info.isCanceled) {\n        throw info.error;\n      }\n    }\n  }, [api, onClick]);\n  const handlePointerDown = (0,react.useCallback)(() => {\n    document.addEventListener(\"pointerup\", (newEvt) => {\n      handleClick(newEvt);\n    }, {\n      once: true\n    });\n  }, [handleClick]);\n  const handleDoubleClick = (0,react.useCallback)(() => {\n    api.clearPendingPromises();\n    onDoubleClick();\n  }, [api, onDoubleClick]);\n  const returnValue = (0,react.useMemo)(() => {\n    if (!doubleClickToFullscreen) {\n      return { handlePointerDown: onClick, handleDoubleClick: () => {\n        return;\n      } };\n    }\n    return { handlePointerDown, handleDoubleClick };\n  }, [doubleClickToFullscreen, handleDoubleClick, handlePointerDown, onClick]);\n  return returnValue;\n};\n\n// src/PlayerUI.tsx\n\nvar reactVersion = react.version.split(\".\")[0];\nif (reactVersion === \"0\") {\n  throw new Error(`Version ${reactVersion} of \"react\" is not supported by Remotion`);\n}\nvar doesReactVersionSupportSuspense = parseInt(reactVersion, 10) >= 18;\nvar PlayerUI = ({\n  controls,\n  style: style2,\n  loop,\n  autoPlay,\n  allowFullscreen,\n  inputProps,\n  clickToPlay,\n  showVolumeControls,\n  doubleClickToFullscreen,\n  spaceKeyToPlayOrPause,\n  errorFallback,\n  playbackRate,\n  renderLoading,\n  renderPoster,\n  className: className2,\n  moveToBeginningWhenEnded,\n  showPosterWhenUnplayed,\n  showPosterWhenEnded,\n  showPosterWhenPaused,\n  showPosterWhenBuffering,\n  showPosterWhenBufferingAndPaused,\n  inFrame,\n  outFrame,\n  initiallyShowControls,\n  renderFullscreen: renderFullscreenButton,\n  renderPlayPauseButton,\n  renderMuteButton,\n  renderVolumeSlider,\n  alwaysShowControls,\n  showPlaybackRateControl,\n  posterFillMode,\n  bufferStateDelayInMilliseconds,\n  hideControlsWhenPointerDoesntMove,\n  overflowVisible,\n  browserMediaControlsBehavior,\n  overrideInternalClassName,\n  noSuspense\n}, ref) => {\n  const config = esm.Internals.useUnsafeVideoConfig();\n  const video = esm.Internals.useVideo();\n  const container = (0,react.useRef)(null);\n  const canvasSize = useElementSize(container, {\n    triggerOnWindowResize: false,\n    shouldApplyCssTransforms: false\n  });\n  const [hasPausedToResume, setHasPausedToResume] = (0,react.useState)(false);\n  const [shouldAutoplay, setShouldAutoPlay] = (0,react.useState)(autoPlay);\n  const [isFullscreen, setIsFullscreen] = (0,react.useState)(() => false);\n  const [seeking, setSeeking] = (0,react.useState)(false);\n  const supportsFullScreen = (0,react.useMemo)(() => {\n    if (typeof document === \"undefined\") {\n      return false;\n    }\n    return Boolean(document.fullscreenEnabled || document.webkitFullscreenEnabled);\n  }, []);\n  const player = usePlayer();\n  const playerToggle = player.toggle;\n  usePlayback({\n    loop,\n    playbackRate,\n    moveToBeginningWhenEnded,\n    inFrame,\n    outFrame,\n    getCurrentFrame: player.getCurrentFrame,\n    browserMediaControlsBehavior\n  });\n  (0,react.useEffect)(() => {\n    if (hasPausedToResume && !player.playing) {\n      setHasPausedToResume(false);\n      player.play();\n    }\n  }, [hasPausedToResume, player]);\n  (0,react.useEffect)(() => {\n    const { current } = container;\n    if (!current) {\n      return;\n    }\n    const onFullscreenChange = () => {\n      const newValue = document.fullscreenElement === current || document.webkitFullscreenElement === current;\n      setIsFullscreen(newValue);\n    };\n    document.addEventListener(\"fullscreenchange\", onFullscreenChange);\n    document.addEventListener(\"webkitfullscreenchange\", onFullscreenChange);\n    return () => {\n      document.removeEventListener(\"fullscreenchange\", onFullscreenChange);\n      document.removeEventListener(\"webkitfullscreenchange\", onFullscreenChange);\n    };\n  }, []);\n  const toggle = (0,react.useCallback)((e) => {\n    playerToggle(e);\n  }, [playerToggle]);\n  const requestFullscreen = (0,react.useCallback)(() => {\n    if (!allowFullscreen) {\n      throw new Error(\"allowFullscreen is false\");\n    }\n    if (!supportsFullScreen) {\n      throw new Error(\"Browser doesnt support fullscreen\");\n    }\n    if (!container.current) {\n      throw new Error(\"No player ref found\");\n    }\n    if (container.current.webkitRequestFullScreen) {\n      container.current.webkitRequestFullScreen();\n    } else {\n      container.current.requestFullscreen();\n    }\n  }, [allowFullscreen, supportsFullScreen]);\n  const exitFullscreen = (0,react.useCallback)(() => {\n    if (document.webkitExitFullscreen) {\n      document.webkitExitFullscreen();\n    } else {\n      document.exitFullscreen();\n    }\n  }, []);\n  (0,react.useEffect)(() => {\n    const { current } = container;\n    if (!current) {\n      return;\n    }\n    const fullscreenChange = () => {\n      const element = document.webkitFullscreenElement ?? document.fullscreenElement;\n      if (element && element === container.current) {\n        player.emitter.dispatchFullscreenChange({\n          isFullscreen: true\n        });\n      } else {\n        player.emitter.dispatchFullscreenChange({\n          isFullscreen: false\n        });\n      }\n    };\n    current.addEventListener(\"webkitfullscreenchange\", fullscreenChange);\n    current.addEventListener(\"fullscreenchange\", fullscreenChange);\n    return () => {\n      current.removeEventListener(\"webkitfullscreenchange\", fullscreenChange);\n      current.removeEventListener(\"fullscreenchange\", fullscreenChange);\n    };\n  }, [player.emitter]);\n  const durationInFrames = config?.durationInFrames ?? 1;\n  const layout = (0,react.useMemo)(() => {\n    if (!config || !canvasSize) {\n      return null;\n    }\n    return calculateCanvasTransformation({\n      canvasSize,\n      compositionHeight: config.height,\n      compositionWidth: config.width,\n      previewSize: \"auto\"\n    });\n  }, [canvasSize, config]);\n  const scale = layout?.scale ?? 1;\n  const initialScaleIgnored = (0,react.useRef)(false);\n  (0,react.useEffect)(() => {\n    if (!initialScaleIgnored.current) {\n      initialScaleIgnored.current = true;\n      return;\n    }\n    player.emitter.dispatchScaleChange(scale);\n  }, [player.emitter, scale]);\n  const { setMediaVolume, setMediaMuted } = (0,react.useContext)(esm.Internals.SetMediaVolumeContext);\n  const { mediaMuted, mediaVolume } = (0,react.useContext)(esm.Internals.MediaVolumeContext);\n  (0,react.useEffect)(() => {\n    player.emitter.dispatchVolumeChange(mediaVolume);\n  }, [player.emitter, mediaVolume]);\n  const isMuted = mediaMuted || mediaVolume === 0;\n  (0,react.useEffect)(() => {\n    player.emitter.dispatchMuteChange({\n      isMuted\n    });\n  }, [player.emitter, isMuted]);\n  const [showBufferIndicator, setShowBufferState] = (0,react.useState)(false);\n  (0,react.useEffect)(() => {\n    let timeout = null;\n    let stopped = false;\n    const onBuffer = () => {\n      stopped = false;\n      requestAnimationFrame(() => {\n        if (bufferStateDelayInMilliseconds === 0) {\n          setShowBufferState(true);\n        } else {\n          timeout = setTimeout(() => {\n            if (!stopped) {\n              setShowBufferState(true);\n            }\n          }, bufferStateDelayInMilliseconds);\n        }\n      });\n    };\n    const onResume = () => {\n      requestAnimationFrame(() => {\n        stopped = true;\n        setShowBufferState(false);\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n      });\n    };\n    player.emitter.addEventListener(\"waiting\", onBuffer);\n    player.emitter.addEventListener(\"resume\", onResume);\n    return () => {\n      player.emitter.removeEventListener(\"waiting\", onBuffer);\n      player.emitter.removeEventListener(\"resume\", onResume);\n      setShowBufferState(false);\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n      stopped = true;\n    };\n  }, [bufferStateDelayInMilliseconds, player.emitter]);\n  (0,react.useImperativeHandle)(ref, () => {\n    const methods = {\n      play: player.play,\n      pause: () => {\n        setHasPausedToResume(false);\n        player.pause();\n      },\n      toggle,\n      getContainerNode: () => container.current,\n      getCurrentFrame: player.getCurrentFrame,\n      isPlaying: player.isPlaying,\n      seekTo: (f) => {\n        const lastFrame = durationInFrames - 1;\n        const frameToSeekTo = Math.max(0, Math.min(lastFrame, f));\n        if (player.isPlaying()) {\n          const pauseToResume = frameToSeekTo !== lastFrame || loop;\n          setHasPausedToResume(pauseToResume);\n          player.pause();\n        }\n        if (frameToSeekTo === lastFrame && !loop) {\n          player.emitter.dispatchEnded();\n        }\n        player.seek(frameToSeekTo);\n      },\n      isFullscreen: () => {\n        const { current } = container;\n        if (!current) {\n          return false;\n        }\n        return document.fullscreenElement === current || document.webkitFullscreenElement === current;\n      },\n      requestFullscreen,\n      exitFullscreen,\n      getVolume: () => {\n        if (mediaMuted) {\n          return 0;\n        }\n        return mediaVolume;\n      },\n      setVolume: (vol) => {\n        if (typeof vol !== \"number\") {\n          throw new TypeError(`setVolume() takes a number, got value of type ${typeof vol}`);\n        }\n        if (isNaN(vol)) {\n          throw new TypeError(`setVolume() got a number that is NaN. Volume must be between 0 and 1.`);\n        }\n        if (vol < 0 || vol > 1) {\n          throw new TypeError(`setVolume() got a number that is out of range. Must be between 0 and 1, got ${typeof vol}`);\n        }\n        setMediaVolume(vol);\n      },\n      isMuted: () => isMuted,\n      mute: () => {\n        setMediaMuted(true);\n      },\n      unmute: () => {\n        setMediaMuted(false);\n      },\n      getScale: () => scale,\n      pauseAndReturnToPlayStart: () => {\n        player.pauseAndReturnToPlayStart();\n      }\n    };\n    return Object.assign(player.emitter, methods);\n  }, [\n    durationInFrames,\n    exitFullscreen,\n    loop,\n    mediaMuted,\n    isMuted,\n    mediaVolume,\n    player,\n    requestFullscreen,\n    setMediaMuted,\n    setMediaVolume,\n    toggle,\n    scale\n  ]);\n  const VideoComponent = video ? video.component : null;\n  const outerStyle = (0,react.useMemo)(() => {\n    return calculateOuterStyle({\n      canvasSize,\n      config,\n      style: style2,\n      overflowVisible,\n      layout\n    });\n  }, [canvasSize, config, layout, overflowVisible, style2]);\n  const outer = (0,react.useMemo)(() => {\n    return calculateOuter({ config, layout, scale, overflowVisible });\n  }, [config, layout, overflowVisible, scale]);\n  const containerStyle3 = (0,react.useMemo)(() => {\n    return calculateContainerStyle({\n      config,\n      layout,\n      scale,\n      overflowVisible\n    });\n  }, [config, layout, overflowVisible, scale]);\n  const playerPause = player.pause;\n  const playerDispatchError = player.emitter.dispatchError;\n  const onError = (0,react.useCallback)((error) => {\n    playerPause();\n    playerDispatchError(error);\n  }, [playerDispatchError, playerPause]);\n  const onFullscreenButtonClick = (0,react.useCallback)((e) => {\n    e.stopPropagation();\n    requestFullscreen();\n  }, [requestFullscreen]);\n  const onExitFullscreenButtonClick = (0,react.useCallback)((e) => {\n    e.stopPropagation();\n    exitFullscreen();\n  }, [exitFullscreen]);\n  const onSingleClick = (0,react.useCallback)((e) => {\n    const rightClick = e instanceof MouseEvent ? e.button === 2 : e.nativeEvent.button;\n    if (rightClick) {\n      return;\n    }\n    toggle(e);\n  }, [toggle]);\n  const onSeekStart = (0,react.useCallback)(() => {\n    setSeeking(true);\n  }, []);\n  const onSeekEnd = (0,react.useCallback)(() => {\n    setSeeking(false);\n  }, []);\n  const onDoubleClick = (0,react.useCallback)(() => {\n    if (isFullscreen) {\n      exitFullscreen();\n    } else {\n      requestFullscreen();\n    }\n  }, [exitFullscreen, isFullscreen, requestFullscreen]);\n  const { handlePointerDown, handleDoubleClick } = useClickPreventionOnDoubleClick(onSingleClick, onDoubleClick, doubleClickToFullscreen && allowFullscreen && supportsFullScreen);\n  (0,react.useEffect)(() => {\n    if (shouldAutoplay) {\n      player.play();\n      setShouldAutoPlay(false);\n    }\n  }, [shouldAutoplay, player]);\n  const loadingMarkup = (0,react.useMemo)(() => {\n    return renderLoading ? renderLoading({\n      height: outerStyle.height,\n      width: outerStyle.width,\n      isBuffering: showBufferIndicator\n    }) : null;\n  }, [outerStyle.height, outerStyle.width, renderLoading, showBufferIndicator]);\n  const currentScale = (0,react.useMemo)(() => {\n    return {\n      type: \"scale\",\n      scale\n    };\n  }, [scale]);\n  if (!config) {\n    return null;\n  }\n  const poster = renderPoster ? renderPoster({\n    height: posterFillMode === \"player-size\" ? outerStyle.height : config.height,\n    width: posterFillMode === \"player-size\" ? outerStyle.width : config.width,\n    isBuffering: showBufferIndicator\n  }) : null;\n  if (poster === undefined) {\n    throw new TypeError(\"renderPoster() must return a React element, but undefined was returned\");\n  }\n  const shouldShowPoster = poster && [\n    showPosterWhenPaused && !player.isPlaying() && !seeking,\n    showPosterWhenEnded && player.isLastFrame && !player.isPlaying(),\n    showPosterWhenUnplayed && !player.hasPlayed && !player.isPlaying(),\n    showPosterWhenBuffering && showBufferIndicator && player.isPlaying(),\n    showPosterWhenBufferingAndPaused && showBufferIndicator && !player.isPlaying()\n  ].some(Boolean);\n  const { left, top, width, height, ...outerWithoutScale } = outer;\n  const content = /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [\n      /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"div\", {\n        style: outer,\n        onPointerDown: clickToPlay ? handlePointerDown : undefined,\n        onDoubleClick: doubleClickToFullscreen ? handleDoubleClick : undefined,\n        children: [\n          /* @__PURE__ */ (0,jsx_runtime.jsxs)(\"div\", {\n            style: containerStyle3,\n            className: playerCssClassname(overrideInternalClassName),\n            children: [\n              VideoComponent ? /* @__PURE__ */ (0,jsx_runtime.jsx)(ErrorBoundary, {\n                onError,\n                errorFallback,\n                children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.CurrentScaleContext.Provider, {\n                  value: currentScale,\n                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(VideoComponent, {\n                    ...video?.props ?? {},\n                    ...inputProps ?? {}\n                  })\n                })\n              }) : null,\n              shouldShowPoster && posterFillMode === \"composition-size\" ? /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n                style: {\n                  ...outerWithoutScale,\n                  width: config.width,\n                  height: config.height\n                },\n                onPointerDown: clickToPlay ? handlePointerDown : undefined,\n                onDoubleClick: doubleClickToFullscreen ? handleDoubleClick : undefined,\n                children: poster\n              }) : null\n            ]\n          }),\n          /* @__PURE__ */ (0,jsx_runtime.jsx)(RenderWarningIfBlacklist, {})\n        ]\n      }),\n      shouldShowPoster && posterFillMode === \"player-size\" ? /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n        style: outer,\n        onPointerDown: clickToPlay ? handlePointerDown : undefined,\n        onDoubleClick: doubleClickToFullscreen ? handleDoubleClick : undefined,\n        children: poster\n      }) : null,\n      controls ? /* @__PURE__ */ (0,jsx_runtime.jsx)(Controls, {\n        fps: config.fps,\n        playing: player.playing,\n        toggle: player.toggle,\n        durationInFrames: config.durationInFrames,\n        containerRef: container,\n        onFullscreenButtonClick,\n        isFullscreen,\n        allowFullscreen,\n        showVolumeControls,\n        onExitFullscreenButtonClick,\n        spaceKeyToPlayOrPause,\n        onSeekEnd,\n        onSeekStart,\n        inFrame,\n        outFrame,\n        initiallyShowControls,\n        canvasSize,\n        renderFullscreenButton,\n        renderPlayPauseButton,\n        alwaysShowControls,\n        showPlaybackRateControl,\n        buffering: showBufferIndicator,\n        hideControlsWhenPointerDoesntMove,\n        onDoubleClick: doubleClickToFullscreen ? handleDoubleClick : undefined,\n        onPointerDown: clickToPlay ? handlePointerDown : undefined,\n        renderMuteButton,\n        renderVolumeSlider\n      }) : null\n    ]\n  });\n  if (noSuspense || IS_NODE && !doesReactVersionSupportSuspense) {\n    return /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n      ref: container,\n      style: outerStyle,\n      className: className2,\n      children: content\n    });\n  }\n  return /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n    ref: container,\n    style: outerStyle,\n    className: className2,\n    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(react.Suspense, {\n      fallback: loadingMarkup,\n      children: content\n    })\n  });\n};\nvar PlayerUI_default = (0,react.forwardRef)(PlayerUI);\n\n// src/SharedPlayerContext.tsx\n\n\n\n// src/volume-persistance.ts\n\nvar DEFAULT_VOLUME_PERSISTANCE_KEY = \"remotion.volumePreference\";\nvar persistVolume = (volume, logLevel, volumePersistenceKey) => {\n  if (typeof window === \"undefined\") {\n    return;\n  }\n  try {\n    window.localStorage.setItem(volumePersistenceKey ?? DEFAULT_VOLUME_PERSISTANCE_KEY, String(volume));\n  } catch (e) {\n    esm.Internals.Log.error(logLevel, \"Could not persist volume\", e);\n  }\n};\nvar getPreferredVolume = (volumePersistenceKey) => {\n  if (typeof window === \"undefined\") {\n    return 1;\n  }\n  try {\n    const val = window.localStorage.getItem(volumePersistenceKey ?? DEFAULT_VOLUME_PERSISTANCE_KEY);\n    return val ? Number(val) : 1;\n  } catch {\n    return 1;\n  }\n};\n\n// src/SharedPlayerContext.tsx\n\nvar PLAYER_COMP_ID = \"player-comp\";\nvar SharedPlayerContexts = ({\n  children,\n  timelineContext,\n  fps,\n  compositionHeight,\n  compositionWidth,\n  durationInFrames,\n  component,\n  numberOfSharedAudioTags,\n  initiallyMuted,\n  logLevel,\n  audioLatencyHint,\n  volumePersistenceKey\n}) => {\n  const compositionManagerContext = (0,react.useMemo)(() => {\n    const context = {\n      compositions: [\n        {\n          component,\n          durationInFrames,\n          height: compositionHeight,\n          width: compositionWidth,\n          fps,\n          id: PLAYER_COMP_ID,\n          nonce: 777,\n          folderName: null,\n          parentFolderName: null,\n          schema: null,\n          calculateMetadata: null\n        }\n      ],\n      folders: [],\n      currentCompositionMetadata: null,\n      canvasContent: { type: \"composition\", compositionId: \"player-comp\" }\n    };\n    return context;\n  }, [component, durationInFrames, compositionHeight, compositionWidth, fps]);\n  const [mediaMuted, setMediaMuted] = (0,react.useState)(() => initiallyMuted);\n  const [mediaVolume, setMediaVolume] = (0,react.useState)(() => getPreferredVolume(volumePersistenceKey ?? null));\n  const mediaVolumeContextValue = (0,react.useMemo)(() => {\n    return {\n      mediaMuted,\n      mediaVolume\n    };\n  }, [mediaMuted, mediaVolume]);\n  const setMediaVolumeAndPersist = (0,react.useCallback)((vol) => {\n    setMediaVolume(vol);\n    persistVolume(vol, logLevel, volumePersistenceKey ?? null);\n  }, [logLevel, volumePersistenceKey]);\n  const setMediaVolumeContextValue = (0,react.useMemo)(() => {\n    return {\n      setMediaMuted,\n      setMediaVolume: setMediaVolumeAndPersist\n    };\n  }, [setMediaVolumeAndPersist]);\n  const logLevelContext = (0,react.useMemo)(() => {\n    return {\n      logLevel,\n      mountTime: Date.now()\n    };\n  }, [logLevel]);\n  const env = (0,react.useMemo)(() => {\n    return {\n      isPlayer: true,\n      isRendering: false,\n      isStudio: false,\n      isClientSideRendering: false,\n      isReadOnlyStudio: false\n    };\n  }, []);\n  return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.RemotionEnvironmentContext, {\n    value: env,\n    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.LogLevelContext.Provider, {\n      value: logLevelContext,\n      children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.CanUseRemotionHooksProvider, {\n        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.Timeline.TimelineContext.Provider, {\n          value: timelineContext,\n          children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.CompositionManager.Provider, {\n            value: compositionManagerContext,\n            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.ResolveCompositionConfig, {\n              children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.PrefetchProvider, {\n                children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.DurationsContextProvider, {\n                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.MediaVolumeContext.Provider, {\n                    value: mediaVolumeContextValue,\n                    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.SetMediaVolumeContext.Provider, {\n                      value: setMediaVolumeContextValue,\n                      children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.SharedAudioContextProvider, {\n                        numberOfAudioTags: numberOfSharedAudioTags,\n                        component,\n                        audioLatencyHint,\n                        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.BufferingProvider, {\n                          children\n                        })\n                      })\n                    })\n                  })\n                })\n              })\n            })\n          })\n        })\n      })\n    })\n  });\n};\n\n// src/use-remotion-license-acknowledge.ts\n\nvar warningShown = false;\nvar acknowledgeRemotionLicenseMessage = (acknowledge, logLevel) => {\n  if (acknowledge) {\n    return;\n  }\n  if (warningShown) {\n    return;\n  }\n  warningShown = true;\n  esm.Internals.Log.warn(logLevel, \"Note: Some companies are required to obtain a license to use Remotion. See: https://remotion.dev/license\\nPass the `acknowledgeRemotionLicense` prop to `<Player />` function to make this message disappear.\");\n};\n\n// src/utils/validate-in-out-frame.ts\nvar validateSingleFrame = (frame, variableName) => {\n  if (typeof frame === \"undefined\" || frame === null) {\n    return frame ?? null;\n  }\n  if (typeof frame !== \"number\") {\n    throw new TypeError(`\"${variableName}\" must be a number, but is ${JSON.stringify(frame)}`);\n  }\n  if (Number.isNaN(frame)) {\n    throw new TypeError(`\"${variableName}\" must not be NaN, but is ${JSON.stringify(frame)}`);\n  }\n  if (!Number.isFinite(frame)) {\n    throw new TypeError(`\"${variableName}\" must be finite, but is ${JSON.stringify(frame)}`);\n  }\n  if (frame % 1 !== 0) {\n    throw new TypeError(`\"${variableName}\" must be an integer, but is ${JSON.stringify(frame)}`);\n  }\n  return frame;\n};\nvar validateInOutFrames = ({\n  inFrame,\n  durationInFrames,\n  outFrame\n}) => {\n  const validatedInFrame = validateSingleFrame(inFrame, \"inFrame\");\n  const validatedOutFrame = validateSingleFrame(outFrame, \"outFrame\");\n  if (validatedInFrame === null && validatedOutFrame === null) {\n    return;\n  }\n  if (validatedInFrame !== null && validatedInFrame > durationInFrames - 1) {\n    throw new Error(\"inFrame must be less than (durationInFrames - 1), but is \" + validatedInFrame);\n  }\n  if (validatedOutFrame !== null && validatedOutFrame > durationInFrames - 1) {\n    throw new Error(\"outFrame must be less than (durationInFrames - 1), but is \" + validatedOutFrame);\n  }\n  if (validatedInFrame !== null && validatedInFrame < 0) {\n    throw new Error(\"inFrame must be greater than 0, but is \" + validatedInFrame);\n  }\n  if (validatedOutFrame !== null && validatedOutFrame <= 0) {\n    throw new Error(`outFrame must be greater than 0, but is ${validatedOutFrame}. If you want to render a single frame, use <Thumbnail /> instead.`);\n  }\n  if (validatedOutFrame !== null && validatedInFrame !== null && validatedOutFrame <= validatedInFrame) {\n    throw new Error(\"outFrame must be greater than inFrame, but is \" + validatedOutFrame + \" <= \" + validatedInFrame);\n  }\n};\n\n// src/utils/validate-initial-frame.ts\nvar validateInitialFrame = ({\n  initialFrame,\n  durationInFrames\n}) => {\n  if (typeof durationInFrames !== \"number\") {\n    throw new Error(`\\`durationInFrames\\` must be a number, but is ${JSON.stringify(durationInFrames)}`);\n  }\n  if (typeof initialFrame === \"undefined\") {\n    return;\n  }\n  if (typeof initialFrame !== \"number\") {\n    throw new Error(`\\`initialFrame\\` must be a number, but is ${JSON.stringify(initialFrame)}`);\n  }\n  if (Number.isNaN(initialFrame)) {\n    throw new Error(`\\`initialFrame\\` must be a number, but is NaN`);\n  }\n  if (!Number.isFinite(initialFrame)) {\n    throw new Error(`\\`initialFrame\\` must be a number, but is Infinity`);\n  }\n  if (initialFrame % 1 !== 0) {\n    throw new Error(`\\`initialFrame\\` must be an integer, but is ${JSON.stringify(initialFrame)}`);\n  }\n  if (initialFrame > durationInFrames - 1) {\n    throw new Error(`\\`initialFrame\\` must be less or equal than \\`durationInFrames - 1\\`, but is ${JSON.stringify(initialFrame)}`);\n  }\n};\n\n// src/utils/validate-playbackrate.ts\nvar validatePlaybackRate = (playbackRate) => {\n  if (playbackRate === undefined) {\n    return;\n  }\n  if (playbackRate > 4) {\n    throw new Error(`The highest possible playback rate is 4. You passed: ${playbackRate}`);\n  }\n  if (playbackRate < -4) {\n    throw new Error(`The lowest possible playback rate is -4. You passed: ${playbackRate}`);\n  }\n  if (playbackRate === 0) {\n    throw new Error(`A playback rate of 0 is not supported.`);\n  }\n};\n\n// src/validate.ts\n\nvar validateFps = no_react.NoReactInternals.validateFps;\nvar validateDimension = no_react.NoReactInternals.validateDimension;\nvar validateDurationInFrames = no_react.NoReactInternals.validateDurationInFrames;\nvar validateDefaultAndInputProps = no_react.NoReactInternals.validateDefaultAndInputProps;\n\n// src/Player.tsx\n\nvar componentOrNullIfLazy = (props) => {\n  if (\"component\" in props) {\n    return props.component;\n  }\n  return null;\n};\nvar PlayerFn = ({\n  durationInFrames,\n  compositionHeight,\n  compositionWidth,\n  fps,\n  inputProps,\n  style: style2,\n  controls = false,\n  loop = false,\n  autoPlay = false,\n  showVolumeControls = true,\n  allowFullscreen = true,\n  clickToPlay,\n  doubleClickToFullscreen = false,\n  spaceKeyToPlayOrPause = true,\n  moveToBeginningWhenEnded = true,\n  numberOfSharedAudioTags = 5,\n  errorFallback = () => \"âš ï¸\",\n  playbackRate = 1,\n  renderLoading,\n  className: className2,\n  showPosterWhenUnplayed,\n  showPosterWhenEnded,\n  showPosterWhenPaused,\n  showPosterWhenBuffering,\n  showPosterWhenBufferingAndPaused,\n  initialFrame,\n  renderPoster,\n  inFrame,\n  outFrame,\n  initiallyShowControls,\n  renderFullscreenButton,\n  renderPlayPauseButton,\n  renderVolumeSlider,\n  alwaysShowControls = false,\n  initiallyMuted = false,\n  showPlaybackRateControl = false,\n  posterFillMode = \"player-size\",\n  bufferStateDelayInMilliseconds,\n  hideControlsWhenPointerDoesntMove = true,\n  overflowVisible = false,\n  renderMuteButton,\n  browserMediaControlsBehavior: passedBrowserMediaControlsBehavior,\n  overrideInternalClassName,\n  logLevel = \"info\",\n  noSuspense,\n  acknowledgeRemotionLicense,\n  audioLatencyHint = \"interactive\",\n  volumePersistenceKey,\n  ...componentProps\n}, ref) => {\n  if (typeof window !== \"undefined\") {\n    window.remotion_isPlayer = true;\n  }\n  if (componentProps.defaultProps !== undefined) {\n    throw new Error(\"The <Player /> component does not accept `defaultProps`, but some were passed. Use `inputProps` instead.\");\n  }\n  const componentForValidation = componentOrNullIfLazy(componentProps);\n  if (componentForValidation?.type === esm.Composition) {\n    throw new TypeError(`'component' should not be an instance of <Composition/>. Pass the React component directly, and set the duration, fps and dimensions as separate props. See https://www.remotion.dev/docs/player/examples for an example.`);\n  }\n  if (componentForValidation === esm.Composition) {\n    throw new TypeError(`'component' must not be the 'Composition' component. Pass your own React component directly, and set the duration, fps and dimensions as separate props. See https://www.remotion.dev/docs/player/examples for an example.`);\n  }\n  (0,react.useState)(() => acknowledgeRemotionLicenseMessage(Boolean(acknowledgeRemotionLicense), logLevel));\n  const component = esm.Internals.useLazyComponent({\n    compProps: componentProps,\n    componentName: \"Player\",\n    noSuspense: Boolean(noSuspense)\n  });\n  validateInitialFrame({ initialFrame, durationInFrames });\n  const [frame, setFrame] = (0,react.useState)(() => ({\n    [PLAYER_COMP_ID]: initialFrame ?? 0\n  }));\n  const [playing, setPlaying] = (0,react.useState)(false);\n  const [rootId] = (0,react.useState)(\"player-comp\");\n  const rootRef = (0,react.useRef)(null);\n  const audioAndVideoTags = (0,react.useRef)([]);\n  const imperativePlaying = (0,react.useRef)(false);\n  const [currentPlaybackRate, setCurrentPlaybackRate] = (0,react.useState)(playbackRate);\n  if (typeof compositionHeight !== \"number\") {\n    throw new TypeError(`'compositionHeight' must be a number but got '${typeof compositionHeight}' instead`);\n  }\n  if (typeof compositionWidth !== \"number\") {\n    throw new TypeError(`'compositionWidth' must be a number but got '${typeof compositionWidth}' instead`);\n  }\n  validateDimension(compositionHeight, \"compositionHeight\", \"of the <Player /> component\");\n  validateDimension(compositionWidth, \"compositionWidth\", \"of the <Player /> component\");\n  validateDurationInFrames(durationInFrames, {\n    component: \"of the <Player/> component\",\n    allowFloats: false\n  });\n  validateFps(fps, \"as a prop of the <Player/> component\", false);\n  validateDefaultAndInputProps(inputProps, \"inputProps\", null);\n  validateInOutFrames({\n    durationInFrames,\n    inFrame,\n    outFrame\n  });\n  if (typeof controls !== \"boolean\" && typeof controls !== \"undefined\") {\n    throw new TypeError(`'controls' must be a boolean or undefined but got '${typeof controls}' instead`);\n  }\n  if (typeof autoPlay !== \"boolean\" && typeof autoPlay !== \"undefined\") {\n    throw new TypeError(`'autoPlay' must be a boolean or undefined but got '${typeof autoPlay}' instead`);\n  }\n  if (typeof loop !== \"boolean\" && typeof loop !== \"undefined\") {\n    throw new TypeError(`'loop' must be a boolean or undefined but got '${typeof loop}' instead`);\n  }\n  if (typeof doubleClickToFullscreen !== \"boolean\" && typeof doubleClickToFullscreen !== \"undefined\") {\n    throw new TypeError(`'doubleClickToFullscreen' must be a boolean or undefined but got '${typeof doubleClickToFullscreen}' instead`);\n  }\n  if (typeof showVolumeControls !== \"boolean\" && typeof showVolumeControls !== \"undefined\") {\n    throw new TypeError(`'showVolumeControls' must be a boolean or undefined but got '${typeof showVolumeControls}' instead`);\n  }\n  if (typeof allowFullscreen !== \"boolean\" && typeof allowFullscreen !== \"undefined\") {\n    throw new TypeError(`'allowFullscreen' must be a boolean or undefined but got '${typeof allowFullscreen}' instead`);\n  }\n  if (typeof clickToPlay !== \"boolean\" && typeof clickToPlay !== \"undefined\") {\n    throw new TypeError(`'clickToPlay' must be a boolean or undefined but got '${typeof clickToPlay}' instead`);\n  }\n  if (typeof spaceKeyToPlayOrPause !== \"boolean\" && typeof spaceKeyToPlayOrPause !== \"undefined\") {\n    throw new TypeError(`'spaceKeyToPlayOrPause' must be a boolean or undefined but got '${typeof spaceKeyToPlayOrPause}' instead`);\n  }\n  if (typeof numberOfSharedAudioTags !== \"number\" || numberOfSharedAudioTags % 1 !== 0 || !Number.isFinite(numberOfSharedAudioTags) || Number.isNaN(numberOfSharedAudioTags) || numberOfSharedAudioTags < 0) {\n    throw new TypeError(`'numberOfSharedAudioTags' must be an integer but got '${numberOfSharedAudioTags}' instead`);\n  }\n  validatePlaybackRate(currentPlaybackRate);\n  (0,react.useEffect)(() => {\n    setCurrentPlaybackRate(playbackRate);\n  }, [playbackRate]);\n  (0,react.useImperativeHandle)(ref, () => rootRef.current, []);\n  (0,react.useState)(() => {\n    esm.Internals.playbackLogging({\n      logLevel,\n      message: `[player] Mounting <Player>. User agent = ${typeof navigator === \"undefined\" ? \"server\" : navigator.userAgent}`,\n      tag: \"player\",\n      mountTime: Date.now()\n    });\n  });\n  const timelineContextValue = (0,react.useMemo)(() => {\n    return {\n      frame,\n      playing,\n      rootId,\n      playbackRate: currentPlaybackRate,\n      imperativePlaying,\n      setPlaybackRate: (rate) => {\n        setCurrentPlaybackRate(rate);\n      },\n      audioAndVideoTags\n    };\n  }, [frame, currentPlaybackRate, playing, rootId]);\n  const setTimelineContextValue = (0,react.useMemo)(() => {\n    return {\n      setFrame,\n      setPlaying\n    };\n  }, [setFrame]);\n  if (typeof window !== \"undefined\") {\n    (0,react.useLayoutEffect)(() => {\n      esm.Internals.CSSUtils.injectCSS(esm.Internals.CSSUtils.makeDefaultPreviewCSS(`.${playerCssClassname(overrideInternalClassName)}`, \"#fff\"));\n    }, [overrideInternalClassName]);\n  }\n  const actualInputProps = (0,react.useMemo)(() => inputProps ?? {}, [inputProps]);\n  const browserMediaControlsBehavior = (0,react.useMemo)(() => {\n    return passedBrowserMediaControlsBehavior ?? {\n      mode: \"prevent-media-session\"\n    };\n  }, [passedBrowserMediaControlsBehavior]);\n  return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.IsPlayerContextProvider, {\n    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(SharedPlayerContexts, {\n      timelineContext: timelineContextValue,\n      component,\n      compositionHeight,\n      compositionWidth,\n      durationInFrames,\n      fps,\n      numberOfSharedAudioTags,\n      initiallyMuted,\n      logLevel,\n      audioLatencyHint,\n      volumePersistenceKey,\n      children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.Timeline.SetTimelineContext.Provider, {\n        value: setTimelineContextValue,\n        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(PlayerEmitterProvider, {\n          currentPlaybackRate,\n          children: /* @__PURE__ */ (0,jsx_runtime.jsx)(PlayerUI_default, {\n            ref: rootRef,\n            posterFillMode,\n            renderLoading,\n            autoPlay: Boolean(autoPlay),\n            loop: Boolean(loop),\n            controls: Boolean(controls),\n            errorFallback,\n            style: style2,\n            inputProps: actualInputProps,\n            allowFullscreen: Boolean(allowFullscreen),\n            moveToBeginningWhenEnded: Boolean(moveToBeginningWhenEnded),\n            clickToPlay: typeof clickToPlay === \"boolean\" ? clickToPlay : Boolean(controls),\n            showVolumeControls: Boolean(showVolumeControls),\n            doubleClickToFullscreen: Boolean(doubleClickToFullscreen),\n            spaceKeyToPlayOrPause: Boolean(spaceKeyToPlayOrPause),\n            playbackRate: currentPlaybackRate,\n            className: className2 ?? undefined,\n            showPosterWhenUnplayed: Boolean(showPosterWhenUnplayed),\n            showPosterWhenEnded: Boolean(showPosterWhenEnded),\n            showPosterWhenPaused: Boolean(showPosterWhenPaused),\n            showPosterWhenBuffering: Boolean(showPosterWhenBuffering),\n            showPosterWhenBufferingAndPaused: Boolean(showPosterWhenBufferingAndPaused),\n            renderPoster,\n            inFrame: inFrame ?? null,\n            outFrame: outFrame ?? null,\n            initiallyShowControls: initiallyShowControls ?? true,\n            renderFullscreen: renderFullscreenButton ?? null,\n            renderPlayPauseButton: renderPlayPauseButton ?? null,\n            renderMuteButton: renderMuteButton ?? null,\n            renderVolumeSlider: renderVolumeSlider ?? null,\n            alwaysShowControls,\n            showPlaybackRateControl,\n            bufferStateDelayInMilliseconds: bufferStateDelayInMilliseconds ?? 300,\n            hideControlsWhenPointerDoesntMove,\n            overflowVisible,\n            browserMediaControlsBehavior,\n            overrideInternalClassName: overrideInternalClassName ?? undefined,\n            noSuspense: Boolean(noSuspense)\n          })\n        })\n      })\n    })\n  });\n};\nvar forward = react.forwardRef;\nvar Player = forward(PlayerFn);\n// src/Thumbnail.tsx\n\n\n\n// src/ThumbnailUI.tsx\n\n\n\n// src/use-thumbnail.ts\n\nvar useThumbnail = () => {\n  const emitter = (0,react.useContext)(ThumbnailEmitterContext);\n  if (!emitter) {\n    throw new TypeError(\"Expected Player event emitter context\");\n  }\n  const returnValue = (0,react.useMemo)(() => {\n    return {\n      emitter\n    };\n  }, [emitter]);\n  return returnValue;\n};\n\n// src/ThumbnailUI.tsx\n\nvar reactVersion2 = react.version.split(\".\")[0];\nif (reactVersion2 === \"0\") {\n  throw new Error(`Version ${reactVersion2} of \"react\" is not supported by Remotion`);\n}\nvar doesReactVersionSupportSuspense2 = parseInt(reactVersion2, 10) >= 18;\nvar ThumbnailUI = ({\n  style: style2,\n  inputProps,\n  errorFallback,\n  renderLoading,\n  className: className2,\n  overflowVisible,\n  noSuspense,\n  overrideInternalClassName\n}, ref) => {\n  const config = esm.Internals.useUnsafeVideoConfig();\n  const video = esm.Internals.useVideo();\n  const container = (0,react.useRef)(null);\n  const canvasSize = useElementSize(container, {\n    triggerOnWindowResize: false,\n    shouldApplyCssTransforms: false\n  });\n  const layout = (0,react.useMemo)(() => {\n    if (!config || !canvasSize) {\n      return null;\n    }\n    return calculateCanvasTransformation({\n      canvasSize,\n      compositionHeight: config.height,\n      compositionWidth: config.width,\n      previewSize: \"auto\"\n    });\n  }, [canvasSize, config]);\n  const scale = layout?.scale ?? 1;\n  const thumbnail = useThumbnail();\n  useBufferStateEmitter(thumbnail.emitter);\n  (0,react.useImperativeHandle)(ref, () => {\n    const methods = {\n      getContainerNode: () => container.current,\n      getScale: () => scale\n    };\n    return Object.assign(thumbnail.emitter, methods);\n  }, [scale, thumbnail.emitter]);\n  const VideoComponent = video ? video.component : null;\n  const outerStyle = (0,react.useMemo)(() => {\n    return calculateOuterStyle({\n      config,\n      style: style2,\n      canvasSize,\n      overflowVisible,\n      layout\n    });\n  }, [canvasSize, config, layout, overflowVisible, style2]);\n  const outer = (0,react.useMemo)(() => {\n    return calculateOuter({ config, layout, scale, overflowVisible });\n  }, [config, layout, overflowVisible, scale]);\n  const containerStyle3 = (0,react.useMemo)(() => {\n    return calculateContainerStyle({\n      config,\n      layout,\n      scale,\n      overflowVisible\n    });\n  }, [config, layout, overflowVisible, scale]);\n  const onError = (0,react.useCallback)((error) => {\n    thumbnail.emitter.dispatchError(error);\n  }, [thumbnail.emitter]);\n  const loadingMarkup = (0,react.useMemo)(() => {\n    return renderLoading ? renderLoading({\n      height: outerStyle.height,\n      width: outerStyle.width,\n      isBuffering: false\n    }) : null;\n  }, [outerStyle.height, outerStyle.width, renderLoading]);\n  const currentScaleContext = (0,react.useMemo)(() => {\n    return {\n      type: \"scale\",\n      scale\n    };\n  }, [scale]);\n  if (!config) {\n    return null;\n  }\n  const content = /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n    style: outer,\n    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n      style: containerStyle3,\n      className: playerCssClassname(overrideInternalClassName),\n      children: VideoComponent ? /* @__PURE__ */ (0,jsx_runtime.jsx)(ErrorBoundary, {\n        onError,\n        errorFallback,\n        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.CurrentScaleContext.Provider, {\n          value: currentScaleContext,\n          children: /* @__PURE__ */ (0,jsx_runtime.jsx)(VideoComponent, {\n            ...video?.props ?? {},\n            ...inputProps ?? {}\n          })\n        })\n      }) : null\n    })\n  });\n  if (noSuspense || IS_NODE && !doesReactVersionSupportSuspense2) {\n    return /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n      ref: container,\n      style: outerStyle,\n      className: className2,\n      children: content\n    });\n  }\n  return /* @__PURE__ */ (0,jsx_runtime.jsx)(\"div\", {\n    ref: container,\n    style: outerStyle,\n    className: className2,\n    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(react.Suspense, {\n      fallback: loadingMarkup,\n      children: content\n    })\n  });\n};\nvar ThumbnailUI_default = (0,react.forwardRef)(ThumbnailUI);\n\n// src/Thumbnail.tsx\n\nvar ThumbnailFn = ({\n  frameToDisplay,\n  style: style2,\n  inputProps,\n  compositionHeight,\n  compositionWidth,\n  durationInFrames,\n  fps,\n  className: className2,\n  errorFallback = () => \"âš ï¸\",\n  renderLoading,\n  overflowVisible = false,\n  overrideInternalClassName,\n  logLevel = \"info\",\n  noSuspense,\n  ...componentProps\n}, ref) => {\n  if (typeof window !== \"undefined\") {\n    (0,react.useLayoutEffect)(() => {\n      window.remotion_isPlayer = true;\n    }, []);\n  }\n  const [thumbnailId] = (0,react.useState)(() => String((0,esm.random)(null)));\n  const rootRef = (0,react.useRef)(null);\n  const timelineState = (0,react.useMemo)(() => {\n    const value = {\n      playing: false,\n      frame: {\n        [PLAYER_COMP_ID]: frameToDisplay\n      },\n      rootId: thumbnailId,\n      imperativePlaying: {\n        current: false\n      },\n      playbackRate: 1,\n      setPlaybackRate: () => {\n        throw new Error(\"thumbnail\");\n      },\n      audioAndVideoTags: { current: [] }\n    };\n    return value;\n  }, [frameToDisplay, thumbnailId]);\n  (0,react.useImperativeHandle)(ref, () => rootRef.current, []);\n  const Component = esm.Internals.useLazyComponent({\n    compProps: componentProps,\n    componentName: \"Thumbnail\",\n    noSuspense: Boolean(noSuspense)\n  });\n  const [emitter] = (0,react.useState)(() => new ThumbnailEmitter);\n  const passedInputProps = (0,react.useMemo)(() => {\n    return inputProps ?? {};\n  }, [inputProps]);\n  return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Internals.IsPlayerContextProvider, {\n    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(SharedPlayerContexts, {\n      timelineContext: timelineState,\n      component: Component,\n      compositionHeight,\n      compositionWidth,\n      durationInFrames,\n      fps,\n      numberOfSharedAudioTags: 0,\n      initiallyMuted: true,\n      logLevel,\n      audioLatencyHint: \"playback\",\n      children: /* @__PURE__ */ (0,jsx_runtime.jsx)(ThumbnailEmitterContext.Provider, {\n        value: emitter,\n        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(ThumbnailUI_default, {\n          ref: rootRef,\n          className: className2,\n          errorFallback,\n          inputProps: passedInputProps,\n          renderLoading,\n          style: style2,\n          overflowVisible,\n          overrideInternalClassName,\n          noSuspense: Boolean(noSuspense)\n        })\n      })\n    })\n  });\n};\nvar forward2 = react.forwardRef;\nvar Thumbnail = forward2(ThumbnailFn);\n\n// src/index.ts\nvar PlayerInternals = {\n  PlayerEventEmitterContext,\n  PlayerEmitter,\n  usePlayer,\n  usePlayback,\n  useElementSize,\n  calculateCanvasTransformation,\n  useHoverState,\n  updateAllElementsSizes,\n  PlayerEmitterProvider,\n  BufferingIndicator,\n  useFrameImperative\n};\n\n\n// EXTERNAL MODULE: ./node_modules/@remotion/media-utils/dist/index.js\nvar dist = __webpack_require__(6996);\n// EXTERNAL MODULE: ./node_modules/@remotion/studio-shared/dist/index.js\nvar studio_shared_dist = __webpack_require__(6588);\n// EXTERNAL MODULE: ./node_modules/@remotion/studio/node_modules/source-map/source-map.js\nvar source_map = __webpack_require__(4531);\n// EXTERNAL MODULE: ./node_modules/react-dom/client.js\nvar client = __webpack_require__(5338);\n;// ./node_modules/@remotion/media-parser/dist/esm/index.mjs\n// src/aac-codecprivate.ts\nvar getSampleRateFromSampleFrequencyIndex = (samplingFrequencyIndex) => {\n  switch (samplingFrequencyIndex) {\n    case 0:\n      return 96000;\n    case 1:\n      return 88200;\n    case 2:\n      return 64000;\n    case 3:\n      return 48000;\n    case 4:\n      return 44100;\n    case 5:\n      return 32000;\n    case 6:\n      return 24000;\n    case 7:\n      return 22050;\n    case 8:\n      return 16000;\n    case 9:\n      return 12000;\n    case 10:\n      return 11025;\n    case 11:\n      return 8000;\n    case 12:\n      return 7350;\n    default:\n      throw new Error(`Unexpected sampling frequency index ${samplingFrequencyIndex}`);\n  }\n};\nvar getConfigForSampleRate = (sampleRate) => {\n  if (sampleRate === 96000) {\n    return 0;\n  }\n  if (sampleRate === 88200) {\n    return 1;\n  }\n  if (sampleRate === 64000) {\n    return 2;\n  }\n  if (sampleRate === 48000) {\n    return 3;\n  }\n  if (sampleRate === 44100) {\n    return 4;\n  }\n  if (sampleRate === 32000) {\n    return 5;\n  }\n  if (sampleRate === 24000) {\n    return 6;\n  }\n  if (sampleRate === 22050) {\n    return 7;\n  }\n  if (sampleRate === 16000) {\n    return 8;\n  }\n  if (sampleRate === 12000) {\n    return 9;\n  }\n  if (sampleRate === 11025) {\n    return 10;\n  }\n  if (sampleRate === 8000) {\n    return 11;\n  }\n  if (sampleRate === 7350) {\n    return 12;\n  }\n  throw new Error(`Unexpected sample rate ${sampleRate}`);\n};\nvar createAacCodecPrivate = ({\n  audioObjectType,\n  sampleRate,\n  channelConfiguration,\n  codecPrivate\n}) => {\n  if (codecPrivate !== null && codecPrivate.length > 2) {\n    return codecPrivate;\n  }\n  const bits = `${audioObjectType.toString(2).padStart(5, \"0\")}${getConfigForSampleRate(sampleRate).toString(2).padStart(4, \"0\")}${channelConfiguration.toString(2).padStart(4, \"0\")}000`;\n  if (bits.length !== 16) {\n    throw new Error(\"Invalid AAC codec private \" + bits.length);\n  }\n  if (channelConfiguration === 0 || channelConfiguration > 7) {\n    throw new Error(\"Invalid channel configuration \" + channelConfiguration);\n  }\n  const firstByte = parseInt(bits.slice(0, 8), 2);\n  const secondByte = parseInt(bits.slice(8, 16), 2);\n  return new Uint8Array([firstByte, secondByte]);\n};\nvar parseAacCodecPrivate = (bytes) => {\n  if (bytes.length < 2) {\n    throw new Error(\"Invalid AAC codec private length\");\n  }\n  const bits = [...bytes].map((b) => b.toString(2).padStart(8, \"0\")).join(\"\");\n  let offset = 0;\n  const audioObjectType = parseInt(bits.slice(offset, offset + 5), 2);\n  offset += 5;\n  const samplingFrequencyIndex = parseInt(bits.slice(offset, offset + 4), 2);\n  offset += 4;\n  if (samplingFrequencyIndex === 15) {\n    offset += 24;\n  }\n  const channelConfiguration = parseInt(bits.slice(offset, offset + 4), 2);\n  offset += 4;\n  if (audioObjectType === 5) {\n    const extensionSamplingFrequencyIndex = parseInt(bits.slice(offset, offset + 4), 2);\n    offset += 4;\n    const newAudioObjectType = parseInt(bits.slice(offset, offset + 5), 2);\n    offset += 5;\n    return {\n      audioObjectType: newAudioObjectType,\n      sampleRate: getSampleRateFromSampleFrequencyIndex(extensionSamplingFrequencyIndex),\n      channelConfiguration\n    };\n  }\n  const sampleRate = getSampleRateFromSampleFrequencyIndex(samplingFrequencyIndex);\n  return {\n    audioObjectType,\n    sampleRate,\n    channelConfiguration\n  };\n};\nvar mapAudioObjectTypeToCodecString = (audioObjectType) => {\n  switch (audioObjectType) {\n    case 1:\n      return \"mp4a.40.2\";\n    case 2:\n      return \"mp4a.40.5\";\n    case 3:\n      return \"mp4a.40.29\";\n    case 4:\n      return \"mp4a.40.1\";\n    case 5:\n      return \"mp4a.40.3\";\n    case 6:\n      return \"mp4a.40.4\";\n    case 17:\n      return \"mp4a.40.17\";\n    case 23:\n      return \"mp4a.40.23\";\n    default:\n      throw new Error(`Unexpected audio object type ${audioObjectType}`);\n  }\n};\n\n// src/containers/iso-base-media/ftyp.ts\nvar parseFtyp = ({\n  iterator,\n  size,\n  offset\n}) => {\n  const majorBrand = iterator.getByteString(4, false);\n  const minorVersion = iterator.getFourByteNumber();\n  const types = (size - iterator.counter.getOffset()) / 4;\n  const compatibleBrands = [];\n  for (let i = 0;i < types; i++) {\n    compatibleBrands.push(iterator.getByteString(4, false).trim());\n  }\n  const offsetAtEnd = iterator.counter.getOffset();\n  return {\n    type: \"ftyp-box\",\n    majorBrand,\n    minorVersion,\n    compatibleBrands,\n    offset,\n    boxSize: offsetAtEnd - offset\n  };\n};\n\n// src/containers/webm/segments/all-segments.ts\nvar matroskaElements = {\n  Header: \"0x1a45dfa3\",\n  EBMLMaxIDLength: \"0x42f2\",\n  EBMLVersion: \"0x4286\",\n  EBMLReadVersion: \"0x42f7\",\n  EBMLMaxSizeLength: \"0x42f3\",\n  DocType: \"0x4282\",\n  DocTypeVersion: \"0x4287\",\n  DocTypeReadVersion: \"0x4285\",\n  Segment: \"0x18538067\",\n  SeekHead: \"0x114d9b74\",\n  Seek: \"0x4dbb\",\n  SeekID: \"0x53ab\",\n  SeekPosition: \"0x53ac\",\n  Info: \"0x1549a966\",\n  SegmentUUID: \"0x73a4\",\n  SegmentFilename: \"0x7384\",\n  PrevUUID: \"0x3cb923\",\n  PrevFilename: \"0x3c83ab\",\n  NextUUID: \"0x3eb923\",\n  NextFilename: \"0x3e83bb\",\n  SegmentFamily: \"0x4444\",\n  ChapterTranslate: \"0x6924\",\n  ChapterTranslateID: \"0x69a5\",\n  ChapterTranslateCodec: \"0x69bf\",\n  ChapterTranslateEditionUID: \"0x69fc\",\n  TimestampScale: \"0x2ad7b1\",\n  Duration: \"0x4489\",\n  DateUTC: \"0x4461\",\n  Title: \"0x7ba9\",\n  MuxingApp: \"0x4d80\",\n  WritingApp: \"0x5741\",\n  Cluster: \"0x1f43b675\",\n  Timestamp: \"0xe7\",\n  SilentTracks: \"0x5854\",\n  SilentTrackNumber: \"0x58d7\",\n  Position: \"0xa7\",\n  PrevSize: \"0xab\",\n  SimpleBlock: \"0xa3\",\n  BlockGroup: \"0xa0\",\n  Block: \"0xa1\",\n  BlockVirtual: \"0xa2\",\n  BlockAdditions: \"0x75a1\",\n  BlockMore: \"0xa6\",\n  BlockAdditional: \"0xa5\",\n  BlockAddID: \"0xee\",\n  BlockDuration: \"0x9b\",\n  ReferencePriority: \"0xfa\",\n  ReferenceBlock: \"0xfb\",\n  ReferenceVirtual: \"0xfd\",\n  CodecState: \"0xa4\",\n  DiscardPadding: \"0x75a2\",\n  Slices: \"0x8e\",\n  TimeSlice: \"0xe8\",\n  LaceNumber: \"0xcc\",\n  FrameNumber: \"0xcd\",\n  BlockAdditionID: \"0xcb\",\n  Delay: \"0xce\",\n  SliceDuration: \"0xcf\",\n  ReferenceFrame: \"0xc8\",\n  ReferenceOffset: \"0xc9\",\n  ReferenceTimestamp: \"0xca\",\n  EncryptedBlock: \"0xaf\",\n  Tracks: \"0x1654ae6b\",\n  TrackEntry: \"0xae\",\n  TrackNumber: \"0xd7\",\n  TrackUID: \"0x73c5\",\n  TrackType: \"0x83\",\n  FlagEnabled: \"0xb9\",\n  FlagDefault: \"0x88\",\n  FlagForced: \"0x55aa\",\n  FlagHearingImpaired: \"0x55ab\",\n  FlagVisualImpaired: \"0x55ac\",\n  FlagTextDescriptions: \"0x55ad\",\n  FlagOriginal: \"0x55ae\",\n  FlagCommentary: \"0x55af\",\n  FlagLacing: \"0x9c\",\n  MinCache: \"0x6de7\",\n  MaxCache: \"0x6df8\",\n  DefaultDuration: \"0x23e383\",\n  DefaultDecodedFieldDuration: \"0x234e7a\",\n  TrackTimestampScale: \"0x23314f\",\n  TrackOffset: \"0x537f\",\n  MaxBlockAdditionID: \"0x55ee\",\n  BlockAdditionMapping: \"0x41e4\",\n  BlockAddIDValue: \"0x41f0\",\n  BlockAddIDName: \"0x41a4\",\n  BlockAddIDType: \"0x41e7\",\n  BlockAddIDExtraData: \"0x41ed\",\n  Name: \"0x536e\",\n  Language: \"0x22b59c\",\n  LanguageBCP47: \"0x22b59d\",\n  CodecID: \"0x86\",\n  CodecPrivate: \"0x63a2\",\n  CodecName: \"0x258688\",\n  AttachmentLink: \"0x7446\",\n  CodecSettings: \"0x3a9697\",\n  CodecInfoURL: \"0x3b4040\",\n  CodecDownloadURL: \"0x26b240\",\n  CodecDecodeAll: \"0xaa\",\n  TrackOverlay: \"0x6fab\",\n  CodecDelay: \"0x56aa\",\n  SeekPreRoll: \"0x56bb\",\n  TrackTranslate: \"0x6624\",\n  TrackTranslateTrackID: \"0x66a5\",\n  TrackTranslateCodec: \"0x66bf\",\n  TrackTranslateEditionUID: \"0x66fc\",\n  Video: \"0xe0\",\n  FlagInterlaced: \"0x9a\",\n  FieldOrder: \"0x9d\",\n  StereoMode: \"0x53b8\",\n  AlphaMode: \"0x53c0\",\n  OldStereoMode: \"0x53b9\",\n  PixelWidth: \"0xb0\",\n  PixelHeight: \"0xba\",\n  PixelCropBottom: \"0x54aa\",\n  PixelCropTop: \"0x54bb\",\n  PixelCropLeft: \"0x54cc\",\n  PixelCropRight: \"0x54dd\",\n  DisplayWidth: \"0x54b0\",\n  DisplayHeight: \"0x54ba\",\n  DisplayUnit: \"0x54b2\",\n  AspectRatioType: \"0x54b3\",\n  UncompressedFourCC: \"0x2eb524\",\n  GammaValue: \"0x2fb523\",\n  FrameRate: \"0x2383e3\",\n  Colour: \"0x55b0\",\n  MatrixCoefficients: \"0x55b1\",\n  BitsPerChannel: \"0x55b2\",\n  ChromaSubsamplingHorz: \"0x55b3\",\n  ChromaSubsamplingVert: \"0x55b4\",\n  CbSubsamplingHorz: \"0x55b5\",\n  CbSubsamplingVert: \"0x55b6\",\n  ChromaSitingHorz: \"0x55b7\",\n  ChromaSitingVert: \"0x55b8\",\n  Range: \"0x55b9\",\n  TransferCharacteristics: \"0x55ba\",\n  Primaries: \"0x55bb\",\n  MaxCLL: \"0x55bc\",\n  MaxFALL: \"0x55bd\",\n  MasteringMetadata: \"0x55d0\",\n  PrimaryRChromaticityX: \"0x55d1\",\n  PrimaryRChromaticityY: \"0x55d2\",\n  PrimaryGChromaticityX: \"0x55d3\",\n  PrimaryGChromaticityY: \"0x55d4\",\n  PrimaryBChromaticityX: \"0x55d5\",\n  PrimaryBChromaticityY: \"0x55d6\",\n  WhitePointChromaticityX: \"0x55d7\",\n  WhitePointChromaticityY: \"0x55d8\",\n  LuminanceMax: \"0x55d9\",\n  LuminanceMin: \"0x55da\",\n  Projection: \"0x7670\",\n  ProjectionType: \"0x7671\",\n  ProjectionPrivate: \"0x7672\",\n  ProjectionPoseYaw: \"0x7673\",\n  ProjectionPosePitch: \"0x7674\",\n  ProjectionPoseRoll: \"0x7675\",\n  Audio: \"0xe1\",\n  SamplingFrequency: \"0xb5\",\n  OutputSamplingFrequency: \"0x78b5\",\n  Channels: \"0x9f\",\n  ChannelPositions: \"0x7d7b\",\n  BitDepth: \"0x6264\",\n  Emphasis: \"0x52f1\",\n  TrackOperation: \"0xe2\",\n  TrackCombinePlanes: \"0xe3\",\n  TrackPlane: \"0xe4\",\n  TrackPlaneUID: \"0xe5\",\n  TrackPlaneType: \"0xe6\",\n  TrackJoinBlocks: \"0xe9\",\n  TrackJoinUID: \"0xed\",\n  TrickTrackUID: \"0xc0\",\n  TrickTrackSegmentUID: \"0xc1\",\n  TrickTrackFlag: \"0xc6\",\n  TrickMasterTrackUID: \"0xc7\",\n  TrickMasterTrackSegmentUID: \"0xc4\",\n  ContentEncodings: \"0x6d80\",\n  ContentEncoding: \"0x6240\",\n  ContentEncodingOrder: \"0x5031\",\n  ContentEncodingScope: \"0x5032\",\n  ContentEncodingType: \"0x5033\",\n  ContentCompression: \"0x5034\",\n  ContentCompAlgo: \"0x4254\",\n  ContentCompSettings: \"0x4255\",\n  ContentEncryption: \"0x5035\",\n  ContentEncAlgo: \"0x47e1\",\n  ContentEncKeyID: \"0x47e2\",\n  ContentEncAESSettings: \"0x47e7\",\n  AESSettingsCipherMode: \"0x47e8\",\n  ContentSignature: \"0x47e3\",\n  ContentSigKeyID: \"0x47e4\",\n  ContentSigAlgo: \"0x47e5\",\n  ContentSigHashAlgo: \"0x47e6\",\n  Cues: \"0x1c53bb6b\",\n  CuePoint: \"0xbb\",\n  CueTime: \"0xb3\",\n  CueTrackPositions: \"0xb7\",\n  CueTrack: \"0xf7\",\n  CueClusterPosition: \"0xf1\",\n  CueRelativePosition: \"0xf0\",\n  CueDuration: \"0xb2\",\n  CueBlockNumber: \"0x5378\",\n  CueCodecState: \"0xea\",\n  CueReference: \"0xdb\",\n  CueRefTime: \"0x96\",\n  CueRefCluster: \"0x97\",\n  CueRefNumber: \"0x535f\",\n  CueRefCodecState: \"0xeb\",\n  Attachments: \"0x1941a469\",\n  AttachedFile: \"0x61a7\",\n  FileDescription: \"0x467e\",\n  FileName: \"0x466e\",\n  FileMediaType: \"0x4660\",\n  FileData: \"0x465c\",\n  FileUID: \"0x46ae\",\n  FileReferral: \"0x4675\",\n  FileUsedStartTime: \"0x4661\",\n  FileUsedEndTime: \"0x4662\",\n  Chapters: \"0x1043a770\",\n  EditionEntry: \"0x45b9\",\n  EditionUID: \"0x45bc\",\n  EditionFlagHidden: \"0x45bd\",\n  EditionFlagDefault: \"0x45db\",\n  EditionFlagOrdered: \"0x45dd\",\n  EditionDisplay: \"0x4520\",\n  EditionString: \"0x4521\",\n  EditionLanguageIETF: \"0x45e4\",\n  ChapterAtom: \"0xb6\",\n  ChapterUID: \"0x73c4\",\n  ChapterStringUID: \"0x5654\",\n  ChapterTimeStart: \"0x91\",\n  ChapterTimeEnd: \"0x92\",\n  ChapterFlagHidden: \"0x98\",\n  ChapterFlagEnabled: \"0x4598\",\n  ChapterSegmentUUID: \"0x6e67\",\n  ChapterSkipType: \"0x4588\",\n  ChapterSegmentEditionUID: \"0x6ebc\",\n  ChapterPhysicalEquiv: \"0x63c3\",\n  ChapterTrack: \"0x8f\",\n  ChapterTrackUID: \"0x89\",\n  ChapterDisplay: \"0x80\",\n  ChapString: \"0x85\",\n  ChapLanguage: \"0x437c\",\n  ChapLanguageBCP47: \"0x437d\",\n  ChapCountry: \"0x437e\",\n  ChapProcess: \"0x6944\",\n  ChapProcessCodecID: \"0x6955\",\n  ChapProcessPrivate: \"0x450d\",\n  ChapProcessCommand: \"0x6911\",\n  ChapProcessTime: \"0x6922\",\n  ChapProcessData: \"0x6933\",\n  Tags: \"0x1254c367\",\n  Tag: \"0x7373\",\n  Targets: \"0x63c0\",\n  TargetTypeValue: \"0x68ca\",\n  TargetType: \"0x63ca\",\n  TagTrackUID: \"0x63c5\",\n  TagEditionUID: \"0x63c9\",\n  TagChapterUID: \"0x63c4\",\n  TagAttachmentUID: \"0x63c6\",\n  SimpleTag: \"0x67c8\",\n  TagName: \"0x45a3\",\n  TagLanguage: \"0x447a\",\n  TagLanguageBCP47: \"0x447b\",\n  TagDefault: \"0x4484\",\n  TagDefaultBogus: \"0x44b4\",\n  TagString: \"0x4487\",\n  TagBinary: \"0x4485\",\n  Void: \"0xec\",\n  Crc32: \"0xbf\"\n};\nvar matroskaIds = Object.values(matroskaElements);\nvar knownIdsWithOneLength = matroskaIds.filter((id) => id.length === 4);\nvar knownIdsWithTwoLength = matroskaIds.filter((id) => id.length === 6);\nvar knownIdsWithThreeLength = matroskaIds.filter((id) => id.length === 8);\nvar ebmlVersion = {\n  name: \"EBMLVersion\",\n  type: \"uint\"\n};\nvar ebmlReadVersion = {\n  name: \"EBMLReadVersion\",\n  type: \"uint\"\n};\nvar ebmlMaxIdLength = {\n  name: \"EBMLMaxIDLength\",\n  type: \"uint\"\n};\nvar ebmlMaxSizeLength = {\n  name: \"EBMLMaxSizeLength\",\n  type: \"uint\"\n};\nvar docType = {\n  name: \"DocType\",\n  type: \"string\"\n};\nvar docTypeVersion = {\n  name: \"DocTypeVersion\",\n  type: \"uint\"\n};\nvar docTypeReadVersion = {\n  name: \"DocTypeReadVersion\",\n  type: \"uint\"\n};\nvar voidEbml = {\n  name: \"Void\",\n  type: \"uint8array\"\n};\nvar matroskaHeader = {\n  name: \"Header\",\n  type: \"children\"\n};\nvar seekId = {\n  name: \"SeekID\",\n  type: \"hex-string\"\n};\nvar _name = {\n  name: \"Name\",\n  type: \"string\"\n};\nvar minCache = {\n  name: \"MinCache\",\n  type: \"uint\"\n};\nvar maxCache = {\n  name: \"MaxCache\",\n  type: \"uint\"\n};\nvar seekPosition = {\n  name: \"SeekPosition\",\n  type: \"uint\"\n};\nvar seek = {\n  name: \"Seek\",\n  type: \"children\"\n};\nvar seekHead = {\n  name: \"SeekHead\",\n  type: \"children\"\n};\nvar trackType = {\n  name: \"TrackType\",\n  type: \"uint\"\n};\nvar widthType = {\n  name: \"PixelWidth\",\n  type: \"uint\"\n};\nvar heightType = {\n  name: \"PixelHeight\",\n  type: \"uint\"\n};\nvar muxingApp = {\n  name: \"MuxingApp\",\n  type: \"string\"\n};\nvar duration = {\n  name: \"Duration\",\n  type: \"float\"\n};\nvar timestampScale = {\n  name: \"TimestampScale\",\n  type: \"uint\"\n};\nvar infoType = {\n  name: \"Info\",\n  type: \"children\"\n};\nvar titleType = {\n  name: \"Title\",\n  type: \"string\"\n};\nvar tagTrackUidType = {\n  name: \"TagTrackUID\",\n  type: \"hex-string\"\n};\nvar samplingFrequency = {\n  name: \"SamplingFrequency\",\n  type: \"float\"\n};\nvar channels = {\n  name: \"Channels\",\n  type: \"uint\"\n};\nvar alphaMode = {\n  name: \"AlphaMode\",\n  type: \"uint\"\n};\nvar interlaced = {\n  name: \"FlagInterlaced\",\n  type: \"uint\"\n};\nvar bitDepth = {\n  name: \"BitDepth\",\n  type: \"uint\"\n};\nvar displayWidth = {\n  name: \"DisplayWidth\",\n  type: \"uint\"\n};\nvar displayHeight = {\n  name: \"DisplayHeight\",\n  type: \"uint\"\n};\nvar displayUnit = {\n  name: \"DisplayUnit\",\n  type: \"uint\"\n};\nvar flagLacing = {\n  name: \"FlagLacing\",\n  type: \"uint\"\n};\nvar tagSegment = {\n  name: \"Tag\",\n  type: \"children\"\n};\nvar tags = {\n  name: \"Tags\",\n  type: \"children\"\n};\nvar trackNumber = {\n  name: \"TrackNumber\",\n  type: \"uint\"\n};\nvar trackUID = {\n  name: \"TrackUID\",\n  type: \"hex-string\"\n};\nvar color = {\n  name: \"Colour\",\n  type: \"children\"\n};\nvar transferCharacteristics = {\n  name: \"TransferCharacteristics\",\n  type: \"uint\"\n};\nvar matrixCoefficients = {\n  name: \"MatrixCoefficients\",\n  type: \"uint\"\n};\nvar primaries = {\n  name: \"Primaries\",\n  type: \"uint\"\n};\nvar range = {\n  name: \"Range\",\n  type: \"uint\"\n};\nvar ChromaSitingHorz = {\n  name: \"ChromaSitingHorz\",\n  type: \"uint\"\n};\nvar ChromaSitingVert = {\n  name: \"ChromaSitingVert\",\n  type: \"uint\"\n};\nvar language = {\n  name: \"Language\",\n  type: \"string\"\n};\nvar defaultDuration = {\n  name: \"DefaultDuration\",\n  type: \"uint\"\n};\nvar codecPrivate = {\n  name: \"CodecPrivate\",\n  type: \"uint8array\"\n};\nvar blockAdditionsSegment = {\n  name: \"BlockAdditions\",\n  type: \"uint8array\"\n};\nvar maxBlockAdditionIdSegment = {\n  name: \"MaxBlockAdditionID\",\n  type: \"uint\"\n};\nvar audioSegment = {\n  name: \"Audio\",\n  type: \"children\"\n};\nvar videoSegment = {\n  name: \"Video\",\n  type: \"children\"\n};\nvar flagDefault = {\n  name: \"FlagDefault\",\n  type: \"uint\"\n};\nvar referenceBlock = {\n  name: \"ReferenceBlock\",\n  type: \"uint\"\n};\nvar blockDurationSegment = {\n  name: \"BlockDuration\",\n  type: \"uint\"\n};\nvar codecName = {\n  name: \"CodecName\",\n  type: \"string\"\n};\nvar trackTimestampScale = {\n  name: \"TrackTimestampScale\",\n  type: \"float\"\n};\nvar trackEntry = {\n  name: \"TrackEntry\",\n  type: \"children\"\n};\nvar tracks = {\n  name: \"Tracks\",\n  type: \"children\"\n};\nvar block = {\n  name: \"Block\",\n  type: \"uint8array\"\n};\nvar simpleBlock = {\n  name: \"SimpleBlock\",\n  type: \"uint8array\"\n};\nvar blockGroup = {\n  name: \"BlockGroup\",\n  type: \"children\"\n};\nvar targetsType = {\n  name: \"Targets\",\n  type: \"children\"\n};\nvar simpleTagType = {\n  name: \"SimpleTag\",\n  type: \"children\"\n};\nvar tagNameType = {\n  name: \"TagName\",\n  type: \"string\"\n};\nvar tagStringType = {\n  name: \"TagString\",\n  type: \"string\"\n};\nvar ebmlMap = {\n  [matroskaElements.Header]: matroskaHeader,\n  [matroskaElements.DocType]: docType,\n  [matroskaElements.Targets]: targetsType,\n  [matroskaElements.SimpleTag]: simpleTagType,\n  [matroskaElements.TagName]: tagNameType,\n  [matroskaElements.TagString]: tagStringType,\n  [matroskaElements.DocTypeVersion]: docTypeVersion,\n  [matroskaElements.DocTypeReadVersion]: docTypeReadVersion,\n  [matroskaElements.EBMLVersion]: ebmlVersion,\n  [matroskaElements.EBMLReadVersion]: ebmlReadVersion,\n  [matroskaElements.EBMLMaxIDLength]: ebmlMaxIdLength,\n  [matroskaElements.EBMLMaxSizeLength]: ebmlMaxSizeLength,\n  [matroskaElements.Void]: voidEbml,\n  [matroskaElements.Cues]: {\n    name: \"Cues\",\n    type: \"children\"\n  },\n  [matroskaElements.CuePoint]: {\n    name: \"CuePoint\",\n    type: \"children\"\n  },\n  [matroskaElements.CueTime]: {\n    name: \"CueTime\",\n    type: \"uint\"\n  },\n  [matroskaElements.CueTrackPositions]: {\n    name: \"CueTrackPositions\",\n    type: \"children\"\n  },\n  [matroskaElements.CueClusterPosition]: {\n    name: \"CueClusterPosition\",\n    type: \"uint\"\n  },\n  [matroskaElements.CueRelativePosition]: {\n    name: \"CueRelativePosition\",\n    type: \"uint\"\n  },\n  [matroskaElements.CueBlockNumber]: {\n    name: \"CueBlockNumber\",\n    type: \"uint\"\n  },\n  [matroskaElements.CueTrack]: {\n    name: \"CueTrack\",\n    type: \"uint\"\n  },\n  [matroskaElements.DateUTC]: {\n    name: \"DateUTC\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.TrackTimestampScale]: trackTimestampScale,\n  [matroskaElements.CodecDelay]: {\n    name: \"CodecDelay\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.SeekPreRoll]: {\n    name: \"SeekPreRoll\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.DiscardPadding]: {\n    name: \"DiscardPadding\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.OutputSamplingFrequency]: {\n    name: \"OutputSamplingFrequency\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.CodecName]: codecName,\n  [matroskaElements.Position]: {\n    name: \"Position\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.SliceDuration]: {\n    name: \"SliceDuration\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.TagTrackUID]: tagTrackUidType,\n  [matroskaElements.SeekHead]: seekHead,\n  [matroskaElements.Seek]: seek,\n  [matroskaElements.SeekID]: seekId,\n  [matroskaElements.Name]: _name,\n  [matroskaElements.MinCache]: minCache,\n  [matroskaElements.MaxCache]: maxCache,\n  [matroskaElements.SeekPosition]: seekPosition,\n  [matroskaElements.Crc32]: {\n    name: \"Crc32\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.MuxingApp]: muxingApp,\n  [matroskaElements.WritingApp]: {\n    name: \"WritingApp\",\n    type: \"string\"\n  },\n  [matroskaElements.SegmentUUID]: {\n    name: \"SegmentUUID\",\n    type: \"string\"\n  },\n  [matroskaElements.Duration]: duration,\n  [matroskaElements.CodecID]: {\n    name: \"CodecID\",\n    type: \"string\"\n  },\n  [matroskaElements.TrackType]: trackType,\n  [matroskaElements.PixelWidth]: widthType,\n  [matroskaElements.PixelHeight]: heightType,\n  [matroskaElements.TimestampScale]: timestampScale,\n  [matroskaElements.Info]: infoType,\n  [matroskaElements.Title]: titleType,\n  [matroskaElements.SamplingFrequency]: samplingFrequency,\n  [matroskaElements.Channels]: channels,\n  [matroskaElements.AlphaMode]: alphaMode,\n  [matroskaElements.FlagInterlaced]: interlaced,\n  [matroskaElements.BitDepth]: bitDepth,\n  [matroskaElements.DisplayHeight]: displayHeight,\n  [matroskaElements.DisplayWidth]: displayWidth,\n  [matroskaElements.DisplayUnit]: displayUnit,\n  [matroskaElements.FlagLacing]: flagLacing,\n  [matroskaElements.Tags]: tags,\n  [matroskaElements.Tag]: tagSegment,\n  [matroskaElements.TrackNumber]: trackNumber,\n  [matroskaElements.TrackUID]: trackUID,\n  [matroskaElements.Colour]: color,\n  [matroskaElements.Language]: language,\n  [matroskaElements.DefaultDuration]: defaultDuration,\n  [matroskaElements.CodecPrivate]: codecPrivate,\n  [matroskaElements.BlockDuration]: blockDurationSegment,\n  [matroskaElements.BlockAdditions]: blockAdditionsSegment,\n  [matroskaElements.MaxBlockAdditionID]: maxBlockAdditionIdSegment,\n  [matroskaElements.Audio]: audioSegment,\n  [matroskaElements.Video]: videoSegment,\n  [matroskaElements.FlagDefault]: flagDefault,\n  [matroskaElements.ReferenceBlock]: referenceBlock,\n  [matroskaElements.TrackEntry]: trackEntry,\n  [matroskaElements.Timestamp]: {\n    name: \"Timestamp\",\n    type: \"uint\"\n  },\n  [matroskaElements.Tracks]: tracks,\n  [matroskaElements.Block]: block,\n  [matroskaElements.SimpleBlock]: simpleBlock,\n  [matroskaElements.BlockGroup]: blockGroup,\n  [matroskaElements.Segment]: {\n    name: \"Segment\",\n    type: \"children\"\n  },\n  [matroskaElements.Cluster]: {\n    name: \"Cluster\",\n    type: \"children\"\n  },\n  [matroskaElements.TransferCharacteristics]: transferCharacteristics,\n  [matroskaElements.MatrixCoefficients]: matrixCoefficients,\n  [matroskaElements.Primaries]: primaries,\n  [matroskaElements.Range]: range,\n  [matroskaElements.ChromaSitingHorz]: ChromaSitingHorz,\n  [matroskaElements.ChromaSitingVert]: ChromaSitingVert\n};\n\n// src/file-types/detect-file-type.ts\nvar webmPattern = new Uint8Array([26, 69, 223, 163]);\nvar matchesPattern = (pattern) => {\n  return (data) => {\n    return pattern.every((value, index) => data[index] === value);\n  };\n};\nvar isRiffAvi = (data) => {\n  const riffPattern = new Uint8Array([82, 73, 70, 70]);\n  if (!matchesPattern(riffPattern)(data.subarray(0, 4))) {\n    return false;\n  }\n  const fileType = data.subarray(8, 12);\n  const aviPattern = new Uint8Array([65, 86, 73, 32]);\n  return matchesPattern(aviPattern)(fileType);\n};\nvar isRiffWave = (data) => {\n  const riffPattern = new Uint8Array([82, 73, 70, 70]);\n  if (!matchesPattern(riffPattern)(data.subarray(0, 4))) {\n    return false;\n  }\n  const fileType = data.subarray(8, 12);\n  const wavePattern = new Uint8Array([87, 65, 86, 69]);\n  return matchesPattern(wavePattern)(fileType);\n};\nvar isWebm = (data) => {\n  return matchesPattern(webmPattern)(data.subarray(0, 4));\n};\nvar isIsoBaseMedia = (data) => {\n  const isoBaseMediaMp4Pattern = new TextEncoder().encode(\"ftyp\");\n  return matchesPattern(isoBaseMediaMp4Pattern)(data.subarray(4, 8));\n};\nvar isTransportStream = (data) => {\n  return data[0] === 71 && data[188] === 71;\n};\nvar isMp3 = (data) => {\n  const mpegPattern = new Uint8Array([255, 243]);\n  const mpegPattern2 = new Uint8Array([255, 251]);\n  const id3v4Pattern = new Uint8Array([73, 68, 51, 4]);\n  const id3v3Pattern = new Uint8Array([73, 68, 51, 3]);\n  const id3v2Pattern = new Uint8Array([73, 68, 51, 2]);\n  const subarray = data.subarray(0, 4);\n  return matchesPattern(mpegPattern)(subarray) || matchesPattern(mpegPattern2)(subarray) || matchesPattern(id3v4Pattern)(subarray) || matchesPattern(id3v3Pattern)(subarray) || matchesPattern(id3v2Pattern)(subarray);\n};\nvar isAac = (data) => {\n  const aacPattern = new Uint8Array([255, 241]);\n  return matchesPattern(aacPattern)(data.subarray(0, 2));\n};\nvar isFlac = (data) => {\n  const flacPattern = new Uint8Array([102, 76, 97, 67]);\n  return matchesPattern(flacPattern)(data.subarray(0, 4));\n};\nvar isM3u = (data) => {\n  return new TextDecoder(\"utf-8\").decode(data.slice(0, 7)) === \"#EXTM3U\";\n};\n\n// src/file-types/bmp.ts\nfunction getBmpDimensions(bmpData) {\n  if (bmpData.length < 26) {\n    return null;\n  }\n  const view = new DataView(bmpData.buffer, bmpData.byteOffset);\n  return {\n    width: view.getUint32(18, true),\n    height: Math.abs(view.getInt32(22, true))\n  };\n}\nvar isBmp = (data) => {\n  const bmpPattern = new Uint8Array([66, 77]);\n  if (matchesPattern(bmpPattern)(data.subarray(0, 2))) {\n    const bmp = getBmpDimensions(data);\n    return { dimensions: bmp, type: \"bmp\" };\n  }\n  return null;\n};\n\n// src/file-types/gif.ts\nvar getGifDimensions = (data) => {\n  const view = new DataView(data.buffer, data.byteOffset);\n  const width = view.getUint16(6, true);\n  const height = view.getUint16(8, true);\n  return { width, height };\n};\nvar isGif = (data) => {\n  const gifPattern = new Uint8Array([71, 73, 70, 56]);\n  if (matchesPattern(gifPattern)(data.subarray(0, 4))) {\n    return { type: \"gif\", dimensions: getGifDimensions(data) };\n  }\n  return null;\n};\n\n// src/file-types/jpeg.ts\nfunction getJpegDimensions(data) {\n  let offset = 0;\n  function readUint16BE(o) {\n    return data[o] << 8 | data[o + 1];\n  }\n  if (readUint16BE(offset) !== 65496) {\n    return null;\n  }\n  offset += 2;\n  while (offset < data.length) {\n    if (data[offset] === 255) {\n      const marker = data[offset + 1];\n      if (marker === 192 || marker === 194) {\n        const height = readUint16BE(offset + 5);\n        const width = readUint16BE(offset + 7);\n        return { width, height };\n      }\n      const length = readUint16BE(offset + 2);\n      offset += length + 2;\n    } else {\n      offset++;\n    }\n  }\n  return null;\n}\nvar isJpeg = (data) => {\n  const jpegPattern = new Uint8Array([255, 216]);\n  const jpeg = matchesPattern(jpegPattern)(data.subarray(0, 2));\n  if (!jpeg) {\n    return null;\n  }\n  const dim = getJpegDimensions(data);\n  return { dimensions: dim, type: \"jpeg\" };\n};\n\n// src/file-types/pdf.ts\nvar isPdf = (data) => {\n  if (data.length < 4) {\n    return null;\n  }\n  const pdfPattern = new Uint8Array([37, 80, 68, 70]);\n  return matchesPattern(pdfPattern)(data.subarray(0, 4)) ? { type: \"pdf\" } : null;\n};\n\n// src/file-types/png.ts\nfunction getPngDimensions(pngData) {\n  if (pngData.length < 24) {\n    return null;\n  }\n  const view = new DataView(pngData.buffer, pngData.byteOffset);\n  const pngSignature = [137, 80, 78, 71, 13, 10, 26, 10];\n  for (let i = 0;i < 8; i++) {\n    if (pngData[i] !== pngSignature[i]) {\n      return null;\n    }\n  }\n  return {\n    width: view.getUint32(16, false),\n    height: view.getUint32(20, false)\n  };\n}\nvar isPng = (data) => {\n  const pngPattern = new Uint8Array([137, 80, 78, 71]);\n  if (matchesPattern(pngPattern)(data.subarray(0, 4))) {\n    const png = getPngDimensions(data);\n    return { dimensions: png, type: \"png\" };\n  }\n  return null;\n};\n\n// src/file-types/webp.ts\nfunction getWebPDimensions(bytes) {\n  if (bytes.length < 30) {\n    return null;\n  }\n  if (bytes[0] !== 82 || bytes[1] !== 73 || bytes[2] !== 70 || bytes[3] !== 70 || bytes[8] !== 87 || bytes[9] !== 69 || bytes[10] !== 66 || bytes[11] !== 80) {\n    return null;\n  }\n  if (bytes[12] === 86 && bytes[13] === 80 && bytes[14] === 56) {\n    if (bytes[15] === 32) {\n      return {\n        width: bytes[26] | bytes[27] << 8 & 16383,\n        height: bytes[28] | bytes[29] << 8 & 16383\n      };\n    }\n  }\n  if (bytes[12] === 86 && bytes[13] === 80 && bytes[14] === 56 && bytes[15] === 76) {\n    return {\n      width: 1 + (bytes[21] | (bytes[22] & 63) << 8),\n      height: 1 + ((bytes[22] & 192) >> 6 | bytes[23] << 2 | (bytes[24] & 15) << 10)\n    };\n  }\n  if (bytes[12] === 86 && bytes[13] === 80 && bytes[14] === 56 && bytes[15] === 88) {\n    return {\n      width: 1 + (bytes[24] | bytes[25] << 8 | bytes[26] << 16),\n      height: 1 + (bytes[27] | bytes[28] << 8 | bytes[29] << 16)\n    };\n  }\n  return null;\n}\nvar isWebp = (data) => {\n  const webpPattern = new Uint8Array([82, 73, 70, 70]);\n  if (matchesPattern(webpPattern)(data.subarray(0, 4))) {\n    return {\n      type: \"webp\",\n      dimensions: getWebPDimensions(data)\n    };\n  }\n  return null;\n};\n\n// src/file-types/index.ts\nvar detectFileType = (data) => {\n  if (isRiffWave(data)) {\n    return { type: \"wav\" };\n  }\n  if (isRiffAvi(data)) {\n    return { type: \"riff\" };\n  }\n  if (isAac(data)) {\n    return { type: \"aac\" };\n  }\n  if (isFlac(data)) {\n    return { type: \"flac\" };\n  }\n  if (isM3u(data)) {\n    return { type: \"m3u\" };\n  }\n  const webp = isWebp(data);\n  if (webp) {\n    return webp;\n  }\n  if (isWebm(data)) {\n    return { type: \"webm\" };\n  }\n  if (isIsoBaseMedia(data)) {\n    return { type: \"iso-base-media\" };\n  }\n  if (isTransportStream(data)) {\n    return { type: \"transport-stream\" };\n  }\n  if (isMp3(data)) {\n    return { type: \"mp3\" };\n  }\n  const gif = isGif(data);\n  if (gif) {\n    return gif;\n  }\n  const png = isPng(data);\n  if (png) {\n    return png;\n  }\n  const pdf = isPdf(data);\n  if (pdf) {\n    return pdf;\n  }\n  const bmp = isBmp(data);\n  if (bmp) {\n    return bmp;\n  }\n  const jpeg = isJpeg(data);\n  if (jpeg) {\n    return jpeg;\n  }\n  return { type: \"unknown\" };\n};\n\n// src/log.ts\nvar logLevels = [\"trace\", \"verbose\", \"info\", \"warn\", \"error\"];\nvar getNumberForLogLevel = (level) => {\n  return logLevels.indexOf(level);\n};\nvar isEqualOrBelowLogLevel = (currentLevel, level) => {\n  return getNumberForLogLevel(currentLevel) <= getNumberForLogLevel(level);\n};\nvar Log = {\n  trace: (logLevel, ...args) => {\n    if (isEqualOrBelowLogLevel(logLevel, \"trace\")) {\n      return console.log(...args);\n    }\n  },\n  verbose: (logLevel, ...args) => {\n    if (isEqualOrBelowLogLevel(logLevel, \"verbose\")) {\n      return console.log(...args);\n    }\n  },\n  info: (logLevel, ...args) => {\n    if (isEqualOrBelowLogLevel(logLevel, \"info\")) {\n      return console.log(...args);\n    }\n  },\n  warn: (logLevel, ...args) => {\n    if (isEqualOrBelowLogLevel(logLevel, \"warn\")) {\n      return console.warn(...args);\n    }\n  },\n  error: (...args) => {\n    return console.error(...args);\n  }\n};\n\n// src/iterator/polyfilled-arraybuffer.ts\nclass ResizableBuffer {\n  buffer;\n  uintarray;\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.uintarray = new Uint8Array(buffer);\n  }\n  resize(newLength) {\n    if (typeof this.buffer.resize === \"function\") {\n      this.buffer.resize(newLength);\n    } else {\n      const newBuffer = new ArrayBuffer(newLength);\n      new Uint8Array(newBuffer).set(new Uint8Array(this.buffer).subarray(0, Math.min(this.buffer.byteLength, newLength)));\n      this.buffer = newBuffer;\n      this.uintarray = new Uint8Array(newBuffer);\n    }\n  }\n}\n\n// src/iterator/buffer-manager.ts\nvar makeBufferWithMaxBytes = (initialData, maxBytes) => {\n  const maxByteLength = Math.min(maxBytes, 2 ** 31);\n  try {\n    const buf = new ArrayBuffer(initialData.byteLength, {\n      maxByteLength\n    });\n    return new ResizableBuffer(buf);\n  } catch (e) {\n    if (e instanceof RangeError && maxBytes > 2 ** 27) {\n      return new ResizableBuffer(new ArrayBuffer(initialData.byteLength, {\n        maxByteLength: 2 ** 27\n      }));\n    }\n    throw e;\n  }\n};\nvar bufferManager = ({\n  initialData,\n  maxBytes,\n  counter,\n  logLevel\n}) => {\n  const buf = makeBufferWithMaxBytes(initialData, maxBytes);\n  if (!buf.buffer.resize) {\n    Log.warn(logLevel, \"`ArrayBuffer.resize` is not supported in this Runtime. Using slow polyfill.\");\n  }\n  buf.uintarray.set(initialData);\n  let view = new DataView(buf.uintarray.buffer);\n  const destroy = () => {\n    buf.uintarray = new Uint8Array(0);\n    buf.resize(0);\n  };\n  const flushBytesRead = (force, mode) => {\n    const bytesToRemove = counter.getDiscardedOffset();\n    if (bytesToRemove < 3000000 && !force) {\n      return { bytesRemoved: 0, removedData: null };\n    }\n    if (view.byteLength < bytesToRemove && !force) {\n      return { bytesRemoved: 0, removedData: null };\n    }\n    counter.discardBytes(bytesToRemove);\n    const removedData = mode === \"download\" ? buf.uintarray.slice(0, bytesToRemove) : null;\n    const newData = buf.uintarray.slice(bytesToRemove);\n    buf.uintarray.set(newData);\n    buf.resize(newData.byteLength);\n    view = new DataView(buf.uintarray.buffer);\n    return { bytesRemoved: bytesToRemove, removedData };\n  };\n  const skipTo = (offset) => {\n    const becomesSmaller = offset < counter.getOffset();\n    if (becomesSmaller) {\n      const toDecrement = counter.getOffset() - offset;\n      if (toDecrement > counter.getDiscardedOffset()) {\n        throw new Error(\"Cannot count backwards, data has already been flushed\");\n      }\n      counter.decrement(toDecrement);\n    }\n    const currentOffset = counter.getOffset();\n    counter.increment(offset - currentOffset);\n  };\n  const addData = (newData) => {\n    const oldLength = buf.buffer.byteLength;\n    const newLength = oldLength + newData.byteLength;\n    if (newLength < oldLength) {\n      throw new Error(\"Cannot decrement size\");\n    }\n    if (newLength > (maxBytes ?? Infinity)) {\n      throw new Error(`Exceeded maximum byte length ${maxBytes} with ${newLength}`);\n    }\n    buf.resize(newLength);\n    buf.uintarray = new Uint8Array(buf.buffer);\n    buf.uintarray.set(newData, oldLength);\n    view = new DataView(buf.uintarray.buffer);\n  };\n  const replaceData = (newData, seekTo) => {\n    buf.resize(newData.byteLength);\n    buf.uintarray = new Uint8Array(buf.buffer);\n    buf.uintarray.set(newData);\n    view = new DataView(buf.uintarray.buffer);\n    counter.setDiscardedOffset(seekTo);\n    counter.decrement(counter.getOffset());\n    counter.increment(seekTo);\n  };\n  return {\n    getView: () => view,\n    getUint8Array: () => buf.uintarray,\n    destroy,\n    addData,\n    skipTo,\n    removeBytesRead: flushBytesRead,\n    replaceData\n  };\n};\n\n// src/iterator/offset-counter.ts\nvar makeOffsetCounter = (initial) => {\n  let offset = initial;\n  let discardedBytes = 0;\n  return {\n    getOffset: () => offset,\n    discardBytes: (bytes) => {\n      discardedBytes += bytes;\n    },\n    increment: (bytes) => {\n      if (bytes < 0) {\n        throw new Error(\"Cannot increment by a negative amount: \" + bytes);\n      }\n      offset += bytes;\n    },\n    getDiscardedBytes: () => discardedBytes,\n    setDiscardedOffset: (bytes) => {\n      discardedBytes = bytes;\n    },\n    getDiscardedOffset: () => offset - discardedBytes,\n    decrement: (bytes) => {\n      if (bytes < 0) {\n        throw new Error(\"Cannot decrement by a negative amount: \" + bytes);\n      }\n      offset -= bytes;\n    }\n  };\n};\n\n// src/iterator/buffer-iterator.ts\nvar getArrayBufferIterator = ({\n  initialData,\n  maxBytes,\n  logLevel\n}) => {\n  const counter = makeOffsetCounter(0);\n  const {\n    getUint8Array,\n    getView,\n    addData,\n    destroy,\n    removeBytesRead,\n    skipTo,\n    replaceData\n  } = bufferManager({ initialData, maxBytes, counter, logLevel });\n  const startCheckpoint = () => {\n    const checkpoint = counter.getOffset();\n    return {\n      returnToCheckpoint: () => {\n        counter.decrement(counter.getOffset() - checkpoint);\n      }\n    };\n  };\n  const getSlice = (amount) => {\n    const value = getUint8Array().slice(counter.getDiscardedOffset(), counter.getDiscardedOffset() + amount);\n    counter.increment(value.length);\n    return value;\n  };\n  const discard = (length) => {\n    counter.increment(length);\n  };\n  const readUntilNullTerminator = () => {\n    const bytes = [];\n    let byte;\n    while ((byte = getUint8()) !== 0) {\n      bytes.push(byte);\n    }\n    counter.decrement(1);\n    return new TextDecoder().decode(new Uint8Array(bytes));\n  };\n  const readUntilLineEnd = () => {\n    const bytes = [];\n    while (true) {\n      if (bytesRemaining() === 0) {\n        return null;\n      }\n      const byte = getUint8();\n      bytes.push(byte);\n      if (byte === 10) {\n        break;\n      }\n    }\n    const str = new TextDecoder().decode(new Uint8Array(bytes)).trim();\n    return str;\n  };\n  const getUint8 = () => {\n    const val = getView().getUint8(counter.getDiscardedOffset());\n    counter.increment(1);\n    return val;\n  };\n  const getEightByteNumber = (littleEndian = false) => {\n    if (littleEndian) {\n      const one = getUint8();\n      const two = getUint8();\n      const three = getUint8();\n      const four = getUint8();\n      const five = getUint8();\n      const six = getUint8();\n      const seven = getUint8();\n      const eight = getUint8();\n      return (eight << 56 | seven << 48 | six << 40 | five << 32 | four << 24 | three << 16 | two << 8 | one) >>> 0;\n    }\n    function byteArrayToBigInt(byteArray) {\n      let result = BigInt(0);\n      for (let i = 0;i < byteArray.length; i++) {\n        result = (result << BigInt(8)) + BigInt(byteArray[i]);\n      }\n      return result;\n    }\n    const bigInt = byteArrayToBigInt([\n      getUint8(),\n      getUint8(),\n      getUint8(),\n      getUint8(),\n      getUint8(),\n      getUint8(),\n      getUint8(),\n      getUint8()\n    ]);\n    return Number(bigInt);\n  };\n  const getFourByteNumber = () => {\n    const unsigned = getUint8() << 24 | getUint8() << 16 | getUint8() << 8 | getUint8();\n    return unsigned >>> 0;\n  };\n  const getPaddedFourByteNumber = () => {\n    let lastInt = 128;\n    while (lastInt = getUint8(), lastInt === 128) {}\n    return lastInt;\n  };\n  const getUint32 = () => {\n    const val = getView().getUint32(counter.getDiscardedOffset());\n    counter.increment(4);\n    return val;\n  };\n  const getSyncSafeInt32 = () => {\n    const val = getView().getUint32(counter.getDiscardedOffset());\n    counter.increment(4);\n    return (val & 2130706432) >> 3 | (val & 8323072) >> 2 | (val & 32512) >> 1 | val & 127;\n  };\n  const getUint64 = (littleEndian = false) => {\n    const val = getView().getBigUint64(counter.getDiscardedOffset(), littleEndian);\n    counter.increment(8);\n    return val;\n  };\n  const getInt64 = (littleEndian = false) => {\n    const val = getView().getBigInt64(counter.getDiscardedOffset(), littleEndian);\n    counter.increment(8);\n    return val;\n  };\n  const startBox = (size) => {\n    const startOffset = counter.getOffset();\n    return {\n      discardRest: () => discard(size - (counter.getOffset() - startOffset)),\n      expectNoMoreBytes: () => {\n        const remaining = size - (counter.getOffset() - startOffset);\n        if (remaining !== 0) {\n          throw new Error(\"expected 0 bytes, got \" + remaining);\n        }\n      }\n    };\n  };\n  const getUint32Le = () => {\n    const val = getView().getUint32(counter.getDiscardedOffset(), true);\n    counter.increment(4);\n    return val;\n  };\n  const getInt32Le = () => {\n    const val = getView().getInt32(counter.getDiscardedOffset(), true);\n    counter.increment(4);\n    return val;\n  };\n  const getInt32 = () => {\n    const val = getView().getInt32(counter.getDiscardedOffset());\n    counter.increment(4);\n    return val;\n  };\n  const bytesRemaining = () => {\n    return getUint8Array().byteLength - counter.getDiscardedOffset();\n  };\n  const readExpGolomb = () => {\n    if (!bitReadingMode) {\n      throw new Error(\"Not in bit reading mode\");\n    }\n    let zerosCount = 0;\n    while (getBits(1) === 0) {\n      zerosCount++;\n    }\n    let suffix = 0;\n    for (let i = 0;i < zerosCount; i++) {\n      suffix = suffix << 1 | getBits(1);\n    }\n    return (1 << zerosCount) - 1 + suffix;\n  };\n  const peekB = (length) => {\n    Log.info(\"info\", [...getSlice(length)].map((b) => b.toString(16).padStart(2, \"0\")));\n    counter.decrement(length);\n  };\n  const peekD = (length) => {\n    Log.info(\"info\", [...getSlice(length)].map((b) => b.toString(16).padStart(2, \"0\")));\n    counter.decrement(length);\n  };\n  const leb128 = () => {\n    let result = 0;\n    let shift = 0;\n    let byte;\n    do {\n      byte = getBits(8);\n      result |= (byte & 127) << shift;\n      shift += 7;\n    } while (byte >= 128);\n    return result;\n  };\n  let bitIndex = 0;\n  const stopReadingBits = () => {\n    bitIndex = 0;\n    bitReadingMode = false;\n  };\n  let byteToShift = 0;\n  let bitReadingMode = false;\n  const startReadingBits = () => {\n    bitReadingMode = true;\n    byteToShift = getUint8();\n  };\n  const getFlacCodecNumber = () => {\n    let ones = 0;\n    let bits = 0;\n    while ((++bits || true) && getBits(1) === 1) {\n      ones++;\n    }\n    if (ones === 0) {\n      return getBits(7);\n    }\n    const bitArray = [];\n    const firstByteBits = 8 - ones - 1;\n    for (let i = 0;i < firstByteBits; i++) {\n      bitArray.unshift(getBits(1));\n    }\n    const extraBytes = ones - 1;\n    for (let i = 0;i < extraBytes; i++) {\n      for (let j = 0;j < 8; j++) {\n        const val = getBits(1);\n        if (j < 2) {\n          continue;\n        }\n        bitArray.unshift(val);\n      }\n    }\n    const encoded = bitArray.reduce((acc, bit, index) => {\n      return acc | bit << index;\n    }, 0);\n    return encoded;\n  };\n  const getBits = (bits) => {\n    let result = 0;\n    let bitsCollected = 0;\n    while (bitsCollected < bits) {\n      if (bitIndex >= 8) {\n        bitIndex = 0;\n        byteToShift = getUint8();\n      }\n      const remainingBitsInByte = 8 - bitIndex;\n      const bitsToReadNow = Math.min(bits - bitsCollected, remainingBitsInByte);\n      const mask = (1 << bitsToReadNow) - 1;\n      const shift = remainingBitsInByte - bitsToReadNow;\n      result <<= bitsToReadNow;\n      result |= byteToShift >> shift & mask;\n      bitsCollected += bitsToReadNow;\n      bitIndex += bitsToReadNow;\n    }\n    return result;\n  };\n  return {\n    startReadingBits,\n    stopReadingBits,\n    skipTo,\n    addData,\n    counter,\n    peekB,\n    peekD,\n    getBits,\n    bytesRemaining,\n    leb128,\n    removeBytesRead,\n    discard,\n    getEightByteNumber,\n    getFourByteNumber,\n    getSlice,\n    getAtom: () => {\n      const atom = getSlice(4);\n      return new TextDecoder().decode(atom);\n    },\n    detectFileType: () => {\n      return detectFileType(getUint8Array());\n    },\n    getPaddedFourByteNumber,\n    getMatroskaSegmentId: () => {\n      if (bytesRemaining() === 0) {\n        return null;\n      }\n      const first = getSlice(1);\n      const firstOneString = `0x${Array.from(new Uint8Array(first)).map((b) => {\n        return b.toString(16).padStart(2, \"0\");\n      }).join(\"\")}`;\n      if (knownIdsWithOneLength.includes(firstOneString)) {\n        return firstOneString;\n      }\n      if (bytesRemaining() === 0) {\n        return null;\n      }\n      const firstTwo = getSlice(1);\n      const firstTwoString = `${firstOneString}${Array.from(new Uint8Array(firstTwo)).map((b) => {\n        return b.toString(16).padStart(2, \"0\");\n      }).join(\"\")}`;\n      if (knownIdsWithTwoLength.includes(firstTwoString)) {\n        return firstTwoString;\n      }\n      if (bytesRemaining() === 0) {\n        return null;\n      }\n      const firstThree = getSlice(1);\n      const firstThreeString = `${firstTwoString}${Array.from(new Uint8Array(firstThree)).map((b) => {\n        return b.toString(16).padStart(2, \"0\");\n      }).join(\"\")}`;\n      if (knownIdsWithThreeLength.includes(firstThreeString)) {\n        return firstThreeString;\n      }\n      if (bytesRemaining() === 0) {\n        return null;\n      }\n      const segmentId = getSlice(1);\n      return `${firstThreeString}${Array.from(new Uint8Array(segmentId)).map((b) => {\n        return b.toString(16).padStart(2, \"0\");\n      }).join(\"\")}`;\n    },\n    getVint: () => {\n      if (bytesRemaining() === 0) {\n        return null;\n      }\n      const firstByte = getUint8();\n      const totalLength = firstByte;\n      if (totalLength === 0) {\n        return 0;\n      }\n      let actualLength = 0;\n      while ((totalLength >> 7 - actualLength & 1) === 0) {\n        actualLength++;\n      }\n      if (bytesRemaining() < actualLength) {\n        return null;\n      }\n      const slice = getSlice(actualLength);\n      const d = [firstByte, ...Array.from(new Uint8Array(slice))];\n      actualLength += 1;\n      let value = 0;\n      value = totalLength & 255 >> actualLength;\n      for (let i = 1;i < actualLength; i++) {\n        value = value << 8 | d[i];\n      }\n      if (value === -1) {\n        return Infinity;\n      }\n      return value;\n    },\n    getUint8,\n    getEBML: () => {\n      const val = getUint8();\n      const actualValue = val & 127;\n      return actualValue;\n    },\n    getInt8: () => {\n      const val = getView().getInt8(counter.getDiscardedOffset());\n      counter.increment(1);\n      return val;\n    },\n    getUint16: () => {\n      const val = getView().getUint16(counter.getDiscardedOffset());\n      counter.increment(2);\n      return val;\n    },\n    getUint16Le: () => {\n      const val = getView().getUint16(counter.getDiscardedOffset(), true);\n      counter.increment(2);\n      return val;\n    },\n    getUint24: () => {\n      const val1 = getView().getUint8(counter.getDiscardedOffset());\n      const val2 = getView().getUint8(counter.getDiscardedOffset() + 1);\n      const val3 = getView().getUint8(counter.getDiscardedOffset() + 2);\n      counter.increment(3);\n      return val1 << 16 | val2 << 8 | val3;\n    },\n    getInt24: () => {\n      const val1 = getView().getInt8(counter.getDiscardedOffset());\n      const val2 = getView().getUint8(counter.getDiscardedOffset() + 1);\n      const val3 = getView().getUint8(counter.getDiscardedOffset() + 2);\n      counter.increment(3);\n      return val1 << 16 | val2 << 8 | val3;\n    },\n    getInt16: () => {\n      const val = getView().getInt16(counter.getDiscardedOffset());\n      counter.increment(2);\n      return val;\n    },\n    getUint32,\n    getUint64,\n    getInt64,\n    getFixedPointUnsigned1616Number: () => {\n      const val = getUint32();\n      return val / 2 ** 16;\n    },\n    getFixedPointSigned1616Number: () => {\n      const val = getInt32();\n      return val / 2 ** 16;\n    },\n    getFixedPointSigned230Number: () => {\n      const val = getInt32();\n      return val / 2 ** 30;\n    },\n    getPascalString: () => {\n      const val = getSlice(32);\n      return [...Array.from(new Uint8Array(val))];\n    },\n    getUint(length) {\n      const bytes = getSlice(length);\n      const numbers = [...Array.from(new Uint8Array(bytes))];\n      return numbers.reduce((acc, byte, index) => acc + (byte << 8 * (numbers.length - index - 1)), 0);\n    },\n    getByteString(length, trimTrailingZeroes) {\n      let bytes = getSlice(length);\n      while (trimTrailingZeroes && bytes[bytes.length - 1] === 0) {\n        bytes = bytes.slice(0, -1);\n      }\n      return new TextDecoder().decode(bytes).trim();\n    },\n    planBytes: (size) => {\n      const currentOffset = counter.getOffset();\n      return {\n        discardRest: () => {\n          const toDiscard = size - (counter.getOffset() - currentOffset);\n          if (toDiscard < 0) {\n            throw new Error(\"read too many bytes\");\n          }\n          return getSlice(toDiscard);\n        }\n      };\n    },\n    getFloat64: () => {\n      const val = getView().getFloat64(counter.getDiscardedOffset());\n      counter.increment(8);\n      return val;\n    },\n    readUntilNullTerminator,\n    getFloat32: () => {\n      const val = getView().getFloat32(counter.getDiscardedOffset());\n      counter.increment(4);\n      return val;\n    },\n    getUint32Le,\n    getInt32Le,\n    getInt32,\n    destroy,\n    startBox,\n    readExpGolomb,\n    startCheckpoint,\n    getFlacCodecNumber,\n    readUntilLineEnd,\n    getSyncSafeInt32,\n    replaceData\n  };\n};\n\n// src/containers/iso-base-media/to-date.ts\nvar toUnixTimestamp = (value) => {\n  if (value === 0) {\n    return null;\n  }\n  const baseDate = new Date(\"1904-01-01T00:00:00Z\");\n  return Math.floor(value + baseDate.getTime() / 1000) * 1000;\n};\n\n// src/containers/iso-base-media/moov/mvhd.ts\nvar parseMvhd = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const version = iterator.getUint8();\n  iterator.discard(3);\n  const creationTime = version === 1 ? iterator.getUint64() : iterator.getUint32();\n  const modificationTime = version === 1 ? iterator.getUint64() : iterator.getUint32();\n  const timeScale = iterator.getUint32();\n  const durationInUnits = version === 1 ? iterator.getUint64() : iterator.getUint32();\n  const durationInSeconds = Number(durationInUnits) / timeScale;\n  const rateArray = iterator.getSlice(4);\n  const rateView = getArrayBufferIterator({\n    initialData: rateArray,\n    maxBytes: rateArray.length,\n    logLevel: \"error\"\n  });\n  const rate = rateView.getInt8() * 10 + rateView.getInt8() + rateView.getInt8() * 0.1 + rateView.getInt8() * 0.01;\n  const volumeArray = iterator.getSlice(2);\n  const volumeView = getArrayBufferIterator({\n    initialData: volumeArray,\n    maxBytes: volumeArray.length,\n    logLevel: \"error\"\n  });\n  const volume = volumeView.getInt8() + volumeView.getInt8() * 0.1;\n  iterator.discard(2);\n  iterator.discard(4);\n  iterator.discard(4);\n  const matrix = [\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned230Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned230Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned230Number()\n  ];\n  iterator.discard(4 * 6);\n  const nextTrackId = iterator.getUint32();\n  volumeView.destroy();\n  const bytesRemaining = size - (iterator.counter.getOffset() - offset);\n  if (bytesRemaining !== 0) {\n    throw new Error(\"expected 0 bytes \" + bytesRemaining);\n  }\n  return {\n    creationTime: toUnixTimestamp(Number(creationTime)),\n    modificationTime: toUnixTimestamp(Number(modificationTime)),\n    timeScale,\n    durationInUnits: Number(durationInUnits),\n    durationInSeconds,\n    rate,\n    volume,\n    matrix,\n    nextTrackId,\n    type: \"mvhd-box\",\n    boxSize: size,\n    offset\n  };\n};\n\n// src/containers/avc/codec-string.ts\nvar getCodecStringFromSpsAndPps = (sps) => {\n  return `avc1.${sps.spsData.profile.toString(16).padStart(2, \"0\")}${sps.spsData.compatibility.toString(16).padStart(2, \"0\")}${sps.spsData.level.toString(16).padStart(2, \"0\")}`;\n};\n\n// src/combine-uint8-arrays.ts\nvar combineUint8Arrays = (arrays) => {\n  if (arrays.length === 0) {\n    return new Uint8Array([]);\n  }\n  if (arrays.length === 1) {\n    return arrays[0];\n  }\n  let totalLength = 0;\n  for (const array of arrays) {\n    totalLength += array.length;\n  }\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n};\n\n// src/truthy.ts\nfunction truthy(value) {\n  return Boolean(value);\n}\n\n// src/containers/avc/create-sps-pps-data.ts\nfunction serializeUint16(value) {\n  const buffer = new ArrayBuffer(2);\n  const view = new DataView(buffer);\n  view.setUint16(0, value);\n  return new Uint8Array(buffer);\n}\nvar createSpsPpsData = (avc1Profile) => {\n  return combineUint8Arrays([\n    new Uint8Array([\n      1,\n      avc1Profile.sps.spsData.profile,\n      avc1Profile.sps.spsData.compatibility,\n      avc1Profile.sps.spsData.level,\n      255,\n      225\n    ]),\n    serializeUint16(avc1Profile.sps.sps.length),\n    avc1Profile.sps.sps,\n    new Uint8Array([1]),\n    serializeUint16(avc1Profile.pps.pps.length),\n    avc1Profile.pps.pps,\n    [66, 77, 88].some((b) => avc1Profile.sps.spsData.profile === b) ? null : new Uint8Array([253, 248, 248, 0])\n  ].filter(truthy));\n};\n\n// src/add-avc-profile-to-track.ts\nvar addAvcProfileToTrack = (track, avc1Profile) => {\n  if (avc1Profile === null) {\n    return track;\n  }\n  return {\n    ...track,\n    codec: getCodecStringFromSpsAndPps(avc1Profile.sps),\n    codecData: { type: \"avc-sps-pps\", data: createSpsPpsData(avc1Profile) },\n    description: undefined\n  };\n};\n\n// src/register-track.ts\nvar registerVideoTrack = async ({\n  track,\n  container,\n  logLevel,\n  onVideoTrack,\n  registerVideoSampleCallback,\n  tracks: tracks2\n}) => {\n  if (tracks2.getTracks().find((t) => t.trackId === track.trackId)) {\n    Log.trace(logLevel, `Track ${track.trackId} already registered, skipping`);\n    return null;\n  }\n  if (track.type !== \"video\") {\n    throw new Error(\"Expected video track\");\n  }\n  tracks2.addTrack(track);\n  if (!onVideoTrack) {\n    return null;\n  }\n  const callback = await onVideoTrack({\n    track,\n    container\n  });\n  await registerVideoSampleCallback(track.trackId, callback ?? null);\n  return callback;\n};\nvar registerAudioTrack = async ({\n  track,\n  container,\n  tracks: tracks2,\n  logLevel,\n  onAudioTrack,\n  registerAudioSampleCallback\n}) => {\n  if (tracks2.getTracks().find((t) => t.trackId === track.trackId)) {\n    Log.trace(logLevel, `Track ${track.trackId} already registered, skipping`);\n    return null;\n  }\n  if (track.type !== \"audio\") {\n    throw new Error(\"Expected audio track\");\n  }\n  tracks2.addTrack(track);\n  if (!onAudioTrack) {\n    return null;\n  }\n  const callback = await onAudioTrack({\n    track,\n    container\n  });\n  await registerAudioSampleCallback(track.trackId, callback ?? null);\n  return callback;\n};\nvar registerVideoTrackWhenProfileIsAvailable = ({\n  state,\n  track,\n  container\n}) => {\n  state.riff.registerOnAvcProfileCallback(async (profile) => {\n    await registerVideoTrack({\n      track: addAvcProfileToTrack(track, profile),\n      container,\n      logLevel: state.logLevel,\n      onVideoTrack: state.onVideoTrack,\n      registerVideoSampleCallback: state.callbacks.registerVideoSampleCallback,\n      tracks: state.callbacks.tracks\n    });\n  });\n};\n\n// src/skip.ts\nvar makeSkip = (skipTo) => ({\n  action: \"skip\",\n  skipTo\n});\nvar makeFetchMoreData = (bytesNeeded) => ({\n  action: \"fetch-more-data\",\n  bytesNeeded\n});\n\n// src/containers/iso-base-media/elst.ts\nvar parseElst = ({\n  iterator,\n  size,\n  offset\n}) => {\n  const { expectNoMoreBytes } = iterator.startBox(size - 8);\n  const version = iterator.getUint8();\n  const flags = iterator.getUint24();\n  const entryCount = iterator.getUint32();\n  const entries = [];\n  for (let i = 0;i < entryCount; i++) {\n    const editDuration = Number(version === 1 ? iterator.getUint64() : iterator.getUint32());\n    const mediaTime = Number(version === 1 ? iterator.getUint64() : iterator.getInt32());\n    const mediaRateInteger = iterator.getUint16();\n    const mediaRateFraction = iterator.getUint16();\n    entries.push({\n      editDuration,\n      mediaTime,\n      mediaRateInteger,\n      mediaRateFraction\n    });\n  }\n  expectNoMoreBytes();\n  const result = {\n    type: \"elst-box\",\n    version,\n    flags,\n    entries,\n    boxSize: size,\n    offset\n  };\n  return result;\n};\n\n// src/containers/iso-base-media/esds/decoder-specific-config.ts\nvar parseDecoderSpecificConfig = (iterator) => {\n  const layerTag = iterator.getUint8();\n  const layerSize = iterator.getPaddedFourByteNumber();\n  const start = iterator.counter.getOffset();\n  if (layerTag !== 5) {\n    iterator.discard(layerSize);\n    return {\n      type: \"unknown-decoder-specific-config\"\n    };\n  }\n  const bytes = iterator.getSlice(layerSize);\n  iterator.counter.decrement(layerSize);\n  iterator.startReadingBits();\n  const audioObjectType = iterator.getBits(5);\n  const samplingFrequencyIndex = iterator.getBits(4);\n  if (samplingFrequencyIndex === 15) {\n    iterator.getBits(24);\n  }\n  const channelConfiguration = iterator.getBits(4);\n  iterator.stopReadingBits();\n  const read = iterator.counter.getOffset() - start;\n  if (read < layerSize) {\n    iterator.discard(layerSize - read);\n  }\n  return {\n    type: \"mp4a-specific-config\",\n    audioObjectType,\n    samplingFrequencyIndex,\n    channelConfiguration,\n    asBytes: bytes\n  };\n};\n\n// src/containers/iso-base-media/esds/esds-descriptors.ts\nvar mapToObjectAudioIndicator = (num) => {\n  if (num === 64) {\n    return \"aac\";\n  }\n  if (num === 107) {\n    return \"mp3\";\n  }\n  return \"unknown\";\n};\nvar processDescriptor = ({\n  iterator\n}) => {\n  const tag = iterator.getUint8();\n  if (tag === 4) {\n    const size = iterator.getPaddedFourByteNumber();\n    const initialOffset = iterator.counter.getOffset();\n    const objectTypeIndication = iterator.getUint8();\n    iterator.startReadingBits();\n    const streamType = iterator.getBits(6);\n    const upStream = iterator.getBits(1);\n    iterator.getBits(1);\n    const bufferSizeDB = iterator.getBits(24);\n    iterator.stopReadingBits();\n    const maxBitrate = iterator.getUint32();\n    const avgBitrate = iterator.getUint32();\n    const decoderSpecificConfigs = [];\n    while (size - (iterator.counter.getOffset() - initialOffset) > 0) {\n      const decoderSpecificConfig = parseDecoderSpecificConfig(iterator);\n      decoderSpecificConfigs.push(decoderSpecificConfig);\n    }\n    return {\n      descriptor: {\n        type: \"decoder-config-descriptor\",\n        objectTypeIndication: mapToObjectAudioIndicator(objectTypeIndication),\n        asNumber: objectTypeIndication,\n        bufferSizeDB,\n        streamType,\n        upStream,\n        avgBitrate,\n        maxBitrate,\n        decoderSpecificConfigs\n      }\n    };\n  }\n  if (tag === 6) {\n    const size = iterator.getPaddedFourByteNumber();\n    iterator.discard(size);\n    return {\n      descriptor: {\n        type: \"sl-config-descriptor\"\n      }\n    };\n  }\n  return {\n    descriptor: null\n  };\n};\nvar parseDescriptors = (iterator, maxBytes) => {\n  const descriptors = [];\n  const initialOffset = iterator.counter.getOffset();\n  while (iterator.bytesRemaining() > 0 && iterator.counter.getOffset() - initialOffset < maxBytes) {\n    const { descriptor } = processDescriptor({\n      iterator\n    });\n    if (descriptor) {\n      descriptors.push(descriptor);\n    } else {\n      break;\n    }\n  }\n  return descriptors;\n};\n\n// src/containers/iso-base-media/esds/esds.ts\nvar parseEsds = ({\n  data,\n  size,\n  fileOffset\n}) => {\n  const version = data.getUint8();\n  data.discard(3);\n  const tag = data.getUint8();\n  const sizeOfInstance = data.getPaddedFourByteNumber();\n  const esId = data.getUint16();\n  data.discard(1);\n  const remaining = size - (data.counter.getOffset() - fileOffset);\n  const descriptors = parseDescriptors(data, remaining);\n  const remainingNow = size - (data.counter.getOffset() - fileOffset);\n  data.discard(remainingNow);\n  return {\n    type: \"esds-box\",\n    version,\n    tag,\n    sizeOfInstance,\n    esId,\n    descriptors\n  };\n};\n\n// src/state/iso-base-media/precomputed-moof.ts\nvar precomputedMoofState = () => {\n  let moofBoxes = [];\n  return {\n    getMoofBoxes: () => moofBoxes,\n    setMoofBoxes: (boxes) => {\n      moofBoxes = boxes;\n    }\n  };\n};\nvar toMoofBox = (box) => {\n  if (box.type !== \"regular-box\") {\n    throw new Error(\"expected regular bpx\");\n  }\n  return {\n    offset: box.offset,\n    trafBoxes: box.children.filter((c) => c.type === \"regular-box\" && c.boxType === \"traf\"),\n    size: box.boxSize\n  };\n};\nvar deduplicateMoofBoxesByOffset = (moofBoxes) => {\n  return moofBoxes.filter((m, i, arr) => i === arr.findIndex((t) => t.offset === m.offset));\n};\n\n// src/containers/iso-base-media/traversal.ts\nvar getMoovFromFromIsoStructure = (structure) => {\n  const moovBox = structure.boxes.find((s) => s.type === \"moov-box\");\n  if (!moovBox || moovBox.type !== \"moov-box\") {\n    return null;\n  }\n  return moovBox;\n};\nvar getMoovBoxFromState = ({\n  structureState,\n  isoState,\n  mp4HeaderSegment,\n  mayUsePrecomputed\n}) => {\n  const got = isoState.moov.getMoovBoxAndPrecomputed();\n  if (got && (mayUsePrecomputed || !got.precomputed)) {\n    return got.moovBox;\n  }\n  if (mp4HeaderSegment) {\n    return getMoovFromFromIsoStructure(mp4HeaderSegment);\n  }\n  const structure = structureState.getIsoStructure();\n  return getMoovFromFromIsoStructure(structure);\n};\nvar getMoofBoxes = (main) => {\n  const moofBoxes = main.filter((s) => s.type === \"regular-box\" && s.boxType === \"moof\");\n  return moofBoxes.map((m) => toMoofBox(m));\n};\nvar getMvhdBox = (moovBox) => {\n  const mvHdBox = moovBox.children.find((s) => s.type === \"mvhd-box\");\n  if (!mvHdBox || mvHdBox.type !== \"mvhd-box\") {\n    return null;\n  }\n  return mvHdBox;\n};\nvar getTraks = (moovBox) => {\n  return moovBox.children.filter((s) => s.type === \"trak-box\");\n};\nvar getTkhdBox = (trakBox) => {\n  const tkhdBox = trakBox.children.find((s) => s.type === \"tkhd-box\");\n  return tkhdBox;\n};\nvar getMdiaBox = (trakBox) => {\n  const mdiaBox = trakBox.children.find((s) => s.type === \"regular-box\" && s.boxType === \"mdia\");\n  if (!mdiaBox || mdiaBox.type !== \"regular-box\") {\n    return null;\n  }\n  return mdiaBox;\n};\nvar getMdhdBox = (trakBox) => {\n  const mdiaBox = getMdiaBox(trakBox);\n  if (!mdiaBox) {\n    return null;\n  }\n  const mdhdBox = mdiaBox.children.find((c) => c.type === \"mdhd-box\");\n  return mdhdBox;\n};\nvar getStblBox = (trakBox) => {\n  const mdiaBox = getMdiaBox(trakBox);\n  if (!mdiaBox) {\n    return null;\n  }\n  const minfBox = mdiaBox.children.find((s) => s.type === \"regular-box\" && s.boxType === \"minf\");\n  if (!minfBox || minfBox.type !== \"regular-box\") {\n    return null;\n  }\n  const stblBox = minfBox.children.find((s) => s.type === \"regular-box\" && s.boxType === \"stbl\");\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  return stblBox;\n};\nvar getStsdBox = (trakBox) => {\n  const stblBox = getStblBox(trakBox);\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  const stsdBox = stblBox.children.find((s) => s.type === \"stsd-box\");\n  return stsdBox;\n};\nvar getVideoDescriptors = (trakBox) => {\n  const stsdBox = getStsdBox(trakBox);\n  if (!stsdBox) {\n    return null;\n  }\n  const descriptors = stsdBox.samples.map((s) => {\n    return s.type === \"video\" ? s.descriptors.map((d) => {\n      return d.type === \"avcc-box\" ? d.privateData : d.type === \"hvcc-box\" ? d.privateData : null;\n    }) : [];\n  });\n  return descriptors.flat(1).filter(Boolean)[0] ?? null;\n};\nvar getStcoBox = (trakBox) => {\n  const stblBox = getStblBox(trakBox);\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  const stcoBox = stblBox.children.find((s) => s.type === \"stco-box\");\n  return stcoBox;\n};\nvar getSttsBox = (trakBox) => {\n  const stblBox = getStblBox(trakBox);\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  const sttsBox = stblBox.children.find((s) => s.type === \"stts-box\");\n  return sttsBox;\n};\nvar getCttsBox = (trakBox) => {\n  const stblBox = getStblBox(trakBox);\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  const cttsBox = stblBox.children.find((s) => s.type === \"ctts-box\");\n  return cttsBox;\n};\nvar getStszBox = (trakBox) => {\n  const stblBox = getStblBox(trakBox);\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  const stszBox = stblBox.children.find((s) => s.type === \"stsz-box\");\n  return stszBox;\n};\nvar getStscBox = (trakBox) => {\n  const stblBox = getStblBox(trakBox);\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  const stcoBox = stblBox.children.find((b) => b.type === \"stsc-box\");\n  return stcoBox;\n};\nvar getStssBox = (trakBox) => {\n  const stblBox = getStblBox(trakBox);\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  const stssBox = stblBox.children.find((b) => b.type === \"stss-box\");\n  return stssBox;\n};\nvar getTfdtBox = (segment) => {\n  if (segment.type !== \"regular-box\" || segment.boxType !== \"traf\") {\n    throw new Error(\"Expected traf-box\");\n  }\n  const tfhdBox = segment.children.find((c) => c.type === \"tfdt-box\");\n  if (!tfhdBox || tfhdBox.type !== \"tfdt-box\") {\n    throw new Error(\"Expected tfhd-box\");\n  }\n  return tfhdBox;\n};\nvar getTfhdBox = (segment) => {\n  if (segment.type !== \"regular-box\" || segment.boxType !== \"traf\") {\n    throw new Error(\"Expected traf-box\");\n  }\n  const tfhdBox = segment.children.find((c) => c.type === \"tfhd-box\");\n  if (!tfhdBox || tfhdBox.type !== \"tfhd-box\") {\n    throw new Error(\"Expected tfhd-box\");\n  }\n  return tfhdBox;\n};\nvar getTrunBoxes = (segment) => {\n  if (segment.type !== \"regular-box\" || segment.boxType !== \"traf\") {\n    throw new Error(\"Expected traf-box\");\n  }\n  const trunBoxes = segment.children.filter((c) => c.type === \"trun-box\");\n  return trunBoxes;\n};\nvar getMvexBox = (moovAtom) => {\n  const mvexBox = moovAtom.children.find((s) => s.type === \"regular-box\" && s.boxType === \"mvex\");\n  if (!mvexBox || mvexBox.type !== \"regular-box\") {\n    return null;\n  }\n  return mvexBox;\n};\nvar getTrexBoxes = (moovAtom) => {\n  const mvexBox = getMvexBox(moovAtom);\n  if (!mvexBox) {\n    return [];\n  }\n  const trexBoxes = mvexBox.children.filter((c) => c.type === \"trex-box\");\n  return trexBoxes;\n};\nvar getTfraBoxesFromMfraBoxChildren = (mfraBoxChildren) => {\n  const tfraBoxes = mfraBoxChildren.filter((b) => b.type === \"tfra-box\");\n  return tfraBoxes;\n};\nvar getTfraBoxes = (structure) => {\n  const mfraBox = structure.find((b) => b.type === \"regular-box\" && b.boxType === \"mfra\");\n  if (!mfraBox) {\n    return [];\n  }\n  return getTfraBoxesFromMfraBoxChildren(mfraBox.children);\n};\nvar getTrakBoxByTrackId = (moovBox, trackId) => {\n  const trakBoxes = getTraks(moovBox);\n  return trakBoxes.find((t) => {\n    const tkhd = getTkhdBox(t);\n    if (!tkhd) {\n      return false;\n    }\n    return tkhd.trackId === trackId;\n  }) ?? null;\n};\nvar getElstBox = (trakBox) => {\n  const edtsBox = trakBox.children.find((s) => s.type === \"regular-box\" && s.boxType === \"edts\");\n  if (!edtsBox || edtsBox.type !== \"regular-box\") {\n    return null;\n  }\n  const elstBox = edtsBox.children.find((s) => s.type === \"elst-box\");\n  return elstBox;\n};\n\n// src/containers/iso-base-media/mdat/get-editlist.ts\nvar findTrackStartTimeInSeconds = ({\n  movieTimeScale,\n  trakBox\n}) => {\n  const elstBox = getElstBox(trakBox);\n  if (!elstBox) {\n    return 0;\n  }\n  const { entries } = elstBox;\n  let dwellTime = 0;\n  for (const entry of entries) {\n    const { editDuration, mediaTime } = entry;\n    if (mediaTime !== -1) {\n      continue;\n    }\n    dwellTime += editDuration;\n  }\n  return dwellTime / movieTimeScale;\n};\nvar findTrackMediaTimeOffsetInTrackTimescale = ({\n  trakBox\n}) => {\n  const elstBox = getElstBox(trakBox);\n  if (!elstBox) {\n    return 0;\n  }\n  const { entries } = elstBox;\n  let dwellTime = 0;\n  for (const entry of entries) {\n    const { mediaTime } = entry;\n    if (mediaTime === -1) {\n      continue;\n    }\n    dwellTime += mediaTime;\n  }\n  return dwellTime;\n};\n\n// src/webcodecs-timescale.ts\nvar esm_WEBCODECS_TIMESCALE = 1e6;\n\n// src/containers/riff/timescale.ts\nvar MEDIA_PARSER_RIFF_TIMESCALE = 1e6;\n\n// src/containers/riff/traversal.ts\nvar isRiffAvi2 = (structure) => {\n  return structure.boxes.some((box) => box.type === \"riff-header\" && box.fileType === \"AVI\");\n};\nvar getHdlrBox = (structure) => {\n  return structure.boxes.find((box) => box.type === \"list-box\" && box.listType === \"hdrl\");\n};\nvar getAvihBox = (structure) => {\n  const hdlrBox = getHdlrBox(structure);\n  if (!hdlrBox) {\n    return null;\n  }\n  return hdlrBox.children.find((box) => box.type === \"avih-box\");\n};\nvar getStrlBoxes = (structure) => {\n  const hdlrBox = getHdlrBox(structure);\n  if (!hdlrBox) {\n    return [];\n  }\n  return hdlrBox.children.filter((box) => box.type === \"list-box\" && box.listType === \"strl\");\n};\nvar getStrhBox = (strlBoxChildren) => {\n  return strlBoxChildren.find((box) => box.type === \"strh-box\");\n};\n\n// src/containers/riff/get-tracks-from-avi.ts\nvar TO_BE_OVERRIDDEN_LATER = \"to-be-overriden-later\";\nvar getNumberOfTracks = (structure) => {\n  const avihBox = getAvihBox(structure);\n  if (avihBox) {\n    return avihBox.streams;\n  }\n  throw new Error(\"No avih box found\");\n};\nvar makeAviAudioTrack = ({\n  strf,\n  index\n}) => {\n  if (strf.formatTag !== 255) {\n    throw new Error(`Unsupported audio format ${strf.formatTag}`);\n  }\n  return {\n    type: \"audio\",\n    codec: \"mp4a.40.2\",\n    codecData: { type: \"aac-config\", data: new Uint8Array([18, 16]) },\n    codecEnum: \"aac\",\n    description: new Uint8Array([18, 16]),\n    numberOfChannels: strf.numberOfChannels,\n    sampleRate: strf.sampleRate,\n    originalTimescale: MEDIA_PARSER_RIFF_TIMESCALE,\n    trackId: index,\n    startInSeconds: 0,\n    timescale: esm_WEBCODECS_TIMESCALE,\n    trackMediaTimeOffsetInTrackTimescale: 0\n  };\n};\nvar makeAviVideoTrack = ({\n  strh,\n  strf,\n  index\n}) => {\n  if (strh.handler !== \"H264\") {\n    throw new Error(`Unsupported video codec ${strh.handler}`);\n  }\n  return {\n    codecData: null,\n    codec: TO_BE_OVERRIDDEN_LATER,\n    codecEnum: \"h264\",\n    codedHeight: strf.height,\n    codedWidth: strf.width,\n    width: strf.width,\n    height: strf.height,\n    type: \"video\",\n    displayAspectHeight: strf.height,\n    originalTimescale: MEDIA_PARSER_RIFF_TIMESCALE,\n    description: undefined,\n    m3uStreamFormat: null,\n    trackId: index,\n    colorSpace: {\n      fullRange: null,\n      matrix: null,\n      primaries: null,\n      transfer: null\n    },\n    advancedColor: {\n      fullRange: null,\n      matrix: null,\n      primaries: null,\n      transfer: null\n    },\n    displayAspectWidth: strf.width,\n    rotation: 0,\n    sampleAspectRatio: {\n      numerator: 1,\n      denominator: 1\n    },\n    fps: strh.rate / strh.scale,\n    startInSeconds: 0,\n    timescale: esm_WEBCODECS_TIMESCALE,\n    trackMediaTimeOffsetInTrackTimescale: 0\n  };\n};\nvar getTracksFromAvi = (structure, state) => {\n  const tracks2 = [];\n  const boxes = getStrlBoxes(structure);\n  let i = 0;\n  for (const box of boxes) {\n    const strh = getStrhBox(box.children);\n    if (!strh) {\n      continue;\n    }\n    const { strf } = strh;\n    if (strf.type === \"strf-box-video\") {\n      tracks2.push(addAvcProfileToTrack(makeAviVideoTrack({ strh, strf, index: i }), state.riff.getAvcProfile()));\n    } else if (strh.fccType === \"auds\") {\n      tracks2.push(makeAviAudioTrack({ strf, index: i }));\n    } else {\n      throw new Error(`Unsupported track type ${strh.fccType}`);\n    }\n    i++;\n  }\n  return tracks2;\n};\nvar hasAllTracksFromAvi = (state) => {\n  try {\n    const structure = state.structure.getRiffStructure();\n    const numberOfTracks = getNumberOfTracks(structure);\n    const tracks2 = getTracksFromAvi(structure, state);\n    return tracks2.length === numberOfTracks && !tracks2.find((t) => t.type === \"video\" && t.codec === TO_BE_OVERRIDDEN_LATER);\n  } catch {\n    return false;\n  }\n};\n\n// src/containers/transport-stream/traversal.ts\nvar findProgramAssociationTableOrThrow = (structure) => {\n  const box = structure.boxes.find((b) => b.type === \"transport-stream-pat-box\");\n  if (!box) {\n    throw new Error(\"No PAT box found\");\n  }\n  return box;\n};\nvar findProgramMapOrNull = (structure) => {\n  const box = structure.boxes.find((b) => b.type === \"transport-stream-pmt-box\");\n  if (!box) {\n    return null;\n  }\n  return box;\n};\nvar findProgramMapTableOrThrow = (structure) => {\n  const box = findProgramMapOrNull(structure);\n  if (!box) {\n    throw new Error(\"No PMT box found\");\n  }\n  return box;\n};\nvar getProgramForId = (structure, packetIdentifier) => {\n  const box = findProgramAssociationTableOrThrow(structure);\n  const entry = box.pat.find((e) => e.programMapIdentifier === packetIdentifier);\n  return entry ?? null;\n};\nvar getStreamForId = (structure, packetIdentifier) => {\n  const box = findProgramMapTableOrThrow(structure);\n  const entry = box.streams.find((e) => e.pid === packetIdentifier);\n  return entry ?? null;\n};\n\n// src/containers/transport-stream/get-tracks.ts\nvar filterStreamsBySupportedTypes = (streams) => {\n  return streams.filter((stream) => stream.streamType === 27 || stream.streamType === 15);\n};\nvar getTracksFromTransportStream = (parserState) => {\n  const structure = parserState.structure.getTsStructure();\n  const programMapTable = findProgramMapTableOrThrow(structure);\n  const parserTracks = parserState.callbacks.tracks.getTracks();\n  const mapped = filterStreamsBySupportedTypes(programMapTable.streams).map((stream) => {\n    return parserTracks.find((track) => track.trackId === stream.pid);\n  }).filter(truthy);\n  if (mapped.length !== filterStreamsBySupportedTypes(programMapTable.streams).length) {\n    throw new Error(\"Not all tracks found\");\n  }\n  return mapped;\n};\nvar hasAllTracksFromTransportStream = (parserState) => {\n  try {\n    getTracksFromTransportStream(parserState);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n// src/make-hvc1-codec-strings.ts\nvar getHvc1CodecString = (data) => {\n  const configurationVersion = data.getUint8();\n  if (configurationVersion !== 1) {\n    throw new Error(`Unsupported HVCC version ${configurationVersion}`);\n  }\n  const generalProfileSpaceTierFlagAndIdc = data.getUint8();\n  let generalProfileCompatibility = data.getUint32();\n  const generalProfileSpace = generalProfileSpaceTierFlagAndIdc >> 6;\n  const generalTierFlag = (generalProfileSpaceTierFlagAndIdc & 32) >> 5;\n  const generalProfileIdc = generalProfileSpaceTierFlagAndIdc & 31;\n  const generalConstraintIndicator = data.getSlice(6);\n  const generalLevelIdc = data.getUint8();\n  let profileId = 0;\n  for (let i = 0;i < 32; i++) {\n    profileId |= generalProfileCompatibility & 1;\n    if (i === 31)\n      break;\n    profileId <<= 1;\n    generalProfileCompatibility >>= 1;\n  }\n  const profileSpaceChar = generalProfileSpace === 0 ? \"\" : generalProfileSpace === 1 ? \"A\" : generalProfileSpace === 2 ? \"B\" : \"C\";\n  const generalTierChar = generalTierFlag === 0 ? \"L\" : \"H\";\n  let hasByte = false;\n  let generalConstraintString = \"\";\n  for (let i = 5;i >= 0; i--) {\n    if (generalConstraintIndicator[i] || hasByte) {\n      generalConstraintString = generalConstraintIndicator[i].toString(16) + generalConstraintString;\n      hasByte = true;\n    }\n  }\n  return `${profileSpaceChar}${generalProfileIdc.toString(16)}.${profileId.toString(16)}.${generalTierChar}${generalLevelIdc}${generalConstraintString ? \".\" : \"\"}${generalConstraintString}`;\n};\n\n// src/containers/iso-base-media/color-to-webcodecs-colors.ts\nvar mediaParserAdvancedColorToWebCodecsColor = (color2) => {\n  return {\n    transfer: color2.transfer,\n    matrix: color2.matrix,\n    primaries: color2.primaries,\n    fullRange: color2.fullRange\n  };\n};\n\n// src/containers/webm/av1-codec-private.ts\nvar parseAv1PrivateData = (data, colrAtom) => {\n  const iterator = getArrayBufferIterator({\n    initialData: data,\n    maxBytes: data.byteLength,\n    logLevel: \"error\"\n  });\n  iterator.startReadingBits();\n  if (iterator.getBits(1) !== 1) {\n    iterator.destroy();\n    throw new Error(\"Expected av1 private data to be version 1\");\n  }\n  const version = iterator.getBits(7);\n  if (version !== 1) {\n    iterator.destroy();\n    throw new Error(`Expected av1 private data to be version 1, got ${version}`);\n  }\n  let str = \"av01.\";\n  const seqProfile = iterator.getBits(3);\n  str += seqProfile;\n  str += \".\";\n  const seq_level_idx = iterator.getBits(5);\n  const seq_tier_0 = iterator.getBits(1);\n  str += String(seq_level_idx).padStart(2, \"0\");\n  str += seq_tier_0 ? \"H\" : \"M\";\n  str += \".\";\n  const high_bitdepth = iterator.getBits(1);\n  const twelve_bit = iterator.getBits(1);\n  const bitDepth2 = high_bitdepth && seqProfile === 2 ? twelve_bit ? 12 : 10 : high_bitdepth ? 10 : 8;\n  str += bitDepth2.toString().padStart(2, \"0\");\n  str += \".\";\n  const mono_chrome = iterator.getBits(1);\n  str += mono_chrome ? \"1\" : \"0\";\n  str += \".\";\n  const subsampling_x = iterator.getBits(1);\n  str += subsampling_x ? \"1\" : \"0\";\n  const subsampling_y = iterator.getBits(1);\n  str += subsampling_y ? \"1\" : \"0\";\n  const chroma_sample_position = iterator.getBits(2);\n  str += subsampling_x && subsampling_y ? chroma_sample_position === 1 ? \"1\" : \"0\" : \"0\";\n  str += \".\";\n  if (colrAtom && colrAtom.colorType === \"transfer-characteristics\") {\n    str += colrAtom.primaries.toString().padStart(2, \"0\");\n    str += \".\";\n    str += colrAtom.transfer.toString().padStart(2, \"0\");\n    str += \".\";\n    str += colrAtom.matrixIndex.toString().padStart(2, \"0\");\n    str += \".\";\n    str += colrAtom.fullRangeFlag ? \"1\" : \"0\";\n  } else {\n    str += \"01\";\n    str += \".\";\n    str += \"01\";\n    str += \".\";\n    str += \"01\";\n    str += \".\";\n    str += \"0\";\n  }\n  const suffix = \".0.110.01.01.01.0\";\n  if (str.endsWith(suffix)) {\n    str = str.slice(0, -suffix.length);\n  }\n  iterator.destroy();\n  return str;\n};\n\n// src/containers/avc/color.ts\nvar getMatrixCoefficientsFromIndex = (index) => {\n  if (index === 0) {\n    return \"rgb\";\n  }\n  if (index === 1) {\n    return \"bt709\";\n  }\n  if (index === 5) {\n    return \"bt470bg\";\n  }\n  if (index === 6) {\n    return \"smpte170m\";\n  }\n  if (index === 9) {\n    return \"bt2020-ncl\";\n  }\n  return null;\n};\nvar getTransferCharacteristicsFromIndex = (index) => {\n  if (index === 1) {\n    return \"bt709\";\n  }\n  if (index === 6) {\n    return \"smpte170m\";\n  }\n  if (index === 8) {\n    return \"linear\";\n  }\n  if (index === 13) {\n    return \"iec61966-2-1\";\n  }\n  if (index === 16) {\n    return \"pq\";\n  }\n  if (index === 18) {\n    return \"hlg\";\n  }\n  return null;\n};\nvar getPrimariesFromIndex = (index) => {\n  if (index === 1) {\n    return \"bt709\";\n  }\n  if (index === 5) {\n    return \"bt470bg\";\n  }\n  if (index === 6) {\n    return \"smpte170m\";\n  }\n  if (index === 9) {\n    return \"bt2020\";\n  }\n  if (index === 12) {\n    return \"smpte432\";\n  }\n  return null;\n};\n\n// src/containers/webm/traversal.ts\nvar getMainSegment = (segments) => {\n  return segments.find((s) => s.type === \"Segment\") ?? null;\n};\nvar getTrackCodec = (track) => {\n  const child = track.value.find((b) => b.type === \"CodecID\");\n  return child ?? null;\n};\nvar getTrackTimestampScale = (track) => {\n  const child = track.value.find((b) => b.type === \"TrackTimestampScale\");\n  if (!child) {\n    return null;\n  }\n  if (child.type !== \"TrackTimestampScale\") {\n    throw new Error(\"Expected TrackTimestampScale\");\n  }\n  return child.value;\n};\nvar getTrackId = (track) => {\n  const trackId = track.value.find((b) => b.type === \"TrackNumber\");\n  if (!trackId || trackId.type !== \"TrackNumber\") {\n    throw new Error(\"Expected track number segment\");\n  }\n  return trackId.value.value;\n};\nvar getCodecSegment = (track) => {\n  const codec = track.value.find((b) => b.type === \"CodecID\");\n  if (!codec || codec.type !== \"CodecID\") {\n    return null;\n  }\n  return codec;\n};\nvar getColourSegment = (track) => {\n  const videoSegment2 = getVideoSegment(track);\n  if (!videoSegment2) {\n    return null;\n  }\n  const colour = videoSegment2.value.find((b) => b.type === \"Colour\");\n  if (!colour || colour.type !== \"Colour\") {\n    return null;\n  }\n  return colour;\n};\nvar getTransferCharacteristicsSegment = (color2) => {\n  if (!color2 || color2.type !== \"Colour\") {\n    return null;\n  }\n  const box = color2.value.find((b) => b.type === \"TransferCharacteristics\");\n  if (!box || box.type !== \"TransferCharacteristics\") {\n    return null;\n  }\n  return box;\n};\nvar getMatrixCoefficientsSegment = (color2) => {\n  if (!color2 || color2.type !== \"Colour\") {\n    return null;\n  }\n  const box = color2.value.find((b) => b.type === \"MatrixCoefficients\");\n  if (!box || box.type !== \"MatrixCoefficients\") {\n    return null;\n  }\n  return box;\n};\nvar getPrimariesSegment = (color2) => {\n  if (!color2 || color2.type !== \"Colour\") {\n    return null;\n  }\n  const box = color2.value.find((b) => b.type === \"Primaries\");\n  if (!box || box.type !== \"Primaries\") {\n    return null;\n  }\n  return box;\n};\nvar getRangeSegment = (color2) => {\n  if (!color2 || color2.type !== \"Colour\") {\n    return null;\n  }\n  const box = color2.value.find((b) => b.type === \"Range\");\n  if (!box || box.type !== \"Range\") {\n    return null;\n  }\n  return box;\n};\nvar getDisplayHeightSegment = (track) => {\n  const videoSegment2 = getVideoSegment(track);\n  if (!videoSegment2) {\n    return null;\n  }\n  const displayHeight2 = videoSegment2.value.find((b) => b.type === \"DisplayHeight\");\n  if (!displayHeight2 || displayHeight2.type !== \"DisplayHeight\") {\n    return null;\n  }\n  return displayHeight2;\n};\nvar getTrackTypeSegment = (track) => {\n  const trackType2 = track.value.find((b) => b.type === \"TrackType\");\n  if (!trackType2 || trackType2.type !== \"TrackType\") {\n    return null;\n  }\n  return trackType2;\n};\nvar getWidthSegment = (track) => {\n  const videoSegment2 = getVideoSegment(track);\n  if (!videoSegment2) {\n    return null;\n  }\n  const width = videoSegment2.value.find((b) => b.type === \"PixelWidth\");\n  if (!width || width.type !== \"PixelWidth\") {\n    return null;\n  }\n  return width;\n};\nvar getHeightSegment = (track) => {\n  const videoSegment2 = getVideoSegment(track);\n  if (!videoSegment2) {\n    return null;\n  }\n  const height = videoSegment2.value.find((b) => b.type === \"PixelHeight\");\n  if (!height || height.type !== \"PixelHeight\") {\n    return null;\n  }\n  return height;\n};\nvar getDisplayWidthSegment = (track) => {\n  const videoSegment2 = getVideoSegment(track);\n  if (!videoSegment2) {\n    return null;\n  }\n  const displayWidth2 = videoSegment2.value.find((b) => b.type === \"DisplayWidth\");\n  if (!displayWidth2 || displayWidth2.type !== \"DisplayWidth\") {\n    return null;\n  }\n  return displayWidth2;\n};\nvar getTracksSegment = (segment) => {\n  const tracksSegment = segment.value.find((b) => b.type === \"Tracks\");\n  if (!tracksSegment) {\n    return null;\n  }\n  return tracksSegment;\n};\nvar getTrackWithUid = (segment, trackUid) => {\n  const tracksSegment = getTracksSegment(segment);\n  if (!tracksSegment) {\n    return null;\n  }\n  const trackEntries = tracksSegment.value.filter((t) => t.type === \"TrackEntry\");\n  const trackEntry2 = trackEntries.find((entry) => {\n    return entry?.value.find((t) => t.type === \"TrackUID\" && t.value === trackUid);\n  });\n  if (!trackEntry2) {\n    return null;\n  }\n  return trackEntry2.value.find((t) => t.type === \"TrackNumber\")?.value.value ?? null;\n};\nvar getVideoSegment = (track) => {\n  const videoSegment2 = track.value.find((b) => b.type === \"Video\");\n  if (!videoSegment2 || videoSegment2.type !== \"Video\") {\n    return null;\n  }\n  return videoSegment2 ?? null;\n};\nvar getAudioSegment = (track) => {\n  const audioSegment2 = track.value.find((b) => b.type === \"Audio\");\n  if (!audioSegment2 || audioSegment2.type !== \"Audio\") {\n    return null;\n  }\n  return audioSegment2 ?? null;\n};\nvar getSampleRate = (track) => {\n  const audioSegment2 = getAudioSegment(track);\n  if (!audioSegment2) {\n    return null;\n  }\n  const samplingFrequency2 = audioSegment2.value.find((b) => b.type === \"SamplingFrequency\");\n  if (!samplingFrequency2 || samplingFrequency2.type !== \"SamplingFrequency\") {\n    return null;\n  }\n  return samplingFrequency2.value.value;\n};\nvar getNumberOfChannels = (track) => {\n  const audioSegment2 = getAudioSegment(track);\n  if (!audioSegment2) {\n    throw new Error(\"Could not find audio segment\");\n  }\n  const channels2 = audioSegment2.value.find((b) => b.type === \"Channels\");\n  if (!channels2 || channels2.type !== \"Channels\") {\n    return 1;\n  }\n  return channels2.value.value;\n};\nvar getBitDepth = (track) => {\n  const audioSegment2 = getAudioSegment(track);\n  if (!audioSegment2) {\n    return null;\n  }\n  const bitDepth2 = audioSegment2.value.find((b) => b.type === \"BitDepth\");\n  if (!bitDepth2 || bitDepth2.type !== \"BitDepth\") {\n    return null;\n  }\n  return bitDepth2.value.value;\n};\nvar getPrivateData = (track) => {\n  const privateData = track.value.find((b) => b.type === \"CodecPrivate\");\n  if (!privateData || privateData.type !== \"CodecPrivate\") {\n    return null;\n  }\n  return privateData.value;\n};\n\n// src/containers/webm/color.ts\nvar parseColorSegment = (colourSegment) => {\n  const transferCharacteristics2 = getTransferCharacteristicsSegment(colourSegment);\n  const matrixCoefficients2 = getMatrixCoefficientsSegment(colourSegment);\n  const primaries2 = getPrimariesSegment(colourSegment);\n  const range2 = getRangeSegment(colourSegment);\n  return {\n    transfer: transferCharacteristics2 ? getTransferCharacteristicsFromIndex(transferCharacteristics2.value.value) : null,\n    matrix: matrixCoefficients2 ? getMatrixCoefficientsFromIndex(matrixCoefficients2.value.value) : null,\n    primaries: primaries2 ? getPrimariesFromIndex(primaries2.value.value) : null,\n    fullRange: transferCharacteristics2?.value.value && matrixCoefficients2?.value.value ? null : range2 ? Boolean(range2?.value.value) : null\n  };\n};\n\n// src/containers/webm/description.ts\nvar getAudioDescription = (track) => {\n  const codec = getCodecSegment(track);\n  if (!codec || codec.value !== \"A_VORBIS\") {\n    return;\n  }\n  const privateData = getPrivateData(track);\n  if (!privateData) {\n    return;\n  }\n  if (privateData[0] !== 2) {\n    throw new Error(\"Expected vorbis private data version 2\");\n  }\n  let offset = 1;\n  let vorbisInfoLength = 0;\n  let vorbisSkipLength = 0;\n  while ((privateData[offset] & 255) === 255) {\n    vorbisInfoLength += 255;\n    offset++;\n  }\n  vorbisInfoLength += privateData[offset++] & 255;\n  while ((privateData[offset] & 255) === 255) {\n    vorbisSkipLength += 255;\n    offset++;\n  }\n  vorbisSkipLength += privateData[offset++] & 255;\n  if (privateData[offset] !== 1) {\n    throw new Error(\"Error parsing vorbis codec private\");\n  }\n  const vorbisInfo = privateData.slice(offset, offset + vorbisInfoLength);\n  offset += vorbisInfoLength;\n  if (privateData[offset] !== 3) {\n    throw new Error(\"Error parsing vorbis codec private\");\n  }\n  const vorbisComments = privateData.slice(offset, offset + vorbisSkipLength);\n  offset += vorbisSkipLength;\n  if (privateData[offset] !== 5) {\n    throw new Error(\"Error parsing vorbis codec private\");\n  }\n  const vorbisBooks = privateData.slice(offset);\n  const bufferIterator = getArrayBufferIterator({\n    initialData: vorbisInfo.slice(0),\n    maxBytes: vorbisInfo.length,\n    logLevel: \"error\"\n  });\n  bufferIterator.getUint8();\n  const vorbis = bufferIterator.getByteString(6, false);\n  if (vorbis !== \"vorbis\") {\n    throw new Error(\"Error parsing vorbis codec private\");\n  }\n  const vorbisVersion = bufferIterator.getUint32Le();\n  if (vorbisVersion !== 0) {\n    throw new Error(\"Error parsing vorbis codec private\");\n  }\n  const vorbisDescription = new Uint8Array([\n    2,\n    vorbisInfo.length,\n    vorbisComments.length,\n    ...vorbisInfo,\n    ...vorbisComments,\n    ...vorbisBooks\n  ]);\n  return vorbisDescription;\n};\n\n// src/containers/webm/segments/track-entry.ts\nvar trackTypeToString = (trackType2) => {\n  switch (trackType2) {\n    case 1:\n      return \"video\";\n    case 2:\n      return \"audio\";\n    case 3:\n      return \"complex\";\n    case 4:\n      return \"subtitle\";\n    case 5:\n      return \"button\";\n    case 6:\n      return \"control\";\n    case 7:\n      return \"metadata\";\n    default:\n      throw new Error(`Unknown track type: ${trackType2}`);\n  }\n};\n\n// src/containers/webm/make-track.ts\nvar NO_CODEC_PRIVATE_SHOULD_BE_DERIVED_FROM_SPS = \"no-codec-private-should-be-derived-from-sps\";\nvar getDescription = (track) => {\n  const codec = getCodecSegment(track);\n  if (!codec) {\n    return;\n  }\n  if (codec.value === \"V_MPEG4/ISO/AVC\" || codec.value === \"V_MPEGH/ISO/HEVC\") {\n    const priv = getPrivateData(track);\n    if (priv) {\n      return priv;\n    }\n  }\n  return;\n};\nvar getMatroskaVideoCodecEnum = ({\n  codecSegment: codec\n}) => {\n  if (codec.value === \"V_VP8\") {\n    return \"vp8\";\n  }\n  if (codec.value === \"V_VP9\") {\n    return \"vp9\";\n  }\n  if (codec.value === \"V_MPEG4/ISO/AVC\") {\n    return \"h264\";\n  }\n  if (codec.value === \"V_AV1\") {\n    return \"av1\";\n  }\n  if (codec.value === \"V_MPEGH/ISO/HEVC\") {\n    return \"h265\";\n  }\n  throw new Error(`Unknown codec: ${codec.value}`);\n};\nvar getMatroskaVideoCodecString = ({\n  track,\n  codecSegment: codec\n}) => {\n  if (codec.value === \"V_VP8\") {\n    return \"vp8\";\n  }\n  if (codec.value === \"V_VP9\") {\n    const priv = getPrivateData(track);\n    if (priv) {\n      throw new Error(\"@remotion/media-parser cannot handle the private data for VP9. Do you have an example file you could send so we can implement it? https://remotion.dev/report\");\n    }\n    return \"vp09.00.10.08\";\n  }\n  if (codec.value === \"V_MPEG4/ISO/AVC\") {\n    const priv = getPrivateData(track);\n    if (priv) {\n      return `avc1.${priv[1].toString(16).padStart(2, \"0\")}${priv[2].toString(16).padStart(2, \"0\")}${priv[3].toString(16).padStart(2, \"0\")}`;\n    }\n    return NO_CODEC_PRIVATE_SHOULD_BE_DERIVED_FROM_SPS;\n  }\n  if (codec.value === \"V_MPEGH/ISO/HEVC\") {\n    const priv = getPrivateData(track);\n    const iterator = getArrayBufferIterator({\n      initialData: priv,\n      maxBytes: priv.length,\n      logLevel: \"error\"\n    });\n    return \"hvc1.\" + getHvc1CodecString(iterator);\n  }\n  if (codec.value === \"V_AV1\") {\n    const priv = getPrivateData(track);\n    if (!priv) {\n      throw new Error(\"Expected private data in AV1 track\");\n    }\n    return parseAv1PrivateData(priv, null);\n  }\n  throw new Error(`Unknown codec: ${codec.value}`);\n};\nvar getMatroskaAudioCodecEnum = ({\n  track\n}) => {\n  const codec = getCodecSegment(track);\n  if (!codec) {\n    throw new Error(\"Expected codec segment\");\n  }\n  if (codec.value === \"A_OPUS\") {\n    return \"opus\";\n  }\n  if (codec.value === \"A_VORBIS\") {\n    return \"vorbis\";\n  }\n  if (codec.value === \"A_PCM/INT/LIT\") {\n    const bitDepth2 = getBitDepth(track);\n    if (bitDepth2 === null) {\n      throw new Error(\"Expected bit depth\");\n    }\n    if (bitDepth2 === 8) {\n      return \"pcm-u8\";\n    }\n    if (bitDepth2 === 16) {\n      return \"pcm-s16\";\n    }\n    if (bitDepth2 === 24) {\n      return \"pcm-s24\";\n    }\n    throw new Error(\"Unknown audio format\");\n  }\n  if (codec.value === \"A_AAC\") {\n    return `aac`;\n  }\n  if (codec.value === \"A_MPEG/L3\") {\n    return \"mp3\";\n  }\n  throw new Error(`Unknown codec: ${codec.value}`);\n};\nvar getMatroskaAudioCodecString = (track) => {\n  const codec = getCodecSegment(track);\n  if (!codec) {\n    throw new Error(\"Expected codec segment\");\n  }\n  if (codec.value === \"A_OPUS\") {\n    return \"opus\";\n  }\n  if (codec.value === \"A_VORBIS\") {\n    return \"vorbis\";\n  }\n  if (codec.value === \"A_PCM/INT/LIT\") {\n    const bitDepth2 = getBitDepth(track);\n    if (bitDepth2 === null) {\n      throw new Error(\"Expected bit depth\");\n    }\n    if (bitDepth2 === 8) {\n      return \"pcm-u8\";\n    }\n    return \"pcm-s\" + bitDepth2;\n  }\n  if (codec.value === \"A_AAC\") {\n    const priv = getPrivateData(track);\n    const iterator = getArrayBufferIterator({\n      initialData: priv,\n      maxBytes: priv.length,\n      logLevel: \"error\"\n    });\n    iterator.startReadingBits();\n    const profile = iterator.getBits(5);\n    iterator.stopReadingBits();\n    iterator.destroy();\n    return `mp4a.40.${profile.toString().padStart(2, \"0\")}`;\n  }\n  if (codec.value === \"A_MPEG/L3\") {\n    return \"mp3\";\n  }\n  throw new Error(`Unknown codec: ${codec.value}`);\n};\nvar getTrack = ({\n  timescale,\n  track\n}) => {\n  const trackType2 = getTrackTypeSegment(track);\n  if (!trackType2) {\n    throw new Error(\"Expected track type segment\");\n  }\n  const trackId = getTrackId(track);\n  if (trackTypeToString(trackType2.value.value) === \"video\") {\n    const width = getWidthSegment(track);\n    if (width === null) {\n      throw new Error(\"Expected width segment\");\n    }\n    const height = getHeightSegment(track);\n    if (height === null) {\n      throw new Error(\"Expected height segment\");\n    }\n    const displayHeight2 = getDisplayHeightSegment(track);\n    const displayWidth2 = getDisplayWidthSegment(track);\n    const codec = getCodecSegment(track);\n    if (!codec) {\n      return null;\n    }\n    const codecPrivate2 = getPrivateData(track);\n    const codecString = getMatroskaVideoCodecString({\n      track,\n      codecSegment: codec\n    });\n    const colour = getColourSegment(track);\n    if (!codecString) {\n      return null;\n    }\n    const codecEnum = getMatroskaVideoCodecEnum({\n      codecSegment: codec\n    });\n    const codecData = codecPrivate2 === null ? null : codecEnum === \"h264\" ? { type: \"avc-sps-pps\", data: codecPrivate2 } : codecEnum === \"av1\" ? {\n      type: \"av1c-data\",\n      data: codecPrivate2\n    } : codecEnum === \"h265\" ? {\n      type: \"hvcc-data\",\n      data: codecPrivate2\n    } : codecEnum === \"vp8\" ? {\n      type: \"unknown-data\",\n      data: codecPrivate2\n    } : codecEnum === \"vp9\" ? {\n      type: \"unknown-data\",\n      data: codecPrivate2\n    } : null;\n    const advancedColor = colour ? parseColorSegment(colour) : {\n      fullRange: null,\n      matrix: null,\n      primaries: null,\n      transfer: null\n    };\n    return {\n      m3uStreamFormat: null,\n      type: \"video\",\n      trackId,\n      codec: codecString,\n      description: getDescription(track),\n      height: displayHeight2 ? displayHeight2.value.value : height.value.value,\n      width: displayWidth2 ? displayWidth2.value.value : width.value.value,\n      sampleAspectRatio: {\n        numerator: 1,\n        denominator: 1\n      },\n      originalTimescale: timescale,\n      codedHeight: height.value.value,\n      codedWidth: width.value.value,\n      displayAspectHeight: displayHeight2 ? displayHeight2.value.value : height.value.value,\n      displayAspectWidth: displayWidth2 ? displayWidth2.value.value : width.value.value,\n      rotation: 0,\n      codecData,\n      colorSpace: mediaParserAdvancedColorToWebCodecsColor(advancedColor),\n      advancedColor,\n      codecEnum,\n      fps: null,\n      startInSeconds: 0,\n      timescale: esm_WEBCODECS_TIMESCALE,\n      trackMediaTimeOffsetInTrackTimescale: 0\n    };\n  }\n  if (trackTypeToString(trackType2.value.value) === \"audio\") {\n    const sampleRate = getSampleRate(track);\n    const numberOfChannels = getNumberOfChannels(track);\n    const codecPrivate2 = getPrivateData(track);\n    if (sampleRate === null) {\n      throw new Error(\"Could not find sample rate or number of channels\");\n    }\n    const codecString = getMatroskaAudioCodecString(track);\n    return {\n      type: \"audio\",\n      trackId,\n      codec: codecString,\n      originalTimescale: timescale,\n      numberOfChannels,\n      sampleRate,\n      description: getAudioDescription(track),\n      codecData: codecPrivate2 ? codecString === \"opus\" ? { type: \"ogg-identification\", data: codecPrivate2 } : { type: \"unknown-data\", data: codecPrivate2 } : null,\n      codecEnum: getMatroskaAudioCodecEnum({\n        track\n      }),\n      startInSeconds: 0,\n      timescale: esm_WEBCODECS_TIMESCALE,\n      trackMediaTimeOffsetInTrackTimescale: 0\n    };\n  }\n  return null;\n};\n\n// src/containers/webm/get-ready-tracks.ts\nvar getTracksFromMatroska = ({\n  structureState,\n  webmState\n}) => {\n  const structure = structureState.getMatroskaStructure();\n  const mainSegment = getMainSegment(structure.boxes);\n  if (!mainSegment) {\n    throw new Error(\"No main segment\");\n  }\n  const tracksSegment = getTracksSegment(mainSegment);\n  if (!tracksSegment) {\n    throw new Error(\"No tracks segment\");\n  }\n  const resolvedTracks = [];\n  const missingInfo = [];\n  for (const trackEntrySegment of tracksSegment.value) {\n    if (trackEntrySegment.type === \"Crc32\") {\n      continue;\n    }\n    if (trackEntrySegment.type !== \"TrackEntry\") {\n      throw new Error(\"Expected track entry segment\");\n    }\n    const track = getTrack({\n      track: trackEntrySegment,\n      timescale: webmState.getTimescale()\n    });\n    if (!track) {\n      continue;\n    }\n    if (track.codec === NO_CODEC_PRIVATE_SHOULD_BE_DERIVED_FROM_SPS) {\n      const avc = webmState.getAvcProfileForTrackNumber(track.trackId);\n      if (avc) {\n        resolvedTracks.push({\n          ...track,\n          codec: getCodecStringFromSpsAndPps(avc)\n        });\n      } else {\n        missingInfo.push(track);\n      }\n    } else {\n      resolvedTracks.push(track);\n    }\n  }\n  return { missingInfo, resolved: resolvedTracks };\n};\nvar matroskaHasTracks = ({\n  structureState,\n  webmState\n}) => {\n  const structure = structureState.getMatroskaStructure();\n  const mainSegment = getMainSegment(structure.boxes);\n  if (!mainSegment) {\n    return false;\n  }\n  return getTracksSegment(mainSegment) !== null && getTracksFromMatroska({\n    structureState,\n    webmState\n  }).missingInfo.length === 0;\n};\n\n// src/get-tracks.ts\nvar isoBaseMediaHasTracks = (state, mayUsePrecomputed) => {\n  return Boolean(getMoovBoxFromState({\n    structureState: state.structure,\n    isoState: state.iso,\n    mp4HeaderSegment: state.m3uPlaylistContext?.mp4HeaderSegment ?? null,\n    mayUsePrecomputed\n  }));\n};\nvar getHasTracks = (state, mayUsePrecomputed) => {\n  const structure = state.structure.getStructure();\n  if (structure.type === \"matroska\") {\n    return matroskaHasTracks({\n      structureState: state.structure,\n      webmState: state.webm\n    });\n  }\n  if (structure.type === \"iso-base-media\") {\n    return isoBaseMediaHasTracks(state, mayUsePrecomputed);\n  }\n  if (structure.type === \"riff\") {\n    return hasAllTracksFromAvi(state);\n  }\n  if (structure.type === \"transport-stream\") {\n    return hasAllTracksFromTransportStream(state);\n  }\n  if (structure.type === \"mp3\") {\n    return state.callbacks.tracks.getTracks().length > 0;\n  }\n  if (structure.type === \"wav\") {\n    return state.callbacks.tracks.hasAllTracks();\n  }\n  if (structure.type === \"aac\") {\n    return state.callbacks.tracks.hasAllTracks();\n  }\n  if (structure.type === \"flac\") {\n    return state.callbacks.tracks.hasAllTracks();\n  }\n  if (structure.type === \"m3u\") {\n    return state.callbacks.tracks.hasAllTracks();\n  }\n  throw new Error(\"Unknown container \" + structure);\n};\nvar getCategorizedTracksFromMatroska = (state) => {\n  const { resolved } = getTracksFromMatroska({\n    structureState: state.structure,\n    webmState: state.webm\n  });\n  return resolved;\n};\nvar getTracksFromMoovBox = (moovBox) => {\n  const mediaParserTracks = [];\n  const tracks2 = getTraks(moovBox);\n  for (const trakBox of tracks2) {\n    const mvhdBox = getMvhdBox(moovBox);\n    if (!mvhdBox) {\n      throw new Error(\"Mvhd box is not found\");\n    }\n    const startTime = findTrackStartTimeInSeconds({\n      movieTimeScale: mvhdBox.timeScale,\n      trakBox\n    });\n    const track = makeBaseMediaTrack(trakBox, startTime);\n    if (!track) {\n      continue;\n    }\n    mediaParserTracks.push(track);\n  }\n  return mediaParserTracks;\n};\nvar getTracksFromIsoBaseMedia = ({\n  mayUsePrecomputed,\n  structure,\n  isoState,\n  m3uPlaylistContext\n}) => {\n  const moovBox = getMoovBoxFromState({\n    structureState: structure,\n    isoState,\n    mp4HeaderSegment: m3uPlaylistContext?.mp4HeaderSegment ?? null,\n    mayUsePrecomputed\n  });\n  if (!moovBox) {\n    return [];\n  }\n  return getTracksFromMoovBox(moovBox);\n};\nvar defaultGetTracks = (parserState) => {\n  const tracks2 = parserState.callbacks.tracks.getTracks();\n  if (tracks2.length === 0) {\n    throw new Error(\"No tracks found\");\n  }\n  return tracks2;\n};\nvar getTracks = (state, mayUsePrecomputed) => {\n  const structure = state.structure.getStructure();\n  if (structure.type === \"matroska\") {\n    return getCategorizedTracksFromMatroska(state);\n  }\n  if (structure.type === \"iso-base-media\") {\n    return getTracksFromIsoBaseMedia({\n      isoState: state.iso,\n      m3uPlaylistContext: state.m3uPlaylistContext,\n      structure: state.structure,\n      mayUsePrecomputed\n    });\n  }\n  if (structure.type === \"riff\") {\n    return getTracksFromAvi(structure, state);\n  }\n  if (structure.type === \"transport-stream\") {\n    return getTracksFromTransportStream(state);\n  }\n  if (structure.type === \"mp3\" || structure.type === \"wav\" || structure.type === \"flac\" || structure.type === \"aac\" || structure.type === \"m3u\") {\n    return defaultGetTracks(state);\n  }\n  throw new Error(`Unknown container${structure}`);\n};\n\n// src/get-audio-codec.ts\nvar getAudioCodec = (parserState) => {\n  const tracks2 = getTracks(parserState, true);\n  if (tracks2.length === 0) {\n    throw new Error(\"No tracks yet\");\n  }\n  const audioTrack = tracks2.find((t) => t.type === \"audio\");\n  if (!audioTrack) {\n    return null;\n  }\n  if (audioTrack.type === \"audio\") {\n    return audioTrack.codecEnum;\n  }\n  return null;\n};\nvar hasAudioCodec = (state) => {\n  return getHasTracks(state, true);\n};\nvar getCodecSpecificatorFromEsdsBox = ({\n  child\n}) => {\n  const descriptor = child.descriptors.find((d) => d.type === \"decoder-config-descriptor\");\n  if (!descriptor) {\n    throw new Error(\"No decoder-config-descriptor\");\n  }\n  if (descriptor.type !== \"decoder-config-descriptor\") {\n    throw new Error(\"Expected decoder-config-descriptor\");\n  }\n  if (descriptor.asNumber !== 64) {\n    return {\n      primary: descriptor.asNumber,\n      secondary: null,\n      description: undefined\n    };\n  }\n  const audioSpecificConfig = descriptor.decoderSpecificConfigs.find((d) => {\n    return d.type === \"mp4a-specific-config\" ? d : null;\n  });\n  if (!audioSpecificConfig || audioSpecificConfig.type !== \"mp4a-specific-config\") {\n    throw new Error(\"No audio-specific-config\");\n  }\n  return {\n    primary: descriptor.asNumber,\n    secondary: audioSpecificConfig.audioObjectType,\n    description: audioSpecificConfig.asBytes\n  };\n};\nvar getCodecPrivateFromTrak = (trakBox) => {\n  const stsdBox = getStsdBox(trakBox);\n  if (!stsdBox) {\n    return null;\n  }\n  const audioSample = stsdBox.samples.find((s) => s.type === \"audio\");\n  if (!audioSample || audioSample.type !== \"audio\") {\n    return null;\n  }\n  const esds = audioSample.children.find((b) => b.type === \"esds-box\");\n  if (!esds || esds.type !== \"esds-box\") {\n    return null;\n  }\n  const decoderConfigDescriptor = esds.descriptors.find((d) => d.type === \"decoder-config-descriptor\");\n  if (!decoderConfigDescriptor) {\n    return null;\n  }\n  const mp4a = decoderConfigDescriptor.decoderSpecificConfigs.find((d) => d.type === \"mp4a-specific-config\");\n  if (!mp4a) {\n    return null;\n  }\n  return { type: \"aac-config\", data: mp4a.asBytes };\n};\nvar onSample = (sample, children) => {\n  const child = children.find((c) => c.type === \"esds-box\");\n  if (child && child.type === \"esds-box\") {\n    const ret = getCodecSpecificatorFromEsdsBox({ child });\n    return {\n      format: sample.format,\n      primarySpecificator: ret.primary,\n      secondarySpecificator: ret.secondary,\n      description: ret.description\n    };\n  }\n  return {\n    format: sample.format,\n    primarySpecificator: null,\n    secondarySpecificator: null,\n    description: undefined\n  };\n};\nvar getNumberOfChannelsFromTrak = (trak) => {\n  const stsdBox = getStsdBox(trak);\n  if (!stsdBox) {\n    return null;\n  }\n  const sample = stsdBox.samples.find((s) => s.type === \"audio\");\n  if (!sample || sample.type !== \"audio\") {\n    return null;\n  }\n  return sample.numberOfChannels;\n};\nvar getSampleRate2 = (trak) => {\n  const stsdBox = getStsdBox(trak);\n  if (!stsdBox) {\n    return null;\n  }\n  const sample = stsdBox.samples.find((s) => s.type === \"audio\");\n  if (!sample || sample.type !== \"audio\") {\n    return null;\n  }\n  return sample.sampleRate;\n};\nvar getAudioCodecFromTrak = (trak) => {\n  const stsdBox = getStsdBox(trak);\n  if (!stsdBox) {\n    return null;\n  }\n  const sample = stsdBox.samples.find((s) => s.type === \"audio\");\n  if (!sample || sample.type !== \"audio\") {\n    return null;\n  }\n  const waveBox = sample.children.find((b) => b.type === \"regular-box\" && b.boxType === \"wave\");\n  if (waveBox && waveBox.type === \"regular-box\" && waveBox.boxType === \"wave\") {\n    const esdsSample = onSample(sample, waveBox.children);\n    if (esdsSample) {\n      return esdsSample;\n    }\n  }\n  const ret = onSample(sample, sample.children);\n  if (ret) {\n    return ret;\n  }\n  return null;\n};\nvar isLpcmAudioCodec = (trak) => {\n  return getAudioCodecFromTrak(trak)?.format === \"lpcm\";\n};\nvar isIn24AudioCodec = (trak) => {\n  return getAudioCodecFromTrak(trak)?.format === \"in24\";\n};\nvar isTwosAudioCodec = (trak) => {\n  return getAudioCodecFromTrak(trak)?.format === \"twos\";\n};\nvar getAudioCodecStringFromTrak = (trak) => {\n  const codec = getAudioCodecFromTrak(trak);\n  if (!codec) {\n    throw new Error(\"Expected codec\");\n  }\n  if (codec.format === \"lpcm\") {\n    return {\n      codecString: \"pcm-s16\",\n      description: codec.description ? { type: \"unknown-data\", data: codec.description } : undefined\n    };\n  }\n  if (codec.format === \"twos\") {\n    return {\n      codecString: \"pcm-s16\",\n      description: codec.description ? { type: \"unknown-data\", data: codec.description } : undefined\n    };\n  }\n  if (codec.format === \"in24\") {\n    return {\n      codecString: \"pcm-s24\",\n      description: codec.description ? { type: \"unknown-data\", data: codec.description } : undefined\n    };\n  }\n  const codecStringWithoutMp3Exception = [\n    codec.format,\n    codec.primarySpecificator ? codec.primarySpecificator.toString(16) : null,\n    codec.secondarySpecificator ? codec.secondarySpecificator.toString().padStart(2, \"0\") : null\n  ].filter(Boolean).join(\".\");\n  const codecString = codecStringWithoutMp3Exception.toLowerCase() === \"mp4a.6b\" || codecStringWithoutMp3Exception.toLowerCase() === \"mp4a.69\" ? \"mp3\" : codecStringWithoutMp3Exception;\n  if (codecString === \"mp3\") {\n    return {\n      codecString,\n      description: codec.description ? {\n        type: \"unknown-data\",\n        data: codec.description\n      } : undefined\n    };\n  }\n  if (codecString.startsWith(\"mp4a.\")) {\n    return {\n      codecString,\n      description: codec.description ? {\n        type: \"aac-config\",\n        data: codec.description\n      } : undefined\n    };\n  }\n  return {\n    codecString,\n    description: codec.description ? {\n      type: \"unknown-data\",\n      data: codec.description\n    } : undefined\n  };\n};\nvar getAudioCodecFromAudioCodecInfo = (codec) => {\n  if (codec.format === \"twos\") {\n    return \"pcm-s16\";\n  }\n  if (codec.format === \"in24\") {\n    return \"pcm-s24\";\n  }\n  if (codec.format === \"lpcm\") {\n    return \"pcm-s16\";\n  }\n  if (codec.format === \"sowt\") {\n    return \"aiff\";\n  }\n  if (codec.format === \"ac-3\") {\n    return \"ac3\";\n  }\n  if (codec.format === \"Opus\") {\n    return \"opus\";\n  }\n  if (codec.format === \"mp4a\") {\n    if (codec.primarySpecificator === 64) {\n      return \"aac\";\n    }\n    if (codec.primarySpecificator === 107) {\n      return \"mp3\";\n    }\n    if (codec.primarySpecificator === null) {\n      return \"aac\";\n    }\n    throw new Error(\"Unknown mp4a codec: \" + codec.primarySpecificator);\n  }\n  throw new Error(`Unknown audio format: ${codec.format}`);\n};\nvar getAudioCodecFromTrack = (track) => {\n  const audioSample = getAudioCodecFromTrak(track);\n  if (!audioSample) {\n    throw new Error(\"Could not find audio sample\");\n  }\n  return getAudioCodecFromAudioCodecInfo(audioSample);\n};\n\n// src/is-audio-structure.ts\nvar isAudioStructure = (structure) => {\n  if (structure.type === \"mp3\") {\n    return true;\n  }\n  if (structure.type === \"wav\") {\n    return true;\n  }\n  if (structure.type === \"aac\") {\n    return true;\n  }\n  if (structure.type === \"flac\") {\n    return true;\n  }\n  if (structure.type === \"iso-base-media\") {\n    return false;\n  }\n  if (structure.type === \"matroska\") {\n    return false;\n  }\n  if (structure.type === \"transport-stream\") {\n    return false;\n  }\n  if (structure.type === \"riff\") {\n    return false;\n  }\n  if (structure.type === \"m3u\") {\n    return false;\n  }\n  throw new Error(`Unhandled structure type: ${structure}`);\n};\n\n// src/get-fps.ts\nvar calculateFps = ({\n  sttsBox,\n  timeScale,\n  durationInSamples\n}) => {\n  let totalSamples = 0;\n  for (const sample of sttsBox.sampleDistribution) {\n    totalSamples += sample.sampleCount;\n  }\n  if (totalSamples === 0) {\n    return null;\n  }\n  const durationInSeconds = durationInSamples / timeScale;\n  const fps = totalSamples / durationInSeconds;\n  return fps;\n};\nvar trakBoxContainsAudio = (trakBox) => {\n  const stsd = getStsdBox(trakBox);\n  if (!stsd) {\n    return false;\n  }\n  const videoSample = stsd.samples.find((s) => s.type === \"audio\");\n  if (!videoSample || videoSample.type !== \"audio\") {\n    return false;\n  }\n  return true;\n};\nvar trakBoxContainsVideo = (trakBox) => {\n  const stsd = getStsdBox(trakBox);\n  if (!stsd) {\n    return false;\n  }\n  const videoSample = stsd.samples.find((s) => s.type === \"video\");\n  if (!videoSample || videoSample.type !== \"video\") {\n    return false;\n  }\n  return true;\n};\nvar getTimescaleAndDuration = (trakBox) => {\n  const mdhdBox = getMdhdBox(trakBox);\n  if (mdhdBox) {\n    return { timescale: mdhdBox.timescale, duration: mdhdBox.duration };\n  }\n  return null;\n};\nvar getFpsFromMp4TrakBox = (trakBox) => {\n  const timescaleAndDuration = getTimescaleAndDuration(trakBox);\n  if (!timescaleAndDuration) {\n    return null;\n  }\n  const sttsBox = getSttsBox(trakBox);\n  if (!sttsBox) {\n    return null;\n  }\n  return calculateFps({\n    sttsBox,\n    timeScale: timescaleAndDuration.timescale,\n    durationInSamples: timescaleAndDuration.duration\n  });\n};\nvar getFpsFromIsoMaseMedia = (state) => {\n  const moovBox = getMoovBoxFromState({\n    structureState: state.structure,\n    isoState: state.iso,\n    mp4HeaderSegment: state.m3uPlaylistContext?.mp4HeaderSegment ?? null,\n    mayUsePrecomputed: true\n  });\n  if (!moovBox) {\n    return null;\n  }\n  const trackBoxes = getTraks(moovBox);\n  const trackBox = trackBoxes.find(trakBoxContainsVideo);\n  if (!trackBox) {\n    return null;\n  }\n  return getFpsFromMp4TrakBox(trackBox);\n};\nvar getFpsFromAvi = (structure) => {\n  const strl = getStrlBoxes(structure);\n  for (const s of strl) {\n    const strh = getStrhBox(s.children);\n    if (!strh) {\n      throw new Error(\"No strh box\");\n    }\n    if (strh.fccType === \"auds\") {\n      continue;\n    }\n    return strh.rate;\n  }\n  return null;\n};\nvar getFps = (state) => {\n  const segments = state.structure.getStructure();\n  if (segments.type === \"iso-base-media\") {\n    return getFpsFromIsoMaseMedia(state);\n  }\n  if (segments.type === \"riff\") {\n    return getFpsFromAvi(segments);\n  }\n  if (segments.type === \"matroska\") {\n    return null;\n  }\n  if (segments.type === \"transport-stream\") {\n    return null;\n  }\n  if (segments.type === \"m3u\") {\n    return null;\n  }\n  if (segments.type === \"mp3\" || segments.type === \"wav\" || segments.type === \"flac\" || segments.type === \"aac\") {\n    return null;\n  }\n  throw new Error(\"Cannot get fps, not implemented: \" + segments);\n};\nvar hasFpsSuitedForSlowFps = (state) => {\n  try {\n    return getFps(state) !== null;\n  } catch {\n    return false;\n  }\n};\nvar hasFps = (state) => {\n  const structure = state.structure.getStructure();\n  if (isAudioStructure(structure)) {\n    return true;\n  }\n  if (structure.type === \"matroska\") {\n    return true;\n  }\n  if (structure.type === \"transport-stream\") {\n    return true;\n  }\n  if (structure.type === \"m3u\") {\n    return true;\n  }\n  return hasFpsSuitedForSlowFps(state);\n};\n\n// src/get-sample-aspect-ratio.ts\nvar getStsdVideoConfig = (trakBox) => {\n  const stsdBox = getStsdBox(trakBox);\n  if (!stsdBox) {\n    return null;\n  }\n  const videoConfig = stsdBox.samples.find((s) => s.type === \"video\");\n  if (!videoConfig || videoConfig.type !== \"video\") {\n    return null;\n  }\n  return videoConfig;\n};\nvar getAvccBox = (trakBox) => {\n  const videoConfig = getStsdVideoConfig(trakBox);\n  if (!videoConfig) {\n    return null;\n  }\n  const avccBox = videoConfig.descriptors.find((c) => c.type === \"avcc-box\");\n  if (!avccBox || avccBox.type !== \"avcc-box\") {\n    return null;\n  }\n  return avccBox;\n};\nvar getVpccBox = (trakBox) => {\n  const videoConfig = getStsdVideoConfig(trakBox);\n  if (!videoConfig) {\n    return null;\n  }\n  const vpccBox = videoConfig.descriptors.find((c) => c.type === \"vpcc-box\");\n  if (!vpccBox || vpccBox.type !== \"vpcc-box\") {\n    return null;\n  }\n  return vpccBox;\n};\nvar getAv1CBox = (trakBox) => {\n  const videoConfig = getStsdVideoConfig(trakBox);\n  if (!videoConfig) {\n    return null;\n  }\n  const av1cBox = videoConfig.descriptors.find((c) => c.type === \"av1C-box\");\n  if (!av1cBox || av1cBox.type !== \"av1C-box\") {\n    return null;\n  }\n  return av1cBox;\n};\nvar getPaspBox = (trakBox) => {\n  const videoConfig = getStsdVideoConfig(trakBox);\n  if (!videoConfig) {\n    return null;\n  }\n  const paspBox = videoConfig.descriptors.find((c) => c.type === \"pasp-box\");\n  if (!paspBox || paspBox.type !== \"pasp-box\") {\n    return null;\n  }\n  return paspBox;\n};\nvar getHvccBox = (trakBox) => {\n  const videoConfig = getStsdVideoConfig(trakBox);\n  if (!videoConfig) {\n    return null;\n  }\n  const hvccBox = videoConfig.descriptors.find((c) => c.type === \"hvcc-box\");\n  if (!hvccBox || hvccBox.type !== \"hvcc-box\") {\n    return null;\n  }\n  return hvccBox;\n};\nvar getSampleAspectRatio = (trakBox) => {\n  const paspBox = getPaspBox(trakBox);\n  if (!paspBox) {\n    return {\n      numerator: 1,\n      denominator: 1\n    };\n  }\n  return {\n    numerator: paspBox.hSpacing,\n    denominator: paspBox.vSpacing\n  };\n};\nvar getColrBox = (videoSample) => {\n  const colrBox = videoSample.descriptors.find((c) => c.type === \"colr-box\");\n  if (!colrBox || colrBox.type !== \"colr-box\") {\n    return null;\n  }\n  return colrBox;\n};\nvar applyTkhdBox = (aspectRatioApplied, tkhdBox) => {\n  if (tkhdBox === null || tkhdBox.rotation === 0) {\n    return {\n      displayAspectWidth: aspectRatioApplied.width,\n      displayAspectHeight: aspectRatioApplied.height,\n      width: aspectRatioApplied.width,\n      height: aspectRatioApplied.height,\n      rotation: 0\n    };\n  }\n  return {\n    width: tkhdBox.width,\n    height: tkhdBox.height,\n    rotation: tkhdBox.rotation,\n    displayAspectWidth: aspectRatioApplied.width,\n    displayAspectHeight: aspectRatioApplied.height\n  };\n};\nvar applyAspectRatios = ({\n  dimensions,\n  sampleAspectRatio,\n  displayAspectRatio\n}) => {\n  if (displayAspectRatio.numerator === 0) {\n    return dimensions;\n  }\n  if (displayAspectRatio.denominator === 0) {\n    return dimensions;\n  }\n  const newWidth = Math.round(dimensions.width * sampleAspectRatio.numerator / sampleAspectRatio.denominator);\n  const newHeight = Math.floor(newWidth / (displayAspectRatio.numerator / displayAspectRatio.denominator));\n  return {\n    width: Math.floor(newWidth),\n    height: newHeight\n  };\n};\nfunction gcd(a, b) {\n  return b === 0 ? a : gcd(b, a % b);\n}\nfunction reduceFraction(numerator, denominator) {\n  const greatestCommonDivisor = gcd(Math.abs(numerator), Math.abs(denominator));\n  return {\n    numerator: numerator / greatestCommonDivisor,\n    denominator: denominator / greatestCommonDivisor\n  };\n}\nvar getDisplayAspectRatio = ({\n  sampleAspectRatio,\n  nativeDimensions\n}) => {\n  const num = Math.round(nativeDimensions.width * sampleAspectRatio.numerator);\n  const den = Math.round(nativeDimensions.height * sampleAspectRatio.denominator);\n  return reduceFraction(num, den);\n};\n\n// src/get-video-codec.ts\nvar getVideoCodec = (state) => {\n  const track = getTracks(state, true);\n  return track.find((t) => t.type === \"video\")?.codecEnum ?? null;\n};\nvar hasVideoCodec = (state) => {\n  return getHasTracks(state, true);\n};\nvar getVideoPrivateData = (trakBox) => {\n  const videoSample = getStsdVideoConfig(trakBox);\n  const avccBox = getAvccBox(trakBox);\n  const hvccBox = getHvccBox(trakBox);\n  const av1cBox = getAv1CBox(trakBox);\n  if (!videoSample) {\n    return null;\n  }\n  if (avccBox) {\n    return { type: \"avc-sps-pps\", data: avccBox.privateData };\n  }\n  if (hvccBox) {\n    return { type: \"hvcc-data\", data: hvccBox.privateData };\n  }\n  if (av1cBox) {\n    return { type: \"av1c-data\", data: av1cBox.privateData };\n  }\n  return null;\n};\nvar getIsoBmColrConfig = (trakBox) => {\n  const videoSample = getStsdVideoConfig(trakBox);\n  if (!videoSample) {\n    return null;\n  }\n  const colrAtom = getColrBox(videoSample);\n  if (!colrAtom) {\n    return null;\n  }\n  if (colrAtom.colorType !== \"transfer-characteristics\") {\n    return null;\n  }\n  return {\n    fullRange: colrAtom.fullRangeFlag,\n    matrix: getMatrixCoefficientsFromIndex(colrAtom.matrixIndex),\n    primaries: getPrimariesFromIndex(colrAtom.primaries),\n    transfer: getTransferCharacteristicsFromIndex(colrAtom.transfer)\n  };\n};\nvar getVideoCodecString = (trakBox) => {\n  const videoSample = getStsdVideoConfig(trakBox);\n  const avccBox = getAvccBox(trakBox);\n  if (!videoSample) {\n    return null;\n  }\n  if (avccBox) {\n    return `${videoSample.format}.${avccBox.configurationString}`;\n  }\n  const hvccBox = getHvccBox(trakBox);\n  if (hvccBox) {\n    return `${videoSample.format}.${hvccBox.configurationString}`;\n  }\n  const av1cBox = getAv1CBox(trakBox);\n  if (av1cBox) {\n    const colrAtom = getColrBox(videoSample);\n    return parseAv1PrivateData(av1cBox.privateData, colrAtom);\n  }\n  const vpccBox = getVpccBox(trakBox);\n  if (vpccBox) {\n    return `${videoSample.format}.${vpccBox.codecString}`;\n  }\n  return videoSample.format;\n};\n\n// src/normalize-video-rotation.ts\nvar normalizeVideoRotation = (rotation) => {\n  return (rotation % 360 + 360) % 360;\n};\n\n// src/containers/iso-base-media/get-actual-number-of-channels.ts\nvar getActualDecoderParameters = ({\n  audioCodec,\n  codecPrivate: codecPrivate2,\n  numberOfChannels,\n  sampleRate\n}) => {\n  if (audioCodec !== \"aac\") {\n    return {\n      numberOfChannels,\n      sampleRate,\n      codecPrivate: codecPrivate2\n    };\n  }\n  if (codecPrivate2 === null) {\n    return { numberOfChannels, sampleRate, codecPrivate: codecPrivate2 };\n  }\n  if (codecPrivate2.type !== \"aac-config\") {\n    throw new Error(\"Expected AAC codec private data\");\n  }\n  const parsed = parseAacCodecPrivate(codecPrivate2.data);\n  const actual = createAacCodecPrivate({\n    ...parsed,\n    codecPrivate: codecPrivate2.data\n  });\n  return {\n    numberOfChannels: parsed.channelConfiguration,\n    sampleRate: parsed.sampleRate,\n    codecPrivate: { type: \"aac-config\", data: actual }\n  };\n};\n\n// src/containers/iso-base-media/get-video-codec-from-iso-track.ts\nvar getVideoCodecFromIsoTrak = (trakBox) => {\n  const stsdBox = getStsdBox(trakBox);\n  if (stsdBox && stsdBox.type === \"stsd-box\") {\n    const videoSample = stsdBox.samples.find((s) => s.type === \"video\");\n    if (videoSample && videoSample.type === \"video\") {\n      if (videoSample.format === \"hvc1\" || videoSample.format === \"hev1\") {\n        return \"h265\";\n      }\n      if (videoSample.format === \"avc1\") {\n        return \"h264\";\n      }\n      if (videoSample.format === \"av01\") {\n        return \"av1\";\n      }\n      if (videoSample.format === \"vp09\") {\n        return \"vp9\";\n      }\n      if (videoSample.format === \"ap4h\") {\n        return \"prores\";\n      }\n      if (videoSample.format === \"ap4x\") {\n        return \"prores\";\n      }\n      if (videoSample.format === \"apch\") {\n        return \"prores\";\n      }\n      if (videoSample.format === \"apcn\") {\n        return \"prores\";\n      }\n      if (videoSample.format === \"apcs\") {\n        return \"prores\";\n      }\n      if (videoSample.format === \"apco\") {\n        return \"prores\";\n      }\n      if (videoSample.format === \"aprh\") {\n        return \"prores\";\n      }\n      if (videoSample.format === \"aprn\") {\n        return \"prores\";\n      }\n    }\n  }\n  throw new Error(\"Could not find video codec\");\n};\n\n// src/containers/iso-base-media/make-track.ts\nvar makeBaseMediaTrack = (trakBox, startTimeInSeconds) => {\n  const tkhdBox = getTkhdBox(trakBox);\n  const videoDescriptors = getVideoDescriptors(trakBox);\n  const timescaleAndDuration = getTimescaleAndDuration(trakBox);\n  if (!tkhdBox) {\n    throw new Error(\"Expected tkhd box in trak box\");\n  }\n  if (!timescaleAndDuration) {\n    throw new Error(\"Expected timescale and duration in trak box\");\n  }\n  if (trakBoxContainsAudio(trakBox)) {\n    const numberOfChannels = getNumberOfChannelsFromTrak(trakBox);\n    if (numberOfChannels === null) {\n      throw new Error(\"Could not find number of channels\");\n    }\n    const sampleRate = getSampleRate2(trakBox);\n    if (sampleRate === null) {\n      throw new Error(\"Could not find sample rate\");\n    }\n    const { codecString, description } = getAudioCodecStringFromTrak(trakBox);\n    const codecPrivate2 = getCodecPrivateFromTrak(trakBox) ?? description ?? null;\n    const codecEnum = getAudioCodecFromTrack(trakBox);\n    const actual = getActualDecoderParameters({\n      audioCodec: codecEnum,\n      codecPrivate: codecPrivate2 ?? null,\n      numberOfChannels,\n      sampleRate\n    });\n    return {\n      type: \"audio\",\n      trackId: tkhdBox.trackId,\n      originalTimescale: timescaleAndDuration.timescale,\n      codec: codecString,\n      numberOfChannels: actual.numberOfChannels,\n      sampleRate: actual.sampleRate,\n      description: actual.codecPrivate?.data ?? undefined,\n      codecData: actual.codecPrivate,\n      codecEnum,\n      startInSeconds: startTimeInSeconds,\n      timescale: esm_WEBCODECS_TIMESCALE,\n      trackMediaTimeOffsetInTrackTimescale: findTrackMediaTimeOffsetInTrackTimescale({\n        trakBox\n      })\n    };\n  }\n  if (!trakBoxContainsVideo(trakBox)) {\n    return {\n      type: \"other\",\n      trackId: tkhdBox.trackId,\n      originalTimescale: timescaleAndDuration.timescale,\n      trakBox,\n      startInSeconds: startTimeInSeconds,\n      timescale: esm_WEBCODECS_TIMESCALE,\n      trackMediaTimeOffsetInTrackTimescale: findTrackMediaTimeOffsetInTrackTimescale({\n        trakBox\n      })\n    };\n  }\n  const videoSample = getStsdVideoConfig(trakBox);\n  if (!videoSample) {\n    throw new Error(\"No video sample\");\n  }\n  const sampleAspectRatio = getSampleAspectRatio(trakBox);\n  const aspectRatioApplied = applyAspectRatios({\n    dimensions: videoSample,\n    sampleAspectRatio,\n    displayAspectRatio: getDisplayAspectRatio({\n      sampleAspectRatio,\n      nativeDimensions: videoSample\n    })\n  });\n  const { displayAspectHeight, displayAspectWidth, height, rotation, width } = applyTkhdBox(aspectRatioApplied, tkhdBox);\n  const codec = getVideoCodecString(trakBox);\n  if (!codec) {\n    throw new Error(\"Could not find video codec\");\n  }\n  const privateData = getVideoPrivateData(trakBox);\n  const advancedColor = getIsoBmColrConfig(trakBox) ?? {\n    fullRange: null,\n    matrix: null,\n    primaries: null,\n    transfer: null\n  };\n  const track = {\n    m3uStreamFormat: null,\n    type: \"video\",\n    trackId: tkhdBox.trackId,\n    description: videoDescriptors ?? undefined,\n    originalTimescale: timescaleAndDuration.timescale,\n    codec,\n    sampleAspectRatio: getSampleAspectRatio(trakBox),\n    width,\n    height,\n    codedWidth: videoSample.width,\n    codedHeight: videoSample.height,\n    displayAspectWidth,\n    displayAspectHeight,\n    rotation: normalizeVideoRotation(0 - rotation),\n    codecData: privateData,\n    colorSpace: mediaParserAdvancedColorToWebCodecsColor(advancedColor),\n    advancedColor,\n    codecEnum: getVideoCodecFromIsoTrak(trakBox),\n    fps: getFpsFromMp4TrakBox(trakBox),\n    startInSeconds: startTimeInSeconds,\n    timescale: esm_WEBCODECS_TIMESCALE,\n    trackMediaTimeOffsetInTrackTimescale: findTrackMediaTimeOffsetInTrackTimescale({\n      trakBox\n    })\n  };\n  return track;\n};\n\n// src/containers/iso-base-media/mdhd.ts\nvar parseMdhd = ({\n  data,\n  size,\n  fileOffset\n}) => {\n  const version = data.getUint8();\n  data.discard(3);\n  const creationTime = version === 1 ? Number(data.getUint64()) : data.getUint32();\n  const modificationTime = version === 1 ? Number(data.getUint64()) : data.getUint32();\n  const timescale = data.getUint32();\n  const duration2 = version === 1 ? data.getUint64() : data.getUint32();\n  const language2 = data.getUint16();\n  const quality = data.getUint16();\n  const remaining = size - (data.counter.getOffset() - fileOffset);\n  if (remaining !== 0) {\n    throw new Error(`Expected remaining bytes to be 0, got ${remaining}`);\n  }\n  return {\n    type: \"mdhd-box\",\n    duration: Number(duration2),\n    timescale,\n    version,\n    language: language2,\n    quality,\n    creationTime,\n    modificationTime\n  };\n};\n\n// src/containers/iso-base-media/meta/hdlr.ts\nvar parseHdlr = ({\n  iterator,\n  size,\n  offset\n}) => {\n  const box = iterator.startBox(size - 8);\n  const version = iterator.getUint8();\n  if (version !== 0) {\n    throw new Error(`Unsupported hdlr version: ${version}`);\n  }\n  iterator.discard(3);\n  iterator.discard(4);\n  const hdlrType = iterator.getByteString(4, false);\n  iterator.discard(4);\n  iterator.discard(4);\n  iterator.discard(4);\n  const componentName = iterator.readUntilNullTerminator();\n  box.discardRest();\n  return Promise.resolve({\n    type: \"hdlr-box\",\n    boxSize: size,\n    offset,\n    hdlrType,\n    componentName\n  });\n};\n\n// src/containers/iso-base-media/meta/ilst.ts\nvar parseFromWellKnownType = (wellKnownType, iterator, size) => {\n  if (wellKnownType === 1) {\n    const value = iterator.getByteString(size, false);\n    return { type: \"text\", value };\n  }\n  if (wellKnownType === 21) {\n    if (size === 1) {\n      return { type: \"number\", value: iterator.getInt8() };\n    }\n    if (size === 2) {\n      return { type: \"number\", value: iterator.getInt16() };\n    }\n    if (size === 3) {\n      return { type: \"number\", value: iterator.getInt24() };\n    }\n    if (size === 4) {\n      return { type: \"number\", value: iterator.getInt32() };\n    }\n    if (size === 8) {\n      return { type: \"number\", value: Number(iterator.getInt64()) };\n    }\n    throw new Error(`Weird size for number ${size}`);\n  }\n  if (wellKnownType === 22) {\n    if (size === 1) {\n      return { type: \"number\", value: iterator.getUint8() };\n    }\n    if (size === 2) {\n      return { type: \"number\", value: iterator.getUint16() };\n    }\n    if (size === 3) {\n      return { type: \"number\", value: iterator.getUint24() };\n    }\n    if (size === 4) {\n      return { type: \"number\", value: iterator.getUint32() };\n    }\n    throw new Error(`Weird size for number ${size}`);\n  }\n  if (wellKnownType === 23) {\n    if (size === 4) {\n      return { type: \"number\", value: iterator.getFloat32() };\n    }\n    if (size === 8) {\n      return { type: \"number\", value: iterator.getFloat64() };\n    }\n    throw new Error(`Weird size for number ${size}`);\n  }\n  iterator.discard(size);\n  return { type: \"unknown\", value: null };\n};\nvar parseIlstBox = ({\n  iterator,\n  size,\n  offset\n}) => {\n  const box = iterator.startBox(size - 8);\n  const entries = [];\n  while (iterator.counter.getOffset() < size + offset) {\n    const metadataSize = iterator.getUint32();\n    const index = iterator.getAtom();\n    if (!index.startsWith(\"ï¿½\") && !index.startsWith(\"\\x00\")) {\n      if (index === \"skip\") {\n        iterator.discard(metadataSize - 8);\n        continue;\n      }\n      if (index === \"----\") {\n        iterator.discard(metadataSize - 8);\n        continue;\n      }\n      iterator.discard(metadataSize - 8);\n      continue;\n    }\n    const innerSize = iterator.getUint32();\n    const type = iterator.getAtom();\n    const typeIndicator = iterator.getUint8();\n    if (typeIndicator !== 0) {\n      throw new Error(\"Expected type indicator to be 0\");\n    }\n    const wellKnownType = iterator.getUint24();\n    iterator.discard(4);\n    const value = parseFromWellKnownType(wellKnownType, iterator, innerSize - 16);\n    entries.push({ index, type, wellKnownType, value });\n  }\n  box.discardRest();\n  return {\n    type: \"ilst-box\",\n    boxSize: size,\n    offset,\n    entries\n  };\n};\n\n// src/containers/iso-base-media/mfra/tfra.ts\nvar readTrafNumber = (iterator, lengthSizeOfTrafNum) => {\n  const uintTypeTrafNum = (lengthSizeOfTrafNum + 1) * 8;\n  if (uintTypeTrafNum === 8) {\n    return iterator.getUint8();\n  }\n  if (uintTypeTrafNum === 16) {\n    return iterator.getUint16();\n  }\n  if (uintTypeTrafNum === 32) {\n    return iterator.getUint32();\n  }\n  if (uintTypeTrafNum === 64) {\n    return Number(iterator.getUint64());\n  }\n  throw new Error(\"Invalid traf number size\");\n};\nvar readTrunNumber = (iterator, lengthSizeOfTrunNum) => {\n  const uintTypeTrunNum = (lengthSizeOfTrunNum + 1) * 8;\n  if (uintTypeTrunNum === 8) {\n    return iterator.getUint8();\n  }\n  if (uintTypeTrunNum === 16) {\n    return iterator.getUint16();\n  }\n  if (uintTypeTrunNum === 32) {\n    return iterator.getUint32();\n  }\n  if (uintTypeTrunNum === 64) {\n    return Number(iterator.getUint64());\n  }\n  throw new Error(\"Invalid trun number size\");\n};\nvar readSampleNumber = (iterator, lengthSizeOfSampleNum) => {\n  const uintTypeSampleNum = (lengthSizeOfSampleNum + 1) * 8;\n  if (uintTypeSampleNum === 8) {\n    return iterator.getUint8();\n  }\n  if (uintTypeSampleNum === 16) {\n    return iterator.getUint16();\n  }\n  if (uintTypeSampleNum === 32) {\n    return iterator.getUint32();\n  }\n  if (uintTypeSampleNum === 64) {\n    return Number(iterator.getUint64());\n  }\n  throw new Error(\"Invalid sample number size\");\n};\nvar readTime = (iterator, version) => {\n  if (version === 1) {\n    return Number(iterator.getUint64());\n  }\n  return iterator.getUint32();\n};\nvar readMoofOffset = (iterator, version) => {\n  if (version === 1) {\n    return Number(iterator.getUint64());\n  }\n  return iterator.getUint32();\n};\nvar parseTfraBox = ({\n  iterator,\n  size,\n  offset\n}) => {\n  const box = iterator.startBox(size - 8);\n  const version = iterator.getUint8();\n  iterator.discard(3);\n  const trackId = iterator.getUint32();\n  iterator.getUint24();\n  const tmpByte = iterator.getUint8();\n  const lengthSizeOfTrafNum = tmpByte >> 4 & 3;\n  const lengthSizeOfTrunNum = tmpByte >> 2 & 3;\n  const lengthSizeOfSampleNum = tmpByte & 3;\n  const numberOfEntries = iterator.getUint32();\n  const entries = [];\n  for (let i = 0;i < numberOfEntries; i++) {\n    const time = readTime(iterator, version);\n    const moofOffset = readMoofOffset(iterator, version);\n    const trafNumber = readTrafNumber(iterator, lengthSizeOfTrafNum);\n    const trunNumber = readTrunNumber(iterator, lengthSizeOfTrunNum);\n    const sampleNumber = readSampleNumber(iterator, lengthSizeOfSampleNum);\n    entries.push({\n      time,\n      moofOffset,\n      trafNumber,\n      trunNumber,\n      sampleNumber\n    });\n  }\n  box.expectNoMoreBytes();\n  return {\n    offset,\n    boxSize: size,\n    type: \"tfra-box\",\n    entries,\n    trackId\n  };\n};\n\n// src/containers/iso-base-media/moov/moov.ts\nvar parseMoov = async ({\n  offset,\n  size,\n  onlyIfMoovAtomExpected,\n  iterator,\n  logLevel,\n  contentLength\n}) => {\n  const children = await getIsoBaseMediaChildren({\n    onlyIfMoovAtomExpected,\n    size: size - 8,\n    iterator,\n    logLevel,\n    contentLength\n  });\n  return {\n    offset,\n    boxSize: size,\n    type: \"moov-box\",\n    children\n  };\n};\n\n// src/containers/iso-base-media/moov/trex.ts\nvar parseTrex = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const box = iterator.startBox(size - 8);\n  const version = iterator.getUint8();\n  iterator.discard(3);\n  const trackId = iterator.getUint32();\n  const defaultSampleDescriptionIndex = iterator.getUint32();\n  const defaultSampleDuration = iterator.getUint32();\n  const defaultSampleSize = iterator.getUint32();\n  const defaultSampleFlags = iterator.getUint32();\n  box.expectNoMoreBytes();\n  return {\n    type: \"trex-box\",\n    boxSize: size,\n    offset,\n    trackId,\n    version,\n    defaultSampleDescriptionIndex,\n    defaultSampleDuration,\n    defaultSampleSize,\n    defaultSampleFlags\n  };\n};\n\n// src/containers/iso-base-media/stsd/av1c.ts\nvar parseAv1C = ({\n  data,\n  size\n}) => {\n  return {\n    type: \"av1C-box\",\n    privateData: data.getSlice(size - 8)\n  };\n};\n\n// src/containers/iso-base-media/stsd/avcc.ts\nvar parseAvcc = ({\n  data,\n  size\n}) => {\n  const confVersion = data.getUint8();\n  if (confVersion !== 1) {\n    throw new Error(`Unsupported AVCC version ${confVersion}`);\n  }\n  const profile = data.getUint8();\n  const profileCompatibility = data.getUint8();\n  const level = data.getUint8();\n  const str = `${profile.toString(16).padStart(2, \"0\")}${profileCompatibility.toString(16).padStart(2, \"0\")}${level.toString(16).padStart(2, \"0\")}`;\n  data.counter.decrement(4);\n  const privateData = data.getSlice(size - 8);\n  return {\n    type: \"avcc-box\",\n    privateData,\n    configurationString: str\n  };\n};\n\n// src/containers/iso-base-media/parse-icc-profile.ts\nvar parseIccProfile = (data) => {\n  const iterator = getArrayBufferIterator({\n    initialData: data,\n    maxBytes: data.length,\n    logLevel: \"error\"\n  });\n  const size = iterator.getUint32();\n  if (size !== data.length) {\n    throw new Error(\"Invalid ICC profile size\");\n  }\n  const preferredCMMType = iterator.getByteString(4, false);\n  const profileVersion = iterator.getByteString(4, false);\n  const profileDeviceClass = iterator.getByteString(4, false);\n  const colorSpace = iterator.getByteString(4, false);\n  const pcs = iterator.getByteString(4, false);\n  const dateTime = iterator.getSlice(12);\n  const signature = iterator.getByteString(4, false);\n  if (signature !== \"acsp\") {\n    throw new Error(\"Invalid ICC profile signature\");\n  }\n  const primaryPlatform = iterator.getByteString(4, false);\n  const profileFlags = iterator.getUint32();\n  const deviceManufacturer = iterator.getByteString(4, false);\n  const deviceModel = iterator.getByteString(4, false);\n  const deviceAttributes = iterator.getUint64();\n  const renderingIntent = iterator.getUint32();\n  const pcsIlluminant1 = iterator.getUint32();\n  const pcsIlluminant2 = iterator.getUint32();\n  const pcsIlluminant3 = iterator.getUint32();\n  const profileCreator = iterator.getByteString(4, false);\n  const profileId = iterator.getByteString(16, false);\n  iterator.discard(28);\n  const tagCount = iterator.getUint32();\n  const entries = [];\n  for (let i = 0;i < tagCount; i++) {\n    const entry = {\n      tag: iterator.getByteString(4, false),\n      offset: iterator.getUint32(),\n      size: iterator.getUint32()\n    };\n    entries.push(entry);\n  }\n  let lastOffset = -1;\n  let rXYZ = null;\n  let gXYZ = null;\n  let bXYZ = null;\n  let whitePoint = null;\n  for (const entry of entries) {\n    const found = data.slice(entry.offset, entry.offset + entry.size);\n    if (entry.tag === \"rXYZ\" || entry.tag === \"gXYZ\" || entry.tag === \"bXYZ\" || entry.tag === \"wtpt\") {\n      const it = getArrayBufferIterator({\n        initialData: found,\n        maxBytes: found.length,\n        logLevel: \"error\"\n      });\n      it.discard(4);\n      const x = it.getInt32() / 65536;\n      const y = it.getInt32() / 65536;\n      const z = it.getInt32() / 65536;\n      it.destroy();\n      const point = { x, y, z };\n      if (entry.tag === \"rXYZ\") {\n        rXYZ = point;\n      } else if (entry.tag === \"gXYZ\") {\n        gXYZ = point;\n      } else if (entry.tag === \"bXYZ\") {\n        bXYZ = point;\n      } else if (entry.tag === \"wtpt\") {\n        whitePoint = point;\n      }\n    }\n    if (lastOffset !== -1) {\n      const bytesToAdvance = entry.offset - lastOffset;\n      const bytesToGoBackwards = entry.size - bytesToAdvance;\n      if (bytesToGoBackwards > 0) {\n        iterator.counter.decrement(bytesToGoBackwards);\n      }\n    }\n    lastOffset = entry.offset;\n  }\n  const profile = {\n    size,\n    preferredCMMType,\n    profileVersion,\n    profileDeviceClass,\n    colorSpace,\n    pcs,\n    dateTime,\n    signature,\n    primaryPlatform,\n    profileFlags,\n    deviceManufacturer,\n    deviceModel,\n    deviceAttributes,\n    renderingIntent,\n    pcsIlluminant: [\n      pcsIlluminant1 / 65536,\n      pcsIlluminant2 / 65536,\n      pcsIlluminant3 / 65536\n    ],\n    profileCreator,\n    profileId,\n    entries,\n    bXYZ,\n    gXYZ,\n    rXYZ,\n    whitePoint\n  };\n  iterator.destroy();\n  return profile;\n};\n\n// src/containers/iso-base-media/stsd/colr.ts\nvar parseColorParameterBox = ({\n  iterator,\n  size\n}) => {\n  const byteString = iterator.getByteString(4, false);\n  if (byteString === \"nclx\") {\n    const primaries2 = iterator.getUint16();\n    const transfer = iterator.getUint16();\n    const matrixIndex = iterator.getUint16();\n    iterator.startReadingBits();\n    const fullRangeFlag = Boolean(iterator.getBits(1));\n    iterator.stopReadingBits();\n    return {\n      type: \"colr-box\",\n      colorType: \"transfer-characteristics\",\n      fullRangeFlag,\n      matrixIndex,\n      primaries: primaries2,\n      transfer\n    };\n  }\n  if (byteString === \"nclc\") {\n    const primaries2 = iterator.getUint16();\n    const transfer = iterator.getUint16();\n    const matrixIndex = iterator.getUint16();\n    return {\n      type: \"colr-box\",\n      colorType: \"transfer-characteristics\",\n      fullRangeFlag: false,\n      matrixIndex,\n      primaries: primaries2,\n      transfer\n    };\n  }\n  if (byteString === \"prof\") {\n    const profile = iterator.getSlice(size - 12);\n    return {\n      type: \"colr-box\",\n      colorType: \"icc-profile\",\n      profile,\n      parsed: parseIccProfile(profile)\n    };\n  }\n  throw new Error(\"Unexpected box type \" + byteString);\n};\n\n// src/containers/iso-base-media/stsd/ctts.ts\nvar parseCtts = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const version = iterator.getUint8();\n  if (version !== 0 && version !== 1) {\n    throw new Error(`Unsupported CTTS version ${version}`);\n  }\n  const flags = iterator.getSlice(3);\n  const entryCount = iterator.getUint32();\n  const entries = [];\n  for (let i = 0;i < entryCount; i++) {\n    const sampleCount = iterator.getUint32();\n    const sampleOffset = iterator.getInt32();\n    entries.push({\n      sampleCount,\n      sampleOffset\n    });\n  }\n  return {\n    type: \"ctts-box\",\n    boxSize: size,\n    offset,\n    version,\n    flags: [...flags],\n    entryCount,\n    entries\n  };\n};\n\n// src/containers/iso-base-media/stsd/hvcc.ts\nvar parseHvcc = ({\n  data,\n  size,\n  offset\n}) => {\n  const privateData = data.getSlice(size - 8);\n  data.counter.decrement(size - 8);\n  const constraintString = getHvc1CodecString(data);\n  const remaining = size - (data.counter.getOffset() - offset);\n  data.discard(remaining);\n  return {\n    type: \"hvcc-box\",\n    privateData,\n    configurationString: constraintString\n  };\n};\n\n// src/containers/iso-base-media/stsd/keys.ts\nvar parseKeys = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const box = iterator.startBox(size - 8);\n  const version = iterator.getUint8();\n  iterator.discard(3);\n  const entryCount = iterator.getUint32();\n  const entries = [];\n  for (let i = 0;i < entryCount; i++) {\n    const keySize = iterator.getUint32();\n    const namespace = iterator.getAtom();\n    const value = iterator.getByteString(keySize - 8, false);\n    const entry = {\n      keySize,\n      namespace,\n      value\n    };\n    entries.push(entry);\n  }\n  box.discardRest();\n  return {\n    type: \"keys-box\",\n    boxSize: size,\n    offset,\n    version,\n    entryCount,\n    entries\n  };\n};\n\n// src/containers/iso-base-media/stsd/mebx.ts\nvar parseMebx = async ({\n  offset,\n  size,\n  iterator,\n  logLevel,\n  contentLength\n}) => {\n  iterator.discard(6);\n  const dataReferenceIndex = iterator.getUint16();\n  const children = await getIsoBaseMediaChildren({\n    iterator,\n    size: size - 8,\n    logLevel,\n    onlyIfMoovAtomExpected: null,\n    contentLength\n  });\n  return {\n    type: \"mebx-box\",\n    boxSize: size,\n    offset,\n    dataReferenceIndex,\n    format: \"mebx\",\n    children\n  };\n};\n\n// src/containers/iso-base-media/stsd/pasp.ts\nvar parsePasp = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const hSpacing = iterator.getUint32();\n  const vSpacing = iterator.getUint32();\n  const bytesRemainingInBox = size - (iterator.counter.getOffset() - offset);\n  iterator.discard(bytesRemainingInBox);\n  return {\n    type: \"pasp-box\",\n    boxSize: size,\n    offset,\n    hSpacing,\n    vSpacing\n  };\n};\n\n// src/containers/iso-base-media/stsd/stco.ts\nvar parseStco = ({\n  iterator,\n  offset,\n  size,\n  mode64Bit\n}) => {\n  const version = iterator.getUint8();\n  if (version !== 0) {\n    throw new Error(`Unsupported STSD version ${version}`);\n  }\n  const flags = iterator.getSlice(3);\n  const entryCount = iterator.getUint32();\n  const entries = [];\n  for (let i = 0;i < entryCount; i++) {\n    const bytesRemaining = size - (iterator.counter.getOffset() - offset);\n    if (bytesRemaining < 4) {\n      break;\n    }\n    entries.push(mode64Bit ? iterator.getUint64() : iterator.getUint32());\n  }\n  iterator.discard(size - (iterator.counter.getOffset() - offset));\n  return {\n    type: \"stco-box\",\n    boxSize: size,\n    offset,\n    version,\n    flags: [...flags],\n    entries,\n    entryCount\n  };\n};\n\n// src/containers/iso-base-media/stsd/stsc.ts\nvar parseStsc = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const version = iterator.getUint8();\n  if (version !== 0) {\n    throw new Error(`Unsupported STSD version ${version}`);\n  }\n  const flags = iterator.getSlice(3);\n  const entryCount = iterator.getUint32();\n  const entries = new Map;\n  for (let i = 0;i < entryCount; i++) {\n    const firstChunk = iterator.getUint32();\n    const samplesPerChunk = iterator.getUint32();\n    const sampleDescriptionIndex = iterator.getUint32();\n    if (sampleDescriptionIndex !== 1) {\n      throw new Error(`Expected sampleDescriptionIndex to be 1, but got ${sampleDescriptionIndex}`);\n    }\n    entries.set(firstChunk, samplesPerChunk);\n  }\n  return {\n    type: \"stsc-box\",\n    boxSize: size,\n    offset,\n    version,\n    flags: [...flags],\n    entryCount,\n    entries\n  };\n};\n\n// src/containers/iso-base-media/stsd/stsd.ts\nvar parseStsd = async ({\n  offset,\n  size,\n  iterator,\n  logLevel,\n  contentLength\n}) => {\n  const version = iterator.getUint8();\n  if (version !== 0) {\n    throw new Error(`Unsupported STSD version ${version}`);\n  }\n  iterator.discard(3);\n  const numberOfEntries = iterator.getUint32();\n  const bytesRemainingInBox = size - (iterator.counter.getOffset() - offset);\n  const boxes = await parseIsoFormatBoxes({\n    maxBytes: bytesRemainingInBox,\n    logLevel,\n    iterator,\n    contentLength\n  });\n  if (boxes.length !== numberOfEntries) {\n    throw new Error(`Expected ${numberOfEntries} sample descriptions, got ${boxes.length}`);\n  }\n  return {\n    type: \"stsd-box\",\n    boxSize: size,\n    offset,\n    numberOfEntries,\n    samples: boxes\n  };\n};\n\n// src/containers/iso-base-media/stsd/stss.ts\nvar parseStss = ({\n  iterator,\n  offset,\n  boxSize\n}) => {\n  const version = iterator.getUint8();\n  if (version !== 0) {\n    throw new Error(`Unsupported STSS version ${version}`);\n  }\n  const flags = iterator.getSlice(3);\n  const sampleCount = iterator.getUint32();\n  const sampleNumber = new Set;\n  for (let i = 0;i < sampleCount; i++) {\n    sampleNumber.add(iterator.getUint32());\n  }\n  const bytesRemainingInBox = boxSize - (iterator.counter.getOffset() - offset);\n  if (bytesRemainingInBox > 0) {\n    throw new Error(`Unexpected bytes remaining in box stss`);\n  }\n  return {\n    type: \"stss-box\",\n    version,\n    flags: [...flags],\n    sampleNumber,\n    boxSize,\n    offset\n  };\n};\n\n// src/containers/iso-base-media/stsd/stsz.ts\nvar parseStsz = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const version = iterator.getUint8();\n  if (version !== 0) {\n    throw new Error(`Unsupported STSD version ${version}`);\n  }\n  const flags = iterator.getSlice(3);\n  const sampleSize = iterator.getUint32();\n  const sampleCount = iterator.getUint32();\n  if (sampleSize !== 0) {\n    return {\n      type: \"stsz-box\",\n      boxSize: size,\n      offset,\n      version,\n      flags: [...flags],\n      sampleCount,\n      countType: \"fixed\",\n      sampleSize\n    };\n  }\n  const samples = [];\n  for (let i = 0;i < sampleCount; i++) {\n    const bytesRemaining = size - (iterator.counter.getOffset() - offset);\n    if (bytesRemaining < 4) {\n      break;\n    }\n    samples.push(iterator.getUint32());\n  }\n  iterator.discard(size - (iterator.counter.getOffset() - offset));\n  return {\n    type: \"stsz-box\",\n    boxSize: size,\n    offset,\n    version,\n    flags: [...flags],\n    sampleCount,\n    countType: \"variable\",\n    entries: samples\n  };\n};\n\n// src/containers/iso-base-media/stsd/stts.ts\nvar parseStts = ({\n  data,\n  size,\n  fileOffset\n}) => {\n  const initialOffset = data.counter.getOffset();\n  const initialCounter = initialOffset - fileOffset;\n  const version = data.getUint8();\n  if (version !== 0) {\n    throw new Error(`Unsupported STTS version ${version}`);\n  }\n  data.discard(3);\n  const entryCount = data.getUint32();\n  const sampleDistributions = [];\n  for (let i = 0;i < entryCount; i++) {\n    const sampleCount = data.getUint32();\n    const sampleDelta = data.getUint32();\n    const sampleDistribution = {\n      sampleCount,\n      sampleDelta\n    };\n    sampleDistributions.push(sampleDistribution);\n  }\n  const bytesUsed = data.counter.getOffset() - initialOffset + initialCounter;\n  if (bytesUsed !== size) {\n    throw new Error(`Expected stts box to be ${size} bytes, but was ${bytesUsed} bytes`);\n  }\n  return {\n    type: \"stts-box\",\n    sampleDistribution: sampleDistributions\n  };\n};\n\n// src/containers/iso-base-media/stsd/vpcc.ts\nvar getvp09ConfigurationString = ({\n  profile,\n  level,\n  bitDepth: bitDepth2\n}) => {\n  return `${String(profile).padStart(2, \"0\")}.${String(level).padStart(2, \"0\")}.${String(bitDepth2).padStart(2, \"0\")}`;\n};\nvar parseVpcc = ({\n  data,\n  size\n}) => {\n  const box = data.startBox(size - 8);\n  const confVersion = data.getUint8();\n  if (confVersion !== 1) {\n    throw new Error(`Unsupported AVCC version ${confVersion}`);\n  }\n  data.discard(3);\n  const profile = data.getUint8();\n  const level = data.getUint8();\n  data.startReadingBits();\n  const bitDepth2 = data.getBits(4);\n  const chromaSubsampling = data.getBits(3);\n  const videoFullRangeFlag = data.getBits(1);\n  const videoColorPrimaries = data.getBits(8);\n  const videoTransferCharacteristics = data.getBits(8);\n  const videoMatrixCoefficients = data.getBits(8);\n  data.stopReadingBits();\n  const codecInitializationDataSize = data.getUint16();\n  const codecInitializationData = data.getSlice(codecInitializationDataSize);\n  box.expectNoMoreBytes();\n  return {\n    type: \"vpcc-box\",\n    profile,\n    level,\n    bitDepth: bitDepth2,\n    chromaSubsampling,\n    videoFullRangeFlag,\n    videoColorPrimaries,\n    videoTransferCharacteristics,\n    videoMatrixCoefficients,\n    codecInitializationDataSize,\n    codecInitializationData,\n    codecString: getvp09ConfigurationString({ profile, level, bitDepth: bitDepth2 })\n  };\n};\n\n// src/containers/iso-base-media/tfdt.ts\nvar parseTfdt = ({\n  iterator,\n  size,\n  offset\n}) => {\n  const version = iterator.getUint8();\n  iterator.discard(3);\n  const num = version === 0 ? iterator.getUint32() : Number(iterator.getUint64());\n  const bytesRemaining = size - (iterator.counter.getOffset() - offset);\n  if (bytesRemaining !== 0) {\n    throw new Error(\"expected 0 bytes \" + bytesRemaining);\n  }\n  return {\n    type: \"tfdt-box\",\n    version,\n    baseMediaDecodeTime: num,\n    offset\n  };\n};\n\n// src/containers/iso-base-media/tfhd.ts\nvar getTfhd = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const version = iterator.getUint8();\n  const flags = iterator.getUint24();\n  const trackId = iterator.getUint32();\n  const baseDataOffsetPresent = flags & 1;\n  const baseDataOffset = baseDataOffsetPresent ? Number(iterator.getUint64()) : 0;\n  const baseSampleDescriptionIndexPresent = flags & 2;\n  const baseSampleDescriptionIndex = baseSampleDescriptionIndexPresent ? iterator.getUint32() : 0;\n  const defaultSampleDurationPresent = flags & 8;\n  const defaultSampleDuration = defaultSampleDurationPresent ? iterator.getUint32() : 0;\n  const defaultSampleSizePresent = flags & 16;\n  const defaultSampleSize = defaultSampleSizePresent ? iterator.getUint32() : 0;\n  const defaultSampleFlagsPresent = flags & 32;\n  const defaultSampleFlags = defaultSampleFlagsPresent ? iterator.getUint32() : 0;\n  const bytesRemaining = size - (iterator.counter.getOffset() - offset);\n  if (bytesRemaining !== 0) {\n    throw new Error(\"expected 0 bytes \" + bytesRemaining);\n  }\n  return {\n    type: \"tfhd-box\",\n    version,\n    trackId,\n    baseDataOffset,\n    baseSampleDescriptionIndex,\n    defaultSampleDuration,\n    defaultSampleSize,\n    defaultSampleFlags\n  };\n};\n\n// src/containers/iso-base-media/tkhd.ts\nfunction getRotationAngleFromMatrix(matrix) {\n  const [a, b, c, d] = matrix;\n  if (a === 0 && b === 0 && c === 0 && d === 0) {\n    return 0;\n  }\n  if (Math.round(a * a + b * b) !== 1 || Math.round(c * c + d * d) !== 1) {\n    throw new Error(\"The provided matrix is not a valid rotation matrix.\");\n  }\n  const angleRadians = Math.atan2(c, a);\n  const angleDegrees = angleRadians * (180 / Math.PI);\n  return angleDegrees;\n}\nvar applyRotation = ({\n  matrix,\n  width,\n  height\n}) => {\n  const newWidth = matrix[0] * width + matrix[1] * height;\n  const newHeight = matrix[2] * width + matrix[3] * height;\n  return {\n    width: Math.abs(newWidth),\n    height: Math.abs(newHeight)\n  };\n};\nvar parseTkhd = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const version = iterator.getUint8();\n  iterator.discard(3);\n  const creationTime = version === 1 ? iterator.getUint64() : iterator.getUint32();\n  const modificationTime = version === 1 ? iterator.getUint64() : iterator.getUint32();\n  const trackId = iterator.getUint32();\n  iterator.discard(4);\n  const duration2 = version === 1 ? iterator.getUint64() : iterator.getUint32();\n  iterator.discard(4);\n  iterator.discard(4);\n  const layer = iterator.getUint16();\n  const alternateGroup = iterator.getUint16();\n  const volume = iterator.getUint16();\n  iterator.discard(2);\n  const matrix = [\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned230Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned230Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned230Number()\n  ];\n  const rotationMatrix = [matrix[0], matrix[1], matrix[3], matrix[4]];\n  const widthWithoutRotationApplied = iterator.getFixedPointUnsigned1616Number();\n  const heightWithoutRotationApplied = iterator.getFixedPointSigned1616Number();\n  const { width, height } = applyRotation({\n    matrix: rotationMatrix,\n    width: widthWithoutRotationApplied,\n    height: heightWithoutRotationApplied\n  });\n  const rotation = getRotationAngleFromMatrix(rotationMatrix);\n  return {\n    offset,\n    boxSize: size,\n    type: \"tkhd-box\",\n    creationTime: toUnixTimestamp(Number(creationTime)),\n    modificationTime: toUnixTimestamp(Number(modificationTime)),\n    trackId,\n    duration: Number(duration2),\n    layer,\n    alternateGroup,\n    volume,\n    matrix,\n    width,\n    height,\n    version,\n    rotation,\n    unrotatedWidth: widthWithoutRotationApplied,\n    unrotatedHeight: heightWithoutRotationApplied\n  };\n};\n\n// src/containers/iso-base-media/trak/trak.ts\nvar parseTrak = async ({\n  size,\n  offsetAtStart,\n  iterator,\n  logLevel,\n  contentLength\n}) => {\n  const children = await getIsoBaseMediaChildren({\n    onlyIfMoovAtomExpected: null,\n    size: size - 8,\n    iterator,\n    logLevel,\n    contentLength\n  });\n  return {\n    offset: offsetAtStart,\n    boxSize: size,\n    type: \"trak-box\",\n    children\n  };\n};\n\n// src/containers/iso-base-media/trun.ts\nvar parseTrun = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const version = iterator.getUint8();\n  if (version !== 0 && version !== 1) {\n    throw new Error(`Unsupported TRUN version ${version}`);\n  }\n  const flags = iterator.getUint24();\n  const sampleCount = iterator.getUint32();\n  const dataOffset = flags & 1 ? iterator.getInt32() : null;\n  const firstSampleFlags = flags & 4 ? iterator.getUint32() : null;\n  const samples = [];\n  for (let i = 0;i < sampleCount; i++) {\n    const sampleDuration = flags & 256 ? iterator.getUint32() : null;\n    const sampleSize = flags & 512 ? iterator.getUint32() : null;\n    const sampleFlags = flags & 1024 ? iterator.getUint32() : null;\n    const sampleCompositionTimeOffset = flags & 2048 ? version === 0 ? iterator.getUint32() : iterator.getInt32() : null;\n    samples.push({\n      sampleDuration,\n      sampleSize,\n      sampleFlags,\n      sampleCompositionTimeOffset\n    });\n  }\n  const currentOffset = iterator.counter.getOffset();\n  const left = size - (currentOffset - offset);\n  if (left !== 0) {\n    throw new Error(`Unexpected data left in TRUN box: ${left}`);\n  }\n  return {\n    type: \"trun-box\",\n    version,\n    sampleCount,\n    dataOffset,\n    firstSampleFlags,\n    samples\n  };\n};\n\n// src/containers/iso-base-media/process-box.ts\nvar processBox = async ({\n  iterator,\n  logLevel,\n  onlyIfMoovAtomExpected,\n  onlyIfMdatAtomExpected,\n  contentLength\n}) => {\n  const fileOffset = iterator.counter.getOffset();\n  const { returnToCheckpoint } = iterator.startCheckpoint();\n  const bytesRemaining = iterator.bytesRemaining();\n  const startOff = iterator.counter.getOffset();\n  const boxSizeRaw = iterator.getFourByteNumber();\n  if (boxSizeRaw === 0) {\n    return {\n      type: \"box\",\n      box: {\n        type: \"void-box\",\n        boxSize: 0\n      }\n    };\n  }\n  if (boxSizeRaw === 1 && iterator.bytesRemaining() < 12 || iterator.bytesRemaining() < 4) {\n    iterator.counter.decrement(iterator.counter.getOffset() - fileOffset);\n    throw new Error(`Expected box size of ${bytesRemaining}, got ${boxSizeRaw}. Incomplete boxes are not allowed.`);\n  }\n  const maxSize = contentLength - startOff;\n  const boxType = iterator.getByteString(4, false);\n  const boxSizeUnlimited = boxSizeRaw === 1 ? iterator.getEightByteNumber() : boxSizeRaw;\n  const boxSize = Math.min(boxSizeUnlimited, maxSize);\n  const headerLength = iterator.counter.getOffset() - startOff;\n  if (boxType === \"mdat\") {\n    if (!onlyIfMdatAtomExpected) {\n      return { type: \"nothing\" };\n    }\n    const { mediaSectionState } = onlyIfMdatAtomExpected;\n    mediaSectionState.addMediaSection({\n      size: boxSize - headerLength,\n      start: iterator.counter.getOffset()\n    });\n    return { type: \"nothing\" };\n  }\n  if (bytesRemaining < boxSize) {\n    returnToCheckpoint();\n    return {\n      type: \"fetch-more-data\",\n      bytesNeeded: makeFetchMoreData(boxSize - bytesRemaining)\n    };\n  }\n  if (boxType === \"ftyp\") {\n    return {\n      type: \"box\",\n      box: parseFtyp({ iterator, size: boxSize, offset: fileOffset })\n    };\n  }\n  if (boxType === \"elst\") {\n    return {\n      type: \"box\",\n      box: parseElst({\n        iterator,\n        size: boxSize,\n        offset: fileOffset\n      })\n    };\n  }\n  if (boxType === \"colr\") {\n    return {\n      type: \"box\",\n      box: parseColorParameterBox({\n        iterator,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"mvhd\") {\n    const mvhdBox = parseMvhd({\n      iterator,\n      offset: fileOffset,\n      size: boxSize\n    });\n    if (!onlyIfMoovAtomExpected) {\n      throw new Error(\"State is required\");\n    }\n    onlyIfMoovAtomExpected.movieTimeScaleState.setTrackTimescale(mvhdBox.timeScale);\n    return {\n      type: \"box\",\n      box: mvhdBox\n    };\n  }\n  if (boxType === \"tkhd\") {\n    return {\n      type: \"box\",\n      box: parseTkhd({ iterator, offset: fileOffset, size: boxSize })\n    };\n  }\n  if (boxType === \"trun\") {\n    return {\n      type: \"box\",\n      box: parseTrun({ iterator, offset: fileOffset, size: boxSize })\n    };\n  }\n  if (boxType === \"tfdt\") {\n    return {\n      type: \"box\",\n      box: parseTfdt({ iterator, size: boxSize, offset: fileOffset })\n    };\n  }\n  if (boxType === \"stsd\") {\n    return {\n      type: \"box\",\n      box: await parseStsd({\n        offset: fileOffset,\n        size: boxSize,\n        iterator,\n        logLevel,\n        contentLength\n      })\n    };\n  }\n  if (boxType === \"stsz\") {\n    return {\n      type: \"box\",\n      box: parseStsz({\n        iterator,\n        offset: fileOffset,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"stco\" || boxType === \"co64\") {\n    return {\n      type: \"box\",\n      box: parseStco({\n        iterator,\n        offset: fileOffset,\n        size: boxSize,\n        mode64Bit: boxType === \"co64\"\n      })\n    };\n  }\n  if (boxType === \"pasp\") {\n    return {\n      type: \"box\",\n      box: parsePasp({\n        iterator,\n        offset: fileOffset,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"stss\") {\n    return {\n      type: \"box\",\n      box: parseStss({\n        iterator,\n        offset: fileOffset,\n        boxSize\n      })\n    };\n  }\n  if (boxType === \"ctts\") {\n    return {\n      type: \"box\",\n      box: parseCtts({\n        iterator,\n        offset: fileOffset,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"stsc\") {\n    return {\n      type: \"box\",\n      box: parseStsc({\n        iterator,\n        offset: fileOffset,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"mebx\") {\n    return {\n      type: \"box\",\n      box: await parseMebx({\n        offset: fileOffset,\n        size: boxSize,\n        iterator,\n        logLevel,\n        contentLength\n      })\n    };\n  }\n  if (boxType === \"hdlr\") {\n    return {\n      type: \"box\",\n      box: await parseHdlr({ iterator, size: boxSize, offset: fileOffset })\n    };\n  }\n  if (boxType === \"keys\") {\n    return {\n      type: \"box\",\n      box: await parseKeys({ iterator, size: boxSize, offset: fileOffset })\n    };\n  }\n  if (boxType === \"ilst\") {\n    return {\n      type: \"box\",\n      box: await parseIlstBox({\n        iterator,\n        offset: fileOffset,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"tfra\") {\n    return {\n      type: \"box\",\n      box: await parseTfraBox({\n        iterator,\n        offset: fileOffset,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"moov\") {\n    if (!onlyIfMoovAtomExpected) {\n      throw new Error(\"State is required\");\n    }\n    const { tracks: tracks2, isoState } = onlyIfMoovAtomExpected;\n    if (tracks2.hasAllTracks()) {\n      iterator.discard(boxSize - 8);\n      return { type: \"nothing\" };\n    }\n    if (isoState && isoState.moov.getMoovBoxAndPrecomputed() && !isoState.moov.getMoovBoxAndPrecomputed()?.precomputed) {\n      Log.verbose(logLevel, \"Moov box already parsed, skipping\");\n      iterator.discard(boxSize - 8);\n      return { type: \"nothing\" };\n    }\n    const box = await parseMoov({\n      offset: fileOffset,\n      size: boxSize,\n      onlyIfMoovAtomExpected,\n      iterator,\n      logLevel,\n      contentLength\n    });\n    tracks2.setIsDone(logLevel);\n    return { type: \"box\", box };\n  }\n  if (boxType === \"trak\") {\n    if (!onlyIfMoovAtomExpected) {\n      throw new Error(\"State is required\");\n    }\n    const { tracks: tracks2, onAudioTrack, onVideoTrack } = onlyIfMoovAtomExpected;\n    const trakBox = await parseTrak({\n      size: boxSize,\n      offsetAtStart: fileOffset,\n      iterator,\n      logLevel,\n      contentLength\n    });\n    const movieTimeScale = onlyIfMoovAtomExpected.movieTimeScaleState.getTrackTimescale();\n    if (movieTimeScale === null) {\n      throw new Error(\"Movie timescale is not set\");\n    }\n    const editList = findTrackStartTimeInSeconds({ movieTimeScale, trakBox });\n    const transformedTrack = makeBaseMediaTrack(trakBox, editList);\n    if (transformedTrack && transformedTrack.type === \"video\") {\n      await registerVideoTrack({\n        track: transformedTrack,\n        container: \"mp4\",\n        logLevel,\n        onVideoTrack,\n        registerVideoSampleCallback: onlyIfMoovAtomExpected.registerVideoSampleCallback,\n        tracks: tracks2\n      });\n    }\n    if (transformedTrack && transformedTrack.type === \"audio\") {\n      await registerAudioTrack({\n        track: transformedTrack,\n        container: \"mp4\",\n        registerAudioSampleCallback: onlyIfMoovAtomExpected.registerAudioSampleCallback,\n        tracks: tracks2,\n        logLevel,\n        onAudioTrack\n      });\n    }\n    return { type: \"box\", box: trakBox };\n  }\n  if (boxType === \"stts\") {\n    return {\n      type: \"box\",\n      box: parseStts({\n        data: iterator,\n        size: boxSize,\n        fileOffset\n      })\n    };\n  }\n  if (boxType === \"avcC\") {\n    return {\n      type: \"box\",\n      box: parseAvcc({\n        data: iterator,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"vpcC\") {\n    return {\n      type: \"box\",\n      box: parseVpcc({ data: iterator, size: boxSize })\n    };\n  }\n  if (boxType === \"av1C\") {\n    return {\n      type: \"box\",\n      box: parseAv1C({\n        data: iterator,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"hvcC\") {\n    return {\n      type: \"box\",\n      box: parseHvcc({\n        data: iterator,\n        size: boxSize,\n        offset: fileOffset\n      })\n    };\n  }\n  if (boxType === \"tfhd\") {\n    return {\n      type: \"box\",\n      box: getTfhd({\n        iterator,\n        offset: fileOffset,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"mdhd\") {\n    return {\n      type: \"box\",\n      box: parseMdhd({\n        data: iterator,\n        size: boxSize,\n        fileOffset\n      })\n    };\n  }\n  if (boxType === \"esds\") {\n    return {\n      type: \"box\",\n      box: parseEsds({\n        data: iterator,\n        size: boxSize,\n        fileOffset\n      })\n    };\n  }\n  if (boxType === \"trex\") {\n    return {\n      type: \"box\",\n      box: parseTrex({ iterator, offset: fileOffset, size: boxSize })\n    };\n  }\n  if (boxType === \"moof\") {\n    await onlyIfMoovAtomExpected?.isoState?.mfra.triggerLoad();\n  }\n  if (boxType === \"mdia\" || boxType === \"minf\" || boxType === \"stbl\" || boxType === \"udta\" || boxType === \"moof\" || boxType === \"dims\" || boxType === \"meta\" || boxType === \"wave\" || boxType === \"traf\" || boxType === \"mfra\" || boxType === \"edts\" || boxType === \"mvex\" || boxType === \"stsb\") {\n    const children = await getIsoBaseMediaChildren({\n      iterator,\n      size: boxSize - 8,\n      logLevel,\n      onlyIfMoovAtomExpected,\n      contentLength\n    });\n    return {\n      type: \"box\",\n      box: {\n        type: \"regular-box\",\n        boxType,\n        boxSize,\n        children,\n        offset: fileOffset\n      }\n    };\n  }\n  iterator.discard(boxSize - 8);\n  Log.verbose(logLevel, \"Unknown ISO Base Media Box:\", boxType);\n  return {\n    type: \"box\",\n    box: {\n      type: \"regular-box\",\n      boxType,\n      boxSize,\n      children: [],\n      offset: fileOffset\n    }\n  };\n};\n\n// src/containers/iso-base-media/get-children.ts\nvar getIsoBaseMediaChildren = async ({\n  size,\n  iterator,\n  logLevel,\n  onlyIfMoovAtomExpected,\n  contentLength\n}) => {\n  const boxes = [];\n  const initial = iterator.counter.getOffset();\n  while (iterator.counter.getOffset() < size + initial) {\n    const parsed = await processBox({\n      iterator,\n      logLevel,\n      onlyIfMoovAtomExpected,\n      onlyIfMdatAtomExpected: null,\n      contentLength\n    });\n    if (parsed.type !== \"box\") {\n      throw new Error(\"Expected box\");\n    }\n    boxes.push(parsed.box);\n  }\n  if (iterator.counter.getOffset() > size + initial) {\n    throw new Error(`read too many bytes - size: ${size}, read: ${iterator.counter.getOffset() - initial}. initial offset: ${initial}`);\n  }\n  return boxes;\n};\n\n// src/containers/iso-base-media/stsd/samples.ts\nvar videoTags = [\n  \"cvid\",\n  \"jpeg\",\n  \"smc \",\n  \"rle \",\n  \"rpza\",\n  \"kpcd\",\n  \"png \",\n  \"mjpa\",\n  \"mjpb\",\n  \"SVQ1\",\n  \"SVQ3\",\n  \"mp4v\",\n  \"avc1\",\n  \"dvc \",\n  \"dvcp\",\n  \"gif \",\n  \"h263\",\n  \"tiff\",\n  \"raw \",\n  \"2vuY\",\n  \"yuv2\",\n  \"v308\",\n  \"v408\",\n  \"v216\",\n  \"v410\",\n  \"v210\",\n  \"hvc1\",\n  \"hev1\",\n  \"ap4h\",\n  \"av01\",\n  \"vp08\",\n  \"vp09\"\n];\nvar audioTags = [\n  0,\n  \"NONE\",\n  \"raw \",\n  \"twos\",\n  \"sowt\",\n  \"MAC3 \",\n  \"MAC6 \",\n  \"ima4\",\n  \"fl32\",\n  \"lpcm\",\n  \"fl64\",\n  \"in24\",\n  \"in32\",\n  \"ulaw\",\n  \"alaw\",\n  1836253186,\n  1836253201,\n  \"dvca\",\n  \"QDMC\",\n  \"QDM2\",\n  \"Qclp\",\n  1836253269,\n  \".mp3\",\n  \"mp4a\",\n  \"ac-3\",\n  \"Opus\"\n];\nvar processIsoFormatBox = async ({\n  iterator,\n  logLevel,\n  contentLength\n}) => {\n  const fileOffset = iterator.counter.getOffset();\n  const bytesRemaining = iterator.bytesRemaining();\n  const boxSize = iterator.getUint32();\n  if (bytesRemaining < boxSize) {\n    throw new Error(`Expected box size of ${bytesRemaining}, got ${boxSize}`);\n  }\n  const boxFormat = iterator.getAtom();\n  const isVideo = videoTags.includes(boxFormat);\n  const isAudio = audioTags.includes(boxFormat) || audioTags.includes(Numbe","size_bytes":360000},"prebundled/bundle/bundle.js":{"content":"/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 1247:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n/**\n * @license React\n * react-dom-client.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\n\nvar Scheduler = __webpack_require__(9982),\n  React = __webpack_require__(6540),\n  ReactDOM = __webpack_require__(961);\nfunction formatProdErrorMessage(code) {\n  var url = \"https://react.dev/errors/\" + code;\n  if (1 < arguments.length) {\n    url += \"?args[]=\" + encodeURIComponent(arguments[1]);\n    for (var i = 2; i < arguments.length; i++)\n      url += \"&args[]=\" + encodeURIComponent(arguments[i]);\n  }\n  return (\n    \"Minified React error #\" +\n    code +\n    \"; visit \" +\n    url +\n    \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"\n  );\n}\nfunction isValidContainer(node) {\n  return !(\n    !node ||\n    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)\n  );\n}\nfunction getNearestMountedFiber(fiber) {\n  var node = fiber,\n    nearestMounted = fiber;\n  if (fiber.alternate) for (; node.return; ) node = node.return;\n  else {\n    fiber = node;\n    do\n      (node = fiber),\n        0 !== (node.flags & 4098) && (nearestMounted = node.return),\n        (fiber = node.return);\n    while (fiber);\n  }\n  return 3 === node.tag ? nearestMounted : null;\n}\nfunction getSuspenseInstanceFromFiber(fiber) {\n  if (13 === fiber.tag) {\n    var suspenseState = fiber.memoizedState;\n    null === suspenseState &&\n      ((fiber = fiber.alternate),\n      null !== fiber && (suspenseState = fiber.memoizedState));\n    if (null !== suspenseState) return suspenseState.dehydrated;\n  }\n  return null;\n}\nfunction assertIsMounted(fiber) {\n  if (getNearestMountedFiber(fiber) !== fiber)\n    throw Error(formatProdErrorMessage(188));\n}\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    alternate = getNearestMountedFiber(fiber);\n    if (null === alternate) throw Error(formatProdErrorMessage(188));\n    return alternate !== fiber ? null : fiber;\n  }\n  for (var a = fiber, b = alternate; ; ) {\n    var parentA = a.return;\n    if (null === parentA) break;\n    var parentB = parentA.alternate;\n    if (null === parentB) {\n      b = parentA.return;\n      if (null !== b) {\n        a = b;\n        continue;\n      }\n      break;\n    }\n    if (parentA.child === parentB.child) {\n      for (parentB = parentA.child; parentB; ) {\n        if (parentB === a) return assertIsMounted(parentA), fiber;\n        if (parentB === b) return assertIsMounted(parentA), alternate;\n        parentB = parentB.sibling;\n      }\n      throw Error(formatProdErrorMessage(188));\n    }\n    if (a.return !== b.return) (a = parentA), (b = parentB);\n    else {\n      for (var didFindChild = !1, child$0 = parentA.child; child$0; ) {\n        if (child$0 === a) {\n          didFindChild = !0;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (child$0 === b) {\n          didFindChild = !0;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        child$0 = child$0.sibling;\n      }\n      if (!didFindChild) {\n        for (child$0 = parentB.child; child$0; ) {\n          if (child$0 === a) {\n            didFindChild = !0;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (child$0 === b) {\n            didFindChild = !0;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          child$0 = child$0.sibling;\n        }\n        if (!didFindChild) throw Error(formatProdErrorMessage(189));\n      }\n    }\n    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));\n  }\n  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));\n  return a.stateNode.current === a ? fiber : alternate;\n}\nfunction findCurrentHostFiberImpl(node) {\n  var tag = node.tag;\n  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n  for (node = node.child; null !== node; ) {\n    tag = findCurrentHostFiberImpl(node);\n    if (null !== tag) return tag;\n    node = node.sibling;\n  }\n  return null;\n}\nvar assign = Object.assign,\n  REACT_LEGACY_ELEMENT_TYPE = Symbol.for(\"react.element\"),\n  REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n  REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n  REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n  REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"),\n  REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n  REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n  REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n  REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n  REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n  REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n  REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\nSymbol.for(\"react.scope\");\nvar REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\");\nSymbol.for(\"react.legacy_hidden\");\nSymbol.for(\"react.tracing_marker\");\nvar REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\");\nSymbol.for(\"react.view_transition\");\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nfunction getIteratorFn(maybeIterable) {\n  if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n  maybeIterable =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[\"@@iterator\"];\n  return \"function\" === typeof maybeIterable ? maybeIterable : null;\n}\nvar REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\nfunction getComponentNameFromType(type) {\n  if (null == type) return null;\n  if (\"function\" === typeof type)\n    return type.$$typeof === REACT_CLIENT_REFERENCE\n      ? null\n      : type.displayName || type.name || null;\n  if (\"string\" === typeof type) return type;\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return \"Fragment\";\n    case REACT_PROFILER_TYPE:\n      return \"Profiler\";\n    case REACT_STRICT_MODE_TYPE:\n      return \"StrictMode\";\n    case REACT_SUSPENSE_TYPE:\n      return \"Suspense\";\n    case REACT_SUSPENSE_LIST_TYPE:\n      return \"SuspenseList\";\n    case REACT_ACTIVITY_TYPE:\n      return \"Activity\";\n  }\n  if (\"object\" === typeof type)\n    switch (type.$$typeof) {\n      case REACT_PORTAL_TYPE:\n        return \"Portal\";\n      case REACT_CONTEXT_TYPE:\n        return (type.displayName || \"Context\") + \".Provider\";\n      case REACT_CONSUMER_TYPE:\n        return (type._context.displayName || \"Context\") + \".Consumer\";\n      case REACT_FORWARD_REF_TYPE:\n        var innerType = type.render;\n        type = type.displayName;\n        type ||\n          ((type = innerType.displayName || innerType.name || \"\"),\n          (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n        return type;\n      case REACT_MEMO_TYPE:\n        return (\n          (innerType = type.displayName || null),\n          null !== innerType\n            ? innerType\n            : getComponentNameFromType(type.type) || \"Memo\"\n        );\n      case REACT_LAZY_TYPE:\n        innerType = type._payload;\n        type = type._init;\n        try {\n          return getComponentNameFromType(type(innerType));\n        } catch (x) {}\n    }\n  return null;\n}\nvar isArrayImpl = Array.isArray,\n  ReactSharedInternals =\n    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  ReactDOMSharedInternals =\n    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  sharedNotPendingObject = {\n    pending: !1,\n    data: null,\n    method: null,\n    action: null\n  },\n  valueStack = [],\n  index = -1;\nfunction createCursor(defaultValue) {\n  return { current: defaultValue };\n}\nfunction pop(cursor) {\n  0 > index ||\n    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);\n}\nfunction push(cursor, value) {\n  index++;\n  valueStack[index] = cursor.current;\n  cursor.current = value;\n}\nvar contextStackCursor = createCursor(null),\n  contextFiberStackCursor = createCursor(null),\n  rootInstanceStackCursor = createCursor(null),\n  hostTransitionProviderCursor = createCursor(null);\nfunction pushHostContainer(fiber, nextRootInstance) {\n  push(rootInstanceStackCursor, nextRootInstance);\n  push(contextFiberStackCursor, fiber);\n  push(contextStackCursor, null);\n  switch (nextRootInstance.nodeType) {\n    case 9:\n    case 11:\n      fiber = (fiber = nextRootInstance.documentElement)\n        ? (fiber = fiber.namespaceURI)\n          ? getOwnHostContext(fiber)\n          : 0\n        : 0;\n      break;\n    default:\n      if (\n        ((fiber = nextRootInstance.tagName),\n        (nextRootInstance = nextRootInstance.namespaceURI))\n      )\n        (nextRootInstance = getOwnHostContext(nextRootInstance)),\n          (fiber = getChildHostContextProd(nextRootInstance, fiber));\n      else\n        switch (fiber) {\n          case \"svg\":\n            fiber = 1;\n            break;\n          case \"math\":\n            fiber = 2;\n            break;\n          default:\n            fiber = 0;\n        }\n  }\n  pop(contextStackCursor);\n  push(contextStackCursor, fiber);\n}\nfunction popHostContainer() {\n  pop(contextStackCursor);\n  pop(contextFiberStackCursor);\n  pop(rootInstanceStackCursor);\n}\nfunction pushHostContext(fiber) {\n  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);\n  var context = contextStackCursor.current;\n  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);\n  context !== JSCompiler_inline_result &&\n    (push(contextFiberStackCursor, fiber),\n    push(contextStackCursor, JSCompiler_inline_result));\n}\nfunction popHostContext(fiber) {\n  contextFiberStackCursor.current === fiber &&\n    (pop(contextStackCursor), pop(contextFiberStackCursor));\n  hostTransitionProviderCursor.current === fiber &&\n    (pop(hostTransitionProviderCursor),\n    (HostTransitionContext._currentValue = sharedNotPendingObject));\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty,\n  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,\n  cancelCallback$1 = Scheduler.unstable_cancelCallback,\n  shouldYield = Scheduler.unstable_shouldYield,\n  requestPaint = Scheduler.unstable_requestPaint,\n  now = Scheduler.unstable_now,\n  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,\n  ImmediatePriority = Scheduler.unstable_ImmediatePriority,\n  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,\n  NormalPriority$1 = Scheduler.unstable_NormalPriority,\n  LowPriority = Scheduler.unstable_LowPriority,\n  IdlePriority = Scheduler.unstable_IdlePriority,\n  log$1 = Scheduler.log,\n  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,\n  rendererID = null,\n  injectedHook = null;\nfunction setIsStrictModeForDevtools(newIsStrictMode) {\n  \"function\" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);\n  if (injectedHook && \"function\" === typeof injectedHook.setStrictMode)\n    try {\n      injectedHook.setStrictMode(rendererID, newIsStrictMode);\n    } catch (err) {}\n}\nvar clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,\n  log = Math.log,\n  LN2 = Math.LN2;\nfunction clz32Fallback(x) {\n  x >>>= 0;\n  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;\n}\nvar nextTransitionLane = 256,\n  nextRetryLane = 4194304;\nfunction getHighestPriorityLanes(lanes) {\n  var pendingSyncLanes = lanes & 42;\n  if (0 !== pendingSyncLanes) return pendingSyncLanes;\n  switch (lanes & -lanes) {\n    case 1:\n      return 1;\n    case 2:\n      return 2;\n    case 4:\n      return 4;\n    case 8:\n      return 8;\n    case 16:\n      return 16;\n    case 32:\n      return 32;\n    case 64:\n      return 64;\n    case 128:\n      return 128;\n    case 256:\n    case 512:\n    case 1024:\n    case 2048:\n    case 4096:\n    case 8192:\n    case 16384:\n    case 32768:\n    case 65536:\n    case 131072:\n    case 262144:\n    case 524288:\n    case 1048576:\n    case 2097152:\n      return lanes & 4194048;\n    case 4194304:\n    case 8388608:\n    case 16777216:\n    case 33554432:\n      return lanes & 62914560;\n    case 67108864:\n      return 67108864;\n    case 134217728:\n      return 134217728;\n    case 268435456:\n      return 268435456;\n    case 536870912:\n      return 536870912;\n    case 1073741824:\n      return 0;\n    default:\n      return lanes;\n  }\n}\nfunction getNextLanes(root, wipLanes, rootHasPendingCommit) {\n  var pendingLanes = root.pendingLanes;\n  if (0 === pendingLanes) return 0;\n  var nextLanes = 0,\n    suspendedLanes = root.suspendedLanes,\n    pingedLanes = root.pingedLanes;\n  root = root.warmLanes;\n  var nonIdlePendingLanes = pendingLanes & 134217727;\n  0 !== nonIdlePendingLanes\n    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),\n      0 !== pendingLanes\n        ? (nextLanes = getHighestPriorityLanes(pendingLanes))\n        : ((pingedLanes &= nonIdlePendingLanes),\n          0 !== pingedLanes\n            ? (nextLanes = getHighestPriorityLanes(pingedLanes))\n            : rootHasPendingCommit ||\n              ((rootHasPendingCommit = nonIdlePendingLanes & ~root),\n              0 !== rootHasPendingCommit &&\n                (nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))))\n    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),\n      0 !== nonIdlePendingLanes\n        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))\n        : 0 !== pingedLanes\n          ? (nextLanes = getHighestPriorityLanes(pingedLanes))\n          : rootHasPendingCommit ||\n            ((rootHasPendingCommit = pendingLanes & ~root),\n            0 !== rootHasPendingCommit &&\n              (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));\n  return 0 === nextLanes\n    ? 0\n    : 0 !== wipLanes &&\n        wipLanes !== nextLanes &&\n        0 === (wipLanes & suspendedLanes) &&\n        ((suspendedLanes = nextLanes & -nextLanes),\n        (rootHasPendingCommit = wipLanes & -wipLanes),\n        suspendedLanes >= rootHasPendingCommit ||\n          (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)))\n      ? wipLanes\n      : nextLanes;\n}\nfunction checkIfRootIsPrerendering(root, renderLanes) {\n  return (\n    0 ===\n    (root.pendingLanes &\n      ~(root.suspendedLanes & ~root.pingedLanes) &\n      renderLanes)\n  );\n}\nfunction computeExpirationTime(lane, currentTime) {\n  switch (lane) {\n    case 1:\n    case 2:\n    case 4:\n    case 8:\n    case 64:\n      return currentTime + 250;\n    case 16:\n    case 32:\n    case 128:\n    case 256:\n    case 512:\n    case 1024:\n    case 2048:\n    case 4096:\n    case 8192:\n    case 16384:\n    case 32768:\n    case 65536:\n    case 131072:\n    case 262144:\n    case 524288:\n    case 1048576:\n    case 2097152:\n      return currentTime + 5e3;\n    case 4194304:\n    case 8388608:\n    case 16777216:\n    case 33554432:\n      return -1;\n    case 67108864:\n    case 134217728:\n    case 268435456:\n    case 536870912:\n    case 1073741824:\n      return -1;\n    default:\n      return -1;\n  }\n}\nfunction claimNextTransitionLane() {\n  var lane = nextTransitionLane;\n  nextTransitionLane <<= 1;\n  0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);\n  return lane;\n}\nfunction claimNextRetryLane() {\n  var lane = nextRetryLane;\n  nextRetryLane <<= 1;\n  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);\n  return lane;\n}\nfunction createLaneMap(initial) {\n  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);\n  return laneMap;\n}\nfunction markRootUpdated$1(root, updateLane) {\n  root.pendingLanes |= updateLane;\n  268435456 !== updateLane &&\n    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));\n}\nfunction markRootFinished(\n  root,\n  finishedLanes,\n  remainingLanes,\n  spawnedLane,\n  updatedLanes,\n  suspendedRetryLanes\n) {\n  var previouslyPendingLanes = root.pendingLanes;\n  root.pendingLanes = remainingLanes;\n  root.suspendedLanes = 0;\n  root.pingedLanes = 0;\n  root.warmLanes = 0;\n  root.expiredLanes &= remainingLanes;\n  root.entangledLanes &= remainingLanes;\n  root.errorRecoveryDisabledLanes &= remainingLanes;\n  root.shellSuspendCounter = 0;\n  var entanglements = root.entanglements,\n    expirationTimes = root.expirationTimes,\n    hiddenUpdates = root.hiddenUpdates;\n  for (\n    remainingLanes = previouslyPendingLanes & ~remainingLanes;\n    0 < remainingLanes;\n\n  ) {\n    var index$5 = 31 - clz32(remainingLanes),\n      lane = 1 << index$5;\n    entanglements[index$5] = 0;\n    expirationTimes[index$5] = -1;\n    var hiddenUpdatesForLane = hiddenUpdates[index$5];\n    if (null !== hiddenUpdatesForLane)\n      for (\n        hiddenUpdates[index$5] = null, index$5 = 0;\n        index$5 < hiddenUpdatesForLane.length;\n        index$5++\n      ) {\n        var update = hiddenUpdatesForLane[index$5];\n        null !== update && (update.lane &= -536870913);\n      }\n    remainingLanes &= ~lane;\n  }\n  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);\n  0 !== suspendedRetryLanes &&\n    0 === updatedLanes &&\n    0 !== root.tag &&\n    (root.suspendedLanes |=\n      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));\n}\nfunction markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n  root.pendingLanes |= spawnedLane;\n  root.suspendedLanes &= ~spawnedLane;\n  var spawnedLaneIndex = 31 - clz32(spawnedLane);\n  root.entangledLanes |= spawnedLane;\n  root.entanglements[spawnedLaneIndex] =\n    root.entanglements[spawnedLaneIndex] |\n    1073741824 |\n    (entangledLanes & 4194090);\n}\nfunction markRootEntangled(root, entangledLanes) {\n  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);\n  for (root = root.entanglements; rootEntangledLanes; ) {\n    var index$6 = 31 - clz32(rootEntangledLanes),\n      lane = 1 << index$6;\n    (lane & entangledLanes) | (root[index$6] & entangledLanes) &&\n      (root[index$6] |= entangledLanes);\n    rootEntangledLanes &= ~lane;\n  }\n}\nfunction getBumpedLaneForHydrationByLane(lane) {\n  switch (lane) {\n    case 2:\n      lane = 1;\n      break;\n    case 8:\n      lane = 4;\n      break;\n    case 32:\n      lane = 16;\n      break;\n    case 256:\n    case 512:\n    case 1024:\n    case 2048:\n    case 4096:\n    case 8192:\n    case 16384:\n    case 32768:\n    case 65536:\n    case 131072:\n    case 262144:\n    case 524288:\n    case 1048576:\n    case 2097152:\n    case 4194304:\n    case 8388608:\n    case 16777216:\n    case 33554432:\n      lane = 128;\n      break;\n    case 268435456:\n      lane = 134217728;\n      break;\n    default:\n      lane = 0;\n  }\n  return lane;\n}\nfunction lanesToEventPriority(lanes) {\n  lanes &= -lanes;\n  return 2 < lanes\n    ? 8 < lanes\n      ? 0 !== (lanes & 134217727)\n        ? 32\n        : 268435456\n      : 8\n    : 2;\n}\nfunction resolveUpdatePriority() {\n  var updatePriority = ReactDOMSharedInternals.p;\n  if (0 !== updatePriority) return updatePriority;\n  updatePriority = window.event;\n  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);\n}\nfunction runWithPriority(priority, fn) {\n  var previousPriority = ReactDOMSharedInternals.p;\n  try {\n    return (ReactDOMSharedInternals.p = priority), fn();\n  } finally {\n    ReactDOMSharedInternals.p = previousPriority;\n  }\n}\nvar randomKey = Math.random().toString(36).slice(2),\n  internalInstanceKey = \"__reactFiber$\" + randomKey,\n  internalPropsKey = \"__reactProps$\" + randomKey,\n  internalContainerInstanceKey = \"__reactContainer$\" + randomKey,\n  internalEventHandlersKey = \"__reactEvents$\" + randomKey,\n  internalEventHandlerListenersKey = \"__reactListeners$\" + randomKey,\n  internalEventHandlesSetKey = \"__reactHandles$\" + randomKey,\n  internalRootNodeResourcesKey = \"__reactResources$\" + randomKey,\n  internalHoistableMarker = \"__reactMarker$\" + randomKey;\nfunction detachDeletedInstance(node) {\n  delete node[internalInstanceKey];\n  delete node[internalPropsKey];\n  delete node[internalEventHandlersKey];\n  delete node[internalEventHandlerListenersKey];\n  delete node[internalEventHandlesSetKey];\n}\nfunction getClosestInstanceFromNode(targetNode) {\n  var targetInst = targetNode[internalInstanceKey];\n  if (targetInst) return targetInst;\n  for (var parentNode = targetNode.parentNode; parentNode; ) {\n    if (\n      (targetInst =\n        parentNode[internalContainerInstanceKey] ||\n        parentNode[internalInstanceKey])\n    ) {\n      parentNode = targetInst.alternate;\n      if (\n        null !== targetInst.child ||\n        (null !== parentNode && null !== parentNode.child)\n      )\n        for (\n          targetNode = getParentSuspenseInstance(targetNode);\n          null !== targetNode;\n\n        ) {\n          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;\n          targetNode = getParentSuspenseInstance(targetNode);\n        }\n      return targetInst;\n    }\n    targetNode = parentNode;\n    parentNode = targetNode.parentNode;\n  }\n  return null;\n}\nfunction getInstanceFromNode(node) {\n  if (\n    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])\n  ) {\n    var tag = node.tag;\n    if (\n      5 === tag ||\n      6 === tag ||\n      13 === tag ||\n      26 === tag ||\n      27 === tag ||\n      3 === tag\n    )\n      return node;\n  }\n  return null;\n}\nfunction getNodeFromInstance(inst) {\n  var tag = inst.tag;\n  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;\n  throw Error(formatProdErrorMessage(33));\n}\nfunction getResourcesFromRoot(root) {\n  var resources = root[internalRootNodeResourcesKey];\n  resources ||\n    (resources = root[internalRootNodeResourcesKey] =\n      { hoistableStyles: new Map(), hoistableScripts: new Map() });\n  return resources;\n}\nfunction markNodeAsHoistable(node) {\n  node[internalHoistableMarker] = !0;\n}\nvar allNativeEvents = new Set(),\n  registrationNameDependencies = {};\nfunction registerTwoPhaseEvent(registrationName, dependencies) {\n  registerDirectEvent(registrationName, dependencies);\n  registerDirectEvent(registrationName + \"Capture\", dependencies);\n}\nfunction registerDirectEvent(registrationName, dependencies) {\n  registrationNameDependencies[registrationName] = dependencies;\n  for (\n    registrationName = 0;\n    registrationName < dependencies.length;\n    registrationName++\n  )\n    allNativeEvents.add(dependencies[registrationName]);\n}\nvar VALID_ATTRIBUTE_NAME_REGEX = RegExp(\n    \"^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n  ),\n  illegalAttributeNameCache = {},\n  validatedAttributeNameCache = {};\nfunction isAttributeNameSafe(attributeName) {\n  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))\n    return !0;\n  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\n    return (validatedAttributeNameCache[attributeName] = !0);\n  illegalAttributeNameCache[attributeName] = !0;\n  return !1;\n}\nfunction setValueForAttribute(node, name, value) {\n  if (isAttributeNameSafe(name))\n    if (null === value) node.removeAttribute(name);\n    else {\n      switch (typeof value) {\n        case \"undefined\":\n        case \"function\":\n        case \"symbol\":\n          node.removeAttribute(name);\n          return;\n        case \"boolean\":\n          var prefix$8 = name.toLowerCase().slice(0, 5);\n          if (\"data-\" !== prefix$8 && \"aria-\" !== prefix$8) {\n            node.removeAttribute(name);\n            return;\n          }\n      }\n      node.setAttribute(name, \"\" + value);\n    }\n}\nfunction setValueForKnownAttribute(node, name, value) {\n  if (null === value) node.removeAttribute(name);\n  else {\n    switch (typeof value) {\n      case \"undefined\":\n      case \"function\":\n      case \"symbol\":\n      case \"boolean\":\n        node.removeAttribute(name);\n        return;\n    }\n    node.setAttribute(name, \"\" + value);\n  }\n}\nfunction setValueForNamespacedAttribute(node, namespace, name, value) {\n  if (null === value) node.removeAttribute(name);\n  else {\n    switch (typeof value) {\n      case \"undefined\":\n      case \"function\":\n      case \"symbol\":\n      case \"boolean\":\n        node.removeAttribute(name);\n        return;\n    }\n    node.setAttributeNS(namespace, name, \"\" + value);\n  }\n}\nvar prefix, suffix;\nfunction describeBuiltInComponentFrame(name) {\n  if (void 0 === prefix)\n    try {\n      throw Error();\n    } catch (x) {\n      var match = x.stack.trim().match(/\\n( *(at )?)/);\n      prefix = (match && match[1]) || \"\";\n      suffix =\n        -1 < x.stack.indexOf(\"\\n    at\")\n          ? \" (<anonymous>)\"\n          : -1 < x.stack.indexOf(\"@\")\n            ? \"@unknown:0:0\"\n            : \"\";\n    }\n  return \"\\n\" + prefix + name + suffix;\n}\nvar reentry = !1;\nfunction describeNativeComponentFrame(fn, construct) {\n  if (!fn || reentry) return \"\";\n  reentry = !0;\n  var previousPrepareStackTrace = Error.prepareStackTrace;\n  Error.prepareStackTrace = void 0;\n  try {\n    var RunInRootFrame = {\n      DetermineComponentFrameRoot: function () {\n        try {\n          if (construct) {\n            var Fake = function () {\n              throw Error();\n            };\n            Object.defineProperty(Fake.prototype, \"props\", {\n              set: function () {\n                throw Error();\n              }\n            });\n            if (\"object\" === typeof Reflect && Reflect.construct) {\n              try {\n                Reflect.construct(Fake, []);\n              } catch (x) {\n                var control = x;\n              }\n              Reflect.construct(fn, [], Fake);\n            } else {\n              try {\n                Fake.call();\n              } catch (x$9) {\n                control = x$9;\n              }\n              fn.call(Fake.prototype);\n            }\n          } else {\n            try {\n              throw Error();\n            } catch (x$10) {\n              control = x$10;\n            }\n            (Fake = fn()) &&\n              \"function\" === typeof Fake.catch &&\n              Fake.catch(function () {});\n          }\n        } catch (sample) {\n          if (sample && control && \"string\" === typeof sample.stack)\n            return [sample.stack, control.stack];\n        }\n        return [null, null];\n      }\n    };\n    RunInRootFrame.DetermineComponentFrameRoot.displayName =\n      \"DetermineComponentFrameRoot\";\n    var namePropDescriptor = Object.getOwnPropertyDescriptor(\n      RunInRootFrame.DetermineComponentFrameRoot,\n      \"name\"\n    );\n    namePropDescriptor &&\n      namePropDescriptor.configurable &&\n      Object.defineProperty(\n        RunInRootFrame.DetermineComponentFrameRoot,\n        \"name\",\n        { value: \"DetermineComponentFrameRoot\" }\n      );\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n      sampleStack = _RunInRootFrame$Deter[0],\n      controlStack = _RunInRootFrame$Deter[1];\n    if (sampleStack && controlStack) {\n      var sampleLines = sampleStack.split(\"\\n\"),\n        controlLines = controlStack.split(\"\\n\");\n      for (\n        namePropDescriptor = RunInRootFrame = 0;\n        RunInRootFrame < sampleLines.length &&\n        !sampleLines[RunInRootFrame].includes(\"DetermineComponentFrameRoot\");\n\n      )\n        RunInRootFrame++;\n      for (\n        ;\n        namePropDescriptor < controlLines.length &&\n        !controlLines[namePropDescriptor].includes(\n          \"DetermineComponentFrameRoot\"\n        );\n\n      )\n        namePropDescriptor++;\n      if (\n        RunInRootFrame === sampleLines.length ||\n        namePropDescriptor === controlLines.length\n      )\n        for (\n          RunInRootFrame = sampleLines.length - 1,\n            namePropDescriptor = controlLines.length - 1;\n          1 <= RunInRootFrame &&\n          0 <= namePropDescriptor &&\n          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];\n\n        )\n          namePropDescriptor--;\n      for (\n        ;\n        1 <= RunInRootFrame && 0 <= namePropDescriptor;\n        RunInRootFrame--, namePropDescriptor--\n      )\n        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {\n          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {\n            do\n              if (\n                (RunInRootFrame--,\n                namePropDescriptor--,\n                0 > namePropDescriptor ||\n                  sampleLines[RunInRootFrame] !==\n                    controlLines[namePropDescriptor])\n              ) {\n                var frame =\n                  \"\\n\" +\n                  sampleLines[RunInRootFrame].replace(\" at new \", \" at \");\n                fn.displayName &&\n                  frame.includes(\"<anonymous>\") &&\n                  (frame = frame.replace(\"<anonymous>\", fn.displayName));\n                return frame;\n              }\n            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);\n          }\n          break;\n        }\n    }\n  } finally {\n    (reentry = !1), (Error.prepareStackTrace = previousPrepareStackTrace);\n  }\n  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : \"\")\n    ? describeBuiltInComponentFrame(previousPrepareStackTrace)\n    : \"\";\n}\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case 26:\n    case 27:\n    case 5:\n      return describeBuiltInComponentFrame(fiber.type);\n    case 16:\n      return describeBuiltInComponentFrame(\"Lazy\");\n    case 13:\n      return describeBuiltInComponentFrame(\"Suspense\");\n    case 19:\n      return describeBuiltInComponentFrame(\"SuspenseList\");\n    case 0:\n    case 15:\n      return describeNativeComponentFrame(fiber.type, !1);\n    case 11:\n      return describeNativeComponentFrame(fiber.type.render, !1);\n    case 1:\n      return describeNativeComponentFrame(fiber.type, !0);\n    case 31:\n      return describeBuiltInComponentFrame(\"Activity\");\n    default:\n      return \"\";\n  }\n}\nfunction getStackByFiberInDevAndProd(workInProgress) {\n  try {\n    var info = \"\";\n    do\n      (info += describeFiber(workInProgress)),\n        (workInProgress = workInProgress.return);\n    while (workInProgress);\n    return info;\n  } catch (x) {\n    return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n  }\n}\nfunction getToStringValue(value) {\n  switch (typeof value) {\n    case \"bigint\":\n    case \"boolean\":\n    case \"number\":\n    case \"string\":\n    case \"undefined\":\n      return value;\n    case \"object\":\n      return value;\n    default:\n      return \"\";\n  }\n}\nfunction isCheckable(elem) {\n  var type = elem.type;\n  return (\n    (elem = elem.nodeName) &&\n    \"input\" === elem.toLowerCase() &&\n    (\"checkbox\" === type || \"radio\" === type)\n  );\n}\nfunction trackValueOnNode(node) {\n  var valueField = isCheckable(node) ? \"checked\" : \"value\",\n    descriptor = Object.getOwnPropertyDescriptor(\n      node.constructor.prototype,\n      valueField\n    ),\n    currentValue = \"\" + node[valueField];\n  if (\n    !node.hasOwnProperty(valueField) &&\n    \"undefined\" !== typeof descriptor &&\n    \"function\" === typeof descriptor.get &&\n    \"function\" === typeof descriptor.set\n  ) {\n    var get = descriptor.get,\n      set = descriptor.set;\n    Object.defineProperty(node, valueField, {\n      configurable: !0,\n      get: function () {\n        return get.call(this);\n      },\n      set: function (value) {\n        currentValue = \"\" + value;\n        set.call(this, value);\n      }\n    });\n    Object.defineProperty(node, valueField, {\n      enumerable: descriptor.enumerable\n    });\n    return {\n      getValue: function () {\n        return currentValue;\n      },\n      setValue: function (value) {\n        currentValue = \"\" + value;\n      },\n      stopTracking: function () {\n        node._valueTracker = null;\n        delete node[valueField];\n      }\n    };\n  }\n}\nfunction track(node) {\n  node._valueTracker || (node._valueTracker = trackValueOnNode(node));\n}\nfunction updateValueIfChanged(node) {\n  if (!node) return !1;\n  var tracker = node._valueTracker;\n  if (!tracker) return !0;\n  var lastValue = tracker.getValue();\n  var value = \"\";\n  node &&\n    (value = isCheckable(node)\n      ? node.checked\n        ? \"true\"\n        : \"false\"\n      : node.value);\n  node = value;\n  return node !== lastValue ? (tracker.setValue(node), !0) : !1;\n}\nfunction getActiveElement(doc) {\n  doc = doc || (\"undefined\" !== typeof document ? document : void 0);\n  if (\"undefined\" === typeof doc) return null;\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\nvar escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\\n\"\\\\]/g;\nfunction escapeSelectorAttributeValueInsideDoubleQuotes(value) {\n  return value.replace(\n    escapeSelectorAttributeValueInsideDoubleQuotesRegex,\n    function (ch) {\n      return \"\\\\\" + ch.charCodeAt(0).toString(16) + \" \";\n    }\n  );\n}\nfunction updateInput(\n  element,\n  value,\n  defaultValue,\n  lastDefaultValue,\n  checked,\n  defaultChecked,\n  type,\n  name\n) {\n  element.name = \"\";\n  null != type &&\n  \"function\" !== typeof type &&\n  \"symbol\" !== typeof type &&\n  \"boolean\" !== typeof type\n    ? (element.type = type)\n    : element.removeAttribute(\"type\");\n  if (null != value)\n    if (\"number\" === type) {\n      if ((0 === value && \"\" === element.value) || element.value != value)\n        element.value = \"\" + getToStringValue(value);\n    } else\n      element.value !== \"\" + getToStringValue(value) &&\n        (element.value = \"\" + getToStringValue(value));\n  else\n    (\"submit\" !== type && \"reset\" !== type) || element.removeAttribute(\"value\");\n  null != value\n    ? setDefaultValue(element, type, getToStringValue(value))\n    : null != defaultValue\n      ? setDefaultValue(element, type, getToStringValue(defaultValue))\n      : null != lastDefaultValue && element.removeAttribute(\"value\");\n  null == checked &&\n    null != defaultChecked &&\n    (element.defaultChecked = !!defaultChecked);\n  null != checked &&\n    (element.checked =\n      checked && \"function\" !== typeof checked && \"symbol\" !== typeof checked);\n  null != name &&\n  \"function\" !== typeof name &&\n  \"symbol\" !== typeof name &&\n  \"boolean\" !== typeof name\n    ? (element.name = \"\" + getToStringValue(name))\n    : element.removeAttribute(\"name\");\n}\nfunction initInput(\n  element,\n  value,\n  defaultValue,\n  checked,\n  defaultChecked,\n  type,\n  name,\n  isHydrating\n) {\n  null != type &&\n    \"function\" !== typeof type &&\n    \"symbol\" !== typeof type &&\n    \"boolean\" !== typeof type &&\n    (element.type = type);\n  if (null != value || null != defaultValue) {\n    if (\n      !(\n        (\"submit\" !== type && \"reset\" !== type) ||\n        (void 0 !== value && null !== value)\n      )\n    )\n      return;\n    defaultValue =\n      null != defaultValue ? \"\" + getToStringValue(defaultValue) : \"\";\n    value = null != value ? \"\" + getToStringValue(value) : defaultValue;\n    isHydrating || value === element.value || (element.value = value);\n    element.defaultValue = value;\n  }\n  checked = null != checked ? checked : defaultChecked;\n  checked =\n    \"function\" !== typeof checked && \"symbol\" !== typeof checked && !!checked;\n  element.checked = isHydrating ? element.checked : !!checked;\n  element.defaultChecked = !!checked;\n  null != name &&\n    \"function\" !== typeof name &&\n    \"symbol\" !== typeof name &&\n    \"boolean\" !== typeof name &&\n    (element.name = name);\n}\nfunction setDefaultValue(node, type, value) {\n  (\"number\" === type && getActiveElement(node.ownerDocument) === node) ||\n    node.defaultValue === \"\" + value ||\n    (node.defaultValue = \"\" + value);\n}\nfunction updateOptions(node, multiple, propValue, setDefaultSelected) {\n  node = node.options;\n  if (multiple) {\n    multiple = {};\n    for (var i = 0; i < propValue.length; i++)\n      multiple[\"$\" + propValue[i]] = !0;\n    for (propValue = 0; propValue < node.length; propValue++)\n      (i = multiple.hasOwnProperty(\"$\" + node[propValue].value)),\n        node[propValue].selected !== i && (node[propValue].selected = i),\n        i && setDefaultSelected && (node[propValue].defaultSelected = !0);\n  } else {\n    propValue = \"\" + getToStringValue(propValue);\n    multiple = null;\n    for (i = 0; i < node.length; i++) {\n      if (node[i].value === propValue) {\n        node[i].selected = !0;\n        setDefaultSelected && (node[i].defaultSelected = !0);\n        return;\n      }\n      null !== multiple || node[i].disabled || (multiple = node[i]);\n    }\n    null !== multiple && (multiple.selected = !0);\n  }\n}\nfunction updateTextarea(element, value, defaultValue) {\n  if (\n    null != value &&\n    ((value = \"\" + getToStringValue(value)),\n    value !== element.value && (element.value = value),\n    null == defaultValue)\n  ) {\n    element.defaultValue !== value && (element.defaultValue = value);\n    return;\n  }\n  element.defaultValue =\n    null != defaultValue ? \"\" + getToStringValue(defaultValue) : \"\";\n}\nfunction initTextarea(element, value, defaultValue, children) {\n  if (null == value) {\n    if (null != children) {\n      if (null != defaultValue) throw Error(formatProdErrorMessage(92));\n      if (isArrayImpl(children)) {\n        if (1 < children.length) throw Error(formatProdErrorMessage(93));\n        children = children[0];\n      }\n      defaultValue = children;\n    }\n    null == defaultValue && (defaultValue = \"\");\n    value = defaultValue;\n  }\n  defaultValue = getToStringValue(value);\n  element.defaultValue = defaultValue;\n  children = element.textContent;\n  children === defaultValue &&\n    \"\" !== children &&\n    null !== children &&\n    (element.value = children);\n}\nfunction setTextContent(node, text) {\n  if (text) {\n    var firstChild = node.firstChild;\n    if (\n      firstChild &&\n      firstChild === node.lastChild &&\n      3 === firstChild.nodeType\n    ) {\n      firstChild.nodeValue = text;\n      return;\n    }\n  }\n  node.textContent = text;\n}\nvar unitlessNumbers = new Set(\n  \"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\n    \" \"\n  )\n);\nfunction setValueForStyle(style, styleName, value) {\n  var isCustomProperty = 0 === styleName.indexOf(\"--\");\n  null == value || \"boolean\" === typeof value || \"\" === value\n    ? isCustomProperty\n      ? style.setProperty(styleName, \"\")\n      : \"float\" === styleName\n        ? (style.cssFloat = \"\")\n        : (style[styleName] = \"\")\n    : isCustomProperty\n      ? style.setProperty(styleName, value)\n      : \"number\" !== typeof value ||\n          0 === value ||\n          unitlessNumbers.has(styleName)\n        ? \"float\" === styleName\n          ? (style.cssFloat = value)\n          : (style[styleName] = (\"\" + value).trim())\n        : (style[styleName] = value + \"px\");\n}\nfunction setValueForStyles(node, styles, prevStyles) {\n  if (null != styles && \"object\" !== typeof styles)\n    throw Error(formatProdErrorMessage(62));\n  node = node.style;\n  if (null != prevStyles) {\n    for (var styleName in prevStyles)\n      !prevStyles.hasOwnProperty(styleName) ||\n        (null != styles && styles.hasOwnProperty(styleName)) ||\n        (0 === styleName.indexOf(\"--\")\n          ? node.setProperty(styleName, \"\")\n          : \"float\" === styleName\n            ? (node.cssFloat = \"\")\n            : (node[styleName] = \"\"));\n    for (var styleName$16 in styles)\n      (styleName = styles[styleName$16]),\n        styles.hasOwnProperty(styleName$16) &&\n          prevStyles[styleName$16] !== styleName &&\n          setValueForStyle(node, styleName$16, styleName);\n  } else\n    for (var styleName$17 in styles)\n      styles.hasOwnProperty(styleName$17) &&\n        setValueForStyle(node, styleName$17, styles[styleName$17]);\n}\nfunction isCustomElement(tagName) {\n  if (-1 === tagName.indexOf(\"-\")) return !1;\n  switch (tagName) {\n    case \"annotation-xml\":\n    case \"color-profile\":\n    case \"font-face\":\n    case \"font-face-src\":\n    case \"font-face-uri\":\n    case \"font-face-format\":\n    case \"font-face-name\":\n    case \"missing-glyph\":\n      return !1;\n    default:\n      return !0;\n  }\n}\nvar aliases = new Map([\n    [\"acceptCharset\", \"accept-charset\"],\n    [\"htmlFor\", \"for\"],\n    [\"httpEquiv\", \"http-equiv\"],\n    [\"crossOrigin\", \"crossorigin\"],\n    [\"accentHeight\", \"accent-height\"],\n    [\"alignmentBaseline\", \"alignment-baseline\"],\n    [\"arabicForm\", \"arabic-form\"],\n    [\"baselineShift\", \"baseline-shift\"],\n    [\"capHeight\", \"cap-height\"],\n    [\"clipPath\", \"clip-path\"],\n    [\"clipRule\", \"clip-rule\"],\n    [\"colorInterpolation\", \"color-interpolation\"],\n    [\"colorInterpolationFilters\", \"color-interpolation-filters\"],\n    [\"colorProfile\", \"color-profile\"],\n    [\"colorRendering\", \"color-rendering\"],\n    [\"dominantBaseline\", \"dominant-baseline\"],\n    [\"enableBackground\", \"enable-background\"],\n    [\"fillOpacity\", \"fill-opacity\"],\n    [\"fillRule\", \"fill-rule\"],\n    [\"floodColor\", \"flood-color\"],\n    [\"floodOpacity\", \"flood-opacity\"],\n    [\"fontFamily\", \"font-family\"],\n    [\"fontSize\", \"font-size\"],\n    [\"fontSizeAdjust\", \"font-size-adjust\"],\n    [\"fontStretch\", \"font-stretch\"],\n    [\"fontStyle\", \"font-style\"],\n    [\"fontVariant\", \"font-variant\"],\n    [\"fontWeight\", \"font-weight\"],\n    [\"glyphName\", \"glyph-name\"],\n    [\"glyphOrientationHorizontal\", \"glyph-orientation-horizontal\"],\n    [\"glyphOrientationVertical\", \"glyph-orientation-vertical\"],\n    [\"horizAdvX\", \"horiz-adv-x\"],\n    [\"horizOriginX\", \"horiz-origin-x\"],\n    [\"imageRendering\", \"image-rendering\"],\n    [\"letterSpacing\", \"letter-spacing\"],\n    [\"lightingColor\", \"lighting-color\"],\n    [\"markerEnd\", \"marker-end\"],\n    [\"markerMid\", \"marker-mid\"],\n    [\"markerStart\", \"marker-start\"],\n    [\"overlinePosition\", \"overline-position\"],\n    [\"overlineThickness\", \"overline-thickness\"],\n    [\"paintOrder\", \"paint-order\"],\n    [\"panose-1\", \"panose-1\"],\n    [\"pointerEvents\", \"pointer-events\"],\n    [\"renderingIntent\", \"rendering-intent\"],\n    [\"shapeRendering\", \"shape-rendering\"],\n    [\"stopColor\", \"stop-color\"],\n    [\"stopOpacity\", \"stop-opacity\"],\n    [\"strikethroughPosition\", \"strikethrough-position\"],\n    [\"strikethroughThickness\", \"strikethrough-thickness\"],\n    [\"strokeDasharray\", \"stroke-dasharray\"],\n    [\"strokeDashoffset\", \"stroke-dashoffset\"],\n    [\"strokeLinecap\", \"stroke-linecap\"],\n    [\"strokeLinejoin\", \"stroke-linejoin\"],\n    [\"strokeMiterlimit\", \"stroke-miterlimit\"],\n    [\"strokeOpacity\", \"stroke-opacity\"],\n    [\"strokeWidth\", \"stroke-width\"],\n    [\"textAnchor\", \"text-anchor\"],\n    [\"textDecoration\", \"text-decoration\"],\n    [\"textRendering\", \"text-rendering\"],\n    [\"transformOrigin\", \"transform-origin\"],\n    [\"underlinePosition\", \"underline-position\"],\n    [\"underlineThickness\", \"underline-thickness\"],\n    [\"unicodeBidi\", \"unicode-bidi\"],\n    [\"unicodeRange\", \"unicode-range\"],\n    [\"unitsPerEm\", \"units-per-em\"],\n    [\"vAlphabetic\", \"v-alphabetic\"],\n    [\"vHanging\", \"v-hanging\"],\n    [\"vIdeographic\", \"v-ideographic\"],\n    [\"vMathematical\", \"v-mathematical\"],\n    [\"vectorEffect\", \"vector-effect\"],\n    [\"vertAdvY\", \"vert-adv-y\"],\n    [\"vertOriginX\", \"vert-origin-x\"],\n    [\"vertOriginY\", \"vert-origin-y\"],\n    [\"wordSpacing\", \"word-spacing\"],\n    [\"writingMode\", \"writing-mode\"],\n    [\"xmlnsXlink\", \"xmlns:xlink\"],\n    [\"xHeight\", \"x-height\"]\n  ]),\n  isJavaScriptProtocol =\n    /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i;\nfunction sanitizeURL(url) {\n  return isJavaScriptProtocol.test(\"\" + url)\n    ? \"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')\"\n    : url;\n}\nvar currentReplayingEvent = null;\nfunction getEventTarget(nativeEvent) {\n  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;\n  nativeEvent.correspondingUseElement &&\n    (nativeEvent = nativeEvent.correspondingUseElement);\n  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;\n}\nvar restoreTarget = null,\n  restoreQueue = null;\nfunction restoreStateOfTarget(target) {\n  var internalInstance = getInstanceFromNode(target);\n  if (internalInstance && (target = internalInstance.stateNode)) {\n    var props = target[internalPropsKey] || null;\n    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {\n      case \"input\":\n        updateInput(\n          target,\n          props.value,\n          props.defaultValue,\n          props.defaultValue,\n          props.checked,\n          props.defaultChecked,\n          props.type,\n          props.name\n        );\n        internalInstance = props.name;\n        if (\"radio\" === props.type && null != internalInstance) {\n          for (props = target; props.parentNode; ) props = props.parentNode;\n          props = props.querySelectorAll(\n            'input[name=\"' +\n              escapeSelectorAttributeValueInsideDoubleQuotes(\n                \"\" + internalInstance\n              ) +\n              '\"][type=\"radio\"]'\n          );\n          for (\n            internalInstance = 0;\n            internalInstance < props.length;\n            internalInstance++\n          ) {\n            var otherNode = props[internalInstance];\n            if (otherNode !== target && otherNode.form === target.form) {\n              var otherProps = otherNode[internalPropsKey] || null;\n              if (!otherProps) throw Error(formatProdErrorMessage(90));\n              updateInput(\n                otherNode,\n                otherProps.value,\n                otherProps.defaultValue,\n                otherProps.defaultValue,\n                otherProps.checked,\n                otherProps.defaultChecked,\n                otherProps.type,\n                otherProps.name\n              );\n            }\n          }\n          for (\n            internalInstance = 0;\n            internalInstance < props.length;\n            internalInstance++\n          )\n            (otherNode = props[internalInstance]),\n              otherNode.form === target.form && updateValueIfChanged(otherNode);\n        }\n        break a;\n      case \"textarea\":\n        updateTextarea(target, props.value, props.defaultValue);\n        break a;\n      case \"select\":\n        (internalInstance = props.value),\n          null != internalInstance &&\n            updateOptions(target, !!props.multiple, internalInstance, !1);\n    }\n  }\n}\nvar isInsideEventHandler = !1;\nfunction batchedUpdates$1(fn, a, b) {\n  if (isInsideEventHandler) return fn(a, b);\n  isInsideEventHandler = !0;\n  try {\n    var JSCompiler_inline_result = fn(a);\n    return JSCompiler_inline_result;\n  } finally {\n    if (\n      ((isInsideEventHandler = !1),\n      null !== restoreTarget || null !== restoreQueue)\n    )\n      if (\n        (flushSyncWork$1(),\n        restoreTarget &&\n          ((a = restoreTarget),\n          (fn = restoreQueue),\n          (restoreQueue = restoreTarget = null),\n          restoreStateOfTarget(a),\n          fn))\n      )\n        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);\n  }\n}\nfunction getListener(inst, registrationName) {\n  var stateNode = inst.stateNode;\n  if (null === stateNode) return null;\n  var props = stateNode[internalPropsKey] || null;\n  if (null === props) return null;\n  stateNode = props[registrationName];\n  a: switch (registrationName) {\n    case \"onClick\":\n    case \"onClickCapture\":\n    case \"onDoubleClick\":\n    case \"onDoubleClickCapture\":\n    case \"onMouseDown\":\n    case \"onMouseDownCapture\":\n    case \"onMouseMove\":\n    case \"onMouseMoveCapture\":\n    case \"onMouseUp\":\n    case \"onMouseUpCapture\":\n    case \"onMouseEnter\":\n      (props = !props.disabled) ||\n        ((inst = inst.type),\n        (props = !(\n          \"button\" === inst ||\n          \"input\" === inst ||\n          \"select\" === inst ||\n          \"textarea\" === inst\n        )));\n      inst = !props;\n      break a;\n    default:\n      inst = !1;\n  }\n  if (inst) return null;\n  if (stateNode && \"function\" !== typeof stateNode)\n    throw Error(\n      formatProdErrorMessage(231, registrationName, typeof stateNode)\n    );\n  return stateNode;\n}\nvar canUseDOM = !(\n    \"undefined\" === typeof window ||\n    \"undefined\" === typeof window.document ||\n    \"undefined\" === typeof window.document.createElement\n  ),\n  passiveBrowserEventsSupported = !1;\nif (canUseDOM)\n  try {\n    var options = {};\n    Object.defineProperty(options, \"passive\", {\n      get: function () {\n        passiveBrowserEventsSupported = !0;\n      }\n    });\n    window.addEventListener(\"test\", options, options);\n    window.removeEventListener(\"test\", options, options);\n  } catch (e) {\n    passiveBrowserEventsSupported = !1;\n  }\nvar root = null,\n  startText = null,\n  fallbackText = null;\nfunction getData() {\n  if (fallbackText) return fallbackText;\n  var start,\n    startValue = startText,\n    startLength = startValue.length,\n    end,\n    endValue = \"value\" in root ? root.value : root.textContent,\n    endLength = endValue.length;\n  for (\n    start = 0;\n    start < startLength && startValue[start] === endValue[start];\n    start++\n  );\n  var minEnd = startLength - start;\n  for (\n    end = 1;\n    end <= minEnd &&\n    startValue[startLength - end] === endValue[endLength - end];\n    end++\n  );\n  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));\n}\nfunction getEventCharCode(nativeEvent) {\n  var keyCode = nativeEvent.keyCode;\n  \"charCode\" in nativeEvent\n    ? ((nativeEvent = nativeEvent.charCode),\n      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))\n    : (nativeEvent = keyCode);\n  10 === nativeEvent && (nativeEvent = 13);\n  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;\n}\nfunction functionThatReturnsTrue() {\n  return !0;\n}\nfunction functionThatReturnsFalse() {\n  return !1;\n}\nfunction createSyntheticEvent(Interface) {\n  function SyntheticBaseEvent(\n    reactName,\n    reactEventType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    this._reactName = reactName;\n    this._targetInst = targetInst;\n    this.type = reactEventType;\n    this.nativeEvent = nativeEvent;\n    this.target = nativeEventTarget;\n    this.currentTarget = null;\n    for (var propName in Interface)\n      Interface.hasOwnProperty(propName) &&\n        ((reactName = Interface[propName]),\n        (this[propName] = reactName\n          ? reactName(nativeEvent)\n          : nativeEvent[propName]));\n    this.isDefaultPrevented = (\n      null != nativeEvent.defaultPrevented\n        ? nativeEvent.defaultPrevented\n        : !1 === nativeEvent.returnValue\n    )\n      ? functionThatReturnsTrue\n      : functionThatReturnsFalse;\n    this.isPropagationStopped = functionThatReturnsFalse;\n    return this;\n  }\n  assign(SyntheticBaseEvent.prototype, {\n    preventDefault: function () {\n      this.defaultPrevented = !0;\n      var event = this.nativeEvent;\n      event &&\n        (event.preventDefault\n          ? event.preventDefault()\n          : \"unknown\" !== typeof event.returnValue && (event.returnValue = !1),\n        (this.isDefaultPrevented = functionThatReturnsTrue));\n    },\n    stopPropagation: function () {\n      var event = this.nativeEvent;\n      event &&\n        (event.stopPropagation\n          ? event.stopPropagation()\n          : \"unknown\" !== typeof event.cancelBubble &&\n            (event.cancelBubble = !0),\n        (this.isPropagationStopped = functionThatReturnsTrue));\n    },\n    persist: function () {},\n    isPersistent: functionThatReturnsTrue\n  });\n  return SyntheticBaseEvent;\n}\nvar EventInterface = {\n    eventPhase: 0,\n    bubbles: 0,\n    cancelable: 0,\n    timeStamp: function (event) {\n      return event.timeStamp || Date.now();\n    },\n    defaultPrevented: 0,\n    isTrusted: 0\n  },\n  SyntheticEvent = createSyntheticEvent(EventInterface),\n  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),\n  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),\n  lastMovementX,\n  lastMovementY,\n  lastMouseEvent,\n  MouseEventInterface = assign({}, UIEventInterface, {\n    screenX: 0,\n    screenY: 0,\n    clientX: 0,\n    clientY: 0,\n    pageX: 0,\n    pageY: 0,\n    ctrlKey: 0,\n    shiftKey: 0,\n    altKey: 0,\n    metaKey: 0,\n    getModifierState: getEventModifierState,\n    button: 0,\n    buttons: 0,\n    relatedTarget: function (event) {\n      return void 0 === event.relatedTarget\n        ? event.fromElement === event.srcElement\n          ? event.toElement\n          : event.fromElement\n        : event.relatedTarget;\n    },\n    movementX: function (event) {\n      if (\"movementX\" in event) return event.movementX;\n      event !== lastMouseEvent &&\n        (lastMouseEvent && \"mousemove\" === event.type\n          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),\n            (lastMovementY = event.screenY - lastMouseEvent.screenY))\n          : (lastMovementY = lastMovementX = 0),\n        (lastMouseEvent = event));\n      return lastMovementX;\n    },\n    movementY: function (event) {\n      return \"movementY\" in event ? event.movementY : lastMovementY;\n    }\n  }),\n  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),\n  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),\n  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),\n  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),\n  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),\n  AnimationEventInterface = assign({}, EventInterface, {\n    animationName: 0,\n    elapsedTime: 0,\n    pseudoElement: 0\n  }),\n  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),\n  ClipboardEventInterface = assign({}, EventInterface, {\n    clipboardData: function (event) {\n      return \"clipboardData\" in event\n        ? event.clipboardData\n        : window.clipboardData;\n    }\n  }),\n  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),\n  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),\n  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),\n  normalizeKey = {\n    Esc: \"Escape\",\n    Spacebar: \" \",\n    Left: \"ArrowLeft\",\n    Up: \"ArrowUp\",\n    Right: \"ArrowRight\",\n    Down: \"ArrowDown\",\n    Del: \"Delete\",\n    Win: \"OS\",\n    Menu: \"ContextMenu\",\n    Apps: \"ContextMenu\",\n    Scroll: \"ScrollLock\",\n    MozPrintableKey: \"Unidentified\"\n  },\n  translateToKey = {\n    8: \"Backspace\",\n    9: \"Tab\",\n    12: \"Clear\",\n    13: \"Enter\",\n    16: \"Shift\",\n    17: \"Control\",\n    18: \"Alt\",\n    19: \"Pause\",\n    20: \"CapsLock\",\n    27: \"Escape\",\n    32: \" \",\n    33: \"PageUp\",\n    34: \"PageDown\",\n    35: \"End\",\n    36: \"Home\",\n    37: \"ArrowLeft\",\n    38: \"ArrowUp\",\n    39: \"ArrowRight\",\n    40: \"ArrowDown\",\n    45: \"Insert\",\n    46: \"Delete\",\n    112: \"F1\",\n    113: \"F2\",\n    114: \"F3\",\n    115: \"F4\",\n    116: \"F5\",\n    117: \"F6\",\n    118: \"F7\",\n    119: \"F8\",\n    120: \"F9\",\n    121: \"F10\",\n    122: \"F11\",\n    123: \"F12\",\n    144: \"NumLock\",\n    145: \"ScrollLock\",\n    224: \"Meta\"\n  },\n  modifierKeyToProp = {\n    Alt: \"altKey\",\n    Control: \"ctrlKey\",\n    Meta: \"metaKey\",\n    Shift: \"shiftKey\"\n  };\nfunction modifierStateGetter(keyArg) {\n  var nativeEvent = this.nativeEvent;\n  return nativeEvent.getModifierState\n    ? nativeEvent.getModifierState(keyArg)\n    : (keyArg = modifierKeyToProp[keyArg])\n      ? !!nativeEvent[keyArg]\n      : !1;\n}\nfunction getEventModifierState() {\n  return modifierStateGetter;\n}\nvar KeyboardEventInterface = assign({}, UIEventInterface, {\n    key: function (nativeEvent) {\n      if (nativeEvent.key) {\n        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n        if (\"Unidentified\" !== key) return key;\n      }\n      return \"keypress\" === nativeEvent.type\n        ? ((nativeEvent = getEventCharCode(nativeEvent)),\n          13 === nativeEvent ? \"Enter\" : String.fromCharCode(nativeEvent))\n        : \"keydown\" === nativeEvent.type || \"keyup\" === nativeEvent.type\n          ? translateToKey[nativeEvent.keyCode] || \"Unidentified\"\n          : \"\";\n    },\n    code: 0,\n    location: 0,\n    ctrlKey: 0,\n    shiftKey: 0,\n    altKey: 0,\n    metaKey: 0,\n    repeat: 0,\n    locale: 0,\n    getModifierState: getEventModifierState,\n    charCode: function (event) {\n      return \"keypress\" === event.type ? getEventCharCode(event) : 0;\n    },\n    keyCode: function (event) {\n      return \"keydown\" === event.type || \"keyup\" === event.type\n        ? event.keyCode\n        : 0;\n    },\n    which: function (event) {\n      return \"keypress\" === event.type\n        ? getEventCharCode(event)\n        : \"keydown\" === event.type || \"keyup\" === event.type\n          ? event.keyCode\n          : 0;\n    }\n  }),\n  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),\n  PointerEventInterface = assign({}, MouseEventInterface, {\n    pointerId: 0,\n    width: 0,\n    height: 0,\n    pressure: 0,\n    tangentialPressure: 0,\n    tiltX: 0,\n    tiltY: 0,\n    twist: 0,\n    pointerType: 0,\n    isPrimary: 0\n  }),\n  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),\n  TouchEventInterface = assign({}, UIEventInterface, {\n    touches: 0,\n    targetTouches: 0,\n    changedTouches: 0,\n    altKey: 0,\n    metaKey: 0,\n    ctrlKey: 0,\n    shiftKey: 0,\n    getModifierState: getEventModifierState\n  }),\n  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),\n  TransitionEventInterface = assign({}, EventInterface, {\n    propertyName: 0,\n    elapsedTime: 0,\n    pseudoElement: 0\n  }),\n  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),\n  WheelEventInterface = assign({}, MouseEventInterface, {\n    deltaX: function (event) {\n      return \"deltaX\" in event\n        ? event.deltaX\n        : \"wheelDeltaX\" in event\n          ? -event.wheelDeltaX\n          : 0;\n    },\n    deltaY: function (event) {\n      return \"deltaY\" in event\n        ? event.deltaY\n        : \"wheelDeltaY\" in event\n          ? -event.wheelDeltaY\n          : \"wheelDelta\" in event\n            ? -event.wheelDelta\n            : 0;\n    },\n    deltaZ: 0,\n    deltaMode: 0\n  }),\n  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),\n  ToggleEventInterface = assign({}, EventInterface, {\n    newState: 0,\n    oldState: 0\n  }),\n  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),\n  END_KEYCODES = [9, 13, 27, 32],\n  canUseCompositionEvent = canUseDOM && \"CompositionEvent\" in window,\n  documentMode = null;\ncanUseDOM &&\n  \"documentMode\" in document &&\n  (documentMode = document.documentMode);\nvar canUseTextInputEvent = canUseDOM && \"TextEvent\" in window && !documentMode,\n  useFallbackCompositionData =\n    canUseDOM &&\n    (!canUseCompositionEvent ||\n      (documentMode && 8 < documentMode && 11 >= documentMode)),\n  SPACEBAR_CHAR = String.fromCharCode(32),\n  hasSpaceKeypress = !1;\nfunction isFallbackCompositionEnd(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case \"keyup\":\n      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);\n    case \"keydown\":\n      return 229 !== nativeEvent.keyCode;\n    case \"keypress\":\n    case \"mousedown\":\n    case \"focusout\":\n      return !0;\n    default:\n      return !1;\n  }\n}\nfunction getDataFromCustomEvent(nativeEvent) {\n  nativeEvent = nativeEvent.detail;\n  return \"object\" === typeof nativeEvent && \"data\" in nativeEvent\n    ? nativeEvent.data\n    : null;\n}\nvar isComposing = !1;\nfunction getNativeBeforeInputChars(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case \"compositionend\":\n      return getDataFromCustomEvent(nativeEvent);\n    case \"keypress\":\n      if (32 !== nativeEvent.which) return null;\n      hasSpaceKeypress = !0;\n      return SPACEBAR_CHAR;\n    case \"textInput\":\n      return (\n        (domEventName = nativeEvent.data),\n        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName\n      );\n    default:\n      return null;\n  }\n}\nfunction getFallbackBeforeInputChars(domEventName, nativeEvent) {\n  if (isComposing)\n    return \"compositionend\" === domEventName ||\n      (!canUseCompositionEvent &&\n        isFallbackCompositionEnd(domEventName, nativeEvent))\n      ? ((domEventName = getData()),\n        (fallbackText = startText = root = null),\n        (isComposing = !1),\n        domEventName)\n      : null;\n  switch (domEventName) {\n    case \"paste\":\n      return null;\n    case \"keypress\":\n      if (\n        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||\n        (nativeEvent.ctrlKey && nativeEvent.altKey)\n      ) {\n        if (nativeEvent.char && 1 < nativeEvent.char.length)\n          return nativeEvent.char;\n        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);\n      }\n      return null;\n    case \"compositionend\":\n      return useFallbackCompositionData && \"ko\" !== nativeEvent.locale\n        ? null\n        : nativeEvent.data;\n    default:\n      return null;\n  }\n}\nvar supportedInputTypes = {\n  color: !0,\n  date: !0,\n  datetime: !0,\n  \"datetime-local\": !0,\n  email: !0,\n  month: !0,\n  number: !0,\n  password: !0,\n  range: !0,\n  search: !0,\n  tel: !0,\n  text: !0,\n  time: !0,\n  url: !0,\n  week: !0\n};\nfunction isTextInputElement(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return \"input\" === nodeName\n    ? !!supportedInputTypes[elem.type]\n    : \"textarea\" === nodeName\n      ? !0\n      : !1;\n}\nfunction createAndAccumulateChangeEvent(\n  dispatchQueue,\n  inst,\n  nativeEvent,\n  target\n) {\n  restoreTarget\n    ? restoreQueue\n      ? restoreQueue.push(target)\n      : (restoreQueue = [target])\n    : (restoreTarget = target);\n  inst = accumulateTwoPhaseListeners(inst, \"onChange\");\n  0 < inst.length &&\n    ((nativeEvent = new SyntheticEvent(\n      \"onChange\",\n      \"change\",\n      null,\n      nativeEvent,\n      target\n    )),\n    dispatchQueue.push({ event: nativeEvent, listeners: inst }));\n}\nvar activeElement$1 = null,\n  activeElementInst$1 = null;\nfunction runEventInBatch(dispatchQueue) {\n  processDispatchQueue(dispatchQueue, 0);\n}\nfunction getInstIfValueChanged(targetInst) {\n  var targetNode = getNodeFromInstance(targetInst);\n  if (updateValueIfChanged(targetNode)) return targetInst;\n}\nfunction getTargetInstForChangeEvent(domEventName, targetInst) {\n  if (\"change\" === domEventName) return targetInst;\n}\nvar isInputEventSupported = !1;\nif (canUseDOM) {\n  var JSCompiler_inline_result$jscomp$282;\n  if (canUseDOM) {\n    var isSupported$jscomp$inline_417 = \"oninput\" in document;\n    if (!isSupported$jscomp$inline_417) {\n      var element$jscomp$inline_418 = document.createElement(\"div\");\n      element$jscomp$inline_418.setAttribute(\"oninput\", \"return;\");\n      isSupported$jscomp$inline_417 =\n        \"function\" === typeof element$jscomp$inline_418.oninput;\n    }\n    JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;\n  } else JSCompiler_inline_result$jscomp$282 = !1;\n  isInputEventSupported =\n    JSCompiler_inline_result$jscomp$282 &&\n    (!document.documentMode || 9 < document.documentMode);\n}\nfunction stopWatchingForValueChange() {\n  activeElement$1 &&\n    (activeElement$1.detachEvent(\"onpropertychange\", handlePropertyChange),\n    (activeElementInst$1 = activeElement$1 = null));\n}\nfunction handlePropertyChange(nativeEvent) {\n  if (\n    \"value\" === nativeEvent.propertyName &&\n    getInstIfValueChanged(activeElementInst$1)\n  ) {\n    var dispatchQueue = [];\n    createAndAccumulateChangeEvent(\n      dispatchQueue,\n      activeElementInst$1,\n      nativeEvent,\n      getEventTarget(nativeEvent)\n    );\n    batchedUpdates$1(runEventInBatch, dispatchQueue);\n  }\n}\nfunction handleEventsForInputEventPolyfill(domEventName, target, targetInst) {\n  \"focusin\" === domEventName\n    ? (stopWatchingForValueChange(),\n      (activeElement$1 = target),\n      (activeElementInst$1 = targetInst),\n      activeElement$1.attachEvent(\"onpropertychange\", handlePropertyChange))\n    : \"focusout\" === domEventName && stopWatchingForValueChange();\n}\nfunction getTargetInstForInputEventPolyfill(domEventName) {\n  if (\n    \"selectionchange\" === domEventName ||\n    \"keyup\" === domEventName ||\n    \"keydown\" === domEventName\n  )\n    return getInstIfValueChanged(activeElementInst$1);\n}\nfunction getTargetInstForClickEvent(domEventName, targetInst) {\n  if (\"click\" === domEventName) return getInstIfValueChanged(targetInst);\n}\nfunction getTargetInstForInputOrChangeEvent(domEventName, targetInst) {\n  if (\"input\" === domEventName || \"change\" === domEventName)\n    return getInstIfValueChanged(targetInst);\n}\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is;\nfunction shallowEqual(objA, objB) {\n  if (objectIs(objA, objB)) return !0;\n  if (\n    \"object\" !== typeof objA ||\n    null === objA ||\n    \"object\" !== typeof objB ||\n    null === objB\n  )\n    return !1;\n  var keysA = Object.keys(objA),\n    keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return !1;\n  for (keysB = 0; keysB < keysA.length; keysB++) {\n    var currentKey = keysA[keysB];\n    if (\n      !hasOwnProperty.call(objB, currentKey) ||\n      !objectIs(objA[currentKey], objB[currentKey])\n    )\n      return !1;\n  }\n  return !0;\n}\nfunction getLeafNode(node) {\n  for (; node && node.firstChild; ) node = node.firstChild;\n  return node;\n}\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  root = 0;\n  for (var nodeEnd; node; ) {\n    if (3 === node.nodeType) {\n      nodeEnd = root + node.textContent.length;\n      if (root <= offset && nodeEnd >= offset)\n        return { node: node, offset: offset - root };\n      root = nodeEnd;\n    }\n    a: {\n      for (; node; ) {\n        if (node.nextSibling) {\n          node = node.nextSibling;\n          break a;\n        }\n        node = node.parentNode;\n      }\n      node = void 0;\n    }\n    node = getLeafNode(node);\n  }\n}\nfunction containsNode(outerNode, innerNode) {\n  return outerNode && innerNode\n    ? outerNode === innerNode\n      ? !0\n      : outerNode && 3 === outerNode.nodeType\n        ? !1\n        : innerNode && 3 === innerNode.nodeType\n          ? containsNode(outerNode, innerNode.parentNode)\n          : \"contains\" in outerNode\n            ? outerNode.contains(innerNode)\n            : outerNode.compareDocumentPosition\n              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)\n              : !1\n    : !1;\n}\nfunction getActiveElementDeep(containerInfo) {\n  containerInfo =\n    null != containerInfo &&\n    null != containerInfo.ownerDocument &&\n    null != containerInfo.ownerDocument.defaultView\n      ? containerInfo.ownerDocument.defaultView\n      : window;\n  for (\n    var element = getActiveElement(containerInfo.document);\n    element instanceof containerInfo.HTMLIFrameElement;\n\n  ) {\n    try {\n      var JSCompiler_inline_result =\n        \"string\" === typeof element.contentWindow.location.href;\n    } catch (err) {\n      JSCompiler_inline_result = !1;\n    }\n    if (JSCompiler_inline_result) containerInfo = element.contentWindow;\n    else break;\n    element = getActiveElement(containerInfo.document);\n  }\n  return element;\n}\nfunction hasSelectionCapabilities(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return (\n    nodeName &&\n    ((\"input\" === nodeName &&\n      (\"text\" === elem.type ||\n        \"search\" === elem.type ||\n        \"tel\" === elem.type ||\n        \"url\" === elem.type ||\n        \"password\" === elem.type)) ||\n      \"textarea\" === nodeName ||\n      \"true\" === elem.contentEditable)\n  );\n}\nvar skipSelectionChangeEvent =\n    canUseDOM && \"documentMode\" in document && 11 >= document.documentMode,\n  activeElement = null,\n  activeElementInst = null,\n  lastSelection = null,\n  mouseDown = !1;\nfunction constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\n  var doc =\n    nativeEventTarget.window === nativeEventTarget\n      ? nativeEventTarget.document\n      : 9 === nativeEventTarget.nodeType\n        ? nativeEventTarget\n        : nativeEventTarget.ownerDocument;\n  mouseDown ||\n    null == activeElement ||\n    activeElement !== getActiveElement(doc) ||\n    ((doc = activeElement),\n    \"selectionStart\" in doc && hasSelectionCapabilities(doc)\n      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })\n      : ((doc = (\n          (doc.ownerDocument && doc.ownerDocument.defaultView) ||\n          window\n        ).getSelection()),\n        (doc = {\n          anchorNode: doc.anchorNode,\n          anchorOffset: doc.anchorOffset,\n          focusNode: doc.focusNode,\n          focusOffset: doc.focusOffset\n        })),\n    (lastSelection && shallowEqual(lastSelection, doc)) ||\n      ((lastSelection = doc),\n      (doc = accumulateTwoPhaseListeners(activeElementInst, \"onSelect\")),\n      0 < doc.length &&\n        ((nativeEvent = new SyntheticEvent(\n          \"onSelect\",\n          \"select\",\n          null,\n          nativeEvent,\n          nativeEventTarget\n        )),\n        dispatchQueue.push({ event: nativeEvent, listeners: doc }),\n        (nativeEvent.target = activeElement))));\n}\nfunction makePrefixMap(styleProp, eventName) {\n  var prefixes = {};\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes[\"Webkit\" + styleProp] = \"webkit\" + eventName;\n  prefixes[\"Moz\" + styleProp] = \"moz\" + eventName;\n  return prefixes;\n}\nvar vendorPrefixes = {\n    animationend: makePrefixMap(\"Animation\", \"AnimationEnd\"),\n    animationiteration: makePrefixMap(\"Animation\", \"AnimationIteration\"),\n    animationstart: makePrefixMap(\"Animation\", \"AnimationStart\"),\n    transitionrun: makePrefixMap(\"Transition\", \"TransitionRun\"),\n    transitionstart: makePrefixMap(\"Transition\", \"TransitionStart\"),\n    transitioncancel: makePrefixMap(\"Transition\", \"TransitionCancel\"),\n    transitionend: makePrefixMap(\"Transition\", \"TransitionEnd\")\n  },\n  prefixedEventNames = {},\n  style = {};\ncanUseDOM &&\n  ((style = document.createElement(\"div\").style),\n  \"AnimationEvent\" in window ||\n    (delete vendorPrefixes.animationend.animation,\n    delete vendorPrefixes.animationiteration.animation,\n    delete vendorPrefixes.animationstart.animation),\n  \"TransitionEvent\" in window ||\n    delete vendorPrefixes.transitionend.transition);\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];\n  if (!vendorPrefixes[eventName]) return eventName;\n  var prefixMap = vendorPrefixes[eventName],\n    styleProp;\n  for (styleProp in prefixMap)\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)\n      return (prefixedEventNames[eventName] = prefixMap[styleProp]);\n  return eventName;\n}\nvar ANIMATION_END = getVendorPrefixedEventName(\"animationend\"),\n  ANIMATION_ITERATION = getVendorPrefixedEventName(\"animationiteration\"),\n  ANIMATION_START = getVendorPrefixedEventName(\"animationstart\"),\n  TRANSITION_RUN = getVendorPrefixedEventName(\"transitionrun\"),\n  TRANSITION_START = getVendorPrefixedEventName(\"transitionstart\"),\n  TRANSITION_CANCEL = getVendorPrefixedEventName(\"transitioncancel\"),\n  TRANSITION_END = getVendorPrefixedEventName(\"transitionend\"),\n  topLevelEventsToReactNames = new Map(),\n  simpleEventPluginEvents =\n    \"abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel\".split(\n      \" \"\n    );\nsimpleEventPluginEvents.push(\"scrollEnd\");\nfunction registerSimpleEvent(domEventName, reactName) {\n  topLevelEventsToReactNames.set(domEventName, reactName);\n  registerTwoPhaseEvent(reactName, [domEventName]);\n}\nvar CapturedStacks = new WeakMap();\nfunction createCapturedValueAtFiber(value, source) {\n  if (\"object\" === typeof value && null !== value) {\n    var existing = CapturedStacks.get(value);\n    if (void 0 !== existing) return existing;\n    source = {\n      value: value,\n      source: source,\n      stack: getStackByFiberInDevAndProd(source)\n    };\n    CapturedStacks.set(value, source);\n    return source;\n  }\n  return {\n    value: value,\n    source: source,\n    stack: getStackByFiberInDevAndProd(source)\n  };\n}\nvar concurrentQueues = [],\n  concurrentQueuesIndex = 0,\n  concurrentlyUpdatedLanes = 0;\nfunction finishQueueingConcurrentUpdates() {\n  for (\n    var endIndex = concurrentQueuesIndex,\n      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);\n    i < endIndex;\n\n  ) {\n    var fiber = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    var queue = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    var update = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    var lane = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    if (null !== queue && null !== update) {\n      var pending = queue.pending;\n      null === pending\n        ? (update.next = update)\n        : ((update.next = pending.next), (pending.next = update));\n      queue.pending = update;\n    }\n    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);\n  }\n}\nfunction enqueueUpdate$1(fiber, queue, update, lane) {\n  concurrentQueues[concurrentQueuesIndex++] = fiber;\n  concurrentQueues[concurrentQueuesIndex++] = queue;\n  concurrentQueues[concurrentQueuesIndex++] = update;\n  concurrentQueues[concurrentQueuesIndex++] = lane;\n  concurrentlyUpdatedLanes |= lane;\n  fiber.lanes |= lane;\n  fiber = fiber.alternate;\n  null !== fiber && (fiber.lanes |= lane);\n}\nfunction enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n  enqueueUpdate$1(fiber, queue, update, lane);\n  return getRootForUpdatedFiber(fiber);\n}\nfunction enqueueConcurrentRenderForLane(fiber, lane) {\n  enqueueUpdate$1(fiber, null, null, lane);\n  return getRootForUpdatedFiber(fiber);\n}\nfunction markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n  sourceFiber.lanes |= lane;\n  var alternate = sourceFiber.alternate;\n  null !== alternate && (alternate.lanes |= lane);\n  for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )\n    (parent.childLanes |= lane),\n      (alternate = parent.alternate),\n      null !== alternate && (alternate.childLanes |= lane),\n      22 === parent.tag &&\n        ((sourceFiber = parent.stateNode),\n        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)),\n      (sourceFiber = parent),\n      (parent = parent.return);\n  return 3 === sourceFiber.tag\n    ? ((parent = sourceFiber.stateNode),\n      isHidden &&\n        null !== update &&\n        ((isHidden = 31 - clz32(lane)),\n        (sourceFiber = parent.hiddenUpdates),\n        (alternate = sourceFiber[isHidden]),\n        null === alternate\n          ? (sourceFiber[isHidden] = [update])\n          : alternate.push(update),\n        (update.lane = lane | 536870912)),\n      parent)\n    : null;\n}\nfunction getRootForUpdatedFiber(sourceFiber) {\n  if (50 < nestedUpdateCount)\n    throw (\n      ((nestedUpdateCount = 0),\n      (rootWithNestedUpdates = null),\n      Error(formatProdErrorMessage(185)))\n    );\n  for (var parent = sourceFiber.return; null !== parent; )\n    (sourceFiber = parent), (parent = sourceFiber.return);\n  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;\n}\nvar emptyContextObject = {};\nfunction FiberNode(tag, pendingProps, key, mode) {\n  this.tag = tag;\n  this.key = key;\n  this.sibling =\n    this.child =\n    this.return =\n    this.stateNode =\n    this.type =\n    this.elementType =\n      null;\n  this.index = 0;\n  this.refCleanup = this.ref = null;\n  this.pendingProps = pendingProps;\n  this.dependencies =\n    this.memoizedState =\n    this.updateQueue =\n    this.memoizedProps =\n      null;\n  this.mode = mode;\n  this.subtreeFlags = this.flags = 0;\n  this.deletions = null;\n  this.childLanes = this.lanes = 0;\n  this.alternate = null;\n}\nfunction createFiberImplClass(tag, pendingProps, key, mode) {\n  return new FiberNode(tag, pendingProps, key, mode);\n}\nfunction shouldConstruct(Component) {\n  Component = Component.prototype;\n  return !(!Component || !Component.isReactComponent);\n}\nfunction createWorkInProgress(current, pendingProps) {\n  var workInProgress = current.alternate;\n  null === workInProgress\n    ? ((workInProgress = createFiberImplClass(\n        current.tag,\n        pendingProps,\n        current.key,\n        current.mode\n      )),\n      (workInProgress.elementType = current.elementType),\n      (workInProgress.type = current.type),\n      (workInProgress.stateNode = current.stateNode),\n      (workInProgress.alternate = current),\n      (current.alternate = workInProgress))\n    : ((workInProgress.pendingProps = pendingProps),\n      (workInProgress.type = current.type),\n      (workInProgress.flags = 0),\n      (workInProgress.subtreeFlags = 0),\n      (workInProgress.deletions = null));\n  workInProgress.flags = current.flags & 65011712;\n  workInProgress.childLanes = current.childLanes;\n  workInProgress.lanes = current.lanes;\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n  pendingProps = current.dependencies;\n  workInProgress.dependencies =\n    null === pendingProps\n      ? null\n      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n  workInProgress.refCleanup = current.refCleanup;\n  return workInProgress;\n}\nfunction resetWorkInProgress(workInProgress, renderLanes) {\n  workInProgress.flags &= 65011714;\n  var current = workInProgress.alternate;\n  null === current\n    ? ((workInProgress.childLanes = 0),\n      (workInProgress.lanes = renderLanes),\n      (workInProgress.child = null),\n      (workInProgress.subtreeFlags = 0),\n      (workInProgress.memoizedProps = null),\n      (workInProgress.memoizedState = null),\n      (workInProgress.updateQueue = null),\n      (workInProgress.dependencies = null),\n      (workInProgress.stateNode = null))\n    : ((workInProgress.childLanes = current.childLanes),\n      (workInProgress.lanes = current.lanes),\n      (workInProgress.child = current.child),\n      (workInProgress.subtreeFlags = 0),\n      (workInProgress.deletions = null),\n      (workInProgress.memoizedProps = current.memoizedProps),\n      (workInProgress.memoizedState = current.memoizedState),\n      (workInProgress.updateQueue = current.updateQueue),\n      (workInProgress.type = current.type),\n      (renderLanes = current.dependencies),\n      (workInProgress.dependencies =\n        null === renderLanes\n          ? null\n          : {\n              lanes: renderLanes.lanes,\n              firstContext: renderLanes.firstContext\n            }));\n  return workInProgress;\n}\nfunction createFiberFromTypeAndProps(\n  type,\n  key,\n  pendingProps,\n  owner,\n  mode,\n  lanes\n) {\n  var fiberTag = 0;\n  owner = type;\n  if (\"function\" === typeof type) shouldConstruct(type) && (fiberTag = 1);\n  else if (\"string\" === typeof type)\n    fiberTag = isHostHoistableType(\n      type,\n      pendingProps,\n      contextStackCursor.current\n    )\n      ? 26\n      : \"html\" === type || \"head\" === type || \"body\" === type\n        ? 27\n        : 5;\n  else\n    a: switch (type) {\n      case REACT_ACTIVITY_TYPE:\n        return (\n          (type = createFiberImplClass(31, pendingProps, key, mode)),\n          (type.elementType = REACT_ACTIVITY_TYPE),\n          (type.lanes = lanes),\n          type\n        );\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = 8;\n        mode |= 24;\n        break;\n      case REACT_PROFILER_TYPE:\n        return (\n          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),\n          (type.elementType = REACT_PROFILER_TYPE),\n          (type.lanes = lanes),\n          type\n        );\n      case REACT_SUSPENSE_TYPE:\n        return (\n          (type = createFiberImplClass(13, pendingProps, key, mode)),\n          (type.elementType = REACT_SUSPENSE_TYPE),\n          (type.lanes = lanes),\n          type\n        );\n      case REACT_SUSPENSE_LIST_TYPE:\n        return (\n          (type = createFiberImplClass(19, pendingProps, key, mode)),\n          (type.elementType = REACT_SUSPENSE_LIST_TYPE),\n          (type.lanes = lanes),\n          type\n        );\n      default:\n        if (\"object\" === typeof type && null !== type)\n          switch (type.$$typeof) {\n            case REACT_PROVIDER_TYPE:\n            case REACT_CONTEXT_TYPE:\n              fiberTag = 10;\n              break a;\n            case REACT_CONSUMER_TYPE:\n              fiberTag = 9;\n              break a;\n            case REACT_FORWARD_REF_TYPE:\n              fiberTag = 11;\n              break a;\n            case REACT_MEMO_TYPE:\n              fiberTag = 14;\n              break a;\n            case REACT_LAZY_TYPE:\n              fiberTag = 16;\n              owner = null;\n              break a;\n          }\n        fiberTag = 29;\n        pendingProps = Error(\n          formatProdErrorMessage(130, null === type ? \"null\" : typeof type, \"\")\n        );\n        owner = null;\n    }\n  key = createFiberImplClass(fiberTag, pendingProps, key, mode);\n  key.elementType = type;\n  key.type = owner;\n  key.lanes = lanes;\n  return key;\n}\nfunction createFiberFromFragment(elements, mode, lanes, key) {\n  elements = createFiberImplClass(7, elements, key, mode);\n  elements.lanes = lanes;\n  return elements;\n}\nfunction createFiberFromText(content, mode, lanes) {\n  content = createFiberImplClass(6, content, null, mode);\n  content.lanes = lanes;\n  return content;\n}\nfunction createFiberFromPortal(portal, mode, lanes) {\n  mode = createFiberImplClass(\n    4,\n    null !== portal.children ? portal.children : [],\n    portal.key,\n    mode\n  );\n  mode.lanes = lanes;\n  mode.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null,\n    implementation: portal.implementation\n  };\n  return mode;\n}\nvar forkStack = [],\n  forkStackIndex = 0,\n  treeForkProvider = null,\n  treeForkCount = 0,\n  idStack = [],\n  idStackIndex = 0,\n  treeContextProvider = null,\n  treeContextId = 1,\n  treeContextOverflow = \"\";\nfunction pushTreeFork(workInProgress, totalChildren) {\n  forkStack[forkStackIndex++] = treeForkCount;\n  forkStack[forkStackIndex++] = treeForkProvider;\n  treeForkProvider = workInProgress;\n  treeForkCount = totalChildren;\n}\nfunction pushTreeId(workInProgress, totalChildren, index) {\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n  treeContextProvider = workInProgress;\n  var baseIdWithLeadingBit = treeContextId;\n  workInProgress = treeContextOverflow;\n  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n  baseIdWithLeadingBit &= ~(1 << baseLength);\n  index += 1;\n  var length = 32 - clz32(totalChildren) + baseLength;\n  if (30 < length) {\n    var numberOfOverflowBits = baseLength - (baseLength % 5);\n    length = (\n      baseIdWithLeadingBit &\n      ((1 << numberOfOverflowBits) - 1)\n    ).toString(32);\n    baseIdWithLeadingBit >>= numberOfOverflowBits;\n    baseLength -= numberOfOverflowBits;\n    treeContextId =\n      (1 << (32 - clz32(totalChildren) + baseLength)) |\n      (index << baseLength) |\n      baseIdWithLeadingBit;\n    treeContextOverflow = length + workInProgress;\n  } else\n    (treeContextId =\n      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),\n      (treeContextOverflow = workInProgress);\n}\nfunction pushMaterializedTreeId(workInProgress) {\n  null !== workInProgress.return &&\n    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));\n}\nfunction popTreeContext(workInProgress) {\n  for (; workInProgress === treeForkProvider; )\n    (treeForkProvider = forkStack[--forkStackIndex]),\n      (forkStack[forkStackIndex] = null),\n      (treeForkCount = forkStack[--forkStackIndex]),\n      (forkStack[forkStackIndex] = null);\n  for (; workInProgress === treeContextProvider; )\n    (treeContextProvider = idStack[--idStackIndex]),\n      (idStack[idStackIndex] = null),\n      (treeContextOverflow = idStack[--idStackIndex]),\n      (idStack[idStackIndex] = null),\n      (treeContextId = idStack[--idStackIndex]),\n      (idStack[idStackIndex] = null);\n}\nvar hydrationParentFiber = null,\n  nextHydratableInstance = null,\n  isHydrating = !1,\n  hydrationErrors = null,\n  rootOrSingletonContext = !1,\n  HydrationMismatchException = Error(formatProdErrorMessage(519));\nfunction throwOnHydrationMismatch(fiber) {\n  var error = Error(formatProdErrorMessage(418, \"\"));\n  queueHydrationError(createCapturedValueAtFiber(error, fiber));\n  throw HydrationMismatchException;\n}\nfunction prepareToHydrateHostInstance(fiber) {\n  var instance = fiber.stateNode,\n    type = fiber.type,\n    props = fiber.memoizedProps;\n  instance[internalInstanceKey] = fiber;\n  instance[internalPropsKey] = props;\n  switch (type) {\n    case \"dialog\":\n      listenToNonDelegatedEvent(\"cancel\", instance);\n      listenToNonDelegatedEvent(\"close\", instance);\n      break;\n    case \"iframe\":\n    case \"object\":\n    case \"embed\":\n      listenToNonDelegatedEvent(\"load\", instance);\n      break;\n    case \"video\":\n    case \"audio\":\n      for (type = 0; type < mediaEventTypes.length; type++)\n        listenToNonDelegatedEvent(mediaEventTypes[type], instance);\n      break;\n    case \"source\":\n      listenToNonDelegatedEvent(\"error\", instance);\n      break;\n    case \"img\":\n    case \"image\":\n    case \"link\":\n      listenToNonDelegatedEvent(\"error\", instance);\n      listenToNonDelegatedEvent(\"load\", instance);\n      break;\n    case \"details\":\n      listenToNonDelegatedEvent(\"toggle\", instance);\n      break;\n    case \"input\":\n      listenToNonDelegatedEvent(\"invalid\", instance);\n      initInput(\n        instance,\n        props.value,\n        props.defaultValue,\n        props.checked,\n        props.defaultChecked,\n        props.type,\n        props.name,\n        !0\n      );\n      track(instance);\n      break;\n    case \"select\":\n      listenToNonDelegatedEvent(\"invalid\", instance);\n      break;\n    case \"textarea\":\n      listenToNonDelegatedEvent(\"invalid\", instance),\n        initTextarea(instance, props.value, props.defaultValue, props.children),\n        track(instance);\n  }\n  type = props.children;\n  (\"string\" !== typeof type &&\n    \"number\" !== typeof type &&\n    \"bigint\" !== typeof type) ||\n  instance.textContent === \"\" + type ||\n  !0 === props.suppressHydrationWarning ||\n  checkForUnmatchedText(instance.textContent, type)\n    ? (null != props.popover &&\n        (listenToNonDelegatedEvent(\"beforetoggle\", instance),\n        listenToNonDelegatedEvent(\"toggle\", instance)),\n      null != props.onScroll && listenToNonDelegatedEvent(\"scroll\", instance),\n      null != props.onScrollEnd &&\n        listenToNonDelegatedEvent(\"scrollend\", instance),\n      null != props.onClick && (instance.onclick = noop$1),\n      (instance = !0))\n    : (instance = !1);\n  instance || throwOnHydrationMismatch(fiber);\n}\nfunction popToNextHostParent(fiber) {\n  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )\n    switch (hydrationParentFiber.tag) {\n      case 5:\n      case 13:\n        rootOrSingletonContext = !1;\n        return;\n      case 27:\n      case 3:\n        rootOrSingletonContext = !0;\n        return;\n      default:\n        hydrationParentFiber = hydrationParentFiber.return;\n    }\n}\nfunction popHydrationState(fiber) {\n  if (fiber !== hydrationParentFiber) return !1;\n  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;\n  var tag = fiber.tag,\n    JSCompiler_temp;\n  if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {\n    if ((JSCompiler_temp = 5 === tag))\n      (JSCompiler_temp = fiber.type),\n        (JSCompiler_temp =\n          !(\"form\" !== JSCompiler_temp && \"button\" !== JSCompiler_temp) ||\n          shouldSetTextContent(fiber.type, fiber.memoizedProps));\n    JSCompiler_temp = !JSCompiler_temp;\n  }\n  JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);\n  popToNextHostParent(fiber);\n  if (13 === tag) {\n    fiber = fiber.memoizedState;\n    fiber = null !== fiber ? fiber.dehydrated : null;\n    if (!fiber) throw Error(formatProdErrorMessage(317));\n    a: {\n      fiber = fiber.nextSibling;\n      for (tag = 0; fiber; ) {\n        if (8 === fiber.nodeType)\n          if (((JSCompiler_temp = fiber.data), \"/$\" === JSCompiler_temp)) {\n            if (0 === tag) {\n              nextHydratableInstance = getNextHydratable(fiber.nextSibling);\n              break a;\n            }\n            tag--;\n          } else\n            (\"$\" !== JSCompiler_temp &&\n              \"$!\" !== JSCompiler_temp &&\n              \"$?\" !== JSCompiler_temp) ||\n              tag++;\n        fiber = fiber.nextSibling;\n      }\n      nextHydratableInstance = null;\n    }\n  } else\n    27 === tag\n      ? ((tag = nextHydratableInstance),\n        isSingletonScope(fiber.type)\n          ? ((fiber = previousHydratableOnEnteringScopedSingleton),\n            (previousHydratableOnEnteringScopedSingleton = null),\n            (nextHydratableInstance = fiber))\n          : (nextHydratableInstance = tag))\n      : (nextHydratableInstance = hydrationParentFiber\n          ? getNextHydratable(fiber.stateNode.nextSibling)\n          : null);\n  return !0;\n}\nfunction resetHydrationState() {\n  nextHydratableInstance = hydrationParentFiber = null;\n  isHydrating = !1;\n}\nfunction upgradeHydrationErrorsToRecoverable() {\n  var queuedErrors = hydrationErrors;\n  null !== queuedErrors &&\n    (null === workInProgressRootRecoverableErrors\n      ? (workInProgressRootRecoverableErrors = queuedErrors)\n      : workInProgressRootRecoverableErrors.push.apply(\n          workInProgressRootRecoverableErrors,\n          queuedErrors\n        ),\n    (hydrationErrors = null));\n  return queuedErrors;\n}\nfunction queueHydrationError(error) {\n  null === hydrationErrors\n    ? (hydrationErrors = [error])\n    : hydrationErrors.push(error);\n}\nvar valueCursor = createCursor(null),\n  currentlyRenderingFiber$1 = null,\n  lastContextDependency = null;\nfunction pushProvider(providerFiber, context, nextValue) {\n  push(valueCursor, context._currentValue);\n  context._currentValue = nextValue;\n}\nfunction popProvider(context) {\n  context._currentValue = valueCursor.current;\n  pop(valueCursor);\n}\nfunction scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n  for (; null !== parent; ) {\n    var alternate = parent.alternate;\n    (parent.childLanes & renderLanes) !== renderLanes\n      ? ((parent.childLanes |= renderLanes),\n        null !== alternate && (alternate.childLanes |= renderLanes))\n      : null !== alternate &&\n        (alternate.childLanes & renderLanes) !== renderLanes &&\n        (alternate.childLanes |= renderLanes);\n    if (parent === propagationRoot) break;\n    parent = parent.return;\n  }\n}\nfunction propagateContextChanges(\n  workInProgress,\n  contexts,\n  renderLanes,\n  forcePropagateEntireTree\n) {\n  var fiber = workInProgress.child;\n  null !== fiber && (fiber.return = workInProgress);\n  for (; null !== fiber; ) {\n    var list = fiber.dependencies;\n    if (null !== list) {\n      var nextFiber = fiber.child;\n      list = list.firstContext;\n      a: for (; null !== list; ) {\n        var dependency = list;\n        list = fiber;\n        for (var i = 0; i < contexts.length; i++)\n          if (dependency.context === contexts[i]) {\n            list.lanes |= renderLanes;\n            dependency = list.alternate;\n            null !== dependency && (dependency.lanes |= renderLanes);\n            scheduleContextWorkOnParentPath(\n              list.return,\n              renderLanes,\n              workInProgress\n            );\n            forcePropagateEntireTree || (nextFiber = null);\n            break a;\n          }\n        list = dependency.next;\n      }\n    } else if (18 === fiber.tag) {\n      nextFiber = fiber.return;\n      if (null === nextFiber) throw Error(formatProdErrorMessage(341));\n      nextFiber.lanes |= renderLanes;\n      list = nextFiber.alternate;\n      null !== list && (list.lanes |= renderLanes);\n      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);\n      nextFiber = null;\n    } else nextFiber = fiber.child;\n    if (null !== nextFiber) nextFiber.return = fiber;\n    else\n      for (nextFiber = fiber; null !== nextFiber; ) {\n        if (nextFiber === workInProgress) {\n          nextFiber = null;\n          break;\n        }\n        fiber = nextFiber.sibling;\n        if (null !== fiber) {\n          fiber.return = nextFiber.return;\n          nextFiber = fiber;\n          break;\n        }\n        nextFiber = nextFiber.return;\n      }\n    fiber = nextFiber;\n  }\n}\nfunction propagateParentContextChanges(\n  current,\n  workInProgress,\n  renderLanes,\n  forcePropagateEntireTree\n) {\n  current = null;\n  for (\n    var parent = workInProgress, isInsidePropagationBailout = !1;\n    null !== parent;\n\n  ) {\n    if (!isInsidePropagationBailout)\n      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;\n      else if (0 !== (parent.flags & 262144)) break;\n    if (10 === parent.tag) {\n      var currentParent = parent.alternate;\n      if (null === currentParent) throw Error(formatProdErrorMessage(387));\n      currentParent = currentParent.memoizedProps;\n      if (null !== currentParent) {\n        var context = parent.type;\n        objectIs(parent.pendingProps.value, currentParent.value) ||\n          (null !== current ? current.push(context) : (current = [context]));\n      }\n    } else if (parent === hostTransitionProviderCursor.current) {\n      currentParent = parent.alternate;\n      if (null === currentParent) throw Error(formatProdErrorMessage(387));\n      currentParent.memoizedState.memoizedState !==\n        parent.memoizedState.memoizedState &&\n        (null !== current\n          ? current.push(HostTransitionContext)\n          : (current = [HostTransitionContext]));\n    }\n    parent = parent.return;\n  }\n  null !== current &&\n    propagateContextChanges(\n      workInProgress,\n      current,\n      renderLanes,\n      forcePropagateEntireTree\n    );\n  workInProgress.flags |= 262144;\n}\nfunction checkIfContextChanged(currentDependencies) {\n  for (\n    currentDependencies = currentDependencies.firstContext;\n    null !== currentDependencies;\n\n  ) {\n    if (\n      !objectIs(\n        currentDependencies.context._currentValue,\n        currentDependencies.memoizedValue\n      )\n    )\n      return !0;\n    currentDependencies = currentDependencies.next;\n  }\n  return !1;\n}\nfunction prepareToReadContext(workInProgress) {\n  currentlyRenderingFiber$1 = workInProgress;\n  lastContextDependency = null;\n  workInProgress = workInProgress.dependencies;\n  null !== workInProgress && (workInProgress.firstContext = null);\n}\nfunction readContext(context) {\n  return readContextForConsumer(currentlyRenderingFiber$1, context);\n}\nfunction readContextDuringReconciliation(consumer, context) {\n  null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);\n  return readContextForConsumer(consumer, context);\n}\nfunction readContextForConsumer(consumer, context) {\n  var value = context._currentValue;\n  context = { context: context, memoizedValue: value, next: null };\n  if (null === lastContextDependency) {\n    if (null === consumer) throw Error(formatProdErrorMessage(308));\n    lastContextDependency = context;\n    consumer.dependencies = { lanes: 0, firstContext: context };\n    consumer.flags |= 524288;\n  } else lastContextDependency = lastContextDependency.next = context;\n  return value;\n}\nvar AbortControllerLocal =\n    \"undefined\" !== typeof AbortController\n      ? AbortController\n      : function () {\n          var listeners = [],\n            signal = (this.signal = {\n              aborted: !1,\n              addEventListener: function (type, listener) {\n                listeners.push(listener);\n              }\n            });\n          this.abort = function () {\n            signal.aborted = !0;\n            listeners.forEach(function (listener) {\n              return listener();\n            });\n          };\n        },\n  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,\n  NormalPriority = Scheduler.unstable_NormalPriority,\n  CacheContext = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    Consumer: null,\n    Provider: null,\n    _currentValue: null,\n    _currentValue2: null,\n    _threadCount: 0\n  };\nfunction createCache() {\n  return {\n    controller: new AbortControllerLocal(),\n    data: new Map(),\n    refCount: 0\n  };\n}\nfunction releaseCache(cache) {\n  cache.refCount--;\n  0 === cache.refCount &&\n    scheduleCallback$2(NormalPriority, function () {\n      cache.controller.abort();\n    });\n}\nvar currentEntangledListeners = null,\n  currentEntangledPendingCount = 0,\n  currentEntangledLane = 0,\n  currentEntangledActionThenable = null;\nfunction entangleAsyncAction(transition, thenable) {\n  if (null === currentEntangledListeners) {\n    var entangledListeners = (currentEntangledListeners = []);\n    currentEntangledPendingCount = 0;\n    currentEntangledLane = requestTransitionLane();\n    currentEntangledActionThenable = {\n      status: \"pending\",\n      value: void 0,\n      then: function (resolve) {\n        entangledListeners.push(resolve);\n      }\n    };\n  }\n  currentEntangledPendingCount++;\n  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n  return thenable;\n}\nfunction pingEngtangledActionScope() {\n  if (\n    0 === --currentEntangledPendingCount &&\n    null !== currentEntangledListeners\n  ) {\n    null !== currentEntangledActionThenable &&\n      (currentEntangledActionThenable.status = \"fulfilled\");\n    var listeners = currentEntangledListeners;\n    currentEntangledListeners = null;\n    currentEntangledLane = 0;\n    currentEntangledActionThenable = null;\n    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();\n  }\n}\nfunction chainThenableValue(thenable, result) {\n  var listeners = [],\n    thenableWithOverride = {\n      status: \"pending\",\n      value: null,\n      reason: null,\n      then: function (resolve) {\n        listeners.push(resolve);\n      }\n    };\n  thenable.then(\n    function () {\n      thenableWithOverride.status = \"fulfilled\";\n      thenableWithOverride.value = result;\n      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);\n    },\n    function (error) {\n      thenableWithOverride.status = \"rejected\";\n      thenableWithOverride.reason = error;\n      for (error = 0; error < listeners.length; error++)\n        (0, listeners[error])(void 0);\n    }\n  );\n  return thenableWithOverride;\n}\nvar prevOnStartTransitionFinish = ReactSharedInternals.S;\nReactSharedInternals.S = function (transition, returnValue) {\n  \"object\" === typeof returnValue &&\n    null !== returnValue &&\n    \"function\" === typeof returnValue.then &&\n    entangleAsyncAction(transition, returnValue);\n  null !== prevOnStartTransitionFinish &&\n    prevOnStartTransitionFinish(transition, returnValue);\n};\nvar resumedCache = createCursor(null);\nfunction peekCacheFromPool() {\n  var cacheResumedFromPreviousRender = resumedCache.current;\n  return null !== cacheResumedFromPreviousRender\n    ? cacheResumedFromPreviousRender\n    : workInProgressRoot.pooledCache;\n}\nfunction pushTransition(offscreenWorkInProgress, prevCachePool) {\n  null === prevCachePool\n    ? push(resumedCache, resumedCache.current)\n    : push(resumedCache, prevCachePool.pool);\n}\nfunction getSuspendedCache() {\n  var cacheFromPool = peekCacheFromPool();\n  return null === cacheFromPool\n    ? null\n    : { parent: CacheContext._currentValue, pool: cacheFromPool };\n}\nvar SuspenseException = Error(formatProdErrorMessage(460)),\n  SuspenseyCommitException = Error(formatProdErrorMessage(474)),\n  SuspenseActionException = Error(formatProdErrorMessage(542)),\n  noopSuspenseyCommitThenable = { then: function () {} };\nfunction isThenableResolved(thenable) {\n  thenable = thenable.status;\n  return \"fulfilled\" === thenable || \"rejected\" === thenable;\n}\nfunction noop$3() {}\nfunction trackUsedThenable(thenableState, thenable, index) {\n  index = thenableState[index];\n  void 0 === index\n    ? thenableState.push(thenable)\n    : index !== thenable && (thenable.then(noop$3, noop$3), (thenable = index));\n  switch (thenable.status) {\n    case \"fulfilled\":\n      return thenable.value;\n    case \"rejected\":\n      throw (\n        ((thenableState = thenable.reason),\n        checkIfUseWrappedInAsyncCatch(thenableState),\n        thenableState)\n      );\n    default:\n      if (\"string\" === typeof thenable.status) thenable.then(noop$3, noop$3);\n      else {\n        thenableState = workInProgressRoot;\n        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)\n          throw Error(formatProdErrorMessage(482));\n        thenableState = thenable;\n        thenableState.status = \"pending\";\n        thenableState.then(\n          function (fulfilledValue) {\n            if (\"pending\" === thenable.status) {\n              var fulfilledThenable = thenable;\n              fulfilledThenable.status = \"fulfilled\";\n              fulfilledThenable.value = fulfilledValue;\n            }\n          },\n          function (error) {\n            if (\"pending\" === thenable.status) {\n              var rejectedThenable = thenable;\n              rejectedThenable.status = \"rejected\";\n              rejectedThenable.reason = error;\n            }\n          }\n        );\n      }\n      switch (thenable.status) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw (\n            ((thenableState = thenable.reason),\n            checkIfUseWrappedInAsyncCatch(thenableState),\n            thenableState)\n          );\n      }\n      suspendedThenable = thenable;\n      throw SuspenseException;\n  }\n}\nvar suspendedThenable = null;\nfunction getSuspendedThenable() {\n  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));\n  var thenable = suspendedThenable;\n  suspendedThenable = null;\n  return thenable;\n}\nfunction checkIfUseWrappedInAsyncCatch(rejectedReason) {\n  if (\n    rejectedReason === SuspenseException ||\n    rejectedReason === SuspenseActionException\n  )\n    throw Error(formatProdErrorMessage(483));\n}\nvar hasForceUpdate = !1;\nfunction initializeUpdateQueue(fiber) {\n  fiber.updateQueue = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: { pending: null, lanes: 0, hiddenCallbacks: null },\n    callbacks: null\n  };\n}\nfunction cloneUpdateQueue(current, workInProgress) {\n  current = current.updateQueue;\n  workInProgress.updateQueue === current &&\n    (workInProgress.updateQueue = {\n      baseState: current.baseState,\n      firstBaseUpdate: current.firstBaseUpdate,\n      lastBaseUpdate: current.lastBaseUpdate,\n      shared: current.shared,\n      callbacks: null\n    });\n}\nfunction createUpdate(lane) {\n  return { lane: lane, tag: 0, payload: null, callback: null, next: null };\n}\nfunction enqueueUpdate(fiber, update, lane) {\n  var updateQueue = fiber.updateQueue;\n  if (null === updateQueue) return null;\n  updateQueue = updateQueue.shared;\n  if (0 !== (executionContext & 2)) {\n    var pending = updateQueue.pending;\n    null === pending\n      ? (update.next = update)\n      : ((update.next = pending.next), (pending.next = update));\n    updateQueue.pending = update;\n    update = getRootForUpdatedFiber(fiber);\n    markUpdateLaneFromFiberToRoot(fiber, null, lane);\n    return update;\n  }\n  enqueueUpdate$1(fiber, updateQueue, update, lane);\n  return getRootForUpdatedFiber(fiber);\n}\nfunction entangleTransitions(root, fiber, lane) {\n  fiber = fiber.updateQueue;\n  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {\n    var queueLanes = fiber.lanes;\n    queueLanes &= root.pendingLanes;\n    lane |= queueLanes;\n    fiber.lanes = lane;\n    markRootEntangled(root, lane);\n  }\n}\nfunction enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n  var queue = workInProgress.updateQueue,\n    current = workInProgress.alternate;\n  if (\n    null !== current &&\n    ((current = current.updateQueue), queue === current)\n  ) {\n    var newFirst = null,\n      newLast = null;\n    queue = queue.firstBaseUpdate;\n    if (null !== queue) {\n      do {\n        var clone = {\n          lane: queue.lane,\n          tag: queue.tag,\n          payload: queue.payload,\n          callback: null,\n          next: null\n        };\n        null === newLast\n          ? (newFirst = newLast = clone)\n          : (newLast = newLast.next = clone);\n        queue = queue.next;\n      } while (null !== queue);\n      null === newLast\n        ? (newFirst = newLast = capturedUpdate)\n        : (newLast = newLast.next = capturedUpdate);\n    } else newFirst = newLast = capturedUpdate;\n    queue = {\n      baseState: current.baseState,\n      firstBaseUpdate: newFirst,\n      lastBaseUpdate: newLast,\n      shared: current.shared,\n      callbacks: current.callbacks\n    };\n    workInProgress.updateQueue = queue;\n    return;\n  }\n  workInProgress = queue.lastBaseUpdate;\n  null === workInProgress\n    ? (queue.firstBaseUpdate = capturedUpdate)\n    : (workInProgress.next = capturedUpdate);\n  queue.lastBaseUpdate = capturedUpdate;\n}\nvar didReadFromEntangledAsyncAction = !1;\nfunction suspendIfUpdateReadFromEntangledAsyncAction() {\n  if (didReadFromEntangledAsyncAction) {\n    var entangledActionThenable = currentEntangledActionThenable;\n    if (null !== entangledActionThenable) throw entangledActionThenable;\n  }\n}\nfunction processUpdateQueue(\n  workInProgress$jscomp$0,\n  props,\n  instance$jscomp$0,\n  renderLanes\n) {\n  didReadFromEntangledAsyncAction = !1;\n  var queue = workInProgress$jscomp$0.updateQueue;\n  hasForceUpdate = !1;\n  var firstBaseUpdate = queue.firstBaseUpdate,\n    lastBaseUpdate = queue.lastBaseUpdate,\n    pendingQueue = queue.shared.pending;\n  if (null !== pendingQueue) {\n    queue.shared.pending = null;\n    var lastPendingUpdate = pendingQueue,\n      firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null;\n    null === lastBaseUpdate\n      ? (firstBaseUpdate = firstPendingUpdate)\n      : (lastBaseUpdate.next = firstPendingUpdate);\n    lastBaseUpdate = lastPendingUpdate;\n    var current = workInProgress$jscomp$0.alternate;\n    null !== current &&\n      ((current = current.updateQueue),\n      (pendingQueue = current.lastBaseUpdate),\n      pendingQueue !== lastBaseUpdate &&\n        (null === pendingQueue\n          ? (current.firstBaseUpdate = firstPendingUpdate)\n          : (pendingQueue.next = firstPendingUpdate),\n        (current.lastBaseUpdate = lastPendingUpdate)));\n  }\n  if (null !== firstBaseUpdate) {\n    var newState = queue.baseState;\n    lastBaseUpdate = 0;\n    current = firstPendingUpdate = lastPendingUpdate = null;\n    pendingQueue = firstBaseUpdate;\n    do {\n      var updateLane = pendingQueue.lane & -536870913,\n        isHiddenUpdate = updateLane !== pendingQueue.lane;\n      if (\n        isHiddenUpdate\n          ? (workInProgressRootRenderLanes & updateLane) === updateLane\n          : (renderLanes & updateLane) === updateLane\n      ) {\n        0 !== updateLane &&\n          updateLane === currentEntangledLane &&\n          (didReadFromEntangledAsyncAction = !0);\n        null !== current &&\n          (current = current.next =\n            {\n              lane: 0,\n              tag: pendingQueue.tag,\n              payload: pendingQueue.payload,\n              callback: null,\n              next: null\n            });\n        a: {\n          var workInProgress = workInProgress$jscomp$0,\n            update = pendingQueue;\n          updateLane = props;\n          var instance = instance$jscomp$0;\n          switch (update.tag) {\n            case 1:\n              workInProgress = update.payload;\n              if (\"function\" === typeof workInProgress) {\n                newState = workInProgress.call(instance, newState, updateLane);\n                break a;\n              }\n              newState = workInProgress;\n              break a;\n            case 3:\n              workInProgress.flags = (workInProgress.flags & -65537) | 128;\n            case 0:\n              workInProgress = update.payload;\n              updateLane =\n                \"function\" === typeof workInProgress\n                  ? workInProgress.call(instance, newState, updateLane)\n                  : workInProgress;\n              if (null === updateLane || void 0 === updateLane) break a;\n              newState = assign({}, newState, updateLane);\n              break a;\n            case 2:\n              hasForceUpdate = !0;\n          }\n        }\n        updateLane = pendingQueue.callback;\n        null !== updateLane &&\n          ((workInProgress$jscomp$0.flags |= 64),\n          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),\n          (isHiddenUpdate = queue.callbacks),\n          null === isHiddenUpdate\n            ? (queue.callbacks = [updateLane])\n            : isHiddenUpdate.push(updateLane));\n      } else\n        (isHiddenUpdate = {\n          lane: updateLane,\n          tag: pendingQueue.tag,\n          payload: pendingQueue.payload,\n          callback: pendingQueue.callback,\n          next: null\n        }),\n          null === current\n            ? ((firstPendingUpdate = current = isHiddenUpdate),\n              (lastPendingUpdate = newState))\n            : (current = current.next = isHiddenUpdate),\n          (lastBaseUpdate |= updateLane);\n      pendingQueue = pendingQueue.next;\n      if (null === pendingQueue)\n        if (((pendingQueue = queue.shared.pending), null === pendingQueue))\n          break;\n        else\n          (isHiddenUpdate = pendingQueue),\n            (pendingQueue = isHiddenUpdate.next),\n            (isHiddenUpdate.next = null),\n            (queue.lastBaseUpdate = isHiddenUpdate),\n            (queue.shared.pending = null);\n    } while (1);\n    null === current && (lastPendingUpdate = newState);\n    queue.baseState = lastPendingUpdate;\n    queue.firstBaseUpdate = firstPendingUpdate;\n    queue.lastBaseUpdate = current;\n    null === firstBaseUpdate && (queue.shared.lanes = 0);\n    workInProgressRootSkippedLanes |= lastBaseUpdate;\n    workInProgress$jscomp$0.lanes = lastBaseUpdate;\n    workInProgress$jscomp$0.memoizedState = newState;\n  }\n}\nfunction callCallback(callback, context) {\n  if (\"function\" !== typeof callback)\n    throw Error(formatProdErrorMessage(191, callback));\n  callback.call(context);\n}\nfunction commitCallbacks(updateQueue, context) {\n  var callbacks = updateQueue.callbacks;\n  if (null !== callbacks)\n    for (\n      updateQueue.callbacks = null, updateQueue = 0;\n      updateQueue < callbacks.length;\n      updateQueue++\n    )\n      callCallback(callbacks[updateQueue], context);\n}\nvar currentTreeHiddenStackCursor = createCursor(null),\n  prevEntangledRenderLanesCursor = createCursor(0);\nfunction pushHiddenContext(fiber, context) {\n  fiber = entangledRenderLanes;\n  push(prevEntangledRenderLanesCursor, fiber);\n  push(currentTreeHiddenStackCursor, context);\n  entangledRenderLanes = fiber | context.baseLanes;\n}\nfunction reuseHiddenContextOnStack() {\n  push(prevEntangledRenderLanesCursor, entangledRenderLanes);\n  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);\n}\nfunction popHiddenContext() {\n  entangledRenderLanes = prevEntangledRenderLanesCursor.current;\n  pop(currentTreeHiddenStackCursor);\n  pop(prevEntangledRenderLanesCursor);\n}\nvar renderLanes = 0,\n  currentlyRenderingFiber = null,\n  currentHook = null,\n  workInProgressHook = null,\n  didScheduleRenderPhaseUpdate = !1,\n  didScheduleRenderPhaseUpdateDuringThisPass = !1,\n  shouldDoubleInvokeUserFnsInHooksDEV = !1,\n  localIdCounter = 0,\n  thenableIndexCounter$1 = 0,\n  thenableState$1 = null,\n  globalClientIdCounter = 0;\nfunction throwInvalidHookError() {\n  throw Error(formatProdErrorMessage(321));\n}\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  if (null === prevDeps) return !1;\n  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)\n    if (!objectIs(nextDeps[i], prevDeps[i])) return !1;\n  return !0;\n}\nfunction renderWithHooks(\n  current,\n  workInProgress,\n  Component,\n  props,\n  secondArg,\n  nextRenderLanes\n) {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber = workInProgress;\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.lanes = 0;\n  ReactSharedInternals.H =\n    null === current || null === current.memoizedState\n      ? HooksDispatcherOnMount\n      : HooksDispatcherOnUpdate;\n  shouldDoubleInvokeUserFnsInHooksDEV = !1;\n  nextRenderLanes = Component(props, secondArg);\n  shouldDoubleInvokeUserFnsInHooksDEV = !1;\n  didScheduleRenderPhaseUpdateDuringThisPass &&\n    (nextRenderLanes = renderWithHooksAgain(\n      workInProgress,\n      Component,\n      props,\n      secondArg\n    ));\n  finishRenderingHooks(current);\n  return nextRenderLanes;\n}\nfunction finishRenderingHooks(current) {\n  ReactSharedInternals.H = ContextOnlyDispatcher;\n  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;\n  renderLanes = 0;\n  workInProgressHook = currentHook = currentlyRenderingFiber = null;\n  didScheduleRenderPhaseUpdate = !1;\n  thenableIndexCounter$1 = 0;\n  thenableState$1 = null;\n  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));\n  null === current ||\n    didReceiveUpdate ||\n    ((current = current.dependencies),\n    null !== current &&\n      checkIfContextChanged(current) &&\n      (didReceiveUpdate = !0));\n}\nfunction renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n  currentlyRenderingFiber = workInProgress;\n  var numberOfReRenders = 0;\n  do {\n    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);\n    thenableIndexCounter$1 = 0;\n    didScheduleRenderPhaseUpdateDuringThisPass = !1;\n    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));\n    numberOfReRenders += 1;\n    workInProgressHook = currentHook = null;\n    if (null != workInProgress.updateQueue) {\n      var children = workInProgress.updateQueue;\n      children.lastEffect = null;\n      children.events = null;\n      children.stores = null;\n      null != children.memoCache && (children.memoCache.index = 0);\n    }\n    ReactSharedInternals.H = HooksDispatcherOnRerender;\n    children = Component(props, secondArg);\n  } while (didScheduleRenderPhaseUpdateDuringThisPass);\n  return children;\n}\nfunction TransitionAwareHostComponent() {\n  var dispatcher = ReactSharedInternals.H,\n    maybeThenable = dispatcher.useState()[0];\n  maybeThenable =\n    \"function\" === typeof maybeThenable.then\n      ? useThenable(maybeThenable)\n      : maybeThenable;\n  dispatcher = dispatcher.useState()[0];\n  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&\n    (currentlyRenderingFiber.flags |= 1024);\n  return maybeThenable;\n}\nfunction checkDidRenderIdHook() {\n  var didRenderIdHook = 0 !== localIdCounter;\n  localIdCounter = 0;\n  return didRenderIdHook;\n}\nfunction bailoutHooks(current, workInProgress, lanes) {\n  workInProgress.updateQueue = current.updateQueue;\n  workInProgress.flags &= -2053;\n  current.lanes &= ~lanes;\n}\nfunction resetHooksOnUnwind(workInProgress) {\n  if (didScheduleRenderPhaseUpdate) {\n    for (\n      workInProgress = workInProgress.memoizedState;\n      null !== workInProgress;\n\n    ) {\n      var queue = workInProgress.queue;\n      null !== queue && (queue.pending = null);\n      workInProgress = workInProgress.next;\n    }\n    didScheduleRenderPhaseUpdate = !1;\n  }\n  renderLanes = 0;\n  workInProgressHook = currentHook = currentlyRenderingFiber = null;\n  didScheduleRenderPhaseUpdateDuringThisPass = !1;\n  thenableIndexCounter$1 = localIdCounter = 0;\n  thenableState$1 = null;\n}\nfunction mountWorkInProgressHook() {\n  var hook = {\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n    next: null\n  };\n  null === workInProgressHook\n    ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)\n    : (workInProgressHook = workInProgressHook.next = hook);\n  return workInProgressHook;\n}\nfunction updateWorkInProgressHook() {\n  if (null === currentHook) {\n    var nextCurrentHook = currentlyRenderingFiber.alternate;\n    nextCurrentHook =\n      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;\n  } else nextCurrentHook = currentHook.next;\n  var nextWorkInProgressHook =\n    null === workInProgressHook\n      ? currentlyRenderingFiber.memoizedState\n      : workInProgressHook.next;\n  if (null !== nextWorkInProgressHook)\n    (workInProgressHook = nextWorkInProgressHook),\n      (currentHook = nextCurrentHook);\n  else {\n    if (null === nextCurrentHook) {\n      if (null === currentlyRenderingFiber.alternate)\n        throw Error(formatProdErrorMessage(467));\n      throw Error(formatProdErrorMessage(310));\n    }\n    currentHook = nextCurrentHook;\n    nextCurrentHook = {\n      memoizedState: currentHook.memoizedState,\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n      next: null\n    };\n    null === workInProgressHook\n      ? (currentlyRenderingFiber.memoizedState = workInProgressHook =\n          nextCurrentHook)\n      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);\n  }\n  return workInProgressHook;\n}\nfunction createFunctionComponentUpdateQueue() {\n  return { lastEffect: null, events: null, stores: null, memoCache: null };\n}\nfunction useThenable(thenable) {\n  var index = thenableIndexCounter$1;\n  thenableIndexCounter$1 += 1;\n  null === thenableState$1 && (thenableState$1 = []);\n  thenable = trackUsedThenable(thenableState$1, thenable, index);\n  index = currentlyRenderingFiber;\n  null ===\n    (null === workInProgressHook\n      ? index.memoizedState\n      : workInProgressHook.next) &&\n    ((index = index.alternate),\n    (ReactSharedInternals.H =\n      null === index || null === index.memoizedState\n        ? HooksDispatcherOnMount\n        : HooksDispatcherOnUpdate));\n  return thenable;\n}\nfunction use(usable) {\n  if (null !== usable && \"object\" === typeof usable) {\n    if (\"function\" === typeof usable.then) return useThenable(usable);\n    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);\n  }\n  throw Error(formatProdErrorMessage(438, String(usable)));\n}\nfunction useMemoCache(size) {\n  var memoCache = null,\n    updateQueue = currentlyRenderingFiber.updateQueue;\n  null !== updateQueue && (memoCache = updateQueue.memoCache);\n  if (null == memoCache) {\n    var current = currentlyRenderingFiber.alternate;\n    null !== current &&\n      ((current = current.updateQueue),\n      null !== current &&\n        ((current = current.memoCache),\n        null != current &&\n          (memoCache = {\n            data: current.data.map(function (array) {\n              return array.slice();\n            }),\n            index: 0\n          })));\n  }\n  null == memoCache && (memoCache = { data: [], index: 0 });\n  null === updateQueue &&\n    ((updateQueue = createFunctionComponentUpdateQueue()),\n    (currentlyRenderingFiber.updateQueue = updateQueue));\n  updateQueue.memoCache = memoCache;\n  updateQueue = memoCache.data[memoCache.index];\n  if (void 0 === updateQueue)\n    for (\n      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;\n      current < size;\n      current++\n    )\n      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;\n  memoCache.index++;\n  return updateQueue;\n}\nfunction basicStateReducer(state, action) {\n  return \"function\" === typeof action ? action(state) : action;\n}\nfunction updateReducer(reducer) {\n  var hook = updateWorkInProgressHook();\n  return updateReducerImpl(hook, currentHook, reducer);\n}\nfunction updateReducerImpl(hook, current, reducer) {\n  var queue = hook.queue;\n  if (null === queue) throw Error(formatProdErrorMessage(311));\n  queue.lastRenderedReducer = reducer;\n  var baseQueue = hook.baseQueue,\n    pendingQueue = queue.pending;\n  if (null !== pendingQueue) {\n    if (null !== baseQueue) {\n      var baseFirst = baseQueue.next;\n      baseQueue.next = pendingQueue.next;\n      pendingQueue.next = baseFirst;\n    }\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n  pendingQueue = hook.baseState;\n  if (null === baseQueue) hook.memoizedState = pendingQueue;\n  else {\n    current = baseQueue.next;\n    var newBaseQueueFirst = (baseFirst = null),\n      newBaseQueueLast = null,\n      update = current,\n      didReadFromEntangledAsyncAction$32 = !1;\n    do {\n      var updateLane = update.lane & -536870913;\n      if (\n        updateLane !== update.lane\n          ? (workInProgressRootRenderLanes & updateLane) === updateLane\n          : (renderLanes & updateLane) === updateLane\n      ) {\n        var revertLane = update.revertLane;\n        if (0 === revertLane)\n          null !== newBaseQueueLast &&\n            (newBaseQueueLast = newBaseQueueLast.next =\n              {\n                lane: 0,\n                revertLane: 0,\n                action: update.action,\n                hasEagerState: update.hasEagerState,\n                eagerState: update.eagerState,\n                next: null\n              }),\n            updateLane === currentEntangledLane &&\n              (didReadFromEntangledAsyncAction$32 = !0);\n        else if ((renderLanes & revertLane) === revertLane) {\n          update = update.next;\n          revertLane === currentEntangledLane &&\n            (didReadFromEntangledAsyncAction$32 = !0);\n          continue;\n        } else\n          (updateLane = {\n            lane: 0,\n            revertLane: update.revertLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: null\n          }),\n            null === newBaseQueueLast\n              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),\n                (baseFirst = pendingQueue))\n              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),\n            (currentlyRenderingFiber.lanes |= revertLane),\n            (workInProgressRootSkippedLanes |= revertLane);\n        updateLane = update.action;\n        shouldDoubleInvokeUserFnsInHooksDEV &&\n          reducer(pendingQueue, updateLane);\n        pendingQueue = update.hasEagerState\n          ? update.eagerState\n          : reducer(pendingQueue, updateLane);\n      } else\n        (revertLane = {\n          lane: updateLane,\n          revertLane: update.revertLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: null\n        }),\n          null === newBaseQueueLast\n            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),\n              (baseFirst = pendingQueue))\n            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),\n          (currentlyRenderingFiber.lanes |= updateLane),\n          (workInProgressRootSkippedLanes |= updateLane);\n      update = update.next;\n    } while (null !== update && update !== current);\n    null === newBaseQueueLast\n      ? (baseFirst = pendingQueue)\n      : (newBaseQueueLast.next = newBaseQueueFirst);\n    if (\n      !objectIs(pendingQueue, hook.memoizedState) &&\n      ((didReceiveUpdate = !0),\n      didReadFromEntangledAsyncAction$32 &&\n        ((reducer = currentEntangledActionThenable), null !== reducer))\n    )\n      throw reducer;\n    hook.memoizedState = pendingQueue;\n    hook.baseState = baseFirst;\n    hook.baseQueue = newBaseQueueLast;\n    queue.lastRenderedState = pendingQueue;\n  }\n  null === baseQueue && (queue.lanes = 0);\n  return [hook.memoizedState, queue.dispatch];\n}\nfunction rerenderReducer(reducer) {\n  var hook = updateWorkInProgressHook(),\n    queue = hook.queue;\n  if (null === queue) throw Error(formatProdErrorMessage(311));\n  queue.lastRenderedReducer = reducer;\n  var dispatch = queue.dispatch,\n    lastRenderPhaseUpdate = queue.pending,\n    newState = hook.memoizedState;\n  if (null !== lastRenderPhaseUpdate) {\n    queue.pending = null;\n    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);\n    do (newState = reducer(newState, update.action)), (update = update.next);\n    while (update !== lastRenderPhaseUpdate);\n    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);\n    hook.memoizedState = newState;\n    null === hook.baseQueue && (hook.baseState = newState);\n    queue.lastRenderedState = newState;\n  }\n  return [newState, dispatch];\n}\nfunction updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  var fiber = currentlyRenderingFiber,\n    hook = updateWorkInProgressHook(),\n    isHydrating$jscomp$0 = isHydrating;\n  if (isHydrating$jscomp$0) {\n    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));\n    getServerSnapshot = getServerSnapshot();\n  } else getServerSnapshot = getSnapshot();\n  var snapshotChanged = !objectIs(\n    (currentHook || hook).memoizedState,\n    getServerSnapshot\n  );\n  snapshotChanged &&\n    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));\n  hook = hook.queue;\n  var create = subscribeToStore.bind(null, fiber, hook, subscribe);\n  updateEffectImpl(2048, 8, create, [subscribe]);\n  if (\n    hook.getSnapshot !== getSnapshot ||\n    snapshotChanged ||\n    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)\n  ) {\n    fiber.flags |= 2048;\n    pushSimpleEffect(\n      9,\n      createEffectInstance(),\n      updateStoreInstance.bind(\n        null,\n        fiber,\n        hook,\n        getServerSnapshot,\n        getSnapshot\n      ),\n      null\n    );\n    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));\n    isHydrating$jscomp$0 ||\n      0 !== (renderLanes & 124) ||\n      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n  }\n  return getServerSnapshot;\n}\nfunction pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n  fiber.flags |= 16384;\n  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };\n  getSnapshot = currentlyRenderingFiber.updateQueue;\n  null === getSnapshot\n    ? ((getSnapshot = createFunctionComponentUpdateQueue()),\n      (currentlyRenderingFiber.updateQueue = getSnapshot),\n      (getSnapshot.stores = [fiber]))\n    : ((renderedSnapshot = getSnapshot.stores),\n      null === renderedSnapshot\n        ? (getSnapshot.stores = [fiber])\n        : renderedSnapshot.push(fiber));\n}\nfunction updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n  inst.value = nextSnapshot;\n  inst.getSnapshot = getSnapshot;\n  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n}\nfunction subscribeToStore(fiber, inst, subscribe) {\n  return subscribe(function () {\n    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n  });\n}\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  inst = inst.value;\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(inst, nextValue);\n  } catch (error) {\n    return !0;\n  }\n}\nfunction forceStoreRerender(fiber) {\n  var root = enqueueConcurrentRenderForLane(fiber, 2);\n  null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n}\nfunction mountStateImpl(initialState) {\n  var hook = mountWorkInProgressHook();\n  if (\"function\" === typeof initialState) {\n    var initialStateInitializer = initialState;\n    initialState = initialStateInitializer();\n    if (shouldDoubleInvokeUserFnsInHooksDEV) {\n      setIsStrictModeForDevtools(!0);\n      try {\n        initialStateInitializer();\n      } finally {\n        setIsStrictModeForDevtools(!1);\n      }\n    }\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  hook.queue = {\n    pending: null,\n    lanes: 0,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState\n  };\n  return hook;\n}\nfunction updateOptimisticImpl(hook, current, passthrough, reducer) {\n  hook.baseState = passthrough;\n  return updateReducerImpl(\n    hook,\n    currentHook,\n    \"function\" === typeof reducer ? reducer : basicStateReducer\n  );\n}\nfunction dispatchActionState(\n  fiber,\n  actionQueue,\n  setPendingState,\n  setState,\n  payload\n) {\n  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));\n  fiber = actionQueue.action;\n  if (null !== fiber) {\n    var actionNode = {\n      payload: payload,\n      action: fiber,\n      next: null,\n      isTransition: !0,\n      status: \"pending\",\n      value: null,\n      reason: null,\n      listeners: [],\n      then: function (listener) {\n        actionNode.listeners.push(listener);\n      }\n    };\n    null !== ReactSharedInternals.T\n      ? setPendingState(!0)\n      : (actionNode.isTransition = !1);\n    setState(actionNode);\n    setPendingState = actionQueue.pending;\n    null === setPendingState\n      ? ((actionNode.next = actionQueue.pending = actionNode),\n        runActionStateAction(actionQueue, actionNode))\n      : ((actionNode.next = setPendingState.next),\n        (actionQueue.pending = setPendingState.next = actionNode));\n  }\n}\nfunction runActionStateAction(actionQueue, node) {\n  var action = node.action,\n    payload = node.payload,\n    prevState = actionQueue.state;\n  if (node.isTransition) {\n    var prevTransition = ReactSharedInternals.T,\n      currentTransition = {};\n    ReactSharedInternals.T = currentTransition;\n    try {\n      var returnValue = action(prevState, payload),\n        onStartTransitionFinish = ReactSharedInternals.S;\n      null !== onStartTransitionFinish &&\n        onStartTransitionFinish(currentTransition, returnValue);\n      handleActionReturnValue(actionQueue, node, returnValue);\n    } catch (error) {\n      onActionError(actionQueue, node, error);\n    } finally {\n      ReactSharedInternals.T = prevTransition;\n    }\n  } else\n    try {\n      (prevTransition = action(prevState, payload)),\n        handleActionReturnValue(actionQueue, node, prevTransition);\n    } catch (error$38) {\n      onActionError(actionQueue, node, error$38);\n    }\n}\nfunction handleActionReturnValue(actionQueue, node, returnValue) {\n  null !== returnValue &&\n  \"object\" === typeof returnValue &&\n  \"function\" === typeof returnValue.then\n    ? returnValue.then(\n        function (nextState) {\n          onActionSuccess(actionQueue, node, nextState);\n        },\n        function (error) {\n          return onActionError(actionQueue, node, error);\n        }\n      )\n    : onActionSuccess(actionQueue, node, returnValue);\n}\nfunction onActionSuccess(actionQueue, actionNode, nextState) {\n  actionNode.status = \"fulfilled\";\n  actionNode.value = nextState;\n  notifyActionListeners(actionNode);\n  actionQueue.state = nextState;\n  actionNode = actionQueue.pending;\n  null !== actionNode &&\n    ((nextState = actionNode.next),\n    nextState === actionNode\n      ? (actionQueue.pending = null)\n      : ((nextState = nextState.next),\n        (actionNode.next = nextState),\n        runActionStateAction(actionQueue, nextState)));\n}\nfunction onActionError(actionQueue, actionNode, error) {\n  var last = actionQueue.pending;\n  actionQueue.pending = null;\n  if (null !== last) {\n    last = last.next;\n    do\n      (actionNode.status = \"rejected\"),\n        (actionNode.reason = error),\n        notifyActionListeners(actionNode),\n        (actionNode = actionNode.next);\n    while (actionNode !== last);\n  }\n  actionQueue.action = null;\n}\nfunction notifyActionListeners(actionNode) {\n  actionNode = actionNode.listeners;\n  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();\n}\nfunction actionStateReducer(oldState, newState) {\n  return newState;\n}\nfunction mountActionState(action, initialStateProp) {\n  if (isHydrating) {\n    var ssrFormState = workInProgressRoot.formState;\n    if (null !== ssrFormState) {\n      a: {\n        var JSCompiler_inline_result = currentlyRenderingFiber;\n        if (isHydrating) {\n          if (nextHydratableInstance) {\n            b: {\n              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;\n              for (\n                var inRootOrSingleton = rootOrSingletonContext;\n                8 !== JSCompiler_inline_result$jscomp$0.nodeType;\n\n              ) {\n                if (!inRootOrSingleton) {\n                  JSCompiler_inline_result$jscomp$0 = null;\n                  break b;\n                }\n                JSCompiler_inline_result$jscomp$0 = getNextHydratable(\n                  JSCompiler_inline_result$jscomp$0.nextSibling\n                );\n                if (null === JSCompiler_inline_result$jscomp$0) {\n                  JSCompiler_inline_result$jscomp$0 = null;\n                  break b;\n                }\n              }\n              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;\n              JSCompiler_inline_result$jscomp$0 =\n                \"F!\" === inRootOrSingleton || \"F\" === inRootOrSingleton\n                  ? JSCompiler_inline_result$jscomp$0\n                  : null;\n            }\n            if (JSCompiler_inline_result$jscomp$0) {\n              nextHydratableInstance = getNextHydratable(\n                JSCompiler_inline_result$jscomp$0.nextSibling\n              );\n              JSCompiler_inline_result =\n                \"F!\" === JSCompiler_inline_result$jscomp$0.data;\n              break a;\n            }\n          }\n          throwOnHydrationMismatch(JSCompiler_inline_result);\n        }\n        JSCompiler_inline_result = !1;\n      }\n      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);\n    }\n  }\n  ssrFormState = mountWorkInProgressHook();\n  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;\n  JSCompiler_inline_result = {\n    pending: null,\n    lanes: 0,\n    dispatch: null,\n    lastRenderedReducer: actionStateReducer,\n    lastRenderedState: initialStateProp\n  };\n  ssrFormState.queue = JSCompiler_inline_result;\n  ssrFormState = dispatchSetState.bind(\n    null,\n    currentlyRenderingFiber,\n    JSCompiler_inline_result\n  );\n  JSCompiler_inline_result.dispatch = ssrFormState;\n  JSCompiler_inline_result = mountStateImpl(!1);\n  inRootOrSingleton = dispatchOptimisticSetState.bind(\n    null,\n    currentlyRenderingFiber,\n    !1,\n    JSCompiler_inline_result.queue\n  );\n  JSCompiler_inline_result = mountWorkInProgressHook();\n  JSCompiler_inline_result$jscomp$0 = {\n    state: initialStateProp,\n    dispatch: null,\n    action: action,\n    pending: null\n  };\n  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;\n  ssrFormState = dispatchActionState.bind(\n    null,\n    currentlyRenderingFiber,\n    JSCompiler_inline_result$jscomp$0,\n    inRootOrSingleton,\n    ssrFormState\n  );\n  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;\n  JSCompiler_inline_result.memoizedState = action;\n  return [initialStateProp, ssrFormState, !1];\n}\nfunction updateActionState(action) {\n  var stateHook = updateWorkInProgressHook();\n  return updateActionStateImpl(stateHook, currentHook, action);\n}\nfunction updateActionStateImpl(stateHook, currentStateHook, action) {\n  currentStateHook = updateReducerImpl(\n    stateHook,\n    currentStateHook,\n    actionStateReducer\n  )[0];\n  stateHook = updateReducer(basicStateReducer)[0];\n  if (\n    \"object\" === typeof currentStateHook &&\n    null !== currentStateHook &&\n    \"function\" === typeof currentStateHook.then\n  )\n    try {\n      var state = useThenable(currentStateHook);\n    } catch (x) {\n      if (x === SuspenseException) throw SuspenseActionException;\n      throw x;\n    }\n  else state = currentStateHook;\n  currentStateHook = updateWorkInProgressHook();\n  var actionQueue = currentStateHook.queue,\n    dispatch = actionQueue.dispatch;\n  action !== currentStateHook.memoizedState &&\n    ((currentlyRenderingFiber.flags |= 2048),\n    pushSimpleEffect(\n      9,\n      createEffectInstance(),\n      actionStateActionEffect.bind(null, actionQueue, action),\n      null\n    ));\n  return [state, dispatch, stateHook];\n}\nfunction actionStateActionEffect(actionQueue, action) {\n  actionQueue.action = action;\n}\nfunction rerenderActionState(action) {\n  var stateHook = updateWorkInProgressHook(),\n    currentStateHook = currentHook;\n  if (null !== currentStateHook)\n    return updateActionStateImpl(stateHook, currentStateHook, action);\n  updateWorkInProgressHook();\n  stateHook = stateHook.memoizedState;\n  currentStateHook = updateWorkInProgressHook();\n  var dispatch = currentStateHook.queue.dispatch;\n  currentStateHook.memoizedState = action;\n  return [stateHook, dispatch, !1];\n}\nfunction pushSimpleEffect(tag, inst, create, createDeps) {\n  tag = { tag: tag, create: create, deps: createDeps, inst: inst, next: null };\n  inst = currentlyRenderingFiber.updateQueue;\n  null === inst &&\n    ((inst = createFunctionComponentUpdateQueue()),\n    (currentlyRenderingFiber.updateQueue = inst));\n  create = inst.lastEffect;\n  null === create\n    ? (inst.lastEffect = tag.next = tag)\n    : ((createDeps = create.next),\n      (create.next = tag),\n      (tag.next = createDeps),\n      (inst.lastEffect = tag));\n  return tag;\n}\nfunction createEffectInstance() {\n  return { destroy: void 0, resource: void 0 };\n}\nfunction updateRef() {\n  return updateWorkInProgressHook().memoizedState;\n}\nfunction mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {\n  var hook = mountWorkInProgressHook();\n  createDeps = void 0 === createDeps ? null : createDeps;\n  currentlyRenderingFiber.flags |= fiberFlags;\n  hook.memoizedState = pushSimpleEffect(\n    1 | hookFlags,\n    createEffectInstance(),\n    create,\n    createDeps\n  );\n}\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n  var hook = updateWorkInProgressHook();\n  deps = void 0 === deps ? null : deps;\n  var inst = hook.memoizedState.inst;\n  null !== currentHook &&\n  null !== deps &&\n  areHookInputsEqual(deps, currentHook.memoizedState.deps)\n    ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))\n    : ((currentlyRenderingFiber.flags |= fiberFlags),\n      (hook.memoizedState = pushSimpleEffect(\n        1 | hookFlags,\n        inst,\n        create,\n        deps\n      )));\n}\nfunction mountEffect(create, createDeps) {\n  mountEffectImpl(8390656, 8, create, createDeps);\n}\nfunction updateEffect(create, createDeps) {\n  updateEffectImpl(2048, 8, create, createDeps);\n}\nfunction updateInsertionEffect(create, deps) {\n  return updateEffectImpl(4, 2, create, deps);\n}\nfunction updateLayoutEffect(create, deps) {\n  return updateEffectImpl(4, 4, create, deps);\n}\nfunction imperativeHandleEffect(create, ref) {\n  if (\"function\" === typeof ref) {\n    create = create();\n    var refCleanup = ref(create);\n    return function () {\n      \"function\" === typeof refCleanup ? refCleanup() : ref(null);\n    };\n  }\n  if (null !== ref && void 0 !== ref)\n    return (\n      (create = create()),\n      (ref.current = create),\n      function () {\n        ref.current = null;\n      }\n    );\n}\nfunction updateImperativeHandle(ref, create, deps) {\n  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;\n  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);\n}\nfunction mountDebugValue() {}\nfunction updateCallback(callback, deps) {\n  var hook = updateWorkInProgressHook();\n  deps = void 0 === deps ? null : deps;\n  var prevState = hook.memoizedState;\n  if (null !== deps && areHookInputsEqual(deps, prevState[1]))\n    return prevState[0];\n  hook.memoizedState = [callback, deps];\n  return callback;\n}\nfunction updateMemo(nextCreate, deps) {\n  var hook = updateWorkInProgressHook();\n  deps = void 0 === deps ? null : deps;\n  var prevState = hook.memoizedState;\n  if (null !== deps && areHookInputsEqual(deps, prevState[1]))\n    return prevState[0];\n  prevState = nextCreate();\n  if (shouldDoubleInvokeUserFnsInHooksDEV) {\n    setIsStrictModeForDevtools(!0);\n    try {\n      nextCreate();\n    } finally {\n      setIsStrictModeForDevtools(!1);\n    }\n  }\n  hook.memoizedState = [prevState, deps];\n  return prevState;\n}\nfunction mountDeferredValueImpl(hook, value, initialValue) {\n  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))\n    return (hook.memoizedState = value);\n  hook.memoizedState = initialValue;\n  hook = requestDeferredLane();\n  currentlyRenderingFiber.lanes |= hook;\n  workInProgressRootSkippedLanes |= hook;\n  return initialValue;\n}\nfunction updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n  if (objectIs(value, prevValue)) return value;\n  if (null !== currentTreeHiddenStackCursor.current)\n    return (\n      (hook = mountDeferredValueImpl(hook, value, initialValue)),\n      objectIs(hook, prevValue) || (didReceiveUpdate = !0),\n      hook\n    );\n  if (0 === (renderLanes & 42))\n    return (didReceiveUpdate = !0), (hook.memoizedState = value);\n  hook = requestDeferredLane();\n  currentlyRenderingFiber.lanes |= hook;\n  workInProgressRootSkippedLanes |= hook;\n  return prevValue;\n}\nfunction startTransition(fiber, queue, pendingState, finishedState, callback) {\n  var previousPriority = ReactDOMSharedInternals.p;\n  ReactDOMSharedInternals.p =\n    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;\n  var prevTransition = ReactSharedInternals.T,\n    currentTransition = {};\n  ReactSharedInternals.T = currentTransition;\n  dispatchOptimisticSetState(fiber, !1, queue, pendingState);\n  try {\n    var returnValue = callback(),\n      onStartTransitionFinish = ReactSharedInternals.S;\n    null !== onStartTransitionFinish &&\n      onStartTransitionFinish(currentTransition, returnValue);\n    if (\n      null !== returnValue &&\n      \"object\" === typeof returnValue &&\n      \"function\" === typeof returnValue.then\n    ) {\n      var thenableForFinishedState = chainThenableValue(\n        returnValue,\n        finishedState\n      );\n      dispatchSetStateInternal(\n        fiber,\n        queue,\n        thenableForFinishedState,\n        requestUpdateLane(fiber)\n      );\n    } else\n      dispatchSetStateInternal(\n        fiber,\n        queue,\n        finishedState,\n        requestUpdateLane(fiber)\n      );\n  } catch (error) {\n    dispatchSetStateInternal(\n      fiber,\n      queue,\n      { then: function () {}, status: \"rejected\", reason: error },\n      requestUpdateLane()\n    );\n  } finally {\n    (ReactDOMSharedInternals.p = previousPriority),\n      (ReactSharedInternals.T = prevTransition);\n  }\n}\nfunction noop$2() {}\nfunction startHostTransition(formFiber, pendingState, action, formData) {\n  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));\n  var queue = ensureFormComponentIsStateful(formFiber).queue;\n  startTransition(\n    formFiber,\n    queue,\n    pendingState,\n    sharedNotPendingObject,\n    null === action\n      ? noop$2\n      : function () {\n          requestFormReset$1(formFiber);\n          return action(formData);\n        }\n  );\n}\nfunction ensureFormComponentIsStateful(formFiber) {\n  var existingStateHook = formFiber.memoizedState;\n  if (null !== existingStateHook) return existingStateHook;\n  existingStateHook = {\n    memoizedState: sharedNotPendingObject,\n    baseState: sharedNotPendingObject,\n    baseQueue: null,\n    queue: {\n      pending: null,\n      lanes: 0,\n      dispatch: null,\n      lastRenderedReducer: basicStateReducer,\n      lastRenderedState: sharedNotPendingObject\n    },\n    next: null\n  };\n  var initialResetState = {};\n  existingStateHook.next = {\n    memoizedState: initialResetState,\n    baseState: initialResetState,\n    baseQueue: null,\n    queue: {\n      pending: null,\n      lanes: 0,\n      dispatch: null,\n      lastRenderedReducer: basicStateReducer,\n      lastRenderedState: initialResetState\n    },\n    next: null\n  };\n  formFiber.memoizedState = existingStateHook;\n  formFiber = formFiber.alternate;\n  null !== formFiber && (formFiber.memoizedState = existingStateHook);\n  return existingStateHook;\n}\nfunction requestFormReset$1(formFiber) {\n  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;\n  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());\n}\nfunction useHostTransitionStatus() {\n  return readContext(HostTransitionContext);\n}\nfunction updateId() {\n  return updateWorkInProgressHook().memoizedState;\n}\nfunction updateRefresh() {\n  return updateWorkInProgressHook().memoizedState;\n}\nfunction refreshCache(fiber) {\n  for (var provider = fiber.return; null !== provider; ) {\n    switch (provider.tag) {\n      case 24:\n      case 3:\n        var lane = requestUpdateLane();\n        fiber = createUpdate(lane);\n        var root$41 = enqueueUpdate(provider, fiber, lane);\n        null !== root$41 &&\n          (scheduleUpdateOnFiber(root$41, provider, lane),\n          entangleTransitions(root$41, provider, lane));\n        provider = { cache: createCache() };\n        fiber.payload = provider;\n        return;\n    }\n    provider = provider.return;\n  }\n}\nfunction dispatchReducerAction(fiber, queue, action) {\n  var lane = requestUpdateLane();\n  action = {\n    lane: lane,\n    revertLane: 0,\n    action: action,\n    hasEagerState: !1,\n    eagerState: null,\n    next: null\n  };\n  isRenderPhaseUpdate(fiber)\n    ? enqueueRenderPhaseUpdate(queue, action)\n    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),\n      null !== action &&\n        (scheduleUpdateOnFiber(action, fiber, lane),\n        entangleTransitionUpdate(action, queue, lane)));\n}\nfunction dispatchSetState(fiber, queue, action) {\n  var lane = requestUpdateLane();\n  dispatchSetStateInternal(fiber, queue, action, lane);\n}\nfunction dispatchSetStateInternal(fiber, queue, action, lane) {\n  var update = {\n    lane: lane,\n    revertLane: 0,\n    action: action,\n    hasEagerState: !1,\n    eagerState: null,\n    next: null\n  };\n  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);\n  else {\n    var alternate = fiber.alternate;\n    if (\n      0 === fiber.lanes &&\n      (null === alternate || 0 === alternate.lanes) &&\n      ((alternate = queue.lastRenderedReducer), null !== alternate)\n    )\n      try {\n        var currentState = queue.lastRenderedState,\n          eagerState = alternate(currentState, action);\n        update.hasEagerState = !0;\n        update.eagerState = eagerState;\n        if (objectIs(eagerState, currentState))\n          return (\n            enqueueUpdate$1(fiber, queue, update, 0),\n            null === workInProgressRoot && finishQueueingConcurrentUpdates(),\n            !1\n          );\n      } catch (error) {\n      } finally {\n      }\n    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n    if (null !== action)\n      return (\n        scheduleUpdateOnFiber(action, fiber, lane),\n        entangleTransitionUpdate(action, queue, lane),\n        !0\n      );\n  }\n  return !1;\n}\nfunction dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n  action = {\n    lane: 2,\n    revertLane: requestTransitionLane(),\n    action: action,\n    hasEagerState: !1,\n    eagerState: null,\n    next: null\n  };\n  if (isRenderPhaseUpdate(fiber)) {\n    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));\n  } else\n    (throwIfDuringRender = enqueueConcurrentHookUpdate(\n      fiber,\n      queue,\n      action,\n      2\n    )),\n      null !== throwIfDuringRender &&\n        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);\n}\nfunction isRenderPhaseUpdate(fiber) {\n  var alternate = fiber.alternate;\n  return (\n    fiber === currentlyRenderingFiber ||\n    (null !== alternate && alternate === currentlyRenderingFiber)\n  );\n}\nfunction enqueueRenderPhaseUpdate(queue, update) {\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =\n    !0;\n  var pending = queue.pending;\n  null === pending\n    ? (update.next = update)\n    : ((update.next = pending.next), (pending.next = update));\n  queue.pending = update;\n}\nfunction entangleTransitionUpdate(root, queue, lane) {\n  if (0 !== (lane & 4194048)) {\n    var queueLanes = queue.lanes;\n    queueLanes &= root.pendingLanes;\n    lane |= queueLanes;\n    queue.lanes = lane;\n    markRootEntangled(root, lane);\n  }\n}\nvar ContextOnlyDispatcher = {\n    readContext: readContext,\n    use: use,\n    useCallback: throwInvalidHookError,\n    useContext: throwInvalidHookError,\n    useEffect: throwInvalidHookError,\n    useImperativeHandle: throwInvalidHookError,\n    useLayoutEffect: throwInvalidHookError,\n    useInsertionEffect: throwInvalidHookError,\n    useMemo: throwInvalidHookError,\n    useReducer: throwInvalidHookError,\n    useRef: throwInvalidHookError,\n    useState: throwInvalidHookError,\n    useDebugValue: throwInvalidHookError,\n    useDeferredValue: throwInvalidHookError,\n    useTransition: throwInvalidHookError,\n    useSyncExternalStore: throwInvalidHookError,\n    useId: throwInvalidHookError,\n    useHostTransitionStatus: throwInvalidHookError,\n    useFormState: throwInvalidHookError,\n    useActionState: throwInvalidHookError,\n    useOptimistic: throwInvalidHookError,\n    useMemoCache: throwInvalidHookError,\n    useCacheRefresh: throwInvalidHookError\n  },\n  HooksDispatcherOnMount = {\n    readContext: readContext,\n    use: use,\n    useCallback: function (callback, deps) {\n      mountWorkInProgressHook().memoizedState = [\n        callback,\n        void 0 === deps ? null : deps\n      ];\n      return callback;\n    },\n    useContext: readContext,\n    useEffect: mountEffect,\n    useImperativeHandle: function (ref, create, deps) {\n      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;\n      mountEffectImpl(\n        4194308,\n        4,\n        imperativeHandleEffect.bind(null, create, ref),\n        deps\n      );\n    },\n    useLayoutEffect: function (create, deps) {\n      return mountEffectImpl(4194308, 4, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      mountEffectImpl(4, 2, create, deps);\n    },\n    useMemo: function (nextCreate, deps) {\n      var hook = mountWorkInProgressHook();\n      deps = void 0 === deps ? null : deps;\n      var nextValue = nextCreate();\n      if (shouldDoubleInvokeUserFnsInHooksDEV) {\n        setIsStrictModeForDevtools(!0);\n        try {\n          nextCreate();\n        } finally {\n          setIsStrictModeForDevtools(!1);\n        }\n      }\n      hook.memoizedState = [nextValue, deps];\n      return nextValue;\n    },\n    useReducer: function (reducer, initialArg, init) {\n      var hook = mountWorkInProgressHook();\n      if (void 0 !== init) {\n        var initialState = init(initialArg);\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n          setIsStrictModeForDevtools(!0);\n          try {\n            init(initialArg);\n          } finally {\n            setIsStrictModeForDevtools(!1);\n          }\n        }\n      } else initialState = initialArg;\n      hook.memoizedState = hook.baseState = initialState;\n      reducer = {\n        pending: null,\n        lanes: 0,\n        dispatch: null,\n        lastRenderedReducer: reducer,\n        lastRenderedState: initialState\n      };\n      hook.queue = reducer;\n      reducer = reducer.dispatch = dispatchReducerAction.bind(\n        null,\n        currentlyRenderingFiber,\n        reducer\n      );\n      return [hook.memoizedState, reducer];\n    },\n    useRef: function (initialValue) {\n      var hook = mountWorkInProgressHook();\n      initialValue = { current: initialValue };\n      return (hook.memoizedState = initialValue);\n    },\n    useState: function (initialState) {\n      initialState = mountStateImpl(initialState);\n      var queue = initialState.queue,\n        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);\n      queue.dispatch = dispatch;\n      return [initialState.memoizedState, dispatch];\n    },\n    useDebugValue: mountDebugValue,\n    useDeferredValue: function (value, initialValue) {\n      var hook = mountWorkInProgressHook();\n      return mountDeferredValueImpl(hook, value, initialValue);\n    },\n    useTransition: function () {\n      var stateHook = mountStateImpl(!1);\n      stateHook = startTransition.bind(\n        null,\n        currentlyRenderingFiber,\n        stateHook.queue,\n        !0,\n        !1\n      );\n      mountWorkInProgressHook().memoizedState = stateHook;\n      return [!1, stateHook];\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      var fiber = currentlyRenderingFiber,\n        hook = mountWorkInProgressHook();\n      if (isHydrating) {\n        if (void 0 === getServerSnapshot)\n          throw Error(formatProdErrorMessage(407));\n        getServerSnapshot = getServerSnapshot();\n      } else {\n        getServerSnapshot = getSnapshot();\n        if (null === workInProgressRoot)\n          throw Error(formatProdErrorMessage(349));\n        0 !== (workInProgressRootRenderLanes & 124) ||\n          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n      }\n      hook.memoizedState = getServerSnapshot;\n      var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };\n      hook.queue = inst;\n      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n        subscribe\n      ]);\n      fiber.flags |= 2048;\n      pushSimpleEffect(\n        9,\n        createEffectInstance(),\n        updateStoreInstance.bind(\n          null,\n          fiber,\n          inst,\n          getServerSnapshot,\n          getSnapshot\n        ),\n        null\n      );\n      return getServerSnapshot;\n    },\n    useId: function () {\n      var hook = mountWorkInProgressHook(),\n        identifierPrefix = workInProgressRoot.identifierPrefix;\n      if (isHydrating) {\n        var JSCompiler_inline_result = treeContextOverflow;\n        var idWithLeadingBit = treeContextId;\n        JSCompiler_inline_result =\n          (\n            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))\n          ).toString(32) + JSCompiler_inline_result;\n        identifierPrefix =\n          \"\\u00ab\" + identifierPrefix + \"R\" + JSCompiler_inline_result;\n        JSCompiler_inline_result = localIdCounter++;\n        0 < JSCompiler_inline_result &&\n          (identifierPrefix += \"H\" + JSCompiler_inline_result.toString(32));\n        identifierPrefix += \"\\u00bb\";\n      } else\n        (JSCompiler_inline_result = globalClientIdCounter++),\n          (identifierPrefix =\n            \"\\u00ab\" +\n            identifierPrefix +\n            \"r\" +\n            JSCompiler_inline_result.toString(32) +\n            \"\\u00bb\");\n      return (hook.memoizedState = identifierPrefix);\n    },\n    useHostTransitionStatus: useHostTransitionStatus,\n    useFormState: mountActionState,\n    useActionState: mountActionState,\n    useOptimistic: function (passthrough) {\n      var hook = mountWorkInProgressHook();\n      hook.memoizedState = hook.baseState = passthrough;\n      var queue = {\n        pending: null,\n        lanes: 0,\n        dispatch: null,\n        lastRenderedReducer: null,\n        lastRenderedState: null\n      };\n      hook.queue = queue;\n      hook = dispatchOptimisticSetState.bind(\n        null,\n        currentlyRenderingFiber,\n        !0,\n        queue\n      );\n      queue.dispatch = hook;\n      return [passthrough, hook];\n    },\n    useMemoCache: useMemoCache,\n    useCacheRefresh: function () {\n      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(\n        null,\n        currentlyRenderingFiber\n      ));\n    }\n  },\n  HooksDispatcherOnUpdate = {\n    readContext: readContext,\n    use: use,\n    useCallback: updateCallback,\n    useContext: readContext,\n    useEffect: updateEffect,\n    useImperativeHandle: updateImperativeHandle,\n    useInsertionEffect: updateInsertionEffect,\n    useLayoutEffect: updateLayoutEffect,\n    useMemo: updateMemo,\n    useReducer: updateReducer,\n    useRef: updateRef,\n    useState: function () {\n      return updateReducer(basicStateReducer);\n    },\n    useDebugValue: mountDebugValue,\n    useDeferredValue: function (value, initialValue) {\n      var hook = updateWorkInProgressHook();\n      return updateDeferredValueImpl(\n        hook,\n        currentHook.memoizedState,\n        value,\n        initialValue\n      );\n    },\n    useTransition: function () {\n      var booleanOrThenable = updateReducer(basicStateReducer)[0],\n        start = updateWorkInProgressHook().memoizedState;\n      return [\n        \"boolean\" === typeof booleanOrThenable\n          ? booleanOrThenable\n          : useThenable(booleanOrThenable),\n        start\n      ];\n    },\n    useSyncExternalStore: updateSyncExternalStore,\n    useId: updateId,\n    useHostTransitionStatus: useHostTransitionStatus,\n    useFormState: updateActionState,\n    useActionState: updateActionState,\n    useOptimistic: function (passthrough, reducer) {\n      var hook = updateWorkInProgressHook();\n      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n    },\n    useMemoCache: useMemoCache,\n    useCacheRefresh: updateRefresh\n  },\n  HooksDispatcherOnRerender = {\n    readContext: readContext,\n    use: use,\n    useCallback: updateCallback,\n    useContext: readContext,\n    useEffect: updateEffect,\n    useImperativeHandle: updateImperativeHandle,\n    useInsertionEffect: updateInsertionEffect,\n    useLayoutEffect: updateLayoutEffect,\n    useMemo: updateMemo,\n    useReducer: rerenderReducer,\n    useRef: updateRef,\n    useState: function () {\n      return rerenderReducer(basicStateReducer);\n    },\n    useDebugValue: mountDebugValue,\n    useDeferredValue: function (value, initialValue) {\n      var hook = updateWorkInProgressHook();\n      return null === currentHook\n        ? mountDeferredValueImpl(hook, value, initialValue)\n        : updateDeferredValueImpl(\n            hook,\n            currentHook.memoizedState,\n            value,\n            initialValue\n          );\n    },\n    useTransition: function () {\n      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],\n        start = updateWorkInProgressHook().memoizedState;\n      return [\n        \"boolean\" === typeof booleanOrThenable\n          ? booleanOrThenable\n          : useThenable(booleanOrThenable),\n        start\n      ];\n    },\n    useSyncExternalStore: updateSyncExternalStore,\n    useId: updateId,\n    useHostTransitionStatus: useHostTransitionStatus,\n    useFormState: rerenderActionState,\n    useActionState: rerenderActionState,\n    useOptimistic: function (passthrough, reducer) {\n      var hook = updateWorkInProgressHook();\n      if (null !== currentHook)\n        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n      hook.baseState = passthrough;\n      return [passthrough, hook.queue.dispatch];\n    },\n    useMemoCache: useMemoCache,\n    useCacheRefresh: updateRefresh\n  },\n  thenableState = null,\n  thenableIndexCounter = 0;\nfunction unwrapThenable(thenable) {\n  var index = thenableIndexCounter;\n  thenableIndexCounter += 1;\n  null === thenableState && (thenableState = []);\n  return trackUsedThenable(thenableState, thenable, index);\n}\nfunction coerceRef(workInProgress, element) {\n  element = element.props.ref;\n  workInProgress.ref = void 0 !== element ? element : null;\n}\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)\n    throw Error(formatProdErrorMessage(525));\n  returnFiber = Object.prototype.toString.call(newChild);\n  throw Error(\n    formatProdErrorMessage(\n      31,\n      \"[object Object]\" === returnFiber\n        ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\"\n        : returnFiber\n    )\n  );\n}\nfunction resolveLazy(lazyType) {\n  var init = lazyType._init;\n  return init(lazyType._payload);\n}\nfunction createChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (shouldTrackSideEffects) {\n      var deletions = returnFiber.deletions;\n      null === deletions\n        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))\n        : deletions.push(childToDelete);\n    }\n  }\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) return null;\n    for (; null !== currentFirstChild; )\n      deleteChild(returnFiber, currentFirstChild),\n        (currentFirstChild = currentFirstChild.sibling);\n    return null;\n  }\n  function mapRemainingChildren(currentFirstChild) {\n    for (var existingChildren = new Map(); null !== currentFirstChild; )\n      null !== currentFirstChild.key\n        ? existingChildren.set(currentFirstChild.key, currentFirstChild)\n        : existingChildren.set(currentFirstChild.index, currentFirstChild),\n        (currentFirstChild = currentFirstChild.sibling);\n    return existingChildren;\n  }\n  function useFiber(fiber, pendingProps) {\n    fiber = createWorkInProgress(fiber, pendingProps);\n    fiber.index = 0;\n    fiber.sibling = null;\n    return fiber;\n  }\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects)\n      return (newFiber.flags |= 1048576), lastPlacedIndex;\n    newIndex = newFiber.alternate;\n    if (null !== newIndex)\n      return (\n        (newIndex = newIndex.index),\n        newIndex < lastPlacedIndex\n          ? ((newFiber.flags |= 67108866), lastPlacedIndex)\n          : newIndex\n      );\n    newFiber.flags |= 67108866;\n    return lastPlacedIndex;\n  }\n  function placeSingleChild(newFiber) {\n    shouldTrackSideEffects &&\n      null === newFiber.alternate &&\n      (newFiber.flags |= 67108866);\n    return newFiber;\n  }\n  function updateTextNode(returnFiber, current, textContent, lanes) {\n    if (null === current || 6 !== current.tag)\n      return (\n        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),\n        (current.return = returnFiber),\n        current\n      );\n    current = useFiber(current, textContent);\n    current.return = returnFiber;\n    return current;\n  }\n  function updateElement(returnFiber, current, element, lanes) {\n    var elementType = element.type;\n    if (elementType === REACT_FRAGMENT_TYPE)\n      return updateFragment(\n        returnFiber,\n        current,\n        element.props.children,\n        lanes,\n        element.key\n      );\n    if (\n      null !== current &&\n      (current.elementType === elementType ||\n        (\"object\" === typeof elementType &&\n          null !== elementType &&\n          elementType.$$typeof === REACT_LAZY_TYPE &&\n          resolveLazy(elementType) === current.type))\n    )\n      return (\n        (current = useFiber(current, element.props)),\n        coerceRef(current, element),\n        (current.return = returnFiber),\n        current\n      );\n    current = createFiberFromTypeAndProps(\n      element.type,\n      element.key,\n      element.props,\n      null,\n      returnFiber.mode,\n      lanes\n    );\n    coerceRef(current, element);\n    current.return = returnFiber;\n    return current;\n  }\n  function updatePortal(returnFiber, current, portal, lanes) {\n    if (\n      null === current ||\n      4 !== current.tag ||\n      current.stateNode.containerInfo !== portal.containerInfo ||\n      current.stateNode.implementation !== portal.implementation\n    )\n      return (\n        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),\n        (current.return = returnFiber),\n        current\n      );\n    current = useFiber(current, portal.children || []);\n    current.return = returnFiber;\n    return current;\n  }\n  function updateFragment(returnFiber, current, fragment, lanes, key) {\n    if (null === current || 7 !== current.tag)\n      return (\n        (current = createFiberFromFragment(\n          fragment,\n          returnFiber.mode,\n          lanes,\n          key\n        )),\n        (current.return = returnFiber),\n        current\n      );\n    current = useFiber(current, fragment);\n    current.return = returnFiber;\n    return current;\n  }\n  function createChild(returnFiber, newChild, lanes) {\n    if (\n      (\"string\" === typeof newChild && \"\" !== newChild) ||\n      \"number\" === typeof newChild ||\n      \"bigint\" === typeof newChild\n    )\n      return (\n        (newChild = createFiberFromText(\n          \"\" + newChild,\n          returnFiber.mode,\n          lanes\n        )),\n        (newChild.return = returnFiber),\n        newChild\n      );\n    if (\"object\" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return (\n            (lanes = createFiberFromTypeAndProps(\n              newChild.type,\n              newChild.key,\n              newChild.props,\n              null,\n              returnFiber.mode,\n              lanes\n            )),\n            coerceRef(lanes, newChild),\n            (lanes.return = returnFiber),\n            lanes\n          );\n        case REACT_PORTAL_TYPE:\n          return (\n            (newChild = createFiberFromPortal(\n              newChild,\n              returnFiber.mode,\n              lanes\n            )),\n            (newChild.return = returnFiber),\n            newChild\n          );\n        case REACT_LAZY_TYPE:\n          var init = newChild._init;\n          newChild = init(newChild._payload);\n          return createChild(returnFiber, newChild, lanes);\n      }\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\n        return (\n          (newChild = createFiberFromFragment(\n            newChild,\n            returnFiber.mode,\n            lanes,\n            null\n          )),\n          (newChild.return = returnFiber),\n          newChild\n        );\n      if (\"function\" === typeof newChild.then)\n        return createChild(returnFiber, unwrapThenable(newChild), lanes);\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return createChild(\n          returnFiber,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return null;\n  }\n  function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n    var key = null !== oldFiber ? oldFiber.key : null;\n    if (\n      (\"string\" === typeof newChild && \"\" !== newChild) ||\n      \"number\" === typeof newChild ||\n      \"bigint\" === typeof newChild\n    )\n      return null !== key\n        ? null\n        : updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n    if (\"object\" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return newChild.key === key\n            ? updateElement(returnFiber, oldFiber, newChild, lanes)\n            : null;\n        case REACT_PORTAL_TYPE:\n          return newChild.key === key\n            ? updatePortal(returnFiber, oldFiber, newChild, lanes)\n            : null;\n        case REACT_LAZY_TYPE:\n          return (\n            (key = newChild._init),\n            (newChild = key(newChild._payload)),\n            updateSlot(returnFiber, oldFiber, newChild, lanes)\n          );\n      }\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\n        return null !== key\n          ? null\n          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n      if (\"function\" === typeof newChild.then)\n        return updateSlot(\n          returnFiber,\n          oldFiber,\n          unwrapThenable(newChild),\n          lanes\n        );\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return updateSlot(\n          returnFiber,\n          oldFiber,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return null;\n  }\n  function updateFromMap(\n    existingChildren,\n    returnFiber,\n    newIdx,\n    newChild,\n    lanes\n  ) {\n    if (\n      (\"string\" === typeof newChild && \"\" !== newChild) ||\n      \"number\" === typeof newChild ||\n      \"bigint\" === typeof newChild\n    )\n      return (\n        (existingChildren = existingChildren.get(newIdx) || null),\n        updateTextNode(returnFiber, existingChildren, \"\" + newChild, lanes)\n      );\n    if (\"object\" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return (\n            (existingChildren =\n              existingChildren.get(\n                null === newChild.key ? newIdx : newChild.key\n              ) || null),\n            updateElement(returnFiber, existingChildren, newChild, lanes)\n          );\n        case REACT_PORTAL_TYPE:\n          return (\n            (existingChildren =\n              existingChildren.get(\n                null === newChild.key ? newIdx : newChild.key\n              ) || null),\n            updatePortal(returnFiber, existingChildren, newChild, lanes)\n          );\n        case REACT_LAZY_TYPE:\n          var init = newChild._init;\n          newChild = init(newChild._payload);\n          return updateFromMap(\n            existingChildren,\n            returnFiber,\n            newIdx,\n            newChild,\n            lanes\n          );\n      }\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\n        return (\n          (existingChildren = existingChildren.get(newIdx) || null),\n          updateFragment(returnFiber, existingChildren, newChild, lanes, null)\n        );\n      if (\"function\" === typeof newChild.then)\n        return updateFromMap(\n          existingChildren,\n          returnFiber,\n          newIdx,\n          unwrapThenable(newChild),\n          lanes\n        );\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return updateFromMap(\n          existingChildren,\n          returnFiber,\n          newIdx,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return null;\n  }\n  function reconcileChildrenArray(\n    returnFiber,\n    currentFirstChild,\n    newChildren,\n    lanes\n  ) {\n    for (\n      var resultingFirstChild = null,\n        previousNewFiber = null,\n        oldFiber = currentFirstChild,\n        newIdx = (currentFirstChild = 0),\n        nextOldFiber = null;\n      null !== oldFiber && newIdx < newChildren.length;\n      newIdx++\n    ) {\n      oldFiber.index > newIdx\n        ? ((nextOldFiber = oldFiber), (oldFiber = null))\n        : (nextOldFiber = oldFiber.sibling);\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        lanes\n      );\n      if (null === newFiber) {\n        null === oldFiber && (oldFiber = nextOldFiber);\n        break;\n      }\n      shouldTrackSideEffects &&\n        oldFiber &&\n        null === newFiber.alternate &&\n        deleteChild(returnFiber, oldFiber);\n      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n      null === previousNewFiber\n        ? (resultingFirstChild = newFiber)\n        : (previousNewFiber.sibling = newFiber);\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n    if (newIdx === newChildren.length)\n      return (\n        deleteRemainingChildren(returnFiber, oldFiber),\n        isHydrating && pushTreeFork(returnFiber, newIdx),\n        resultingFirstChild\n      );\n    if (null === oldFiber) {\n      for (; newIdx < newChildren.length; newIdx++)\n        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),\n          null !== oldFiber &&\n            ((currentFirstChild = placeChild(\n              oldFiber,\n              currentFirstChild,\n              newIdx\n            )),\n            null === previousNewFiber\n              ? (resultingFirstChild = oldFiber)\n              : (previousNewFiber.sibling = oldFiber),\n            (previousNewFiber = oldFiber));\n      isHydrating && pushTreeFork(returnFiber, newIdx);\n      return resultingFirstChild;\n    }\n    for (\n      oldFiber = mapRemainingChildren(oldFiber);\n      newIdx < newChildren.length;\n      newIdx++\n    )\n      (nextOldFiber = updateFromMap(\n        oldFiber,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        lanes\n      )),\n        null !== nextOldFiber &&\n          (shouldTrackSideEffects &&\n            null !== nextOldFiber.alternate &&\n            oldFiber.delete(\n              null === nextOldFiber.key ? newIdx : nextOldFiber.key\n            ),\n          (currentFirstChild = placeChild(\n            nextOldFiber,\n            currentFirstChild,\n            newIdx\n          )),\n          null === previousNewFiber\n            ? (resultingFirstChild = nextOldFiber)\n            : (previousNewFiber.sibling = nextOldFiber),\n          (previousNewFiber = nextOldFiber));\n    shouldTrackSideEffects &&\n      oldFiber.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    isHydrating && pushTreeFork(returnFiber, newIdx);\n    return resultingFirstChild;\n  }\n  function reconcileChildrenIterator(\n    returnFiber,\n    currentFirstChild,\n    newChildren,\n    lanes\n  ) {\n    if (null == newChildren) throw Error(formatProdErrorMessage(151));\n    for (\n      var resultingFirstChild = null,\n        previousNewFiber = null,\n        oldFiber = currentFirstChild,\n        newIdx = (currentFirstChild = 0),\n        nextOldFiber = null,\n        step = newChildren.next();\n      null !== oldFiber && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      oldFiber.index > newIdx\n        ? ((nextOldFiber = oldFiber), (oldFiber = null))\n        : (nextOldFiber = oldFiber.sibling);\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n      if (null === newFiber) {\n        null === oldFiber && (oldFiber = nextOldFiber);\n        break;\n      }\n      shouldTrackSideEffects &&\n        oldFiber &&\n        null === newFiber.alternate &&\n        deleteChild(returnFiber, oldFiber);\n      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n      null === previousNewFiber\n        ? (resultingFirstChild = newFiber)\n        : (previousNewFiber.sibling = newFiber);\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n    if (step.done)\n      return (\n        deleteRemainingChildren(returnFiber, oldFiber),\n        isHydrating && pushTreeFork(returnFiber, newIdx),\n        resultingFirstChild\n      );\n    if (null === oldFiber) {\n      for (; !step.done; newIdx++, step = newChildren.next())\n        (step = createChild(returnFiber, step.value, lanes)),\n          null !== step &&\n            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),\n            null === previousNewFiber\n              ? (resultingFirstChild = step)\n              : (previousNewFiber.sibling = step),\n            (previousNewFiber = step));\n      isHydrating && pushTreeFork(returnFiber, newIdx);\n      return resultingFirstChild;\n    }\n    for (\n      oldFiber = mapRemainingChildren(oldFiber);\n      !step.done;\n      newIdx++, step = newChildren.next()\n    )\n      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),\n        null !== step &&\n          (shouldTrackSideEffects &&\n            null !== step.alternate &&\n            oldFiber.delete(null === step.key ? newIdx : step.key),\n          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),\n          null === previousNewFiber\n            ? (resultingFirstChild = step)\n            : (previousNewFiber.sibling = step),\n          (previousNewFiber = step));\n    shouldTrackSideEffects &&\n      oldFiber.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    isHydrating && pushTreeFork(returnFiber, newIdx);\n    return resultingFirstChild;\n  }\n  function reconcileChildFibersImpl(\n    returnFiber,\n    currentFirstChild,\n    newChild,\n    lanes\n  ) {\n    \"object\" === typeof newChild &&\n      null !== newChild &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      null === newChild.key &&\n      (newChild = newChild.props.children);\n    if (\"object\" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          a: {\n            for (var key = newChild.key; null !== currentFirstChild; ) {\n              if (currentFirstChild.key === key) {\n                key = newChild.type;\n                if (key === REACT_FRAGMENT_TYPE) {\n                  if (7 === currentFirstChild.tag) {\n                    deleteRemainingChildren(\n                      returnFiber,\n                      currentFirstChild.sibling\n                    );\n                    lanes = useFiber(\n                      currentFirstChild,\n                      newChild.props.children\n                    );\n                    lanes.return = returnFiber;\n                    returnFiber = lanes;\n                    break a;\n                  }\n                } else if (\n                  currentFirstChild.elementType === key ||\n                  (\"object\" === typeof key &&\n                    null !== key &&\n                    key.$$typeof === REACT_LAZY_TYPE &&\n                    resolveLazy(key) === currentFirstChild.type)\n                ) {\n                  deleteRemainingChildren(\n                    returnFiber,\n                    currentFirstChild.sibling\n                  );\n                  lanes = useFiber(currentFirstChild, newChild.props);\n                  coerceRef(lanes, newChild);\n                  lanes.return = returnFiber;\n                  returnFiber = lanes;\n                  break a;\n                }\n                deleteRemainingChildren(returnFiber, currentFirstChild);\n                break;\n              } else deleteChild(returnFiber, currentFirstChild);\n              currentFirstChild = currentFirstChild.sibling;\n            }\n            newChild.type === REACT_FRAGMENT_TYPE\n              ? ((lanes = createFiberFromFragment(\n                  newChild.props.children,\n                  returnFiber.mode,\n                  lanes,\n                  newChild.key\n                )),\n                (lanes.return = returnFiber),\n                (returnFiber = lanes))\n              : ((lanes = createFiberFromTypeAndProps(\n                  newChild.type,\n                  newChild.key,\n                  newChild.props,\n                  null,\n                  returnFiber.mode,\n                  lanes\n                )),\n                coerceRef(lanes, newChild),\n                (lanes.return = returnFiber),\n                (returnFiber = lanes));\n          }\n          return placeSingleChild(returnFiber);\n        case REACT_PORTAL_TYPE:\n          a: {\n            for (key = newChild.key; null !== currentFirstChild; ) {\n              if (currentFirstChild.key === key)\n                if (\n                  4 === currentFirstChild.tag &&\n                  currentFirstChild.stateNode.containerInfo ===\n                    newChild.containerInfo &&\n                  currentFirstChild.stateNode.implementation ===\n                    newChild.implementation\n                ) {\n                  deleteRemainingChildren(\n                    returnFiber,\n                    currentFirstChild.sibling\n                  );\n                  lanes = useFiber(currentFirstChild, newChild.children || []);\n                  lanes.return = returnFiber;\n                  returnFiber = lanes;\n                  break a;\n                } else {\n                  deleteRemainingChildren(returnFiber, currentFirstChild);\n                  break;\n                }\n              else deleteChild(returnFiber, currentFirstChild);\n              currentFirstChild = currentFirstChild.sibling;\n            }\n            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n            lanes.return = returnFiber;\n            returnFiber = lanes;\n          }\n          return placeSingleChild(returnFiber);\n        case REACT_LAZY_TYPE:\n          return (\n            (key = newChild._init),\n            (newChild = key(newChild._payload)),\n            reconcileChildFibersImpl(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              lanes\n            )\n          );\n      }\n      if (isArrayImpl(newChild))\n        return reconcileChildrenArray(\n          returnFiber,\n          currentFirstChild,\n          newChild,\n          lanes\n        );\n      if (getIteratorFn(newChild)) {\n        key = getIteratorFn(newChild);\n        if (\"function\" !== typeof key) throw Error(formatProdErrorMessage(150));\n        newChild = key.call(newChild);\n        return reconcileChildrenIterator(\n          returnFiber,\n          currentFirstChild,\n          newChild,\n          lanes\n        );\n      }\n      if (\"function\" === typeof newChild.then)\n        return reconcileChildFibersImpl(\n          returnFiber,\n          currentFirstChild,\n          unwrapThenable(newChild),\n          lanes\n        );\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return reconcileChildFibersImpl(\n          returnFiber,\n          currentFirstChild,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return (\"string\" === typeof newChild && \"\" !== newChild) ||\n      \"number\" === typeof newChild ||\n      \"bigint\" === typeof newChild\n      ? ((newChild = \"\" + newChild),\n        null !== currentFirstChild && 6 === currentFirstChild.tag\n          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),\n            (lanes = useFiber(currentFirstChild, newChild)),\n            (lanes.return = returnFiber),\n            (returnFiber = lanes))\n          : (deleteRemainingChildren(returnFiber, currentFirstChild),\n            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),\n            (lanes.return = returnFiber),\n            (returnFiber = lanes)),\n        placeSingleChild(returnFiber))\n      : deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n  return function (returnFiber, currentFirstChild, newChild, lanes) {\n    try {\n      thenableIndexCounter = 0;\n      var firstChildFiber = reconcileChildFibersImpl(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        lanes\n      );\n      thenableState = null;\n      return firstChildFiber;\n    } catch (x) {\n      if (x === SuspenseException || x === SuspenseActionException) throw x;\n      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);\n      fiber.lanes = lanes;\n      fiber.return = returnFiber;\n      return fiber;\n    } finally {\n    }\n  };\n}\nvar reconcileChildFibers = createChildReconciler(!0),\n  mountChildFibers = createChildReconciler(!1),\n  suspenseHandlerStackCursor = createCursor(null),\n  shellBoundary = null;\nfunction pushPrimaryTreeSuspenseHandler(handler) {\n  var current = handler.alternate;\n  push(suspenseStackCursor, suspenseStackCursor.current & 1);\n  push(suspenseHandlerStackCursor, handler);\n  null === shellBoundary &&\n    (null === current || null !== currentTreeHiddenStackCursor.current\n      ? (shellBoundary = handler)\n      : null !== current.memoizedState && (shellBoundary = handler));\n}\nfunction pushOffscreenSuspenseHandler(fiber) {\n  if (22 === fiber.tag) {\n    if (\n      (push(suspenseStackCursor, suspenseStackCursor.current),\n      push(suspenseHandlerStackCursor, fiber),\n      null === shellBoundary)\n    ) {\n      var current = fiber.alternate;\n      null !== current &&\n        null !== current.memoizedState &&\n        (shellBoundary = fiber);\n    }\n  } else reuseSuspenseHandlerOnStack(fiber);\n}\nfunction reuseSuspenseHandlerOnStack() {\n  push(suspenseStackCursor, suspenseStackCursor.current);\n  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);\n}\nfunction popSuspenseHandler(fiber) {\n  pop(suspenseHandlerStackCursor);\n  shellBoundary === fiber && (shellBoundary = null);\n  pop(suspenseStackCursor);\n}\nvar suspenseStackCursor = createCursor(0);\nfunction findFirstSuspended(row) {\n  for (var node = row; null !== node; ) {\n    if (13 === node.tag) {\n      var state = node.memoizedState;\n      if (\n        null !== state &&\n        ((state = state.dehydrated),\n        null === state ||\n          \"$?\" === state.data ||\n          isSuspenseInstanceFallback(state))\n      )\n        return node;\n    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {\n      if (0 !== (node.flags & 128)) return node;\n    } else if (null !== node.child) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === row) break;\n    for (; null === node.sibling; ) {\n      if (null === node.return || node.return === row) return null;\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  return null;\n}\nfunction applyDerivedStateFromProps(\n  workInProgress,\n  ctor,\n  getDerivedStateFromProps,\n  nextProps\n) {\n  ctor = workInProgress.memoizedState;\n  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);\n  getDerivedStateFromProps =\n    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps\n      ? ctor\n      : assign({}, ctor, getDerivedStateFromProps);\n  workInProgress.memoizedState = getDerivedStateFromProps;\n  0 === workInProgress.lanes &&\n    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);\n}\nvar classComponentUpdater = {\n  enqueueSetState: function (inst, payload, callback) {\n    inst = inst._reactInternals;\n    var lane = requestUpdateLane(),\n      update = createUpdate(lane);\n    update.payload = payload;\n    void 0 !== callback && null !== callback && (update.callback = callback);\n    payload = enqueueUpdate(inst, update, lane);\n    null !== payload &&\n      (scheduleUpdateOnFiber(payload, inst, lane),\n      entangleTransitions(payload, inst, lane));\n  },\n  enqueueReplaceState: function (inst, payload, callback) {\n    inst = inst._reactInternals;\n    var lane = requestUpdateLane(),\n      update = createUpdate(lane);\n    update.tag = 1;\n    update.payload = payload;\n    void 0 !== callback && null !== callback && (update.callback = callback);\n    payload = enqueueUpdate(inst, update, lane);\n    null !== payload &&\n      (scheduleUpdateOnFiber(payload, inst, lane),\n      entangleTransitions(payload, inst, lane));\n  },\n  enqueueForceUpdate: function (inst, callback) {\n    inst = inst._reactInternals;\n    var lane = requestUpdateLane(),\n      update = createUpdate(lane);\n    update.tag = 2;\n    void 0 !== callback && null !== callback && (update.callback = callback);\n    callback = enqueueUpdate(inst, update, lane);\n    null !== callback &&\n      (scheduleUpdateOnFiber(callback, inst, lane),\n      entangleTransitions(callback, inst, lane));\n  }\n};\nfunction checkShouldComponentUpdate(\n  workInProgress,\n  ctor,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  nextContext\n) {\n  workInProgress = workInProgress.stateNode;\n  return \"function\" === typeof workInProgress.shouldComponentUpdate\n    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)\n    : ctor.prototype && ctor.prototype.isPureReactComponent\n      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n      : !0;\n}\nfunction callComponentWillReceiveProps(\n  workInProgress,\n  instance,\n  newProps,\n  nextContext\n) {\n  workInProgress = instance.state;\n  \"function\" === typeof instance.componentWillReceiveProps &&\n    instance.componentWillReceiveProps(newProps, nextContext);\n  \"function\" === typeof instance.UNSAFE_componentWillReceiveProps &&\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  instance.state !== workInProgress &&\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n}\nfunction resolveClassComponentProps(Component, baseProps) {\n  var newProps = baseProps;\n  if (\"ref\" in baseProps) {\n    newProps = {};\n    for (var propName in baseProps)\n      \"ref\" !== propName && (newProps[propName] = baseProps[propName]);\n  }\n  if ((Component = Component.defaultProps)) {\n    newProps === baseProps && (newProps = assign({}, newProps));\n    for (var propName$73 in Component)\n      void 0 === newProps[propName$73] &&\n        (newProps[propName$73] = Component[propName$73]);\n  }\n  return newProps;\n}\nvar reportGlobalError =\n  \"function\" === typeof reportError\n    ? reportError\n    : function (error) {\n        if (\n          \"object\" === typeof window &&\n          \"function\" === typeof window.ErrorEvent\n        ) {\n          var event = new window.ErrorEvent(\"error\", {\n            bubbles: !0,\n            cancelable: !0,\n            message:\n              \"object\" === typeof error &&\n              null !== error &&\n              \"string\" === typeof error.message\n                ? String(error.message)\n                : String(error),\n            error: error\n          });\n          if (!window.dispatchEvent(event)) return;\n        } else if (\n          \"object\" === typeof process &&\n          \"function\" === typeof process.emit\n        ) {\n          process.emit(\"uncaughtException\", error);\n          return;\n        }\n        console.error(error);\n      };\nfunction defaultOnUncaughtError(error) {\n  reportGlobalError(error);\n}\nfunction defaultOnCaughtError(error) {\n  console.error(error);\n}\nfunction defaultOnRecoverableError(error) {\n  reportGlobalError(error);\n}\nfunction logUncaughtError(root, errorInfo) {\n  try {\n    var onUncaughtError = root.onUncaughtError;\n    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });\n  } catch (e$74) {\n    setTimeout(function () {\n      throw e$74;\n    });\n  }\n}\nfunction logCaughtError(root, boundary, errorInfo) {\n  try {\n    var onCaughtError = root.onCaughtError;\n    onCaughtError(errorInfo.value, {\n      componentStack: errorInfo.stack,\n      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null\n    });\n  } catch (e$75) {\n    setTimeout(function () {\n      throw e$75;\n    });\n  }\n}\nfunction createRootErrorUpdate(root, errorInfo, lane) {\n  lane = createUpdate(lane);\n  lane.tag = 3;\n  lane.payload = { element: null };\n  lane.callback = function () {\n    logUncaughtError(root, errorInfo);\n  };\n  return lane;\n}\nfunction createClassErrorUpdate(lane) {\n  lane = createUpdate(lane);\n  lane.tag = 3;\n  return lane;\n}\nfunction initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n  if (\"function\" === typeof getDerivedStateFromError) {\n    var error = errorInfo.value;\n    update.payload = function () {\n      return getDerivedStateFromError(error);\n    };\n    update.callback = function () {\n      logCaughtError(root, fiber, errorInfo);\n    };\n  }\n  var inst = fiber.stateNode;\n  null !== inst &&\n    \"function\" === typeof inst.componentDidCatch &&\n    (update.callback = function () {\n      logCaughtError(root, fiber, errorInfo);\n      \"function\" !== typeof getDerivedStateFromError &&\n        (null === legacyErrorBoundariesThatAlreadyFailed\n          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))\n          : legacyErrorBoundariesThatAlreadyFailed.add(this));\n      var stack = errorInfo.stack;\n      this.componentDidCatch(errorInfo.value, {\n        componentStack: null !== stack ? stack : \"\"\n      });\n    });\n}\nfunction throwException(\n  root,\n  returnFiber,\n  sourceFiber,\n  value,\n  rootRenderLanes\n) {\n  sourceFiber.flags |= 32768;\n  if (\n    null !== value &&\n    \"object\" === typeof value &&\n    \"function\" === typeof value.then\n  ) {\n    returnFiber = sourceFiber.alternate;\n    null !== returnFiber &&\n      propagateParentContextChanges(\n        returnFiber,\n        sourceFiber,\n        rootRenderLanes,\n        !0\n      );\n    sourceFiber = suspenseHandlerStackCursor.current;\n    if (null !== sourceFiber) {\n      switch (sourceFiber.tag) {\n        case 13:\n          return (\n            null === shellBoundary\n              ? renderDidSuspendDelayIfPossible()\n              : null === sourceFiber.alternate &&\n                0 === workInProgressRootExitStatus &&\n                (workInProgressRootExitStatus = 3),\n            (sourceFiber.flags &= -257),\n            (sourceFiber.flags |= 65536),\n            (sourceFiber.lanes = rootRenderLanes),\n            value === noopSuspenseyCommitThenable\n              ? (sourceFiber.flags |= 16384)\n              : ((returnFiber = sourceFiber.updateQueue),\n                null === returnFiber\n                  ? (sourceFiber.updateQueue = new Set([value]))\n                  : returnFiber.add(value),\n                attachPingListener(root, value, rootRenderLanes)),\n            !1\n          );\n        case 22:\n          return (\n            (sourceFiber.flags |= 65536),\n            value === noopSuspenseyCommitThenable\n              ? (sourceFiber.flags |= 16384)\n              : ((returnFiber = sourceFiber.updateQueue),\n                null === returnFiber\n                  ? ((returnFiber = {\n                      transitions: null,\n                      markerInstances: null,\n                      retryQueue: new Set([value])\n                    }),\n                    (sourceFiber.updateQueue = returnFiber))\n                  : ((sourceFiber = returnFiber.retryQueue),\n                    null === sourceFiber\n                      ? (returnFiber.retryQueue = new Set([value]))\n                      : sourceFiber.add(value)),\n                attachPingListener(root, value, rootRenderLanes)),\n            !1\n          );\n      }\n      throw Error(formatProdErrorMessage(435, sourceFiber.tag));\n    }\n    attachPingListener(root, value, rootRenderLanes);\n    renderDidSuspendDelayIfPossible();\n    return !1;\n  }\n  if (isHydrating)\n    return (\n      (returnFiber = suspenseHandlerStackCursor.current),\n      null !== returnFiber\n        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),\n          (returnFiber.flags |= 65536),\n          (returnFiber.lanes = rootRenderLanes),\n          value !== HydrationMismatchException &&\n            ((root = Error(formatProdErrorMessage(422), { cause: value })),\n            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))\n        : (value !== HydrationMismatchException &&\n            ((returnFiber = Error(formatProdErrorMessage(423), {\n              cause: value\n            })),\n            queueHydrationError(\n              createCapturedValueAtFiber(returnFiber, sourceFiber)\n            )),\n          (root = root.current.alternate),\n          (root.flags |= 65536),\n          (rootRenderLanes &= -rootRenderLanes),\n          (root.lanes |= rootRenderLanes),\n          (value = createCapturedValueAtFiber(value, sourceFiber)),\n          (rootRenderLanes = createRootErrorUpdate(\n            root.stateNode,\n            value,\n            rootRenderLanes\n          )),\n          enqueueCapturedUpdate(root, rootRenderLanes),\n          4 !== workInProgressRootExitStatus &&\n            (workInProgressRootExitStatus = 2)),\n      !1\n    );\n  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });\n  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);\n  null === workInProgressRootConcurrentErrors\n    ? (workInProgressRootConcurrentErrors = [wrapperError])\n    : workInProgressRootConcurrentErrors.push(wrapperError);\n  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);\n  if (null === returnFiber) return !0;\n  value = createCapturedValueAtFiber(value, sourceFiber);\n  sourceFiber = returnFiber;\n  do {\n    switch (sourceFiber.tag) {\n      case 3:\n        return (\n          (sourceFiber.flags |= 65536),\n          (root = rootRenderLanes & -rootRenderLanes),\n          (sourceFiber.lanes |= root),\n          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),\n          enqueueCapturedUpdate(sourceFiber, root),\n          !1\n        );\n      case 1:\n        if (\n          ((returnFiber = sourceFiber.type),\n          (wrapperError = sourceFiber.stateNode),\n          0 === (sourceFiber.flags & 128) &&\n            (\"function\" === typeof returnFiber.getDerivedStateFromError ||\n              (null !== wrapperError &&\n                \"function\" === typeof wrapperError.componentDidCatch &&\n                (null === legacyErrorBoundariesThatAlreadyFailed ||\n                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))\n        )\n          return (\n            (sourceFiber.flags |= 65536),\n            (rootRenderLanes &= -rootRenderLanes),\n            (sourceFiber.lanes |= rootRenderLanes),\n            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),\n            initializeClassErrorUpdate(\n              rootRenderLanes,\n              root,\n              sourceFiber,\n              value\n            ),\n            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),\n            !1\n          );\n    }\n    sourceFiber = sourceFiber.return;\n  } while (null !== sourceFiber);\n  return !1;\n}\nvar SelectiveHydrationException = Error(formatProdErrorMessage(461)),\n  didReceiveUpdate = !1;\nfunction reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n  workInProgress.child =\n    null === current\n      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)\n      : reconcileChildFibers(\n          workInProgress,\n          current.child,\n          nextChildren,\n          renderLanes\n        );\n}\nfunction updateForwardRef(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  Component = Component.render;\n  var ref = workInProgress.ref;\n  if (\"ref\" in nextProps) {\n    var propsWithoutRef = {};\n    for (var key in nextProps)\n      \"ref\" !== key && (propsWithoutRef[key] = nextProps[key]);\n  } else propsWithoutRef = nextProps;\n  prepareToReadContext(workInProgress);\n  nextProps = renderWithHooks(\n    current,\n    workInProgress,\n    Component,\n    propsWithoutRef,\n    ref,\n    renderLanes\n  );\n  key = checkDidRenderIdHook();\n  if (null !== current && !didReceiveUpdate)\n    return (\n      bailoutHooks(current, workInProgress, renderLanes),\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n    );\n  isHydrating && key && pushMaterializedTreeId(workInProgress);\n  workInProgress.flags |= 1;\n  reconcileChildren(current, workInProgress, nextProps, renderLanes);\n  return workInProgress.child;\n}\nfunction updateMemoComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  if (null === current) {\n    var type = Component.type;\n    if (\n      \"function\" === typeof type &&\n      !shouldConstruct(type) &&\n      void 0 === type.defaultProps &&\n      null === Component.compare\n    )\n      return (\n        (workInProgress.tag = 15),\n        (workInProgress.type = type),\n        updateSimpleMemoComponent(\n          current,\n          workInProgress,\n          type,\n          nextProps,\n          renderLanes\n        )\n      );\n    current = createFiberFromTypeAndProps(\n      Component.type,\n      null,\n      nextProps,\n      workInProgress,\n      workInProgress.mode,\n      renderLanes\n    );\n    current.ref = workInProgress.ref;\n    current.return = workInProgress;\n    return (workInProgress.child = current);\n  }\n  type = current.child;\n  if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n    var prevProps = type.memoizedProps;\n    Component = Component.compare;\n    Component = null !== Component ? Component : shallowEqual;\n    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n  workInProgress.flags |= 1;\n  current = createWorkInProgress(type, nextProps);\n  current.ref = workInProgress.ref;\n  current.return = workInProgress;\n  return (workInProgress.child = current);\n}\nfunction updateSimpleMemoComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  if (null !== current) {\n    var prevProps = current.memoizedProps;\n    if (\n      shallowEqual(prevProps, nextProps) &&\n      current.ref === workInProgress.ref\n    )\n      if (\n        ((didReceiveUpdate = !1),\n        (workInProgress.pendingProps = nextProps = prevProps),\n        checkScheduledUpdateOrContext(current, renderLanes))\n      )\n        0 !== (current.flags & 131072) && (didReceiveUpdate = !0);\n      else\n        return (\n          (workInProgress.lanes = current.lanes),\n          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n        );\n  }\n  return updateFunctionComponent(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    renderLanes\n  );\n}\nfunction updateOffscreenComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps,\n    nextChildren = nextProps.children,\n    prevState = null !== current ? current.memoizedState : null;\n  if (\"hidden\" === nextProps.mode) {\n    if (0 !== (workInProgress.flags & 128)) {\n      nextProps =\n        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;\n      if (null !== current) {\n        nextChildren = workInProgress.child = current.child;\n        for (prevState = 0; null !== nextChildren; )\n          (prevState =\n            prevState | nextChildren.lanes | nextChildren.childLanes),\n            (nextChildren = nextChildren.sibling);\n        workInProgress.childLanes = prevState & ~nextProps;\n      } else (workInProgress.childLanes = 0), (workInProgress.child = null);\n      return deferHiddenOffscreenComponent(\n        current,\n        workInProgress,\n        nextProps,\n        renderLanes\n      );\n    }\n    if (0 !== (renderLanes & 536870912))\n      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),\n        null !== current &&\n          pushTransition(\n            workInProgress,\n            null !== prevState ? prevState.cachePool : null\n          ),\n        null !== prevState\n          ? pushHiddenContext(workInProgress, prevState)\n          : reuseHiddenContextOnStack(),\n        pushOffscreenSuspenseHandler(workInProgress);\n    else\n      return (\n        (workInProgress.lanes = workInProgress.childLanes = 536870912),\n        deferHiddenOffscreenComponent(\n          current,\n          workInProgress,\n          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,\n          renderLanes\n        )\n      );\n  } else\n    null !== prevState\n      ? (pushTransition(workInProgress, prevState.cachePool),\n        pushHiddenContext(workInProgress, prevState),\n        reuseSuspenseHandlerOnStack(workInProgress),\n        (workInProgress.memoizedState = null))\n      : (null !== current && pushTransition(workInProgress, null),\n        reuseHiddenContextOnStack(),\n        reuseSuspenseHandlerOnStack(workInProgress));\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\nfunction deferHiddenOffscreenComponent(\n  current,\n  workInProgress,\n  nextBaseLanes,\n  renderLanes\n) {\n  var JSCompiler_inline_result = peekCacheFromPool();\n  JSCompiler_inline_result =\n    null === JSCompiler_inline_result\n      ? null\n      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };\n  workInProgress.memoizedState = {\n    baseLanes: nextBaseLanes,\n    cachePool: JSCompiler_inline_result\n  };\n  null !== current && pushTransition(workInProgress, null);\n  reuseHiddenContextOnStack();\n  pushOffscreenSuspenseHandler(workInProgress);\n  null !== current &&\n    propagateParentContextChanges(current, workInProgress, renderLanes, !0);\n  return null;\n}\nfunction markRef(current, workInProgress) {\n  var ref = workInProgress.ref;\n  if (null === ref)\n    null !== current &&\n      null !== current.ref &&\n      (workInProgress.flags |= 4194816);\n  else {\n    if (\"function\" !== typeof ref && \"object\" !== typeof ref)\n      throw Error(formatProdErrorMessage(284));\n    if (null === current || current.ref !== ref)\n      workInProgress.flags |= 4194816;\n  }\n}\nfunction updateFunctionComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  prepareToReadContext(workInProgress);\n  Component = renderWithHooks(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    void 0,\n    renderLanes\n  );\n  nextProps = checkDidRenderIdHook();\n  if (null !== current && !didReceiveUpdate)\n    return (\n      bailoutHooks(current, workInProgress, renderLanes),\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n    );\n  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);\n  workInProgress.flags |= 1;\n  reconcileChildren(current, workInProgress, Component, renderLanes);\n  return workInProgress.child;\n}\nfunction replayFunctionComponent(\n  current,\n  workInProgress,\n  nextProps,\n  Component,\n  secondArg,\n  renderLanes\n) {\n  prepareToReadContext(workInProgress);\n  workInProgress.updateQueue = null;\n  nextProps = renderWithHooksAgain(\n    workInProgress,\n    Component,\n    nextProps,\n    secondArg\n  );\n  finishRenderingHooks(current);\n  Component = checkDidRenderIdHook();\n  if (null !== current && !didReceiveUpdate)\n    return (\n      bailoutHooks(current, workInProgress, renderLanes),\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n    );\n  isHydrating && Component && pushMaterializedTreeId(workInProgress);\n  workInProgress.flags |= 1;\n  reconcileChildren(current, workInProgress, nextProps, renderLanes);\n  return workInProgress.child;\n}\nfunction updateClassComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  prepareToReadContext(workInProgress);\n  if (null === workInProgress.stateNode) {\n    var context = emptyContextObject,\n      contextType = Component.contextType;\n    \"object\" === typeof contextType &&\n      null !== contextType &&\n      (context = readContext(contextType));\n    context = new Component(nextProps, context);\n    workInProgress.memoizedState =\n      null !== context.state && void 0 !== context.state ? context.state : null;\n    context.updater = classComponentUpdater;\n    workInProgress.stateNode = context;\n    context._reactInternals = workInProgress;\n    context = workInProgress.stateNode;\n    context.props = nextProps;\n    context.state = workInProgress.memoizedState;\n    context.refs = {};\n    initializeUpdateQueue(workInProgress);\n    contextType = Component.contextType;\n    context.context =\n      \"object\" === typeof contextType && null !== contextType\n        ? readContext(contextType)\n        : emptyContextObject;\n    context.state = workInProgress.memoizedState;\n    contextType = Component.getDerivedStateFromProps;\n    \"function\" === typeof contextType &&\n      (applyDerivedStateFromProps(\n        workInProgress,\n        Component,\n        contextType,\n        nextProps\n      ),\n      (context.state = workInProgress.memoizedState));\n    \"function\" === typeof Component.getDerivedStateFromProps ||\n      \"function\" === typeof context.getSnapshotBeforeUpdate ||\n      (\"function\" !== typeof context.UNSAFE_componentWillMount &&\n        \"function\" !== typeof context.componentWillMount) ||\n      ((contextType = context.state),\n      \"function\" === typeof context.componentWillMount &&\n        context.componentWillMount(),\n      \"function\" === typeof context.UNSAFE_componentWillMount &&\n        context.UNSAFE_componentWillMount(),\n      contextType !== context.state &&\n        classComponentUpdater.enqueueReplaceState(context, context.state, null),\n      processUpdateQueue(workInProgress, nextProps, context, renderLanes),\n      suspendIfUpdateReadFromEntangledAsyncAction(),\n      (context.state = workInProgress.memoizedState));\n    \"function\" === typeof context.componentDidMount &&\n      (workInProgress.flags |= 4194308);\n    nextProps = !0;\n  } else if (null === current) {\n    context = workInProgress.stateNode;\n    var unresolvedOldProps = workInProgress.memoizedProps,\n      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);\n    context.props = oldProps;\n    var oldContext = context.context,\n      contextType$jscomp$0 = Component.contextType;\n    contextType = emptyContextObject;\n    \"object\" === typeof contextType$jscomp$0 &&\n      null !== contextType$jscomp$0 &&\n      (contextType = readContext(contextType$jscomp$0));\n    var getDerivedStateFromProps = Component.getDerivedStateFromProps;\n    contextType$jscomp$0 =\n      \"function\" === typeof getDerivedStateFromProps ||\n      \"function\" === typeof context.getSnapshotBeforeUpdate;\n    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;\n    contextType$jscomp$0 ||\n      (\"function\" !== typeof context.UNSAFE_componentWillReceiveProps &&\n        \"function\" !== typeof context.componentWillReceiveProps) ||\n      ((unresolvedOldProps || oldContext !== contextType) &&\n        callComponentWillReceiveProps(\n          workInProgress,\n          context,\n          nextProps,\n          contextType\n        ));\n    hasForceUpdate = !1;\n    var oldState = workInProgress.memoizedState;\n    context.state = oldState;\n    processUpdateQueue(workInProgress, nextProps, context, renderLanes);\n    suspendIfUpdateReadFromEntangledAsyncAction();\n    oldContext = workInProgress.memoizedState;\n    unresolvedOldProps || oldState !== oldContext || hasForceUpdate\n      ? (\"function\" === typeof getDerivedStateFromProps &&\n          (applyDerivedStateFromProps(\n            workInProgress,\n            Component,\n            getDerivedStateFromProps,\n            nextProps\n          ),\n          (oldContext = workInProgress.memoizedState)),\n        (oldProps =\n          hasForceUpdate ||\n          checkShouldComponentUpdate(\n            workInProgress,\n            Component,\n            oldProps,\n            nextProps,\n            oldState,\n            oldContext,\n            contextType\n          ))\n          ? (contextType$jscomp$0 ||\n              (\"function\" !== typeof context.UNSAFE_componentWillMount &&\n                \"function\" !== typeof context.componentWillMount) ||\n              (\"function\" === typeof context.componentWillMount &&\n                context.componentWillMount(),\n              \"function\" === typeof context.UNSAFE_componentWillMount &&\n                context.UNSAFE_componentWillMount()),\n            \"function\" === typeof context.componentDidMount &&\n              (workInProgress.flags |= 4194308))\n          : (\"function\" === typeof context.componentDidMount &&\n              (workInProgress.flags |= 4194308),\n            (workInProgress.memoizedProps = nextProps),\n            (workInProgress.memoizedState = oldContext)),\n        (context.props = nextProps),\n        (context.state = oldContext),\n        (context.context = contextType),\n        (nextProps = oldProps))\n      : (\"function\" === typeof context.componentDidMount &&\n          (workInProgress.flags |= 4194308),\n        (nextProps = !1));\n  } else {\n    context = workInProgress.stateNode;\n    cloneUpdateQueue(current, workInProgress);\n    contextType = workInProgress.memoizedProps;\n    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);\n    context.props = contextType$jscomp$0;\n    getDerivedStateFromProps = workInProgress.pendingProps;\n    oldState = context.context;\n    oldContext = Component.contextType;\n    oldProps = emptyContextObject;\n    \"object\" === typeof oldContext &&\n      null !== oldContext &&\n      (oldProps = readContext(oldContext));\n    unresolvedOldProps = Component.getDerivedStateFromProps;\n    (oldContext =\n      \"function\" === typeof unresolvedOldProps ||\n      \"function\" === typeof context.getSnapshotBeforeUpdate) ||\n      (\"function\" !== typeof context.UNSAFE_componentWillReceiveProps &&\n        \"function\" !== typeof context.componentWillReceiveProps) ||\n      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&\n        callComponentWillReceiveProps(\n          workInProgress,\n          context,\n          nextProps,\n          oldProps\n        ));\n    hasForceUpdate = !1;\n    oldState = workInProgress.memoizedState;\n    context.state = oldState;\n    processUpdateQueue(workInProgress, nextProps, context, renderLanes);\n    suspendIfUpdateReadFromEntangledAsyncAction();\n    var newState = workInProgress.memoizedState;\n    contextType !== getDerivedStateFromProps ||\n    oldState !== newState ||\n    hasForceUpdate ||\n    (null !== current &&\n      null !== current.dependencies &&\n      checkIfContextChanged(current.dependencies))\n      ? (\"function\" === typeof unresolvedOldProps &&\n          (applyDerivedStateFromProps(\n            workInProgress,\n            Component,\n            unresolvedOldProps,\n            nextProps\n          ),\n          (newState = workInProgress.memoizedState)),\n        (contextType$jscomp$0 =\n          hasForceUpdate ||\n          checkShouldComponentUpdate(\n            workInProgress,\n            Component,\n            contextType$jscomp$0,\n            nextProps,\n            oldState,\n            newState,\n            oldProps\n          ) ||\n          (null !== current &&\n            null !== current.dependencies &&\n            checkIfContextChanged(current.dependencies)))\n          ? (oldContext ||\n              (\"function\" !== typeof context.UNSAFE_componentWillUpdate &&\n                \"function\" !== typeof context.componentWillUpdate) ||\n              (\"function\" === typeof context.componentWillUpdate &&\n                context.componentWillUpdate(nextProps, newState, oldProps),\n              \"function\" === typeof context.UNSAFE_componentWillUpdate &&\n                context.UNSAFE_componentWillUpdate(\n                  nextProps,\n                  newState,\n                  oldProps\n                )),\n            \"function\" === typeof context.componentDidUpdate &&\n              (workInProgress.flags |= 4),\n            \"function\" === typeof context.getSnapshotBeforeUpdate &&\n              (workInProgress.flags |= 1024))\n          : (\"function\" !== typeof context.componentDidUpdate ||\n              (contextType === current.memoizedProps &&\n                oldState === current.memoizedState) ||\n              (workInProgress.flags |= 4),\n            \"function\" !== typeof context.getSnapshotBeforeUpdate ||\n              (contextType === current.memoizedProps &&\n                oldState === current.memoizedState) ||\n              (workInProgress.flags |= 1024),\n            (workInProgress.memoizedProps = nextProps),\n            (workInProgress.memoizedState = newState)),\n        (context.props = nextProps),\n        (context.state = newState),\n        (context.context = oldProps),\n        (nextProps = contextType$jscomp$0))\n      : (\"function\" !== typeof context.componentDidUpdate ||\n          (contextType === current.memoizedProps &&\n            oldState === current.memoizedState) ||\n          (workInProgress.flags |= 4),\n        \"function\" !== typeof context.getSnapshotBeforeUpdate ||\n          (contextType === current.memoizedProps &&\n            oldState === current.memoizedState) ||\n          (workInProgress.flags |= 1024),\n        (nextProps = !1));\n  }\n  context = nextProps;\n  markRef(current, workInProgress);\n  nextProps = 0 !== (workInProgress.flags & 128);\n  context || nextProps\n    ? ((context = workInProgress.stateNode),\n      (Component =\n        nextProps && \"function\" !== typeof Component.getDerivedStateFromError\n          ? null\n          : context.render()),\n      (workInProgress.flags |= 1),\n      null !== current && nextProps\n        ? ((workInProgress.child = reconcileChildFibers(\n            workInProgress,\n            current.child,\n            null,\n            renderLanes\n          )),\n          (workInProgress.child = reconcileChildFibers(\n            workInProgress,\n            null,\n            Component,\n            renderLanes\n          )))\n        : reconcileChildren(current, workInProgress, Component, renderLanes),\n      (workInProgress.memoizedState = context.state),\n      (current = workInProgress.child))\n    : (current = bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderLanes\n      ));\n  return current;\n}\nfunction mountHostRootWithoutHydrating(\n  current,\n  workInProgress,\n  nextChildren,\n  renderLanes\n) {\n  resetHydrationState();\n  workInProgress.flags |= 256;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\nvar SUSPENDED_MARKER = {\n  dehydrated: null,\n  treeContext: null,\n  retryLane: 0,\n  hydrationErrors: null\n};\nfunction mountSuspenseOffscreenState(renderLanes) {\n  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };\n}\nfunction getRemainingWorkInPrimaryTree(\n  current,\n  primaryTreeDidDefer,\n  renderLanes\n) {\n  current = null !== current ? current.childLanes & ~renderLanes : 0;\n  primaryTreeDidDefer && (current |= workInProgressDeferredLane);\n  return current;\n}\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps,\n    showFallback = !1,\n    didSuspend = 0 !== (workInProgress.flags & 128),\n    JSCompiler_temp;\n  (JSCompiler_temp = didSuspend) ||\n    (JSCompiler_temp =\n      null !== current && null === current.memoizedState\n        ? !1\n        : 0 !== (suspenseStackCursor.current & 2));\n  JSCompiler_temp && ((showFallback = !0), (workInProgress.flags &= -129));\n  JSCompiler_temp = 0 !== (workInProgress.flags & 32);\n  workInProgress.flags &= -33;\n  if (null === current) {\n    if (isHydrating) {\n      showFallback\n        ? pushPrimaryTreeSuspenseHandler(workInProgress)\n        : reuseSuspenseHandlerOnStack(workInProgress);\n      if (isHydrating) {\n        var nextInstance = nextHydratableInstance,\n          JSCompiler_temp$jscomp$0;\n        if ((JSCompiler_temp$jscomp$0 = nextInstance)) {\n          c: {\n            JSCompiler_temp$jscomp$0 = nextInstance;\n            for (\n              nextInstance = rootOrSingletonContext;\n              8 !== JSCompiler_temp$jscomp$0.nodeType;\n\n            ) {\n              if (!nextInstance) {\n                nextInstance = null;\n                break c;\n              }\n              JSCompiler_temp$jscomp$0 = getNextHydratable(\n                JSCompiler_temp$jscomp$0.nextSibling\n              );\n              if (null === JSCompiler_temp$jscomp$0) {\n                nextInstance = null;\n                break c;\n              }\n            }\n            nextInstance = JSCompiler_temp$jscomp$0;\n          }\n          null !== nextInstance\n            ? ((workInProgress.memoizedState = {\n                dehydrated: nextInstance,\n                treeContext:\n                  null !== treeContextProvider\n                    ? { id: treeContextId, overflow: treeContextOverflow }\n                    : null,\n                retryLane: 536870912,\n                hydrationErrors: null\n              }),\n              (JSCompiler_temp$jscomp$0 = createFiberImplClass(\n                18,\n                null,\n                null,\n                0\n              )),\n              (JSCompiler_temp$jscomp$0.stateNode = nextInstance),\n              (JSCompiler_temp$jscomp$0.return = workInProgress),\n              (workInProgress.child = JSCompiler_temp$jscomp$0),\n              (hydrationParentFiber = workInProgress),\n              (nextHydratableInstance = null),\n              (JSCompiler_temp$jscomp$0 = !0))\n            : (JSCompiler_temp$jscomp$0 = !1);\n        }\n        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);\n      }\n      nextInstance = workInProgress.memoizedState;\n      if (\n        null !== nextInstance &&\n        ((nextInstance = nextInstance.dehydrated), null !== nextInstance)\n      )\n        return (\n          isSuspenseInstanceFallback(nextInstance)\n            ? (workInProgress.lanes = 32)\n            : (workInProgress.lanes = 536870912),\n          null\n        );\n      popSuspenseHandler(workInProgress);\n    }\n    nextInstance = nextProps.children;\n    nextProps = nextProps.fallback;\n    if (showFallback)\n      return (\n        reuseSuspenseHandlerOnStack(workInProgress),\n        (showFallback = workInProgress.mode),\n        (nextInstance = mountWorkInProgressOffscreenFiber(\n          { mode: \"hidden\", children: nextInstance },\n          showFallback\n        )),\n        (nextProps = createFiberFromFragment(\n          nextProps,\n          showFallback,\n          renderLanes,\n          null\n        )),\n        (nextInstance.return = workInProgress),\n        (nextProps.return = workInProgress),\n        (nextInstance.sibling = nextProps),\n        (workInProgress.child = nextInstance),\n        (showFallback = workInProgress.child),\n        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),\n        (showFallback.childLanes = getRemainingWorkInPrimaryTree(\n          current,\n          JSCompiler_temp,\n          renderLanes\n        )),\n        (workInProgress.memoizedState = SUSPENDED_MARKER),\n        nextProps\n      );\n    pushPrimaryTreeSuspenseHandler(workInProgress);\n    return mountSuspensePrimaryChildren(workInProgress, nextInstance);\n  }\n  JSCompiler_temp$jscomp$0 = current.memoizedState;\n  if (\n    null !== JSCompiler_temp$jscomp$0 &&\n    ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),\n    null !== nextInstance)\n  ) {\n    if (didSuspend)\n      workInProgress.flags & 256\n        ? (pushPrimaryTreeSuspenseHandler(workInProgress),\n          (workInProgress.flags &= -257),\n          (workInProgress = retrySuspenseComponentWithoutHydrating(\n            current,\n            workInProgress,\n            renderLanes\n          )))\n        : null !== workInProgress.memoizedState\n          ? (reuseSuspenseHandlerOnStack(workInProgress),\n            (workInProgress.child = current.child),\n            (workInProgress.flags |= 128),\n            (workInProgress = null))\n          : (reuseSuspenseHandlerOnStack(workInProgress),\n            (showFallback = nextProps.fallback),\n            (nextInstance = workInProgress.mode),\n            (nextProps = mountWorkInProgressOffscreenFiber(\n              { mode: \"visible\", children: nextProps.children },\n              nextInstance\n            )),\n            (showFallback = createFiberFromFragment(\n              showFallback,\n              nextInstance,\n              renderLanes,\n              null\n            )),\n            (showFallback.flags |= 2),\n            (nextProps.return = workInProgress),\n            (showFallback.return = workInProgress),\n            (nextProps.sibling = showFallback),\n            (workInProgress.child = nextProps),\n            reconcileChildFibers(\n              workInProgress,\n              current.child,\n              null,\n              renderLanes\n            ),\n            (nextProps = workInProgress.child),\n            (nextProps.memoizedState =\n              mountSuspenseOffscreenState(renderLanes)),\n            (nextProps.childLanes = getRemainingWorkInPrimaryTree(\n              current,\n              JSCompiler_temp,\n              renderLanes\n            )),\n            (workInProgress.memoizedState = SUSPENDED_MARKER),\n            (workInProgress = showFallback));\n    else if (\n      (pushPrimaryTreeSuspenseHandler(workInProgress),\n      isSuspenseInstanceFallback(nextInstance))\n    ) {\n      JSCompiler_temp =\n        nextInstance.nextSibling && nextInstance.nextSibling.dataset;\n      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;\n      JSCompiler_temp = digest;\n      nextProps = Error(formatProdErrorMessage(419));\n      nextProps.stack = \"\";\n      nextProps.digest = JSCompiler_temp;\n      queueHydrationError({ value: nextProps, source: null, stack: null });\n      workInProgress = retrySuspenseComponentWithoutHydrating(\n        current,\n        workInProgress,\n        renderLanes\n      );\n    } else if (\n      (didReceiveUpdate ||\n        propagateParentContextChanges(current, workInProgress, renderLanes, !1),\n      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),\n      didReceiveUpdate || JSCompiler_temp)\n    ) {\n      JSCompiler_temp = workInProgressRoot;\n      if (\n        null !== JSCompiler_temp &&\n        ((nextProps = renderLanes & -renderLanes),\n        (nextProps =\n          0 !== (nextProps & 42)\n            ? 1\n            : getBumpedLaneForHydrationByLane(nextProps)),\n        (nextProps =\n          0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes))\n            ? 0\n            : nextProps),\n        0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)\n      )\n        throw (\n          ((JSCompiler_temp$jscomp$0.retryLane = nextProps),\n          enqueueConcurrentRenderForLane(current, nextProps),\n          scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),\n          SelectiveHydrationException)\n        );\n      \"$?\" === nextInstance.data || renderDidSuspendDelayIfPossible();\n      workInProgress = retrySuspenseComponentWithoutHydrating(\n        current,\n        workInProgress,\n        renderLanes\n      );\n    } else\n      \"$?\" === nextInstance.data\n        ? ((workInProgress.flags |= 192),\n          (workInProgress.child = current.child),\n          (workInProgress = null))\n        : ((current = JSCompiler_temp$jscomp$0.treeContext),\n          (nextHydratableInstance = getNextHydratable(\n            nextInstance.nextSibling\n          )),\n          (hydrationParentFiber = workInProgress),\n          (isHydrating = !0),\n          (hydrationErrors = null),\n          (rootOrSingletonContext = !1),\n          null !== current &&\n            ((idStack[idStackIndex++] = treeContextId),\n            (idStack[idStackIndex++] = treeContextOverflow),\n            (idStack[idStackIndex++] = treeContextProvider),\n            (treeContextId = current.id),\n            (treeContextOverflow = current.overflow),\n            (treeContextProvider = workInProgress)),\n          (workInProgress = mountSuspensePrimaryChildren(\n            workInProgress,\n            nextProps.children\n          )),\n          (workInProgress.flags |= 4096));\n    return workInProgress;\n  }\n  if (showFallback)\n    return (\n      reuseSuspenseHandlerOnStack(workInProgress),\n      (showFallback = nextProps.fallback),\n      (nextInstance = workInProgress.mode),\n      (JSCompiler_temp$jscomp$0 = current.child),\n      (digest = JSCompiler_temp$jscomp$0.sibling),\n      (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {\n        mode: \"hidden\",\n        children: nextProps.children\n      })),\n      (nextProps.subtreeFlags =\n        JSCompiler_temp$jscomp$0.subtreeFlags & 65011712),\n      null !== digest\n        ? (showFallback = createWorkInProgress(digest, showFallback))\n        : ((showFallback = createFiberFromFragment(\n            showFallback,\n            nextInstance,\n            renderLanes,\n            null\n          )),\n          (showFallback.flags |= 2)),\n      (showFallback.return = workInProgress),\n      (nextProps.return = workInProgress),\n      (nextProps.sibling = showFallback),\n      (workInProgress.child = nextProps),\n      (nextProps = showFallback),\n      (showFallback = workInProgress.child),\n      (nextInstance = current.child.memoizedState),\n      null === nextInstance\n        ? (nextInstance = mountSuspenseOffscreenState(renderLanes))\n        : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),\n          null !== JSCompiler_temp$jscomp$0\n            ? ((digest = CacheContext._currentValue),\n              (JSCompiler_temp$jscomp$0 =\n                JSCompiler_temp$jscomp$0.parent !== digest\n                  ? { parent: digest, pool: digest }\n                  : JSCompiler_temp$jscomp$0))\n            : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),\n          (nextInstance = {\n            baseLanes: nextInstance.baseLanes | renderLanes,\n            cachePool: JSCompiler_temp$jscomp$0\n          })),\n      (showFallback.memoizedState = nextInstance),\n      (showFallback.childLanes = getRemainingWorkInPrimaryTree(\n        current,\n        JSCompiler_temp,\n        renderLanes\n      )),\n      (workInProgress.memoizedState = SUSPENDED_MARKER),\n      nextProps\n    );\n  pushPrimaryTreeSuspenseHandler(workInProgress);\n  renderLanes = current.child;\n  current = renderLanes.sibling;\n  renderLanes = createWorkInProgress(renderLanes, {\n    mode: \"visible\",\n    children: nextProps.children\n  });\n  renderLanes.return = workInProgress;\n  renderLanes.sibling = null;\n  null !== current &&\n    ((JSCompiler_temp = workInProgress.deletions),\n    null === JSCompiler_temp\n      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))\n      : JSCompiler_temp.push(current));\n  workInProgress.child = renderLanes;\n  workInProgress.memoizedState = null;\n  return renderLanes;\n}\nfunction mountSuspensePrimaryChildren(workInProgress, primaryChildren) {\n  primaryChildren = mountWorkInProgressOffscreenFiber(\n    { mode: \"visible\", children: primaryChildren },\n    workInProgress.mode\n  );\n  primaryChildren.return = workInProgress;\n  return (workInProgress.child = primaryChildren);\n}\nfunction mountWorkInProgressOffscreenFiber(offscreenProps, mode) {\n  offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);\n  offscreenProps.lanes = 0;\n  offscreenProps.stateNode = {\n    _visibility: 1,\n    _pendingMarkers: null,\n    _retryCache: null,\n    _transitions: null\n  };\n  return offscreenProps;\n}\nfunction retrySuspenseComponentWithoutHydrating(\n  current,\n  workInProgress,\n  renderLanes\n) {\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n  current = mountSuspensePrimaryChildren(\n    workInProgress,\n    workInProgress.pendingProps.children\n  );\n  current.flags |= 2;\n  workInProgress.memoizedState = null;\n  return current;\n}\nfunction scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n  fiber.lanes |= renderLanes;\n  var alternate = fiber.alternate;\n  null !== alternate && (alternate.lanes |= renderLanes);\n  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n}\nfunction initSuspenseListRenderState(\n  workInProgress,\n  isBackwards,\n  tail,\n  lastContentRow,\n  tailMode\n) {\n  var renderState = workInProgress.memoizedState;\n  null === renderState\n    ? (workInProgress.memoizedState = {\n        isBackwards: isBackwards,\n        rendering: null,\n        renderingStartTime: 0,\n        last: lastContentRow,\n        tail: tail,\n        tailMode: tailMode\n      })\n    : ((renderState.isBackwards = isBackwards),\n      (renderState.rendering = null),\n      (renderState.renderingStartTime = 0),\n      (renderState.last = lastContentRow),\n      (renderState.tail = tail),\n      (renderState.tailMode = tailMode));\n}\nfunction updateSuspenseListComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps,\n    revealOrder = nextProps.revealOrder,\n    tailMode = nextProps.tail;\n  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);\n  nextProps = suspenseStackCursor.current;\n  if (0 !== (nextProps & 2))\n    (nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128);\n  else {\n    if (null !== current && 0 !== (current.flags & 128))\n      a: for (current = workInProgress.child; null !== current; ) {\n        if (13 === current.tag)\n          null !== current.memoizedState &&\n            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n        else if (19 === current.tag)\n          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n        else if (null !== current.child) {\n          current.child.return = current;\n          current = current.child;\n          continue;\n        }\n        if (current === workInProgress) break a;\n        for (; null === current.sibling; ) {\n          if (null === current.return || current.return === workInProgress)\n            break a;\n          current = current.return;\n        }\n        current.sibling.return = current.return;\n        current = current.sibling;\n      }\n    nextProps &= 1;\n  }\n  push(suspenseStackCursor, nextProps);\n  switch (revealOrder) {\n    case \"forwards\":\n      renderLanes = workInProgress.child;\n      for (revealOrder = null; null !== renderLanes; )\n        (current = renderLanes.alternate),\n          null !== current &&\n            null === findFirstSuspended(current) &&\n            (revealOrder = renderLanes),\n          (renderLanes = renderLanes.sibling);\n      renderLanes = revealOrder;\n      null === renderLanes\n        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))\n        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));\n      initSuspenseListRenderState(\n        workInProgress,\n        !1,\n        revealOrder,\n        renderLanes,\n        tailMode\n      );\n      break;\n    case \"backwards\":\n      renderLanes = null;\n      revealOrder = workInProgress.child;\n      for (workInProgress.child = null; null !== revealOrder; ) {\n        current = revealOrder.alternate;\n        if (null !== current && null === findFirstSuspended(current)) {\n          workInProgress.child = revealOrder;\n          break;\n        }\n        current = revealOrder.sibling;\n        revealOrder.sibling = renderLanes;\n        renderLanes = revealOrder;\n        revealOrder = current;\n      }\n      initSuspenseListRenderState(\n        workInProgress,\n        !0,\n        renderLanes,\n        null,\n        tailMode\n      );\n      break;\n    case \"together\":\n      initSuspenseListRenderState(workInProgress, !1, null, null, void 0);\n      break;\n    default:\n      workInProgress.memoizedState = null;\n  }\n  return workInProgress.child;\n}\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n  null !== current && (workInProgress.dependencies = current.dependencies);\n  workInProgressRootSkippedLanes |= workInProgress.lanes;\n  if (0 === (renderLanes & workInProgress.childLanes))\n    if (null !== current) {\n      if (\n        (propagateParentContextChanges(\n          current,\n          workInProgress,\n          renderLanes,\n          !1\n        ),\n        0 === (renderLanes & workInProgress.childLanes))\n      )\n        return null;\n    } else return null;\n  if (null !== current && workInProgress.child !== current.child)\n    throw Error(formatProdErrorMessage(153));\n  if (null !== workInProgress.child) {\n    current = workInProgress.child;\n    renderLanes = createWorkInProgress(current, current.pendingProps);\n    workInProgress.child = renderLanes;\n    for (renderLanes.return = workInProgress; null !== current.sibling; )\n      (current = current.sibling),\n        (renderLanes = renderLanes.sibling =\n          createWorkInProgress(current, current.pendingProps)),\n        (renderLanes.return = workInProgress);\n    renderLanes.sibling = null;\n  }\n  return workInProgress.child;\n}\nfunction checkScheduledUpdateOrContext(current, renderLanes) {\n  if (0 !== (current.lanes & renderLanes)) return !0;\n  current = current.dependencies;\n  return null !== current && checkIfContextChanged(current) ? !0 : !1;\n}\nfunction attemptEarlyBailoutIfNoScheduledUpdate(\n  current,\n  workInProgress,\n  renderLanes\n) {\n  switch (workInProgress.tag) {\n    case 3:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n      resetHydrationState();\n      break;\n    case 27:\n    case 5:\n      pushHostContext(workInProgress);\n      break;\n    case 4:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      break;\n    case 10:\n      pushProvider(\n        workInProgress,\n        workInProgress.type,\n        workInProgress.memoizedProps.value\n      );\n      break;\n    case 13:\n      var state = workInProgress.memoizedState;\n      if (null !== state) {\n        if (null !== state.dehydrated)\n          return (\n            pushPrimaryTreeSuspenseHandler(workInProgress),\n            (workInProgress.flags |= 128),\n            null\n          );\n        if (0 !== (renderLanes & workInProgress.child.childLanes))\n          return updateSuspenseComponent(current, workInProgress, renderLanes);\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n        current = bailoutOnAlreadyFinishedWork(\n          current,\n          workInProgress,\n          renderLanes\n        );\n        return null !== current ? current.sibling : null;\n      }\n      pushPrimaryTreeSuspenseHandler(workInProgress);\n      break;\n    case 19:\n      var didSuspendBefore = 0 !== (current.flags & 128);\n      state = 0 !== (renderLanes & workInProgress.childLanes);\n      state ||\n        (propagateParentContextChanges(\n          current,\n          workInProgress,\n          renderLanes,\n          !1\n        ),\n        (state = 0 !== (renderLanes & workInProgress.childLanes)));\n      if (didSuspendBefore) {\n        if (state)\n          return updateSuspenseListComponent(\n            current,\n            workInProgress,\n            renderLanes\n          );\n        workInProgress.flags |= 128;\n      }\n      didSuspendBefore = workInProgress.memoizedState;\n      null !== didSuspendBefore &&\n        ((didSuspendBefore.rendering = null),\n        (didSuspendBefore.tail = null),\n        (didSuspendBefore.lastEffect = null));\n      push(suspenseStackCursor, suspenseStackCursor.current);\n      if (state) break;\n      else return null;\n    case 22:\n    case 23:\n      return (\n        (workInProgress.lanes = 0),\n        updateOffscreenComponent(current, workInProgress, renderLanes)\n      );\n    case 24:\n      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n  }\n  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n}\nfunction beginWork(current, workInProgress, renderLanes) {\n  if (null !== current)\n    if (current.memoizedProps !== workInProgress.pendingProps)\n      didReceiveUpdate = !0;\n    else {\n      if (\n        !checkScheduledUpdateOrContext(current, renderLanes) &&\n        0 === (workInProgress.flags & 128)\n      )\n        return (\n          (didReceiveUpdate = !1),\n          attemptEarlyBailoutIfNoScheduledUpdate(\n            current,\n            workInProgress,\n            renderLanes\n          )\n        );\n      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;\n    }\n  else\n    (didReceiveUpdate = !1),\n      isHydrating &&\n        0 !== (workInProgress.flags & 1048576) &&\n        pushTreeId(workInProgress, treeForkCount, workInProgress.index);\n  workInProgress.lanes = 0;\n  switch (workInProgress.tag) {\n    case 16:\n      a: {\n        current = workInProgress.pendingProps;\n        var lazyComponent = workInProgress.elementType,\n          init = lazyComponent._init;\n        lazyComponent = init(lazyComponent._payload);\n        workInProgress.type = lazyComponent;\n        if (\"function\" === typeof lazyComponent)\n          shouldConstruct(lazyComponent)\n            ? ((current = resolveClassComponentProps(lazyComponent, current)),\n              (workInProgress.tag = 1),\n              (workInProgress = updateClassComponent(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              )))\n            : ((workInProgress.tag = 0),\n              (workInProgress = updateFunctionComponent(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              )));\n        else {\n          if (void 0 !== lazyComponent && null !== lazyComponent)\n            if (\n              ((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)\n            ) {\n              workInProgress.tag = 11;\n              workInProgress = updateForwardRef(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              );\n              break a;\n            } else if (init === REACT_MEMO_TYPE) {\n              workInProgress.tag = 14;\n              workInProgress = updateMemoComponent(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              );\n              break a;\n            }\n          workInProgress =\n            getComponentNameFromType(lazyComponent) || lazyComponent;\n          throw Error(formatProdErrorMessage(306, workInProgress, \"\"));\n        }\n      }\n      return workInProgress;\n    case 0:\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 1:\n      return (\n        (lazyComponent = workInProgress.type),\n        (init = resolveClassComponentProps(\n          lazyComponent,\n          workInProgress.pendingProps\n        )),\n        updateClassComponent(\n          current,\n          workInProgress,\n          lazyComponent,\n          init,\n          renderLanes\n        )\n      );\n    case 3:\n      a: {\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo\n        );\n        if (null === current) throw Error(formatProdErrorMessage(387));\n        lazyComponent = workInProgress.pendingProps;\n        var prevState = workInProgress.memoizedState;\n        init = prevState.element;\n        cloneUpdateQueue(current, workInProgress);\n        processUpdateQueue(workInProgress, lazyComponent, null, renderLanes);\n        var nextState = workInProgress.memoizedState;\n        lazyComponent = nextState.cache;\n        pushProvider(workInProgress, CacheContext, lazyComponent);\n        lazyComponent !== prevState.cache &&\n          propagateContextChanges(\n            workInProgress,\n            [CacheContext],\n            renderLanes,\n            !0\n          );\n        suspendIfUpdateReadFromEntangledAsyncAction();\n        lazyComponent = nextState.element;\n        if (prevState.isDehydrated)\n          if (\n            ((prevState = {\n              element: lazyComponent,\n              isDehydrated: !1,\n              cache: nextState.cache\n            }),\n            (workInProgress.updateQueue.baseState = prevState),\n            (workInProgress.memoizedState = prevState),\n            workInProgress.flags & 256)\n          ) {\n            workInProgress = mountHostRootWithoutHydrating(\n              current,\n              workInProgress,\n              lazyComponent,\n              renderLanes\n            );\n            break a;\n          } else if (lazyComponent !== init) {\n            init = createCapturedValueAtFiber(\n              Error(formatProdErrorMessage(424)),\n              workInProgress\n            );\n            queueHydrationError(init);\n            workInProgress = mountHostRootWithoutHydrating(\n              current,\n              workInProgress,\n              lazyComponent,\n              renderLanes\n            );\n            break a;\n          } else {\n            current = workInProgress.stateNode.containerInfo;\n            switch (current.nodeType) {\n              case 9:\n                current = current.body;\n                break;\n              default:\n                current =\n                  \"HTML\" === current.nodeName\n                    ? current.ownerDocument.body\n                    : current;\n            }\n            nextHydratableInstance = getNextHydratable(current.firstChild);\n            hydrationParentFiber = workInProgress;\n            isHydrating = !0;\n            hydrationErrors = null;\n            rootOrSingletonContext = !0;\n            renderLanes = mountChildFibers(\n              workInProgress,\n              null,\n              lazyComponent,\n              renderLanes\n            );\n            for (workInProgress.child = renderLanes; renderLanes; )\n              (renderLanes.flags = (renderLanes.flags & -3) | 4096),\n                (renderLanes = renderLanes.sibling);\n          }\n        else {\n          resetHydrationState();\n          if (lazyComponent === init) {\n            workInProgress = bailoutOnAlreadyFinishedWork(\n              current,\n              workInProgress,\n              renderLanes\n            );\n            break a;\n          }\n          reconcileChildren(\n            current,\n            workInProgress,\n            lazyComponent,\n            renderLanes\n          );\n        }\n        workInProgress = workInProgress.child;\n      }\n      return workInProgress;\n    case 26:\n      return (\n        markRef(current, workInProgress),\n        null === current\n          ? (renderLanes = getResource(\n              workInProgress.type,\n              null,\n              workInProgress.pendingProps,\n              null\n            ))\n            ? (workInProgress.memoizedState = renderLanes)\n            : isHydrating ||\n              ((renderLanes = workInProgress.type),\n              (current = workInProgress.pendingProps),\n              (lazyComponent = getOwnerDocumentFromRootContainer(\n                rootInstanceStackCursor.current\n              ).createElement(renderLanes)),\n              (lazyComponent[internalInstanceKey] = workInProgress),\n              (lazyComponent[internalPropsKey] = current),\n              setInitialProperties(lazyComponent, renderLanes, current),\n              markNodeAsHoistable(lazyComponent),\n              (workInProgress.stateNode = lazyComponent))\n          : (workInProgress.memoizedState = getResource(\n              workInProgress.type,\n              current.memoizedProps,\n              workInProgress.pendingProps,\n              current.memoizedState\n            )),\n        null\n      );\n    case 27:\n      return (\n        pushHostContext(workInProgress),\n        null === current &&\n          isHydrating &&\n          ((lazyComponent = workInProgress.stateNode =\n            resolveSingletonInstance(\n              workInProgress.type,\n              workInProgress.pendingProps,\n              rootInstanceStackCursor.current\n            )),\n          (hydrationParentFiber = workInProgress),\n          (rootOrSingletonContext = !0),\n          (init = nextHydratableInstance),\n          isSingletonScope(workInProgress.type)\n            ? ((previousHydratableOnEnteringScopedSingleton = init),\n              (nextHydratableInstance = getNextHydratable(\n                lazyComponent.firstChild\n              )))\n            : (nextHydratableInstance = init)),\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        markRef(current, workInProgress),\n        null === current && (workInProgress.flags |= 4194304),\n        workInProgress.child\n      );\n    case 5:\n      if (null === current && isHydrating) {\n        if ((init = lazyComponent = nextHydratableInstance))\n          (lazyComponent = canHydrateInstance(\n            lazyComponent,\n            workInProgress.type,\n            workInProgress.pendingProps,\n            rootOrSingletonContext\n          )),\n            null !== lazyComponent\n              ? ((workInProgress.stateNode = lazyComponent),\n                (hydrationParentFiber = workInProgress),\n                (nextHydratableInstance = getNextHydratable(\n                  lazyComponent.firstChild\n                )),\n                (rootOrSingletonContext = !1),\n                (init = !0))\n              : (init = !1);\n        init || throwOnHydrationMismatch(workInProgress);\n      }\n      pushHostContext(workInProgress);\n      init = workInProgress.type;\n      prevState = workInProgress.pendingProps;\n      nextState = null !== current ? current.memoizedProps : null;\n      lazyComponent = prevState.children;\n      shouldSetTextContent(init, prevState)\n        ? (lazyComponent = null)\n        : null !== nextState &&\n          shouldSetTextContent(init, nextState) &&\n          (workInProgress.flags |= 32);\n      null !== workInProgress.memoizedState &&\n        ((init = renderWithHooks(\n          current,\n          workInProgress,\n          TransitionAwareHostComponent,\n          null,\n          null,\n          renderLanes\n        )),\n        (HostTransitionContext._currentValue = init));\n      markRef(current, workInProgress);\n      reconcileChildren(current, workInProgress, lazyComponent, renderLanes);\n      return workInProgress.child;\n    case 6:\n      if (null === current && isHydrating) {\n        if ((current = renderLanes = nextHydratableInstance))\n          (renderLanes = canHydrateTextInstance(\n            renderLanes,\n            workInProgress.pendingProps,\n            rootOrSingletonContext\n          )),\n            null !== renderLanes\n              ? ((workInProgress.stateNode = renderLanes),\n                (hydrationParentFiber = workInProgress),\n                (nextHydratableInstance = null),\n                (current = !0))\n              : (current = !1);\n        current || throwOnHydrationMismatch(workInProgress);\n      }\n      return null;\n    case 13:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n    case 4:\n      return (\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo\n        ),\n        (lazyComponent = workInProgress.pendingProps),\n        null === current\n          ? (workInProgress.child = reconcileChildFibers(\n              workInProgress,\n              null,\n              lazyComponent,\n              renderLanes\n            ))\n          : reconcileChildren(\n              current,\n              workInProgress,\n              lazyComponent,\n              renderLanes\n            ),\n        workInProgress.child\n      );\n    case 11:\n      return updateForwardRef(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 7:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 8:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 12:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 10:\n      return (\n        (lazyComponent = workInProgress.pendingProps),\n        pushProvider(workInProgress, workInProgress.type, lazyComponent.value),\n        reconcileChildren(\n          current,\n          workInProgress,\n          lazyComponent.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 9:\n      return (\n        (init = workInProgress.type._context),\n        (lazyComponent = workInProgress.pendingProps.children),\n        prepareToReadContext(workInProgress),\n        (init = readContext(init)),\n        (lazyComponent = lazyComponent(init)),\n        (workInProgress.flags |= 1),\n        reconcileChildren(current, workInProgress, lazyComponent, renderLanes),\n        workInProgress.child\n      );\n    case 14:\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 15:\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 19:\n      return updateSuspenseListComponent(current, workInProgress, renderLanes);\n    case 31:\n      return (\n        (lazyComponent = workInProgress.pendingProps),\n        (renderLanes = workInProgress.mode),\n        (lazyComponent = {\n          mode: lazyComponent.mode,\n          children: lazyComponent.children\n        }),\n        null === current\n          ? ((renderLanes = mountWorkInProgressOffscreenFiber(\n              lazyComponent,\n              renderLanes\n            )),\n            (renderLanes.ref = workInProgress.ref),\n            (workInProgress.child = renderLanes),\n            (renderLanes.return = workInProgress),\n            (workInProgress = renderLanes))\n          : ((renderLanes = createWorkInProgress(current.child, lazyComponent)),\n            (renderLanes.ref = workInProgress.ref),\n            (workInProgress.child = renderLanes),\n            (renderLanes.return = workInProgress),\n            (workInProgress = renderLanes)),\n        workInProgress\n      );\n    case 22:\n      return updateOffscreenComponent(current, workInProgress, renderLanes);\n    case 24:\n      return (\n        prepareToReadContext(workInProgress),\n        (lazyComponent = readContext(CacheContext)),\n        null === current\n          ? ((init = peekCacheFromPool()),\n            null === init &&\n              ((init = workInProgressRoot),\n              (prevState = createCache()),\n              (init.pooledCache = prevState),\n              prevState.refCount++,\n              null !== prevState && (init.pooledCacheLanes |= renderLanes),\n              (init = prevState)),\n            (workInProgress.memoizedState = {\n              parent: lazyComponent,\n              cache: init\n            }),\n            initializeUpdateQueue(workInProgress),\n            pushProvider(workInProgress, CacheContext, init))\n          : (0 !== (current.lanes & renderLanes) &&\n              (cloneUpdateQueue(current, workInProgress),\n              processUpdateQueue(workInProgress, null, null, renderLanes),\n              suspendIfUpdateReadFromEntangledAsyncAction()),\n            (init = current.memoizedState),\n            (prevState = workInProgress.memoizedState),\n            init.parent !== lazyComponent\n              ? ((init = { parent: lazyComponent, cache: lazyComponent }),\n                (workInProgress.memoizedState = init),\n                0 === workInProgress.lanes &&\n                  (workInProgress.memoizedState =\n                    workInProgress.updateQueue.baseState =\n                      init),\n                pushProvider(workInProgress, CacheContext, lazyComponent))\n              : ((lazyComponent = prevState.cache),\n                pushProvider(workInProgress, CacheContext, lazyComponent),\n                lazyComponent !== init.cache &&\n                  propagateContextChanges(\n                    workInProgress,\n                    [CacheContext],\n                    renderLanes,\n                    !0\n                  ))),\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 29:\n      throw workInProgress.pendingProps;\n  }\n  throw Error(formatProdErrorMessage(156, workInProgress.tag));\n}\nfunction markUpdate(workInProgress) {\n  workInProgress.flags |= 4;\n}\nfunction preloadResourceAndSuspendIfNeeded(workInProgress, resource) {\n  if (\"stylesheet\" !== resource.type || 0 !== (resource.state.loading & 4))\n    workInProgress.flags &= -16777217;\n  else if (((workInProgress.flags |= 16777216), !preloadResource(resource))) {\n    resource = suspenseHandlerStackCursor.current;\n    if (\n      null !== resource &&\n      ((workInProgressRootRenderLanes & 4194048) ===\n      workInProgressRootRenderLanes\n        ? null !== shellBoundary\n        : ((workInProgressRootRenderLanes & 62914560) !==\n            workInProgressRootRenderLanes &&\n            0 === (workInProgressRootRenderLanes & 536870912)) ||\n          resource !== shellBoundary)\n    )\n      throw (\n        ((suspendedThenable = noopSuspenseyCommitThenable),\n        SuspenseyCommitException)\n      );\n    workInProgress.flags |= 8192;\n  }\n}\nfunction scheduleRetryEffect(workInProgress, retryQueue) {\n  null !== retryQueue && (workInProgress.flags |= 4);\n  workInProgress.flags & 16384 &&\n    ((retryQueue =\n      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),\n    (workInProgress.lanes |= retryQueue),\n    (workInProgressSuspendedRetryLanes |= retryQueue));\n}\nfunction cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n  if (!isHydrating)\n    switch (renderState.tailMode) {\n      case \"hidden\":\n        hasRenderedATailFallback = renderState.tail;\n        for (var lastTailNode = null; null !== hasRenderedATailFallback; )\n          null !== hasRenderedATailFallback.alternate &&\n            (lastTailNode = hasRenderedATailFallback),\n            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);\n        null === lastTailNode\n          ? (renderState.tail = null)\n          : (lastTailNode.sibling = null);\n        break;\n      case \"collapsed\":\n        lastTailNode = renderState.tail;\n        for (var lastTailNode$113 = null; null !== lastTailNode; )\n          null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode),\n            (lastTailNode = lastTailNode.sibling);\n        null === lastTailNode$113\n          ? hasRenderedATailFallback || null === renderState.tail\n            ? (renderState.tail = null)\n            : (renderState.tail.sibling = null)\n          : (lastTailNode$113.sibling = null);\n    }\n}\nfunction bubbleProperties(completedWork) {\n  var didBailout =\n      null !== completedWork.alternate &&\n      completedWork.alternate.child === completedWork.child,\n    newChildLanes = 0,\n    subtreeFlags = 0;\n  if (didBailout)\n    for (var child$114 = completedWork.child; null !== child$114; )\n      (newChildLanes |= child$114.lanes | child$114.childLanes),\n        (subtreeFlags |= child$114.subtreeFlags & 65011712),\n        (subtreeFlags |= child$114.flags & 65011712),\n        (child$114.return = completedWork),\n        (child$114 = child$114.sibling);\n  else\n    for (child$114 = completedWork.child; null !== child$114; )\n      (newChildLanes |= child$114.lanes | child$114.childLanes),\n        (subtreeFlags |= child$114.subtreeFlags),\n        (subtreeFlags |= child$114.flags),\n        (child$114.return = completedWork),\n        (child$114 = child$114.sibling);\n  completedWork.subtreeFlags |= subtreeFlags;\n  completedWork.childLanes = newChildLanes;\n  return didBailout;\n}\nfunction completeWork(current, workInProgress, renderLanes) {\n  var newProps = workInProgress.pendingProps;\n  popTreeContext(workInProgress);\n  switch (workInProgress.tag) {\n    case 31:\n    case 16:\n    case 15:\n    case 0:\n    case 11:\n    case 7:\n    case 8:\n    case 12:\n    case 9:\n    case 14:\n      return bubbleProperties(workInProgress), null;\n    case 1:\n      return bubbleProperties(workInProgress), null;\n    case 3:\n      renderLanes = workInProgress.stateNode;\n      newProps = null;\n      null !== current && (newProps = current.memoizedState.cache);\n      workInProgress.memoizedState.cache !== newProps &&\n        (workInProgress.flags |= 2048);\n      popProvider(CacheContext);\n      popHostContainer();\n      renderLanes.pendingContext &&\n        ((renderLanes.context = renderLanes.pendingContext),\n        (renderLanes.pendingContext = null));\n      if (null === current || null === current.child)\n        popHydrationState(workInProgress)\n          ? markUpdate(workInProgress)\n          : null === current ||\n            (current.memoizedState.isDehydrated &&\n              0 === (workInProgress.flags & 256)) ||\n            ((workInProgress.flags |= 1024),\n            upgradeHydrationErrorsToRecoverable());\n      bubbleProperties(workInProgress);\n      return null;\n    case 26:\n      return (\n        (renderLanes = workInProgress.memoizedState),\n        null === current\n          ? (markUpdate(workInProgress),\n            null !== renderLanes\n              ? (bubbleProperties(workInProgress),\n                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))\n              : (bubbleProperties(workInProgress),\n                (workInProgress.flags &= -16777217)))\n          : renderLanes\n            ? renderLanes !== current.memoizedState\n              ? (markUpdate(workInProgress),\n                bubbleProperties(workInProgress),\n                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))\n              : (bubbleProperties(workInProgress),\n                (workInProgress.flags &= -16777217))\n            : (current.memoizedProps !== newProps && markUpdate(workInProgress),\n              bubbleProperties(workInProgress),\n              (workInProgress.flags &= -16777217)),\n        null\n      );\n    case 27:\n      popHostContext(workInProgress);\n      renderLanes = rootInstanceStackCursor.current;\n      var type = workInProgress.type;\n      if (null !== current && null != workInProgress.stateNode)\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\n      else {\n        if (!newProps) {\n          if (null === workInProgress.stateNode)\n            throw Error(formatProdErrorMessage(166));\n          bubbleProperties(workInProgress);\n          return null;\n        }\n        current = contextStackCursor.current;\n        popHydrationState(workInProgress)\n          ? prepareToHydrateHostInstance(workInProgress, current)\n          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),\n            (workInProgress.stateNode = current),\n            markUpdate(workInProgress));\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    case 5:\n      popHostContext(workInProgress);\n      renderLanes = workInProgress.type;\n      if (null !== current && null != workInProgress.stateNode)\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\n      else {\n        if (!newProps) {\n          if (null === workInProgress.stateNode)\n            throw Error(formatProdErrorMessage(166));\n          bubbleProperties(workInProgress);\n          return null;\n        }\n        current = contextStackCursor.current;\n        if (popHydrationState(workInProgress))\n          prepareToHydrateHostInstance(workInProgress, current);\n        else {\n          type = getOwnerDocumentFromRootContainer(\n            rootInstanceStackCursor.current\n          );\n          switch (current) {\n            case 1:\n              current = type.createElementNS(\n                \"http://www.w3.org/2000/svg\",\n                renderLanes\n              );\n              break;\n            case 2:\n              current = type.createElementNS(\n                \"http://www.w3.org/1998/Math/MathML\",\n                renderLanes\n              );\n              break;\n            default:\n              switch (renderLanes) {\n                case \"svg\":\n                  current = type.createElementNS(\n                    \"http://www.w3.org/2000/svg\",\n                    renderLanes\n                  );\n                  break;\n                case \"math\":\n                  current = type.createElementNS(\n                    \"http://www.w3.org/1998/Math/MathML\",\n                    renderLanes\n                  );\n                  break;\n                case \"script\":\n                  current = type.createElement(\"div\");\n                  current.innerHTML = \"<script>\\x3c/script>\";\n                  current = current.removeChild(current.firstChild);\n                  break;\n                case \"select\":\n                  current =\n                    \"string\" === typeof newProps.is\n                      ? type.createElement(\"select\", { is: newProps.is })\n                      : type.createElement(\"select\");\n                  newProps.multiple\n                    ? (current.multiple = !0)\n                    : newProps.size && (current.size = newProps.size);\n                  break;\n                default:\n                  current =\n                    \"string\" === typeof newProps.is\n                      ? type.createElement(renderLanes, { is: newProps.is })\n                      : type.createElement(renderLanes);\n              }\n          }\n          current[internalInstanceKey] = workInProgress;\n          current[internalPropsKey] = newProps;\n          a: for (type = workInProgress.child; null !== type; ) {\n            if (5 === type.tag || 6 === type.tag)\n              current.appendChild(type.stateNode);\n            else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {\n              type.child.return = type;\n              type = type.child;\n              continue;\n            }\n            if (type === workInProgress) break a;\n            for (; null === type.sibling; ) {\n              if (null === type.return || type.return === workInProgress)\n                break a;\n              type = type.return;\n            }\n            type.sibling.return = type.return;\n            type = type.sibling;\n          }\n          workInProgress.stateNode = current;\n          a: switch (\n            (setInitialProperties(current, renderLanes, newProps), renderLanes)\n          ) {\n            case \"button\":\n            case \"input\":\n            case \"select\":\n            case \"textarea\":\n              current = !!newProps.autoFocus;\n              break a;\n            case \"img\":\n              current = !0;\n              break a;\n            default:\n              current = !1;\n          }\n          current && markUpdate(workInProgress);\n        }\n      }\n      bubbleProperties(workInProgress);\n      workInProgress.flags &= -16777217;\n      return null;\n    case 6:\n      if (current && null != workInProgress.stateNode)\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\n      else {\n        if (\"string\" !== typeof newProps && null === workInProgress.stateNode)\n          throw Error(formatProdErrorMessage(166));\n        current = rootInstanceStackCursor.current;\n        if (popHydrationState(workInProgress)) {\n          current = workInProgress.stateNode;\n          renderLanes = workInProgress.memoizedProps;\n          newProps = null;\n          type = hydrationParentFiber;\n          if (null !== type)\n            switch (type.tag) {\n              case 27:\n              case 5:\n                newProps = type.memoizedProps;\n            }\n          current[internalInstanceKey] = workInProgress;\n          current =\n            current.nodeValue === renderLanes ||\n            (null !== newProps && !0 === newProps.suppressHydrationWarning) ||\n            checkForUnmatchedText(current.nodeValue, renderLanes)\n              ? !0\n              : !1;\n          current || throwOnHydrationMismatch(workInProgress);\n        } else\n          (current =\n            getOwnerDocumentFromRootContainer(current).createTextNode(\n              newProps\n            )),\n            (current[internalInstanceKey] = workInProgress),\n            (workInProgress.stateNode = current);\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    case 13:\n      newProps = workInProgress.memoizedState;\n      if (\n        null === current ||\n        (null !== current.memoizedState &&\n          null !== current.memoizedState.dehydrated)\n      ) {\n        type = popHydrationState(workInProgress);\n        if (null !== newProps && null !== newProps.dehydrated) {\n          if (null === current) {\n            if (!type) throw Error(formatProdErrorMessage(318));\n            type = workInProgress.memoizedState;\n            type = null !== type ? type.dehydrated : null;\n            if (!type) throw Error(formatProdErrorMessage(317));\n            type[internalInstanceKey] = workInProgress;\n          } else\n            resetHydrationState(),\n              0 === (workInProgress.flags & 128) &&\n                (workInProgress.memoizedState = null),\n              (workInProgress.flags |= 4);\n          bubbleProperties(workInProgress);\n          type = !1;\n        } else\n          (type = upgradeHydrationErrorsToRecoverable()),\n            null !== current &&\n              null !== current.memoizedState &&\n              (current.memoizedState.hydrationErrors = type),\n            (type = !0);\n        if (!type) {\n          if (workInProgress.flags & 256)\n            return popSuspenseHandler(workInProgress), workInProgress;\n          popSuspenseHandler(workInProgress);\n          return null;\n        }\n      }\n      popSuspenseHandler(workInProgress);\n      if (0 !== (workInProgress.flags & 128))\n        return (workInProgress.lanes = renderLanes), workInProgress;\n      renderLanes = null !== newProps;\n      current = null !== current && null !== current.memoizedState;\n      if (renderLanes) {\n        newProps = workInProgress.child;\n        type = null;\n        null !== newProps.alternate &&\n          null !== newProps.alternate.memoizedState &&\n          null !== newProps.alternate.memoizedState.cachePool &&\n          (type = newProps.alternate.memoizedState.cachePool.pool);\n        var cache$127 = null;\n        null !== newProps.memoizedState &&\n          null !== newProps.memoizedState.cachePool &&\n          (cache$127 = newProps.memoizedState.cachePool.pool);\n        cache$127 !== type && (newProps.flags |= 2048);\n      }\n      renderLanes !== current &&\n        renderLanes &&\n        (workInProgress.child.flags |= 8192);\n      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);\n      bubbleProperties(workInProgress);\n      return null;\n    case 4:\n      return (\n        popHostContainer(),\n        null === current &&\n          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),\n        bubbleProperties(workInProgress),\n        null\n      );\n    case 10:\n      return (\n        popProvider(workInProgress.type), bubbleProperties(workInProgress), null\n      );\n    case 19:\n      pop(suspenseStackCursor);\n      type = workInProgress.memoizedState;\n      if (null === type) return bubbleProperties(workInProgress), null;\n      newProps = 0 !== (workInProgress.flags & 128);\n      cache$127 = type.rendering;\n      if (null === cache$127)\n        if (newProps) cutOffTailIfNeeded(type, !1);\n        else {\n          if (\n            0 !== workInProgressRootExitStatus ||\n            (null !== current && 0 !== (current.flags & 128))\n          )\n            for (current = workInProgress.child; null !== current; ) {\n              cache$127 = findFirstSuspended(current);\n              if (null !== cache$127) {\n                workInProgress.flags |= 128;\n                cutOffTailIfNeeded(type, !1);\n                current = cache$127.updateQueue;\n                workInProgress.updateQueue = current;\n                scheduleRetryEffect(workInProgress, current);\n                workInProgress.subtreeFlags = 0;\n                current = renderLanes;\n                for (renderLanes = workInProgress.child; null !== renderLanes; )\n                  resetWorkInProgress(renderLanes, current),\n                    (renderLanes = renderLanes.sibling);\n                push(\n                  suspenseStackCursor,\n                  (suspenseStackCursor.current & 1) | 2\n                );\n                return workInProgress.child;\n              }\n              current = current.sibling;\n            }\n          null !== type.tail &&\n            now() > workInProgressRootRenderTargetTime &&\n            ((workInProgress.flags |= 128),\n            (newProps = !0),\n            cutOffTailIfNeeded(type, !1),\n            (workInProgress.lanes = 4194304));\n        }\n      else {\n        if (!newProps)\n          if (((current = findFirstSuspended(cache$127)), null !== current)) {\n            if (\n              ((workInProgress.flags |= 128),\n              (newProps = !0),\n              (current = current.updateQueue),\n              (workInProgress.updateQueue = current),\n              scheduleRetryEffect(workInProgress, current),\n              cutOffTailIfNeeded(type, !0),\n              null === type.tail &&\n                \"hidden\" === type.tailMode &&\n                !cache$127.alternate &&\n                !isHydrating)\n            )\n              return bubbleProperties(workInProgress), null;\n          } else\n            2 * now() - type.renderingStartTime >\n              workInProgressRootRenderTargetTime &&\n              536870912 !== renderLanes &&\n              ((workInProgress.flags |= 128),\n              (newProps = !0),\n              cutOffTailIfNeeded(type, !1),\n              (workInProgress.lanes = 4194304));\n        type.isBackwards\n          ? ((cache$127.sibling = workInProgress.child),\n            (workInProgress.child = cache$127))\n          : ((current = type.last),\n            null !== current\n              ? (current.sibling = cache$127)\n              : (workInProgress.child = cache$127),\n            (type.last = cache$127));\n      }\n      if (null !== type.tail)\n        return (\n          (workInProgress = type.tail),\n          (type.rendering = workInProgress),\n          (type.tail = workInProgress.sibling),\n          (type.renderingStartTime = now()),\n          (workInProgress.sibling = null),\n          (current = suspenseStackCursor.current),\n          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),\n          workInProgress\n        );\n      bubbleProperties(workInProgress);\n      return null;\n    case 22:\n    case 23:\n      return (\n        popSuspenseHandler(workInProgress),\n        popHiddenContext(),\n        (newProps = null !== workInProgress.memoizedState),\n        null !== current\n          ? (null !== current.memoizedState) !== newProps &&\n            (workInProgress.flags |= 8192)\n          : newProps && (workInProgress.flags |= 8192),\n        newProps\n          ? 0 !== (renderLanes & 536870912) &&\n            0 === (workInProgress.flags & 128) &&\n            (bubbleProperties(workInProgress),\n            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))\n          : bubbleProperties(workInProgress),\n        (renderLanes = workInProgress.updateQueue),\n        null !== renderLanes &&\n          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),\n        (renderLanes = null),\n        null !== current &&\n          null !== current.memoizedState &&\n          null !== current.memoizedState.cachePool &&\n          (renderLanes = current.memoizedState.cachePool.pool),\n        (newProps = null),\n        null !== workInProgress.memoizedState &&\n          null !== workInProgress.memoizedState.cachePool &&\n          (newProps = workInProgress.memoizedState.cachePool.pool),\n        newProps !== renderLanes && (workInProgress.flags |= 2048),\n        null !== current && pop(resumedCache),\n        null\n      );\n    case 24:\n      return (\n        (renderLanes = null),\n        null !== current && (renderLanes = current.memoizedState.cache),\n        workInProgress.memoizedState.cache !== renderLanes &&\n          (workInProgress.flags |= 2048),\n        popProvider(CacheContext),\n        bubbleProperties(workInProgress),\n        null\n      );\n    case 25:\n      return null;\n    case 30:\n      return null;\n  }\n  throw Error(formatProdErrorMessage(156, workInProgress.tag));\n}\nfunction unwindWork(current, workInProgress) {\n  popTreeContext(workInProgress);\n  switch (workInProgress.tag) {\n    case 1:\n      return (\n        (current = workInProgress.flags),\n        current & 65536\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n          : null\n      );\n    case 3:\n      return (\n        popProvider(CacheContext),\n        popHostContainer(),\n        (current = workInProgress.flags),\n        0 !== (current & 65536) && 0 === (current & 128)\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n          : null\n      );\n    case 26:\n    case 27:\n    case 5:\n      return popHostContext(workInProgress), null;\n    case 13:\n      popSuspenseHandler(workInProgress);\n      current = workInProgress.memoizedState;\n      if (null !== current && null !== current.dehydrated) {\n        if (null === workInProgress.alternate)\n          throw Error(formatProdErrorMessage(340));\n        resetHydrationState();\n      }\n      current = workInProgress.flags;\n      return current & 65536\n        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n        : null;\n    case 19:\n      return pop(suspenseStackCursor), null;\n    case 4:\n      return popHostContainer(), null;\n    case 10:\n      return popProvider(workInProgress.type), null;\n    case 22:\n    case 23:\n      return (\n        popSuspenseHandler(workInProgress),\n        popHiddenContext(),\n        null !== current && pop(resumedCache),\n        (current = workInProgress.flags),\n        current & 65536\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n          : null\n      );\n    case 24:\n      return popProvider(CacheContext), null;\n    case 25:\n      return null;\n    default:\n      return null;\n  }\n}\nfunction unwindInterruptedWork(current, interruptedWork) {\n  popTreeContext(interruptedWork);\n  switch (interruptedWork.tag) {\n    case 3:\n      popProvider(CacheContext);\n      popHostContainer();\n      break;\n    case 26:\n    case 27:\n    case 5:\n      popHostContext(interruptedWork);\n      break;\n    case 4:\n      popHostContainer();\n      break;\n    case 13:\n      popSuspenseHandler(interruptedWork);\n      break;\n    case 19:\n      pop(suspenseStackCursor);\n      break;\n    case 10:\n      popProvider(interruptedWork.type);\n      break;\n    case 22:\n    case 23:\n      popSuspenseHandler(interruptedWork);\n      popHiddenContext();\n      null !== current && pop(resumedCache);\n      break;\n    case 24:\n      popProvider(CacheContext);\n  }\n}\nfunction commitHookEffectListMount(flags, finishedWork) {\n  try {\n    var updateQueue = finishedWork.updateQueue,\n      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n    if (null !== lastEffect) {\n      var firstEffect = lastEffect.next;\n      updateQueue = firstEffect;\n      do {\n        if ((updateQueue.tag & flags) === flags) {\n          lastEffect = void 0;\n          var create = updateQueue.create,\n            inst = updateQueue.inst;\n          lastEffect = create();\n          inst.destroy = lastEffect;\n        }\n        updateQueue = updateQueue.next;\n      } while (updateQueue !== firstEffect);\n    }\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction commitHookEffectListUnmount(\n  flags,\n  finishedWork,\n  nearestMountedAncestor$jscomp$0\n) {\n  try {\n    var updateQueue = finishedWork.updateQueue,\n      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n    if (null !== lastEffect) {\n      var firstEffect = lastEffect.next;\n      updateQueue = firstEffect;\n      do {\n        if ((updateQueue.tag & flags) === flags) {\n          var inst = updateQueue.inst,\n            destroy = inst.destroy;\n          if (void 0 !== destroy) {\n            inst.destroy = void 0;\n            lastEffect = finishedWork;\n            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0,\n              destroy_ = destroy;\n            try {\n              destroy_();\n            } catch (error) {\n              captureCommitPhaseError(\n                lastEffect,\n                nearestMountedAncestor,\n                error\n              );\n            }\n          }\n        }\n        updateQueue = updateQueue.next;\n      } while (updateQueue !== firstEffect);\n    }\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction commitClassCallbacks(finishedWork) {\n  var updateQueue = finishedWork.updateQueue;\n  if (null !== updateQueue) {\n    var instance = finishedWork.stateNode;\n    try {\n      commitCallbacks(updateQueue, instance);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n  }\n}\nfunction safelyCallComponentWillUnmount(\n  current,\n  nearestMountedAncestor,\n  instance\n) {\n  instance.props = resolveClassComponentProps(\n    current.type,\n    current.memoizedProps\n  );\n  instance.state = current.memoizedState;\n  try {\n    instance.componentWillUnmount();\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\nfunction safelyAttachRef(current, nearestMountedAncestor) {\n  try {\n    var ref = current.ref;\n    if (null !== ref) {\n      switch (current.tag) {\n        case 26:\n        case 27:\n        case 5:\n          var instanceToUse = current.stateNode;\n          break;\n        case 30:\n          instanceToUse = current.stateNode;\n          break;\n        default:\n          instanceToUse = current.stateNode;\n      }\n      \"function\" === typeof ref\n        ? (current.refCleanup = ref(instanceToUse))\n        : (ref.current = instanceToUse);\n    }\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\nfunction safelyDetachRef(current, nearestMountedAncestor) {\n  var ref = current.ref,\n    refCleanup = current.refCleanup;\n  if (null !== ref)\n    if (\"function\" === typeof refCleanup)\n      try {\n        refCleanup();\n      } catch (error) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      } finally {\n        (current.refCleanup = null),\n          (current = current.alternate),\n          null != current && (current.refCleanup = null);\n      }\n    else if (\"function\" === typeof ref)\n      try {\n        ref(null);\n      } catch (error$143) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error$143);\n      }\n    else ref.current = null;\n}\nfunction commitHostMount(finishedWork) {\n  var type = finishedWork.type,\n    props = finishedWork.memoizedProps,\n    instance = finishedWork.stateNode;\n  try {\n    a: switch (type) {\n      case \"button\":\n      case \"input\":\n      case \"select\":\n      case \"textarea\":\n        props.autoFocus && instance.focus();\n        break a;\n      case \"img\":\n        props.src\n          ? (instance.src = props.src)\n          : props.srcSet && (instance.srcset = props.srcSet);\n    }\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction commitHostUpdate(finishedWork, newProps, oldProps) {\n  try {\n    var domElement = finishedWork.stateNode;\n    updateProperties(domElement, finishedWork.type, oldProps, newProps);\n    domElement[internalPropsKey] = newProps;\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction isHostParent(fiber) {\n  return (\n    5 === fiber.tag ||\n    3 === fiber.tag ||\n    26 === fiber.tag ||\n    (27 === fiber.tag && isSingletonScope(fiber.type)) ||\n    4 === fiber.tag\n  );\n}\nfunction getHostSibling(fiber) {\n  a: for (;;) {\n    for (; null === fiber.sibling; ) {\n      if (null === fiber.return || isHostParent(fiber.return)) return null;\n      fiber = fiber.return;\n    }\n    fiber.sibling.return = fiber.return;\n    for (\n      fiber = fiber.sibling;\n      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;\n\n    ) {\n      if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;\n      if (fiber.flags & 2) continue a;\n      if (null === fiber.child || 4 === fiber.tag) continue a;\n      else (fiber.child.return = fiber), (fiber = fiber.child);\n    }\n    if (!(fiber.flags & 2)) return fiber.stateNode;\n  }\n}\nfunction insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n  var tag = node.tag;\n  if (5 === tag || 6 === tag)\n    (node = node.stateNode),\n      before\n        ? (9 === parent.nodeType\n            ? parent.body\n            : \"HTML\" === parent.nodeName\n              ? parent.ownerDocument.body\n              : parent\n          ).insertBefore(node, before)\n        : ((before =\n            9 === parent.nodeType\n              ? parent.body\n              : \"HTML\" === parent.nodeName\n                ? parent.ownerDocument.body\n                : parent),\n          before.appendChild(node),\n          (parent = parent._reactRootContainer),\n          (null !== parent && void 0 !== parent) ||\n            null !== before.onclick ||\n            (before.onclick = noop$1));\n  else if (\n    4 !== tag &&\n    (27 === tag &&\n      isSingletonScope(node.type) &&\n      ((parent = node.stateNode), (before = null)),\n    (node = node.child),\n    null !== node)\n  )\n    for (\n      insertOrAppendPlacementNodeIntoContainer(node, before, parent),\n        node = node.sibling;\n      null !== node;\n\n    )\n      insertOrAppendPlacementNodeIntoContainer(node, before, parent),\n        (node = node.sibling);\n}\nfunction insertOrAppendPlacementNode(node, before, parent) {\n  var tag = node.tag;\n  if (5 === tag || 6 === tag)\n    (node = node.stateNode),\n      before ? parent.insertBefore(node, before) : parent.appendChild(node);\n  else if (\n    4 !== tag &&\n    (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode),\n    (node = node.child),\n    null !== node)\n  )\n    for (\n      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;\n      null !== node;\n\n    )\n      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);\n}\nfunction commitHostSingletonAcquisition(finishedWork) {\n  var singleton = finishedWork.stateNode,\n    props = finishedWork.memoizedProps;\n  try {\n    for (\n      var type = finishedWork.type, attributes = singleton.attributes;\n      attributes.length;\n\n    )\n      singleton.removeAttributeNode(attributes[0]);\n    setInitialProperties(singleton, type, props);\n    singleton[internalInstanceKey] = finishedWork;\n    singleton[internalPropsKey] = props;\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nvar offscreenSubtreeIsHidden = !1,\n  offscreenSubtreeWasHidden = !1,\n  needsFormReset = !1,\n  PossiblyWeakSet = \"function\" === typeof WeakSet ? WeakSet : Set,\n  nextEffect = null;\nfunction commitBeforeMutationEffects(root, firstChild) {\n  root = root.containerInfo;\n  eventsEnabled = _enabled;\n  root = getActiveElementDeep(root);\n  if (hasSelectionCapabilities(root)) {\n    if (\"selectionStart\" in root)\n      var JSCompiler_temp = {\n        start: root.selectionStart,\n        end: root.selectionEnd\n      };\n    else\n      a: {\n        JSCompiler_temp =\n          ((JSCompiler_temp = root.ownerDocument) &&\n            JSCompiler_temp.defaultView) ||\n          window;\n        var selection =\n          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();\n        if (selection && 0 !== selection.rangeCount) {\n          JSCompiler_temp = selection.anchorNode;\n          var anchorOffset = selection.anchorOffset,\n            focusNode = selection.focusNode;\n          selection = selection.focusOffset;\n          try {\n            JSCompiler_temp.nodeType, focusNode.nodeType;\n          } catch (e$20) {\n            JSCompiler_temp = null;\n            break a;\n          }\n          var length = 0,\n            start = -1,\n            end = -1,\n            indexWithinAnchor = 0,\n            indexWithinFocus = 0,\n            node = root,\n            parentNode = null;\n          b: for (;;) {\n            for (var next; ; ) {\n              node !== JSCompiler_temp ||\n                (0 !== anchorOffset && 3 !== node.nodeType) ||\n                (start = length + anchorOffset);\n              node !== focusNode ||\n                (0 !== selection && 3 !== node.nodeType) ||\n                (end = length + selection);\n              3 === node.nodeType && (length += node.nodeValue.length);\n              if (null === (next = node.firstChild)) break;\n              parentNode = node;\n              node = next;\n            }\n            for (;;) {\n              if (node === root) break b;\n              parentNode === JSCompiler_temp &&\n                ++indexWithinAnchor === anchorOffset &&\n                (start = length);\n              parentNode === focusNode &&\n                ++indexWithinFocus === selection &&\n                (end = length);\n              if (null !== (next = node.nextSibling)) break;\n              node = parentNode;\n              parentNode = node.parentNode;\n            }\n            node = next;\n          }\n          JSCompiler_temp =\n            -1 === start || -1 === end ? null : { start: start, end: end };\n        } else JSCompiler_temp = null;\n      }\n    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };\n  } else JSCompiler_temp = null;\n  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };\n  _enabled = !1;\n  for (nextEffect = firstChild; null !== nextEffect; )\n    if (\n      ((firstChild = nextEffect),\n      (root = firstChild.child),\n      0 !== (firstChild.subtreeFlags & 1024) && null !== root)\n    )\n      (root.return = firstChild), (nextEffect = root);\n    else\n      for (; null !== nextEffect; ) {\n        firstChild = nextEffect;\n        focusNode = firstChild.alternate;\n        root = firstChild.flags;\n        switch (firstChild.tag) {\n          case 0:\n            break;\n          case 11:\n          case 15:\n            break;\n          case 1:\n            if (0 !== (root & 1024) && null !== focusNode) {\n              root = void 0;\n              JSCompiler_temp = firstChild;\n              anchorOffset = focusNode.memoizedProps;\n              focusNode = focusNode.memoizedState;\n              selection = JSCompiler_temp.stateNode;\n              try {\n                var resolvedPrevProps = resolveClassComponentProps(\n                  JSCompiler_temp.type,\n                  anchorOffset,\n                  JSCompiler_temp.elementType === JSCompiler_temp.type\n                );\n                root = selection.getSnapshotBeforeUpdate(\n                  resolvedPrevProps,\n                  focusNode\n                );\n                selection.__reactInternalSnapshotBeforeUpdate = root;\n              } catch (error) {\n                captureCommitPhaseError(\n                  JSCompiler_temp,\n                  JSCompiler_temp.return,\n                  error\n                );\n              }\n            }\n            break;\n          case 3:\n            if (0 !== (root & 1024))\n              if (\n                ((root = firstChild.stateNode.containerInfo),\n                (JSCompiler_temp = root.nodeType),\n                9 === JSCompiler_temp)\n              )\n                clearContainerSparingly(root);\n              else if (1 === JSCompiler_temp)\n                switch (root.nodeName) {\n                  case \"HEAD\":\n                  case \"HTML\":\n                  case \"BODY\":\n                    clearContainerSparingly(root);\n                    break;\n                  default:\n                    root.textContent = \"\";\n                }\n            break;\n          case 5:\n          case 26:\n          case 27:\n          case 6:\n          case 4:\n          case 17:\n            break;\n          default:\n            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));\n        }\n        root = firstChild.sibling;\n        if (null !== root) {\n          root.return = firstChild.return;\n          nextEffect = root;\n          break;\n        }\n        nextEffect = firstChild.return;\n      }\n}\nfunction commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {\n  var flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 15:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      flags & 4 && commitHookEffectListMount(5, finishedWork);\n      break;\n    case 1:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      if (flags & 4)\n        if (((finishedRoot = finishedWork.stateNode), null === current))\n          try {\n            finishedRoot.componentDidMount();\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        else {\n          var prevProps = resolveClassComponentProps(\n            finishedWork.type,\n            current.memoizedProps\n          );\n          current = current.memoizedState;\n          try {\n            finishedRoot.componentDidUpdate(\n              prevProps,\n              current,\n              finishedRoot.__reactInternalSnapshotBeforeUpdate\n            );\n          } catch (error$142) {\n            captureCommitPhaseError(\n              finishedWork,\n              finishedWork.return,\n              error$142\n            );\n          }\n        }\n      flags & 64 && commitClassCallbacks(finishedWork);\n      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n      break;\n    case 3:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      if (\n        flags & 64 &&\n        ((finishedRoot = finishedWork.updateQueue), null !== finishedRoot)\n      ) {\n        current = null;\n        if (null !== finishedWork.child)\n          switch (finishedWork.child.tag) {\n            case 27:\n            case 5:\n              current = finishedWork.child.stateNode;\n              break;\n            case 1:\n              current = finishedWork.child.stateNode;\n          }\n        try {\n          commitCallbacks(finishedRoot, current);\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n      break;\n    case 27:\n      null === current &&\n        flags & 4 &&\n        commitHostSingletonAcquisition(finishedWork);\n    case 26:\n    case 5:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      null === current && flags & 4 && commitHostMount(finishedWork);\n      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n      break;\n    case 12:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      break;\n    case 13:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n      flags & 64 &&\n        ((finishedRoot = finishedWork.memoizedState),\n        null !== finishedRoot &&\n          ((finishedRoot = finishedRoot.dehydrated),\n          null !== finishedRoot &&\n            ((finishedWork = retryDehydratedSuspenseBoundary.bind(\n              null,\n              finishedWork\n            )),\n            registerSuspenseInstanceRetry(finishedRoot, finishedWork))));\n      break;\n    case 22:\n      flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;\n      if (!flags) {\n        current =\n          (null !== current && null !== current.memoizedState) ||\n          offscreenSubtreeWasHidden;\n        prevProps = offscreenSubtreeIsHidden;\n        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n        offscreenSubtreeIsHidden = flags;\n        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden\n          ? recursivelyTraverseReappearLayoutEffects(\n              finishedRoot,\n              finishedWork,\n              0 !== (finishedWork.subtreeFlags & 8772)\n            )\n          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n        offscreenSubtreeIsHidden = prevProps;\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n      }\n      break;\n    case 30:\n      break;\n    default:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n  }\n}\nfunction detachFiberAfterEffects(fiber) {\n  var alternate = fiber.alternate;\n  null !== alternate &&\n    ((fiber.alternate = null), detachFiberAfterEffects(alternate));\n  fiber.child = null;\n  fiber.deletions = null;\n  fiber.sibling = null;\n  5 === fiber.tag &&\n    ((alternate = fiber.stateNode),\n    null !== alternate && detachDeletedInstance(alternate));\n  fiber.stateNode = null;\n  fiber.return = null;\n  fiber.dependencies = null;\n  fiber.memoizedProps = null;\n  fiber.memoizedState = null;\n  fiber.pendingProps = null;\n  fiber.stateNode = null;\n  fiber.updateQueue = null;\n}\nvar hostParent = null,\n  hostParentIsContainer = !1;\nfunction recursivelyTraverseDeletionEffects(\n  finishedRoot,\n  nearestMountedAncestor,\n  parent\n) {\n  for (parent = parent.child; null !== parent; )\n    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),\n      (parent = parent.sibling);\n}\nfunction commitDeletionEffectsOnFiber(\n  finishedRoot,\n  nearestMountedAncestor,\n  deletedFiber\n) {\n  if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberUnmount)\n    try {\n      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);\n    } catch (err) {}\n  switch (deletedFiber.tag) {\n    case 26:\n      offscreenSubtreeWasHidden ||\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      deletedFiber.memoizedState\n        ? deletedFiber.memoizedState.count--\n        : deletedFiber.stateNode &&\n          ((deletedFiber = deletedFiber.stateNode),\n          deletedFiber.parentNode.removeChild(deletedFiber));\n      break;\n    case 27:\n      offscreenSubtreeWasHidden ||\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n      var prevHostParent = hostParent,\n        prevHostParentIsContainer = hostParentIsContainer;\n      isSingletonScope(deletedFiber.type) &&\n        ((hostParent = deletedFiber.stateNode), (hostParentIsContainer = !1));\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      releaseSingletonInstance(deletedFiber.stateNode);\n      hostParent = prevHostParent;\n      hostParentIsContainer = prevHostParentIsContainer;\n      break;\n    case 5:\n      offscreenSubtreeWasHidden ||\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n    case 6:\n      prevHostParent = hostParent;\n      prevHostParentIsContainer = hostParentIsContainer;\n      hostParent = null;\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      hostParent = prevHostParent;\n      hostParentIsContainer = prevHostParentIsContainer;\n      if (null !== hostParent)\n        if (hostParentIsContainer)\n          try {\n            (9 === hostParent.nodeType\n              ? hostParent.body\n              : \"HTML\" === hostParent.nodeName\n                ? hostParent.ownerDocument.body\n                : hostParent\n            ).removeChild(deletedFiber.stateNode);\n          } catch (error) {\n            captureCommitPhaseError(\n              deletedFiber,\n              nearestMountedAncestor,\n              error\n            );\n          }\n        else\n          try {\n            hostParent.removeChild(deletedFiber.stateNode);\n          } catch (error) {\n            captureCommitPhaseError(\n              deletedFiber,\n              nearestMountedAncestor,\n              error\n            );\n          }\n      break;\n    case 18:\n      null !== hostParent &&\n        (hostParentIsContainer\n          ? ((finishedRoot = hostParent),\n            clearSuspenseBoundary(\n              9 === finishedRoot.nodeType\n                ? finishedRoot.body\n                : \"HTML\" === finishedRoot.nodeName\n                  ? finishedRoot.ownerDocument.body\n                  : finishedRoot,\n              deletedFiber.stateNode\n            ),\n            retryIfBlockedOn(finishedRoot))\n          : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));\n      break;\n    case 4:\n      prevHostParent = hostParent;\n      prevHostParentIsContainer = hostParentIsContainer;\n      hostParent = deletedFiber.stateNode.containerInfo;\n      hostParentIsContainer = !0;\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      hostParent = prevHostParent;\n      hostParentIsContainer = prevHostParentIsContainer;\n      break;\n    case 0:\n    case 11:\n    case 14:\n    case 15:\n      offscreenSubtreeWasHidden ||\n        commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);\n      offscreenSubtreeWasHidden ||\n        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      break;\n    case 1:\n      offscreenSubtreeWasHidden ||\n        (safelyDetachRef(deletedFiber, nearestMountedAncestor),\n        (prevHostParent = deletedFiber.stateNode),\n        \"function\" === typeof prevHostParent.componentWillUnmount &&\n          safelyCallComponentWillUnmount(\n            deletedFiber,\n            nearestMountedAncestor,\n            prevHostParent\n          ));\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      break;\n    case 21:\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      break;\n    case 22:\n      offscreenSubtreeWasHidden =\n        (prevHostParent = offscreenSubtreeWasHidden) ||\n        null !== deletedFiber.memoizedState;\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      offscreenSubtreeWasHidden = prevHostParent;\n      break;\n    default:\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n  }\n}\nfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n  if (\n    null === finishedWork.memoizedState &&\n    ((finishedRoot = finishedWork.alternate),\n    null !== finishedRoot &&\n      ((finishedRoot = finishedRoot.memoizedState),\n      null !== finishedRoot &&\n        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))\n  )\n    try {\n      retryIfBlockedOn(finishedRoot);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n}\nfunction getRetryCache(finishedWork) {\n  switch (finishedWork.tag) {\n    case 13:\n    case 19:\n      var retryCache = finishedWork.stateNode;\n      null === retryCache &&\n        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());\n      return retryCache;\n    case 22:\n      return (\n        (finishedWork = finishedWork.stateNode),\n        (retryCache = finishedWork._retryCache),\n        null === retryCache &&\n          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),\n        retryCache\n      );\n    default:\n      throw Error(formatProdErrorMessage(435, finishedWork.tag));\n  }\n}\nfunction attachSuspenseRetryListeners(finishedWork, wakeables) {\n  var retryCache = getRetryCache(finishedWork);\n  wakeables.forEach(function (wakeable) {\n    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n    retryCache.has(wakeable) ||\n      (retryCache.add(wakeable), wakeable.then(retry, retry));\n  });\n}\nfunction recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {\n  var deletions = parentFiber.deletions;\n  if (null !== deletions)\n    for (var i = 0; i < deletions.length; i++) {\n      var childToDelete = deletions[i],\n        root = root$jscomp$0,\n        returnFiber = parentFiber,\n        parent = returnFiber;\n      a: for (; null !== parent; ) {\n        switch (parent.tag) {\n          case 27:\n            if (isSingletonScope(parent.type)) {\n              hostParent = parent.stateNode;\n              hostParentIsContainer = !1;\n              break a;\n            }\n            break;\n          case 5:\n            hostParent = parent.stateNode;\n            hostParentIsContainer = !1;\n            break a;\n          case 3:\n          case 4:\n            hostParent = parent.stateNode.containerInfo;\n            hostParentIsContainer = !0;\n            break a;\n        }\n        parent = parent.return;\n      }\n      if (null === hostParent) throw Error(formatProdErrorMessage(160));\n      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);\n      hostParent = null;\n      hostParentIsContainer = !1;\n      root = childToDelete.alternate;\n      null !== root && (root.return = null);\n      childToDelete.return = null;\n    }\n  if (parentFiber.subtreeFlags & 13878)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),\n        (parentFiber = parentFiber.sibling);\n}\nvar currentHoistableRoot = null;\nfunction commitMutationEffectsOnFiber(finishedWork, root) {\n  var current = finishedWork.alternate,\n    flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 14:\n    case 15:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 4 &&\n        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),\n        commitHookEffectListMount(3, finishedWork),\n        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));\n      break;\n    case 1:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      flags & 64 &&\n        offscreenSubtreeIsHidden &&\n        ((finishedWork = finishedWork.updateQueue),\n        null !== finishedWork &&\n          ((flags = finishedWork.callbacks),\n          null !== flags &&\n            ((current = finishedWork.shared.hiddenCallbacks),\n            (finishedWork.shared.hiddenCallbacks =\n              null === current ? flags : current.concat(flags)))));\n      break;\n    case 26:\n      var hoistableRoot = currentHoistableRoot;\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      if (flags & 4) {\n        var currentResource = null !== current ? current.memoizedState : null;\n        flags = finishedWork.memoizedState;\n        if (null === current)\n          if (null === flags)\n            if (null === finishedWork.stateNode) {\n              a: {\n                flags = finishedWork.type;\n                current = finishedWork.memoizedProps;\n                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;\n                b: switch (flags) {\n                  case \"title\":\n                    currentResource =\n                      hoistableRoot.getElementsByTagName(\"title\")[0];\n                    if (\n                      !currentResource ||\n                      currentResource[internalHoistableMarker] ||\n                      currentResource[internalInstanceKey] ||\n                      \"http://www.w3.org/2000/svg\" ===\n                        currentResource.namespaceURI ||\n                      currentResource.hasAttribute(\"itemprop\")\n                    )\n                      (currentResource = hoistableRoot.createElement(flags)),\n                        hoistableRoot.head.insertBefore(\n                          currentResource,\n                          hoistableRoot.querySelector(\"head > title\")\n                        );\n                    setInitialProperties(currentResource, flags, current);\n                    currentResource[internalInstanceKey] = finishedWork;\n                    markNodeAsHoistable(currentResource);\n                    flags = currentResource;\n                    break a;\n                  case \"link\":\n                    var maybeNodes = getHydratableHoistableCache(\n                      \"link\",\n                      \"href\",\n                      hoistableRoot\n                    ).get(flags + (current.href || \"\"));\n                    if (maybeNodes)\n                      for (var i = 0; i < maybeNodes.length; i++)\n                        if (\n                          ((currentResource = maybeNodes[i]),\n                          currentResource.getAttribute(\"href\") ===\n                            (null == current.href || \"\" === current.href\n                              ? null\n                              : current.href) &&\n                            currentResource.getAttribute(\"rel\") ===\n                              (null == current.rel ? null : current.rel) &&\n                            currentResource.getAttribute(\"title\") ===\n                              (null == current.title ? null : current.title) &&\n                            currentResource.getAttribute(\"crossorigin\") ===\n                              (null == current.crossOrigin\n                                ? null\n                                : current.crossOrigin))\n                        ) {\n                          maybeNodes.splice(i, 1);\n                          break b;\n                        }\n                    currentResource = hoistableRoot.createElement(flags);\n                    setInitialProperties(currentResource, flags, current);\n                    hoistableRoot.head.appendChild(currentResource);\n                    break;\n                  case \"meta\":\n                    if (\n                      (maybeNodes = getHydratableHoistableCache(\n                        \"meta\",\n                        \"content\",\n                        hoistableRoot\n                      ).get(flags + (current.content || \"\")))\n                    )\n                      for (i = 0; i < maybeNodes.length; i++)\n                        if (\n                          ((currentResource = maybeNodes[i]),\n                          currentResource.getAttribute(\"content\") ===\n                            (null == current.content\n                              ? null\n                              : \"\" + current.content) &&\n                            currentResource.getAttribute(\"name\") ===\n                              (null == current.name ? null : current.name) &&\n                            currentResource.getAttribute(\"property\") ===\n                              (null == current.property\n                                ? null\n                                : current.property) &&\n                            currentResource.getAttribute(\"http-equiv\") ===\n                              (null == current.httpEquiv\n                                ? null\n                                : current.httpEquiv) &&\n                            currentResource.getAttribute(\"charset\") ===\n                              (null == current.charSet\n                                ? null\n                                : current.charSet))\n                        ) {\n                          maybeNodes.splice(i, 1);\n                          break b;\n                        }\n                    currentResource = hoistableRoot.createElement(flags);\n                    setInitialProperties(currentResource, flags, current);\n                    hoistableRoot.head.appendChild(currentResource);\n                    break;\n                  default:\n                    throw Error(formatProdErrorMessage(468, flags));\n                }\n                currentResource[internalInstanceKey] = finishedWork;\n                markNodeAsHoistable(currentResource);\n                flags = currentResource;\n              }\n              finishedWork.stateNode = flags;\n            } else\n              mountHoistable(\n                hoistableRoot,\n                finishedWork.type,\n                finishedWork.stateNode\n              );\n          else\n            finishedWork.stateNode = acquireResource(\n              hoistableRoot,\n              flags,\n              finishedWork.memoizedProps\n            );\n        else\n          currentResource !== flags\n            ? (null === currentResource\n                ? null !== current.stateNode &&\n                  ((current = current.stateNode),\n                  current.parentNode.removeChild(current))\n                : currentResource.count--,\n              null === flags\n                ? mountHoistable(\n                    hoistableRoot,\n                    finishedWork.type,\n                    finishedWork.stateNode\n                  )\n                : acquireResource(\n                    hoistableRoot,\n                    flags,\n                    finishedWork.memoizedProps\n                  ))\n            : null === flags &&\n              null !== finishedWork.stateNode &&\n              commitHostUpdate(\n                finishedWork,\n                finishedWork.memoizedProps,\n                current.memoizedProps\n              );\n      }\n      break;\n    case 27:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      null !== current &&\n        flags & 4 &&\n        commitHostUpdate(\n          finishedWork,\n          finishedWork.memoizedProps,\n          current.memoizedProps\n        );\n      break;\n    case 5:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      if (finishedWork.flags & 32) {\n        hoistableRoot = finishedWork.stateNode;\n        try {\n          setTextContent(hoistableRoot, \"\");\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n      flags & 4 &&\n        null != finishedWork.stateNode &&\n        ((hoistableRoot = finishedWork.memoizedProps),\n        commitHostUpdate(\n          finishedWork,\n          hoistableRoot,\n          null !== current ? current.memoizedProps : hoistableRoot\n        ));\n      flags & 1024 && (needsFormReset = !0);\n      break;\n    case 6:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      if (flags & 4) {\n        if (null === finishedWork.stateNode)\n          throw Error(formatProdErrorMessage(162));\n        flags = finishedWork.memoizedProps;\n        current = finishedWork.stateNode;\n        try {\n          current.nodeValue = flags;\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n      break;\n    case 3:\n      tagCaches = null;\n      hoistableRoot = currentHoistableRoot;\n      currentHoistableRoot = getHoistableRoot(root.containerInfo);\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      currentHoistableRoot = hoistableRoot;\n      commitReconciliationEffects(finishedWork);\n      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)\n        try {\n          retryIfBlockedOn(root.containerInfo);\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      needsFormReset &&\n        ((needsFormReset = !1), recursivelyResetForms(finishedWork));\n      break;\n    case 4:\n      flags = currentHoistableRoot;\n      currentHoistableRoot = getHoistableRoot(\n        finishedWork.stateNode.containerInfo\n      );\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      currentHoistableRoot = flags;\n      break;\n    case 12:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      break;\n    case 13:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      finishedWork.child.flags & 8192 &&\n        (null !== finishedWork.memoizedState) !==\n          (null !== current && null !== current.memoizedState) &&\n        (globalMostRecentFallbackTime = now());\n      flags & 4 &&\n        ((flags = finishedWork.updateQueue),\n        null !== flags &&\n          ((finishedWork.updateQueue = null),\n          attachSuspenseRetryListeners(finishedWork, flags)));\n      break;\n    case 22:\n      hoistableRoot = null !== finishedWork.memoizedState;\n      var wasHidden = null !== current && null !== current.memoizedState,\n        prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,\n        prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;\n      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n      commitReconciliationEffects(finishedWork);\n      if (flags & 8192)\n        a: for (\n          root = finishedWork.stateNode,\n            root._visibility = hoistableRoot\n              ? root._visibility & -2\n              : root._visibility | 1,\n            hoistableRoot &&\n              (null === current ||\n                wasHidden ||\n                offscreenSubtreeIsHidden ||\n                offscreenSubtreeWasHidden ||\n                recursivelyTraverseDisappearLayoutEffects(finishedWork)),\n            current = null,\n            root = finishedWork;\n          ;\n\n        ) {\n          if (5 === root.tag || 26 === root.tag) {\n            if (null === current) {\n              wasHidden = current = root;\n              try {\n                if (((currentResource = wasHidden.stateNode), hoistableRoot))\n                  (maybeNodes = currentResource.style),\n                    \"function\" === typeof maybeNodes.setProperty\n                      ? maybeNodes.setProperty(\"display\", \"none\", \"important\")\n                      : (maybeNodes.display = \"none\");\n                else {\n                  i = wasHidden.stateNode;\n                  var styleProp = wasHidden.memoizedProps.style,\n                    display =\n                      void 0 !== styleProp &&\n                      null !== styleProp &&\n                      styleProp.hasOwnProperty(\"display\")\n                        ? styleProp.display\n                        : null;\n                  i.style.display =\n                    null == display || \"boolean\" === typeof display\n                      ? \"\"\n                      : (\"\" + display).trim();\n                }\n              } catch (error) {\n                captureCommitPhaseError(wasHidden, wasHidden.return, error);\n              }\n            }\n          } else if (6 === root.tag) {\n            if (null === current) {\n              wasHidden = root;\n              try {\n                wasHidden.stateNode.nodeValue = hoistableRoot\n                  ? \"\"\n                  : wasHidden.memoizedProps;\n              } catch (error) {\n                captureCommitPhaseError(wasHidden, wasHidden.return, error);\n              }\n            }\n          } else if (\n            ((22 !== root.tag && 23 !== root.tag) ||\n              null === root.memoizedState ||\n              root === finishedWork) &&\n            null !== root.child\n          ) {\n            root.child.return = root;\n            root = root.child;\n            continue;\n          }\n          if (root === finishedWork) break a;\n          for (; null === root.sibling; ) {\n            if (null === root.return || root.return === finishedWork) break a;\n            current === root && (current = null);\n            root = root.return;\n          }\n          current === root && (current = null);\n          root.sibling.return = root.return;\n          root = root.sibling;\n        }\n      flags & 4 &&\n        ((flags = finishedWork.updateQueue),\n        null !== flags &&\n          ((current = flags.retryQueue),\n          null !== current &&\n            ((flags.retryQueue = null),\n            attachSuspenseRetryListeners(finishedWork, current))));\n      break;\n    case 19:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 4 &&\n        ((flags = finishedWork.updateQueue),\n        null !== flags &&\n          ((finishedWork.updateQueue = null),\n          attachSuspenseRetryListeners(finishedWork, flags)));\n      break;\n    case 30:\n      break;\n    case 21:\n      break;\n    default:\n      recursivelyTraverseMutationEffects(root, finishedWork),\n        commitReconciliationEffects(finishedWork);\n  }\n}\nfunction commitReconciliationEffects(finishedWork) {\n  var flags = finishedWork.flags;\n  if (flags & 2) {\n    try {\n      for (\n        var hostParentFiber, parentFiber = finishedWork.return;\n        null !== parentFiber;\n\n      ) {\n        if (isHostParent(parentFiber)) {\n          hostParentFiber = parentFiber;\n          break;\n        }\n        parentFiber = parentFiber.return;\n      }\n      if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));\n      switch (hostParentFiber.tag) {\n        case 27:\n          var parent = hostParentFiber.stateNode,\n            before = getHostSibling(finishedWork);\n          insertOrAppendPlacementNode(finishedWork, before, parent);\n          break;\n        case 5:\n          var parent$144 = hostParentFiber.stateNode;\n          hostParentFiber.flags & 32 &&\n            (setTextContent(parent$144, \"\"), (hostParentFiber.flags &= -33));\n          var before$145 = getHostSibling(finishedWork);\n          insertOrAppendPlacementNode(finishedWork, before$145, parent$144);\n          break;\n        case 3:\n        case 4:\n          var parent$146 = hostParentFiber.stateNode.containerInfo,\n            before$147 = getHostSibling(finishedWork);\n          insertOrAppendPlacementNodeIntoContainer(\n            finishedWork,\n            before$147,\n            parent$146\n          );\n          break;\n        default:\n          throw Error(formatProdErrorMessage(161));\n      }\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n    finishedWork.flags &= -3;\n  }\n  flags & 4096 && (finishedWork.flags &= -4097);\n}\nfunction recursivelyResetForms(parentFiber) {\n  if (parentFiber.subtreeFlags & 1024)\n    for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n      var fiber = parentFiber;\n      recursivelyResetForms(fiber);\n      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();\n      parentFiber = parentFiber.sibling;\n    }\n}\nfunction recursivelyTraverseLayoutEffects(root, parentFiber) {\n  if (parentFiber.subtreeFlags & 8772)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),\n        (parentFiber = parentFiber.sibling);\n}\nfunction recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    var finishedWork = parentFiber;\n    switch (finishedWork.tag) {\n      case 0:\n      case 11:\n      case 14:\n      case 15:\n        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      case 1:\n        safelyDetachRef(finishedWork, finishedWork.return);\n        var instance = finishedWork.stateNode;\n        \"function\" === typeof instance.componentWillUnmount &&\n          safelyCallComponentWillUnmount(\n            finishedWork,\n            finishedWork.return,\n            instance\n          );\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      case 27:\n        releaseSingletonInstance(finishedWork.stateNode);\n      case 26:\n      case 5:\n        safelyDetachRef(finishedWork, finishedWork.return);\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      case 22:\n        null === finishedWork.memoizedState &&\n          recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      case 30:\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      default:\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction recursivelyTraverseReappearLayoutEffects(\n  finishedRoot$jscomp$0,\n  parentFiber,\n  includeWorkInProgressEffects\n) {\n  includeWorkInProgressEffects =\n    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    var current = parentFiber.alternate,\n      finishedRoot = finishedRoot$jscomp$0,\n      finishedWork = parentFiber,\n      flags = finishedWork.flags;\n    switch (finishedWork.tag) {\n      case 0:\n      case 11:\n      case 15:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        commitHookEffectListMount(4, finishedWork);\n        break;\n      case 1:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        current = finishedWork;\n        finishedRoot = current.stateNode;\n        if (\"function\" === typeof finishedRoot.componentDidMount)\n          try {\n            finishedRoot.componentDidMount();\n          } catch (error) {\n            captureCommitPhaseError(current, current.return, error);\n          }\n        current = finishedWork;\n        finishedRoot = current.updateQueue;\n        if (null !== finishedRoot) {\n          var instance = current.stateNode;\n          try {\n            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;\n            if (null !== hiddenCallbacks)\n              for (\n                finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;\n                finishedRoot < hiddenCallbacks.length;\n                finishedRoot++\n              )\n                callCallback(hiddenCallbacks[finishedRoot], instance);\n          } catch (error) {\n            captureCommitPhaseError(current, current.return, error);\n          }\n        }\n        includeWorkInProgressEffects &&\n          flags & 64 &&\n          commitClassCallbacks(finishedWork);\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      case 27:\n        commitHostSingletonAcquisition(finishedWork);\n      case 26:\n      case 5:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        includeWorkInProgressEffects &&\n          null === current &&\n          flags & 4 &&\n          commitHostMount(finishedWork);\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      case 12:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        break;\n      case 13:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        includeWorkInProgressEffects &&\n          flags & 4 &&\n          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n        break;\n      case 22:\n        null === finishedWork.memoizedState &&\n          recursivelyTraverseReappearLayoutEffects(\n            finishedRoot,\n            finishedWork,\n            includeWorkInProgressEffects\n          );\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      case 30:\n        break;\n      default:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction commitOffscreenPassiveMountEffects(current, finishedWork) {\n  var previousCache = null;\n  null !== current &&\n    null !== current.memoizedState &&\n    null !== current.memoizedState.cachePool &&\n    (previousCache = current.memoizedState.cachePool.pool);\n  current = null;\n  null !== finishedWork.memoizedState &&\n    null !== finishedWork.memoizedState.cachePool &&\n    (current = finishedWork.memoizedState.cachePool.pool);\n  current !== previousCache &&\n    (null != current && current.refCount++,\n    null != previousCache && releaseCache(previousCache));\n}\nfunction commitCachePassiveMountEffect(current, finishedWork) {\n  current = null;\n  null !== finishedWork.alternate &&\n    (current = finishedWork.alternate.memoizedState.cache);\n  finishedWork = finishedWork.memoizedState.cache;\n  finishedWork !== current &&\n    (finishedWork.refCount++, null != current && releaseCache(current));\n}\nfunction recursivelyTraversePassiveMountEffects(\n  root,\n  parentFiber,\n  committedLanes,\n  committedTransitions\n) {\n  if (parentFiber.subtreeFlags & 10256)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitPassiveMountOnFiber(\n        root,\n        parentFiber,\n        committedLanes,\n        committedTransitions\n      ),\n        (parentFiber = parentFiber.sibling);\n}\nfunction commitPassiveMountOnFiber(\n  finishedRoot,\n  finishedWork,\n  committedLanes,\n  committedTransitions\n) {\n  var flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 15:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      flags & 2048 && commitHookEffectListMount(9, finishedWork);\n      break;\n    case 1:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      break;\n    case 3:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      flags & 2048 &&\n        ((finishedRoot = null),\n        null !== finishedWork.alternate &&\n          (finishedRoot = finishedWork.alternate.memoizedState.cache),\n        (finishedWork = finishedWork.memoizedState.cache),\n        finishedWork !== finishedRoot &&\n          (finishedWork.refCount++,\n          null != finishedRoot && releaseCache(finishedRoot)));\n      break;\n    case 12:\n      if (flags & 2048) {\n        recursivelyTraversePassiveMountEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions\n        );\n        finishedRoot = finishedWork.stateNode;\n        try {\n          var _finishedWork$memoize2 = finishedWork.memoizedProps,\n            id = _finishedWork$memoize2.id,\n            onPostCommit = _finishedWork$memoize2.onPostCommit;\n          \"function\" === typeof onPostCommit &&\n            onPostCommit(\n              id,\n              null === finishedWork.alternate ? \"mount\" : \"update\",\n              finishedRoot.passiveEffectDuration,\n              -0\n            );\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      } else\n        recursivelyTraversePassiveMountEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions\n        );\n      break;\n    case 13:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      break;\n    case 23:\n      break;\n    case 22:\n      _finishedWork$memoize2 = finishedWork.stateNode;\n      id = finishedWork.alternate;\n      null !== finishedWork.memoizedState\n        ? _finishedWork$memoize2._visibility & 2\n          ? recursivelyTraversePassiveMountEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions\n            )\n          : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)\n        : _finishedWork$memoize2._visibility & 2\n          ? recursivelyTraversePassiveMountEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions\n            )\n          : ((_finishedWork$memoize2._visibility |= 2),\n            recursivelyTraverseReconnectPassiveEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions,\n              0 !== (finishedWork.subtreeFlags & 10256)\n            ));\n      flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);\n      break;\n    case 24:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      flags & 2048 &&\n        commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n      break;\n    default:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n  }\n}\nfunction recursivelyTraverseReconnectPassiveEffects(\n  finishedRoot$jscomp$0,\n  parentFiber,\n  committedLanes$jscomp$0,\n  committedTransitions$jscomp$0,\n  includeWorkInProgressEffects\n) {\n  includeWorkInProgressEffects =\n    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    var finishedRoot = finishedRoot$jscomp$0,\n      finishedWork = parentFiber,\n      committedLanes = committedLanes$jscomp$0,\n      committedTransitions = committedTransitions$jscomp$0,\n      flags = finishedWork.flags;\n    switch (finishedWork.tag) {\n      case 0:\n      case 11:\n      case 15:\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects\n        );\n        commitHookEffectListMount(8, finishedWork);\n        break;\n      case 23:\n        break;\n      case 22:\n        var instance = finishedWork.stateNode;\n        null !== finishedWork.memoizedState\n          ? instance._visibility & 2\n            ? recursivelyTraverseReconnectPassiveEffects(\n                finishedRoot,\n                finishedWork,\n                committedLanes,\n                committedTransitions,\n                includeWorkInProgressEffects\n              )\n            : recursivelyTraverseAtomicPassiveEffects(\n                finishedRoot,\n                finishedWork\n              )\n          : ((instance._visibility |= 2),\n            recursivelyTraverseReconnectPassiveEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions,\n              includeWorkInProgressEffects\n            ));\n        includeWorkInProgressEffects &&\n          flags & 2048 &&\n          commitOffscreenPassiveMountEffects(\n            finishedWork.alternate,\n            finishedWork\n          );\n        break;\n      case 24:\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects\n        );\n        includeWorkInProgressEffects &&\n          flags & 2048 &&\n          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n        break;\n      default:\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects\n        );\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction recursivelyTraverseAtomicPassiveEffects(\n  finishedRoot$jscomp$0,\n  parentFiber\n) {\n  if (parentFiber.subtreeFlags & 10256)\n    for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n      var finishedRoot = finishedRoot$jscomp$0,\n        finishedWork = parentFiber,\n        flags = finishedWork.flags;\n      switch (finishedWork.tag) {\n        case 22:\n          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n          flags & 2048 &&\n            commitOffscreenPassiveMountEffects(\n              finishedWork.alternate,\n              finishedWork\n            );\n          break;\n        case 24:\n          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n          flags & 2048 &&\n            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n          break;\n        default:\n          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n      }\n      parentFiber = parentFiber.sibling;\n    }\n}\nvar suspenseyCommitFlag = 8192;\nfunction recursivelyAccumulateSuspenseyCommit(parentFiber) {\n  if (parentFiber.subtreeFlags & suspenseyCommitFlag)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      accumulateSuspenseyCommitOnFiber(parentFiber),\n        (parentFiber = parentFiber.sibling);\n}\nfunction accumulateSuspenseyCommitOnFiber(fiber) {\n  switch (fiber.tag) {\n    case 26:\n      recursivelyAccumulateSuspenseyCommit(fiber);\n      fiber.flags & suspenseyCommitFlag &&\n        null !== fiber.memoizedState &&\n        suspendResource(\n          currentHoistableRoot,\n          fiber.memoizedState,\n          fiber.memoizedProps\n        );\n      break;\n    case 5:\n      recursivelyAccumulateSuspenseyCommit(fiber);\n      break;\n    case 3:\n    case 4:\n      var previousHoistableRoot = currentHoistableRoot;\n      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);\n      recursivelyAccumulateSuspenseyCommit(fiber);\n      currentHoistableRoot = previousHoistableRoot;\n      break;\n    case 22:\n      null === fiber.memoizedState &&\n        ((previousHoistableRoot = fiber.alternate),\n        null !== previousHoistableRoot &&\n        null !== previousHoistableRoot.memoizedState\n          ? ((previousHoistableRoot = suspenseyCommitFlag),\n            (suspenseyCommitFlag = 16777216),\n            recursivelyAccumulateSuspenseyCommit(fiber),\n            (suspenseyCommitFlag = previousHoistableRoot))\n          : recursivelyAccumulateSuspenseyCommit(fiber));\n      break;\n    default:\n      recursivelyAccumulateSuspenseyCommit(fiber);\n  }\n}\nfunction detachAlternateSiblings(parentFiber) {\n  var previousFiber = parentFiber.alternate;\n  if (\n    null !== previousFiber &&\n    ((parentFiber = previousFiber.child), null !== parentFiber)\n  ) {\n    previousFiber.child = null;\n    do\n      (previousFiber = parentFiber.sibling),\n        (parentFiber.sibling = null),\n        (parentFiber = previousFiber);\n    while (null !== parentFiber);\n  }\n}\nfunction recursivelyTraversePassiveUnmountEffects(parentFiber) {\n  var deletions = parentFiber.deletions;\n  if (0 !== (parentFiber.flags & 16)) {\n    if (null !== deletions)\n      for (var i = 0; i < deletions.length; i++) {\n        var childToDelete = deletions[i];\n        nextEffect = childToDelete;\n        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n          childToDelete,\n          parentFiber\n        );\n      }\n    detachAlternateSiblings(parentFiber);\n  }\n  if (parentFiber.subtreeFlags & 10256)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitPassiveUnmountOnFiber(parentFiber),\n        (parentFiber = parentFiber.sibling);\n}\nfunction commitPassiveUnmountOnFiber(finishedWork) {\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 15:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n      finishedWork.flags & 2048 &&\n        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);\n      break;\n    case 3:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n      break;\n    case 12:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n      break;\n    case 22:\n      var instance = finishedWork.stateNode;\n      null !== finishedWork.memoizedState &&\n      instance._visibility & 2 &&\n      (null === finishedWork.return || 13 !== finishedWork.return.tag)\n        ? ((instance._visibility &= -3),\n          recursivelyTraverseDisconnectPassiveEffects(finishedWork))\n        : recursivelyTraversePassiveUnmountEffects(finishedWork);\n      break;\n    default:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n  }\n}\nfunction recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n  var deletions = parentFiber.deletions;\n  if (0 !== (parentFiber.flags & 16)) {\n    if (null !== deletions)\n      for (var i = 0; i < deletions.length; i++) {\n        var childToDelete = deletions[i];\n        nextEffect = childToDelete;\n        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n          childToDelete,\n          parentFiber\n        );\n      }\n    detachAlternateSiblings(parentFiber);\n  }\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    deletions = parentFiber;\n    switch (deletions.tag) {\n      case 0:\n      case 11:\n      case 15:\n        commitHookEffectListUnmount(8, deletions, deletions.return);\n        recursivelyTraverseDisconnectPassiveEffects(deletions);\n        break;\n      case 22:\n        i = deletions.stateNode;\n        i._visibility & 2 &&\n          ((i._visibility &= -3),\n          recursivelyTraverseDisconnectPassiveEffects(deletions));\n        break;\n      default:\n        recursivelyTraverseDisconnectPassiveEffects(deletions);\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n  deletedSubtreeRoot,\n  nearestMountedAncestor\n) {\n  for (; null !== nextEffect; ) {\n    var fiber = nextEffect;\n    switch (fiber.tag) {\n      case 0:\n      case 11:\n      case 15:\n        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);\n        break;\n      case 23:\n      case 22:\n        if (\n          null !== fiber.memoizedState &&\n          null !== fiber.memoizedState.cachePool\n        ) {\n          var cache = fiber.memoizedState.cachePool.pool;\n          null != cache && cache.refCount++;\n        }\n        break;\n      case 24:\n        releaseCache(fiber.memoizedState.cache);\n    }\n    cache = fiber.child;\n    if (null !== cache) (cache.return = fiber), (nextEffect = cache);\n    else\n      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {\n        cache = nextEffect;\n        var sibling = cache.sibling,\n          returnFiber = cache.return;\n        detachFiberAfterEffects(cache);\n        if (cache === fiber) {\n          nextEffect = null;\n          break a;\n        }\n        if (null !== sibling) {\n          sibling.return = returnFiber;\n          nextEffect = sibling;\n          break a;\n        }\n        nextEffect = returnFiber;\n      }\n  }\n}\nvar DefaultAsyncDispatcher = {\n    getCacheForType: function (resourceType) {\n      var cache = readContext(CacheContext),\n        cacheForType = cache.data.get(resourceType);\n      void 0 === cacheForType &&\n        ((cacheForType = resourceType()),\n        cache.data.set(resourceType, cacheForType));\n      return cacheForType;\n    }\n  },\n  PossiblyWeakMap = \"function\" === typeof WeakMap ? WeakMap : Map,\n  executionContext = 0,\n  workInProgressRoot = null,\n  workInProgress = null,\n  workInProgressRootRenderLanes = 0,\n  workInProgressSuspendedReason = 0,\n  workInProgressThrownValue = null,\n  workInProgressRootDidSkipSuspendedSiblings = !1,\n  workInProgressRootIsPrerendering = !1,\n  workInProgressRootDidAttachPingListener = !1,\n  entangledRenderLanes = 0,\n  workInProgressRootExitStatus = 0,\n  workInProgressRootSkippedLanes = 0,\n  workInProgressRootInterleavedUpdatedLanes = 0,\n  workInProgressRootPingedLanes = 0,\n  workInProgressDeferredLane = 0,\n  workInProgressSuspendedRetryLanes = 0,\n  workInProgressRootConcurrentErrors = null,\n  workInProgressRootRecoverableErrors = null,\n  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,\n  globalMostRecentFallbackTime = 0,\n  workInProgressRootRenderTargetTime = Infinity,\n  workInProgressTransitions = null,\n  legacyErrorBoundariesThatAlreadyFailed = null,\n  pendingEffectsStatus = 0,\n  pendingEffectsRoot = null,\n  pendingFinishedWork = null,\n  pendingEffectsLanes = 0,\n  pendingEffectsRemainingLanes = 0,\n  pendingPassiveTransitions = null,\n  pendingRecoverableErrors = null,\n  nestedUpdateCount = 0,\n  rootWithNestedUpdates = null;\nfunction requestUpdateLane() {\n  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)\n    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;\n  if (null !== ReactSharedInternals.T) {\n    var actionScopeLane = currentEntangledLane;\n    return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();\n  }\n  return resolveUpdatePriority();\n}\nfunction requestDeferredLane() {\n  0 === workInProgressDeferredLane &&\n    (workInProgressDeferredLane =\n      0 === (workInProgressRootRenderLanes & 536870912) || isHydrating\n        ? claimNextTransitionLane()\n        : 536870912);\n  var suspenseHandler = suspenseHandlerStackCursor.current;\n  null !== suspenseHandler && (suspenseHandler.flags |= 32);\n  return workInProgressDeferredLane;\n}\nfunction scheduleUpdateOnFiber(root, fiber, lane) {\n  if (\n    (root === workInProgressRoot &&\n      (2 === workInProgressSuspendedReason ||\n        9 === workInProgressSuspendedReason)) ||\n    null !== root.cancelPendingCommit\n  )\n    prepareFreshStack(root, 0),\n      markRootSuspended(\n        root,\n        workInProgressRootRenderLanes,\n        workInProgressDeferredLane,\n        !1\n      );\n  markRootUpdated$1(root, lane);\n  if (0 === (executionContext & 2) || root !== workInProgressRoot)\n    root === workInProgressRoot &&\n      (0 === (executionContext & 2) &&\n        (workInProgressRootInterleavedUpdatedLanes |= lane),\n      4 === workInProgressRootExitStatus &&\n        markRootSuspended(\n          root,\n          workInProgressRootRenderLanes,\n          workInProgressDeferredLane,\n          !1\n        )),\n      ensureRootIsScheduled(root);\n}\nfunction performWorkOnRoot(root$jscomp$0, lanes, forceSync) {\n  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));\n  var shouldTimeSlice =\n      (!forceSync &&\n        0 === (lanes & 124) &&\n        0 === (lanes & root$jscomp$0.expiredLanes)) ||\n      checkIfRootIsPrerendering(root$jscomp$0, lanes),\n    exitStatus = shouldTimeSlice\n      ? renderRootConcurrent(root$jscomp$0, lanes)\n      : renderRootSync(root$jscomp$0, lanes, !0),\n    renderWasConcurrent = shouldTimeSlice;\n  do {\n    if (0 === exitStatus) {\n      workInProgressRootIsPrerendering &&\n        !shouldTimeSlice &&\n        markRootSuspended(root$jscomp$0, lanes, 0, !1);\n      break;\n    } else {\n      forceSync = root$jscomp$0.current.alternate;\n      if (\n        renderWasConcurrent &&\n        !isRenderConsistentWithExternalStores(forceSync)\n      ) {\n        exitStatus = renderRootSync(root$jscomp$0, lanes, !1);\n        renderWasConcurrent = !1;\n        continue;\n      }\n      if (2 === exitStatus) {\n        renderWasConcurrent = lanes;\n        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)\n          var JSCompiler_inline_result = 0;\n        else\n          (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),\n            (JSCompiler_inline_result =\n              0 !== JSCompiler_inline_result\n                ? JSCompiler_inline_result\n                : JSCompiler_inline_result & 536870912\n                  ? 536870912\n                  : 0);\n        if (0 !== JSCompiler_inline_result) {\n          lanes = JSCompiler_inline_result;\n          a: {\n            var root = root$jscomp$0;\n            exitStatus = workInProgressRootConcurrentErrors;\n            var wasRootDehydrated = root.current.memoizedState.isDehydrated;\n            wasRootDehydrated &&\n              (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);\n            JSCompiler_inline_result = renderRootSync(\n              root,\n              JSCompiler_inline_result,\n              !1\n            );\n            if (2 !== JSCompiler_inline_result) {\n              if (\n                workInProgressRootDidAttachPingListener &&\n                !wasRootDehydrated\n              ) {\n                root.errorRecoveryDisabledLanes |= renderWasConcurrent;\n                workInProgressRootInterleavedUpdatedLanes |=\n                  renderWasConcurrent;\n                exitStatus = 4;\n                break a;\n              }\n              renderWasConcurrent = workInProgressRootRecoverableErrors;\n              workInProgressRootRecoverableErrors = exitStatus;\n              null !== renderWasConcurrent &&\n                (null === workInProgressRootRecoverableErrors\n                  ? (workInProgressRootRecoverableErrors = renderWasConcurrent)\n                  : workInProgressRootRecoverableErrors.push.apply(\n                      workInProgressRootRecoverableErrors,\n                      renderWasConcurrent\n                    ));\n            }\n            exitStatus = JSCompiler_inline_result;\n          }\n          renderWasConcurrent = !1;\n          if (2 !== exitStatus) continue;\n        }\n      }\n      if (1 === exitStatus) {\n        prepareFreshStack(root$jscomp$0, 0);\n        markRootSuspended(root$jscomp$0, lanes, 0, !0);\n        break;\n      }\n      a: {\n        shouldTimeSlice = root$jscomp$0;\n        renderWasConcurrent = exitStatus;\n        switch (renderWasConcurrent) {\n          case 0:\n          case 1:\n            throw Error(formatProdErrorMessage(345));\n          case 4:\n            if ((lanes & 4194048) !== lanes) break;\n          case 6:\n            markRootSuspended(\n              shouldTimeSlice,\n              lanes,\n              workInProgressDeferredLane,\n              !workInProgressRootDidSkipSuspendedSiblings\n            );\n            break a;\n          case 2:\n            workInProgressRootRecoverableErrors = null;\n            break;\n          case 3:\n          case 5:\n            break;\n          default:\n            throw Error(formatProdErrorMessage(329));\n        }\n        if (\n          (lanes & 62914560) === lanes &&\n          ((exitStatus = globalMostRecentFallbackTime + 300 - now()),\n          10 < exitStatus)\n        ) {\n          markRootSuspended(\n            shouldTimeSlice,\n            lanes,\n            workInProgressDeferredLane,\n            !workInProgressRootDidSkipSuspendedSiblings\n          );\n          if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;\n          shouldTimeSlice.timeoutHandle = scheduleTimeout(\n            commitRootWhenReady.bind(\n              null,\n              shouldTimeSlice,\n              forceSync,\n              workInProgressRootRecoverableErrors,\n              workInProgressTransitions,\n              workInProgressRootDidIncludeRecursiveRenderUpdate,\n              lanes,\n              workInProgressDeferredLane,\n              workInProgressRootInterleavedUpdatedLanes,\n              workInProgressSuspendedRetryLanes,\n              workInProgressRootDidSkipSuspendedSiblings,\n              renderWasConcurrent,\n              2,\n              -0,\n              0\n            ),\n            exitStatus\n          );\n          break a;\n        }\n        commitRootWhenReady(\n          shouldTimeSlice,\n          forceSync,\n          workInProgressRootRecoverableErrors,\n          workInProgressTransitions,\n          workInProgressRootDidIncludeRecursiveRenderUpdate,\n          lanes,\n          workInProgressDeferredLane,\n          workInProgressRootInterleavedUpdatedLanes,\n          workInProgressSuspendedRetryLanes,\n          workInProgressRootDidSkipSuspendedSiblings,\n          renderWasConcurrent,\n          0,\n          -0,\n          0\n        );\n      }\n    }\n    break;\n  } while (1);\n  ensureRootIsScheduled(root$jscomp$0);\n}\nfunction commitRootWhenReady(\n  root,\n  finishedWork,\n  recoverableErrors,\n  transitions,\n  didIncludeRenderPhaseUpdate,\n  lanes,\n  spawnedLane,\n  updatedLanes,\n  suspendedRetryLanes,\n  didSkipSuspendedSiblings,\n  exitStatus,\n  suspendedCommitReason,\n  completedRenderStartTime,\n  completedRenderEndTime\n) {\n  root.timeoutHandle = -1;\n  suspendedCommitReason = finishedWork.subtreeFlags;\n  if (\n    suspendedCommitReason & 8192 ||\n    16785408 === (suspendedCommitReason & 16785408)\n  )\n    if (\n      ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop }),\n      accumulateSuspenseyCommitOnFiber(finishedWork),\n      (suspendedCommitReason = waitForCommitToBeReady()),\n      null !== suspendedCommitReason)\n    ) {\n      root.cancelPendingCommit = suspendedCommitReason(\n        commitRoot.bind(\n          null,\n          root,\n          finishedWork,\n          lanes,\n          recoverableErrors,\n          transitions,\n          didIncludeRenderPhaseUpdate,\n          spawnedLane,\n          updatedLanes,\n          suspendedRetryLanes,\n          exitStatus,\n          1,\n          completedRenderStartTime,\n          completedRenderEndTime\n        )\n      );\n      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);\n      return;\n    }\n  commitRoot(\n    root,\n    finishedWork,\n    lanes,\n    recoverableErrors,\n    transitions,\n    didIncludeRenderPhaseUpdate,\n    spawnedLane,\n    updatedLanes,\n    suspendedRetryLanes\n  );\n}\nfunction isRenderConsistentWithExternalStores(finishedWork) {\n  for (var node = finishedWork; ; ) {\n    var tag = node.tag;\n    if (\n      (0 === tag || 11 === tag || 15 === tag) &&\n      node.flags & 16384 &&\n      ((tag = node.updateQueue),\n      null !== tag && ((tag = tag.stores), null !== tag))\n    )\n      for (var i = 0; i < tag.length; i++) {\n        var check = tag[i],\n          getSnapshot = check.getSnapshot;\n        check = check.value;\n        try {\n          if (!objectIs(getSnapshot(), check)) return !1;\n        } catch (error) {\n          return !1;\n        }\n      }\n    tag = node.child;\n    if (node.subtreeFlags & 16384 && null !== tag)\n      (tag.return = node), (node = tag);\n    else {\n      if (node === finishedWork) break;\n      for (; null === node.sibling; ) {\n        if (null === node.return || node.return === finishedWork) return !0;\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n  return !0;\n}\nfunction markRootSuspended(\n  root,\n  suspendedLanes,\n  spawnedLane,\n  didAttemptEntireTree\n) {\n  suspendedLanes &= ~workInProgressRootPingedLanes;\n  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;\n  root.suspendedLanes |= suspendedLanes;\n  root.pingedLanes &= ~suspendedLanes;\n  didAttemptEntireTree && (root.warmLanes |= suspendedLanes);\n  didAttemptEntireTree = root.expirationTimes;\n  for (var lanes = suspendedLanes; 0 < lanes; ) {\n    var index$4 = 31 - clz32(lanes),\n      lane = 1 << index$4;\n    didAttemptEntireTree[index$4] = -1;\n    lanes &= ~lane;\n  }\n  0 !== spawnedLane &&\n    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n}\nfunction flushSyncWork$1() {\n  return 0 === (executionContext & 6)\n    ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)\n    : !0;\n}\nfunction resetWorkInProgressStack() {\n  if (null !== workInProgress) {\n    if (0 === workInProgressSuspendedReason)\n      var interruptedWork = workInProgress.return;\n    else\n      (interruptedWork = workInProgress),\n        (lastContextDependency = currentlyRenderingFiber$1 = null),\n        resetHooksOnUnwind(interruptedWork),\n        (thenableState = null),\n        (thenableIndexCounter = 0),\n        (interruptedWork = workInProgress);\n    for (; null !== interruptedWork; )\n      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),\n        (interruptedWork = interruptedWork.return);\n    workInProgress = null;\n  }\n}\nfunction prepareFreshStack(root, lanes) {\n  var timeoutHandle = root.timeoutHandle;\n  -1 !== timeoutHandle &&\n    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));\n  timeoutHandle = root.cancelPendingCommit;\n  null !== timeoutHandle &&\n    ((root.cancelPendingCommit = null), timeoutHandle());\n  resetWorkInProgressStack();\n  workInProgressRoot = root;\n  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);\n  workInProgressRootRenderLanes = lanes;\n  workInProgressSuspendedReason = 0;\n  workInProgressThrownValue = null;\n  workInProgressRootDidSkipSuspendedSiblings = !1;\n  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n  workInProgressRootDidAttachPingListener = !1;\n  workInProgressSuspendedRetryLanes =\n    workInProgressDeferredLane =\n    workInProgressRootPingedLanes =\n    workInProgressRootInterleavedUpdatedLanes =\n    workInProgressRootSkippedLanes =\n    workInProgressRootExitStatus =\n      0;\n  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =\n    null;\n  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;\n  0 !== (lanes & 8) && (lanes |= lanes & 32);\n  var allEntangledLanes = root.entangledLanes;\n  if (0 !== allEntangledLanes)\n    for (\n      root = root.entanglements, allEntangledLanes &= lanes;\n      0 < allEntangledLanes;\n\n    ) {\n      var index$2 = 31 - clz32(allEntangledLanes),\n        lane = 1 << index$2;\n      lanes |= root[index$2];\n      allEntangledLanes &= ~lane;\n    }\n  entangledRenderLanes = lanes;\n  finishQueueingConcurrentUpdates();\n  return timeoutHandle;\n}\nfunction handleThrow(root, thrownValue) {\n  currentlyRenderingFiber = null;\n  ReactSharedInternals.H = ContextOnlyDispatcher;\n  thrownValue === SuspenseException || thrownValue === SuspenseActionException\n    ? ((thrownValue = getSuspendedThenable()),\n      (workInProgressSuspendedReason = 3))\n    : thrownValue === SuspenseyCommitException\n      ? ((thrownValue = getSuspendedThenable()),\n        (workInProgressSuspendedReason = 4))\n      : (workInProgressSuspendedReason =\n          thrownValue === SelectiveHydrationException\n            ? 8\n            : null !== thrownValue &&\n                \"object\" === typeof thrownValue &&\n                \"function\" === typeof thrownValue.then\n              ? 6\n              : 1);\n  workInProgressThrownValue = thrownValue;\n  null === workInProgress &&\n    ((workInProgressRootExitStatus = 1),\n    logUncaughtError(\n      root,\n      createCapturedValueAtFiber(thrownValue, root.current)\n    ));\n}\nfunction pushDispatcher() {\n  var prevDispatcher = ReactSharedInternals.H;\n  ReactSharedInternals.H = ContextOnlyDispatcher;\n  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;\n}\nfunction pushAsyncDispatcher() {\n  var prevAsyncDispatcher = ReactSharedInternals.A;\n  ReactSharedInternals.A = DefaultAsyncDispatcher;\n  return prevAsyncDispatcher;\n}\nfunction renderDidSuspendDelayIfPossible() {\n  workInProgressRootExitStatus = 4;\n  workInProgressRootDidSkipSuspendedSiblings ||\n    ((workInProgressRootRenderLanes & 4194048) !==\n      workInProgressRootRenderLanes &&\n      null !== suspenseHandlerStackCursor.current) ||\n    (workInProgressRootIsPrerendering = !0);\n  (0 === (workInProgressRootSkippedLanes & 134217727) &&\n    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||\n    null === workInProgressRoot ||\n    markRootSuspended(\n      workInProgressRoot,\n      workInProgressRootRenderLanes,\n      workInProgressDeferredLane,\n      !1\n    );\n}\nfunction renderRootSync(root, lanes, shouldYieldForPrerendering) {\n  var prevExecutionContext = executionContext;\n  executionContext |= 2;\n  var prevDispatcher = pushDispatcher(),\n    prevAsyncDispatcher = pushAsyncDispatcher();\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)\n    (workInProgressTransitions = null), prepareFreshStack(root, lanes);\n  lanes = !1;\n  var exitStatus = workInProgressRootExitStatus;\n  a: do\n    try {\n      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {\n        var unitOfWork = workInProgress,\n          thrownValue = workInProgressThrownValue;\n        switch (workInProgressSuspendedReason) {\n          case 8:\n            resetWorkInProgressStack();\n            exitStatus = 6;\n            break a;\n          case 3:\n          case 2:\n          case 9:\n          case 6:\n            null === suspenseHandlerStackCursor.current && (lanes = !0);\n            var reason = workInProgressSuspendedReason;\n            workInProgressSuspendedReason = 0;\n            workInProgressThrownValue = null;\n            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n            if (\n              shouldYieldForPrerendering &&\n              workInProgressRootIsPrerendering\n            ) {\n              exitStatus = 0;\n              break a;\n            }\n            break;\n          default:\n            (reason = workInProgressSuspendedReason),\n              (workInProgressSuspendedReason = 0),\n              (workInProgressThrownValue = null),\n              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n        }\n      }\n      workLoopSync();\n      exitStatus = workInProgressRootExitStatus;\n      break;\n    } catch (t","size_bytes":360000},"app/api/create-checkout/route.ts":{"content":"import { type NextRequest, NextResponse } from \"next/server\"\nimport { createServerClient } from \"@/lib/supabase/server\"\n\nexport async function POST(request: NextRequest) {\n  try {\n    const { plan } = await request.json()\n    const supabase = await createServerClient()\n\n    // Get the current user\n    const {\n      data: { user },\n      error: authError,\n    } = await supabase.auth.getUser()\n\n    if (authError || !user) {\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 })\n    }\n\n    // In a real implementation, you would:\n    // 1. Create a Stripe checkout session\n    // 2. Return the session URL for redirect\n\n    // For now, we'll simulate the upgrade process\n    if (plan === \"pro\") {\n      // Update user's subscription status in the database\n      const { error: updateError } = await supabase\n        .from(\"profiles\")\n        .update({\n          subscription_status: \"active\",\n          subscription_plan: \"pro\",\n          subscription_updated_at: new Date().toISOString(),\n        })\n        .eq(\"id\", user.id)\n\n      if (updateError) {\n        console.error(\"Error updating subscription:\", updateError)\n        return NextResponse.json({ error: \"Failed to update subscription\" }, { status: 500 })\n      }\n\n      // Return success URL (in real implementation, this would be the Stripe checkout URL)\n      return NextResponse.json({\n        url: \"/editor?upgraded=true\",\n        message: \"Subscription activated successfully!\",\n      })\n    }\n\n    return NextResponse.json({ error: \"Invalid plan\" }, { status: 400 })\n  } catch (error) {\n    console.error(\"Checkout error:\", error)\n    return NextResponse.json({ error: \"Internal server error\" }, { status: 500 })\n  }\n}\n","size_bytes":1707},"app/api/generate-video/route.ts":{"content":"import { NextRequest, NextResponse } from 'next/server';\nimport { randomUUID } from 'crypto';\nimport { createServerClient } from '@supabase/ssr';\nimport { createClient as createAuthedClient } from '@/lib/supabase/server';\nimport { getRenderQueue } from '@/lib/queue';\n\n// Force dynamic to avoid caching & ensure Node runtime\nexport const dynamic = 'force-dynamic';\nexport const runtime = 'nodejs';\n\ninterface Character { id: string; name: string; color: string; avatar?: string }\ninterface Message { id: string; characterId: string; text: string; timestamp: number }\ninterface RequestBody { characters: Character[]; messages: Message[]; isPro?: boolean; theme?: string; contactName?: string }\n\nfunction getSupabaseServiceRole() {\n  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;\n  const key = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\n  return createServerClient(url, key, { cookies: { getAll() { return []; }, setAll() {} } });\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    if (!process.env.SUPABASE_SERVICE_ROLE_KEY) {\n      return NextResponse.json({ error: 'Server not configured (SUPABASE_SERVICE_ROLE_KEY missing)' }, { status: 500 });\n    }\n    // Require authentication\n    const authedForCheck = await createAuthedClient();\n    const { data: { user: currentUser } } = await authedForCheck.auth.getUser();\n    if (!currentUser) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    const body: RequestBody = await request.json();\n  const { characters, messages, theme = 'imessage', contactName } = body;\n    \n    // Validate theme parameter\n    const validThemes = ['imessage', 'whatsapp', 'snapchat'];\n    const selectedTheme = validThemes.includes(theme) ? theme : 'imessage';\n    if (theme !== selectedTheme) {\n      console.warn(`Invalid theme \"${theme}\" provided, falling back to imessage`);\n    }\n    if (!characters || !messages || messages.length === 0) {\n      return NextResponse.json({ error: 'Invalid request: characters and messages are required' }, { status: 400 });\n    }\n    // Transform to Remotion props (same mapping as before)\n    const hasYouId = characters.some((c) => c.id === 'you');\n    const remotionMessages = messages.map((msg, index) => {\n      const isOutgoing = hasYouId ? msg.characterId === 'you' : (characters[1] ? msg.characterId === characters[1].id : false);\n      return { id: index + 1, text: msg.text, sent: isOutgoing, time: `0:${String(index * 2).padStart(2, '0')}` };\n    });\n    const contactCharacter = characters.find((c) => c.id === 'them') || characters[0];\n    const inputProps = {\n      messages: remotionMessages,\n      contactName: contactName || contactCharacter?.name || 'Contact',\n      theme: selectedTheme,\n      alwaysShowKeyboard: true,\n    };\n\n    const queueEnabled = process.env.RENDER_QUEUE_ENABLED === 'true';\n    if (queueEnabled && !process.env.REDIS_URL) {\n      return NextResponse.json({ error: 'Server not configured (REDIS_URL missing)' }, { status: 500 });\n    }\n\n  // Resolve user (required)\n  const userId = currentUser.id;\n\n    // Create DB record and enqueue\n    const jobId = randomUUID();\n    const now = new Date().toISOString();\n    const supabase = getSupabaseServiceRole();\n    const { error } = await supabase.from('video_renders').insert({\n      id: jobId,\n      user_id: userId,\n      status: 'pending',\n      composition_id: 'MessageConversation',\n      input_props: inputProps,\n      created_at: now,\n      updated_at: now,\n    });\n    if (error) return NextResponse.json({ error: 'DB insert failed', details: error.message }, { status: 500 });\n\n    if (queueEnabled) {\n      // Try enqueue; fail fast to avoid 504s\n      try {\n        const queue = getRenderQueue();\n        const enqueue = queue.add('render', { jobId });\n        await Promise.race([\n          enqueue,\n          new Promise((_, r) => setTimeout(() => r(new Error('enqueue-timeout')), 2000)),\n        ]);\n      } catch (e: any) {\n        // Log only; we still return 202 and rely on worker polling fallback\n        console.error('[API] Enqueue failed, will rely on polling worker', e?.message || e);\n      }\n    }\n\n    return NextResponse.json(\n      { jobId, statusUrl: `/api/render/${jobId}/status` },\n      { status: 202 }\n    );\n  } catch (e: any) {\n    return NextResponse.json({ error: e?.message || 'Unknown error' }, { status: 500 });\n  }\n}\n","size_bytes":4414},"app/api/render/route.ts":{"content":"import { NextResponse } from 'next/server';\n\nexport const dynamic = 'force-dynamic';\nexport const runtime = 'nodejs';\n\nexport async function POST() {\n  return NextResponse.json({ error: 'This endpoint has moved to /api/generate-video' }, { status: 410 });\n}\n","size_bytes":258},"app/api/render-video/route.ts":{"content":"","size_bytes":0},"app/api/webhook/route.ts":{"content":"","size_bytes":0},"app/auth/check-email/page.tsx":{"content":"import { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card\"\nimport { Button } from \"@/components/ui/button\"\nimport Link from \"next/link\"\nimport { Mail } from \"lucide-react\"\n\nexport default function CheckEmailPage() {\n  return (\n    <div className=\"flex min-h-screen w-full items-center justify-center p-6 bg-background\">\n      <div className=\"w-full max-w-sm\">\n        <Card className=\"bg-background-light/70 backdrop-blur border-border/70\">\n          <CardHeader className=\"text-center space-y-3\">\n            <div className=\"mx-auto mb-2 flex h-12 w-12 items-center justify-center rounded-full bg-primary/20 text-primary\">\n              <Mail className=\"h-6 w-6\" />\n            </div>\n            <CardTitle className=\"text-2xl font-semibold\">Check your email</CardTitle>\n            <CardDescription className=\"text-foreground-muted\">We've sent a confirmation link to finish registration</CardDescription>\n          </CardHeader>\n          <CardContent className=\"text-center\">\n            <p className=\"text-xs text-foreground-muted mb-6\">Click the link in your inbox to verify the account and start creating videos.</p>\n            <Button asChild variant=\"outline\" className=\"w-full\">\n              <Link href=\"/auth/login\">Back to sign in</Link>\n            </Button>\n          </CardContent>\n        </Card>\n      </div>\n    </div>\n  )\n}\n","size_bytes":1383},"app/auth/login/page.tsx":{"content":"\"use client\"\n\nimport type React from \"react\"\n\nimport { createClient } from \"@/lib/supabase/client\"\nimport { Button } from \"@/components/ui/button\"\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card\"\nimport { Input } from \"@/components/ui/input\"\nimport { Label } from \"@/components/ui/label\"\nimport Link from \"next/link\"\nimport { useRouter, useSearchParams } from \"next/navigation\"\nimport { useEffect, useState } from \"react\"\n\nexport default function LoginPage() {\n  const [email, setEmail] = useState(\"\")\n  const [password, setPassword] = useState(\"\")\n  const [error, setError] = useState<string | null>(null)\n  const [isLoading, setIsLoading] = useState(false)\n  const router = useRouter()\n  const searchParams = useSearchParams()\n  // Safely validate redirect parameter to prevent open redirects\n  const redirectParam = searchParams?.get(\"redirect\") ?? null\n  const redirectTo = (redirectParam && redirectParam.startsWith(\"/\") && !redirectParam.startsWith(\"//\")) \n    ? redirectParam \n    : \"/editor\"\n\n  // If already authenticated, skip showing the form and listen for auth changes\n  useEffect(() => {\n    const supabase = createClient()\n    \n    // Check initial auth state\n    supabase.auth.getUser().then(({ data: { user } }) => {\n      if (user) {\n        // Give a small delay to ensure proper session handling\n        setTimeout(() => router.replace(redirectTo), 100)\n      }\n    })\n\n    // Listen for auth state changes\n    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {\n      if (event === 'SIGNED_IN' && session) {\n        // Successful login, redirect after short delay\n        setTimeout(() => router.replace(redirectTo), 100)\n      }\n    })\n\n    return () => subscription.unsubscribe()\n  }, [redirectTo, router])\n\n  const handleLogin = async (e: React.FormEvent) => {\n    e.preventDefault()\n    const supabase = createClient()\n    setIsLoading(true)\n    setError(null)\n\n    try {\n      const { error } = await supabase.auth.signInWithPassword({\n        email,\n        password,\n      })\n      if (error) throw error\n      // Proactively navigate after successful sign-in; listener remains as a fallback\n      // Small delay helps ensure cookies/session are fully synced before navigation\n      setTimeout(() => router.replace(redirectTo), 50)\n    } catch (error: unknown) {\n      setError(error instanceof Error ? error.message : \"An error occurred\")\n    } finally {\n      setIsLoading(false)\n    }\n  }\n\n  return (\n    <div className=\"flex min-h-screen w-full items-center justify-center p-6 bg-background\">\n      <div className=\"w-full max-w-sm\">\n        <Card className=\"bg-background-light/70 backdrop-blur border-border/70\">\n          <CardHeader className=\"text-center space-y-3\">\n            <CardTitle className=\"text-2xl font-semibold\">Welcome back</CardTitle>\n            <CardDescription className=\"text-foreground-muted\">Sign in to your ChatVideo account</CardDescription>\n          </CardHeader>\n          <CardContent>\n            <form onSubmit={handleLogin} className=\"space-y-5\">\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"email\">Email</Label>\n                <Input id=\"email\" type=\"email\" placeholder=\"you@example.com\" required value={email} onChange={(e)=>setEmail(e.target.value)} />\n              </div>\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"password\">Password</Label>\n                <Input id=\"password\" type=\"password\" required value={password} onChange={(e)=>setPassword(e.target.value)} />\n              </div>\n              {error && <div className=\"text-xs rounded-md border border-red-500/40 bg-red-500/10 px-3 py-2 text-red-400\">{error}</div>}\n              <Button type=\"submit\" className=\"w-full\" disabled={isLoading}>{isLoading?\"Signing in...\":\"Sign in\"}</Button>\n            </form>\n            <div className=\"mt-6 text-center text-xs text-foreground-muted\">\n              Don't have an account? <Link href=\"/auth/signup\" className=\"text-primary hover:text-primary-hover font-medium\">Sign up</Link>\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n    </div>\n  )\n}\n","size_bytes":4193},"app/auth/signup/page.tsx":{"content":"\"use client\"\n\nimport type React from \"react\"\n\nimport { createClient } from \"@/lib/supabase/client\"\nimport { Button } from \"@/components/ui/button\"\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card\"\nimport { Input } from \"@/components/ui/input\"\nimport { Label } from \"@/components/ui/label\"\nimport Link from \"next/link\"\nimport { useRouter, useSearchParams } from \"next/navigation\"\nimport { useEffect, useState } from \"react\"\n\nexport default function SignUpPage() {\n  const [email, setEmail] = useState(\"\")\n  const [password, setPassword] = useState(\"\")\n  const [confirmPassword, setConfirmPassword] = useState(\"\")\n  const [error, setError] = useState<string | null>(null)\n  const [isLoading, setIsLoading] = useState(false)\n  const router = useRouter()\n  const searchParams = useSearchParams()\n  const plan = searchParams.get(\"plan\")\n  const postVerifyRedirect = plan ? `/pricing?plan=${encodeURIComponent(plan)}` : \"/editor\"\n\n  // If already signed in, bounce away\n  useEffect(() => {\n    const supabase = createClient()\n    supabase.auth.getUser().then(({ data: { user } }) => {\n      if (user) router.replace(\"/editor\")\n    })\n  }, [router])\n\n  const handleSignUp = async (e: React.FormEvent) => {\n    e.preventDefault()\n    const supabase = createClient()\n    setIsLoading(true)\n    setError(null)\n\n    if (password !== confirmPassword) {\n      setError(\"Passwords do not match\")\n      setIsLoading(false)\n      return\n    }\n\n    if (password.length < 6) {\n      setError(\"Password must be at least 6 characters\")\n      setIsLoading(false)\n      return\n    }\n\n    try {\n      const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://mockvideo.app'\n      const { error } = await supabase.auth.signUp({\n        email,\n        password,\n        options: {\n          // Must be an allowed redirect in Supabase Auth settings\n          emailRedirectTo: `${siteUrl}${postVerifyRedirect}`,\n        },\n      })\n      if (error) throw error\n      router.push(\"/auth/check-email\")\n    } catch (error: unknown) {\n      setError(error instanceof Error ? error.message : \"An error occurred\")\n    } finally {\n      setIsLoading(false)\n    }\n  }\n\n  return (\n    <div className=\"flex min-h-screen w-full items-center justify-center p-6 bg-background\">\n      <div className=\"w-full max-w-sm\">\n        <Card className=\"bg-background-light/70 backdrop-blur border-border/70\">\n          <CardHeader className=\"text-center space-y-3\">\n            <CardTitle className=\"text-2xl font-semibold\">Create account</CardTitle>\n            <CardDescription className=\"text-foreground-muted\">Start creating amazing chat videos</CardDescription>\n          </CardHeader>\n          <CardContent>\n            <form onSubmit={handleSignUp} className=\"space-y-5\">\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"email\">Email</Label>\n                <Input id=\"email\" type=\"email\" placeholder=\"you@example.com\" required value={email} onChange={(e)=>setEmail(e.target.value)} />\n              </div>\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"password\">Password</Label>\n                <Input id=\"password\" type=\"password\" placeholder=\"At least 6 characters\" required value={password} onChange={(e)=>setPassword(e.target.value)} />\n              </div>\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"confirmPassword\">Confirm Password</Label>\n                <Input id=\"confirmPassword\" type=\"password\" placeholder=\"Confirm your password\" required value={confirmPassword} onChange={(e)=>setConfirmPassword(e.target.value)} />\n              </div>\n              {error && <div className=\"text-xs rounded-md border border-red-500/40 bg-red-500/10 px-3 py-2 text-red-400\">{error}</div>}\n              <Button type=\"submit\" className=\"w-full\" disabled={isLoading}>{isLoading?\"Creating account...\":\"Create account\"}</Button>\n            </form>\n            <div className=\"mt-6 text-center text-xs text-foreground-muted\">\n              Already have an account? <Link href=\"/auth/login\" className=\"text-primary hover:text-primary-hover font-medium\">Sign in</Link>\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n    </div>\n  )\n}\n","size_bytes":4245},"app/api/health/queue/route.ts":{"content":"import { NextResponse } from 'next/server';\n\nexport const dynamic = 'force-dynamic';\nexport const runtime = 'nodejs';\n\nexport async function GET() {\n  try {\n    const queueEnabled = process.env.RENDER_QUEUE_ENABLED === 'true';\n    const redisUrl = process.env.REDIS_URL || '';\n    const hasRedisUrl = Boolean(redisUrl);\n    const redisScheme = redisUrl ? (redisUrl.split(':')[0] || null) : null;\n    const supabaseConfigured = Boolean(process.env.NEXT_PUBLIC_SUPABASE_URL) && Boolean(process.env.SUPABASE_SERVICE_ROLE_KEY);\n\n    return NextResponse.json({\n      queueEnabled,\n      hasRedisUrl,\n      redisScheme,\n      supabaseConfigured,\n    });\n  } catch (e: any) {\n    return NextResponse.json({ error: e?.message || 'Unknown error' }, { status: 500 });\n  }\n}\n","size_bytes":764},"app/api/render/[jobId]/download/route.ts":{"content":"import { NextRequest, NextResponse } from 'next/server';\nimport { createServerClient } from '@supabase/ssr';\nimport { generateSASUrl } from '@/lib/azure-blob';\n\nexport const dynamic = 'force-dynamic';\nexport const runtime = 'nodejs';\n\nfunction getSupabaseServiceRole() {\n  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;\n  const key = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\n  return createServerClient(url, key, {\n    cookies: { getAll() { return []; }, setAll() {} },\n  });\n}\n\nconst sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));\n\nexport async function GET(req: NextRequest, ctx: { params: Promise<{ jobId: string }> | { jobId: string } }) {\n  try {\n    if (!process.env.SUPABASE_SERVICE_ROLE_KEY) {\n      return NextResponse.json({ error: 'Server not configured (SUPABASE_SERVICE_ROLE_KEY missing)' }, { status: 500 });\n    }\n\n  const supabase = getSupabaseServiceRole();\n  const { jobId } = await ctx.params;\n\n    // Allow caller to override wait window (bounded)\n  const url = new URL(req.url);\n  // Hard cap to stay under provider function timeouts (override with env)\n  const HARD_CAP = Number.parseInt(process.env.API_DOWNLOAD_MAX_WAIT_MS || '10000'); // 10s default\n  const qMax = Number(url.searchParams.get('maxWaitMs'));\n  const requested = Number.isFinite(qMax) ? Math.max(1000, Math.min(qMax, 10 * 60 * 1000)) : 20_000; // default 20s\n  const maxWaitMs = Math.min(requested, HARD_CAP);\n\n    const start = Date.now();\n    let lastStatus: string | undefined;\n    while (Date.now() - start < maxWaitMs) {\n      const { data, error } = await supabase\n        .from('video_renders')\n        .select('status, url, blob_name')\n  .eq('id', jobId)\n        .maybeSingle();\n\n      if (error) return NextResponse.json({ error: error.message }, { status: 500 });\n      if (!data) return NextResponse.json({ error: 'Not found' }, { status: 404 });\n\n  const { status, url: sasUrl, blob_name } = data as { status: string; url: string | null; blob_name?: string | null };\n      lastStatus = status;\n\n      if (status === 'done' && (sasUrl || blob_name)) {\n        // Prefer generating a fresh SAS to avoid stale/invalid tokens\n        let blobName: string | null = null;\n        if (blob_name && typeof blob_name === 'string') {\n          blobName = blob_name;\n        } else if (sasUrl) {\n          try {\n            const u = new URL(sasUrl);\n            if (u.hostname.endsWith('.blob.core.windows.net')) {\n              const parts = u.pathname.split('/').filter(Boolean);\n              if (parts.length >= 2 && parts[0] === 'videos') {\n                blobName = decodeURIComponent(parts.slice(1).join('/'));\n              }\n            }\n          } catch {}\n        }\n\n        let finalUrl = sasUrl || '';\n        if (blobName) {\n          try {\n            finalUrl = generateSASUrl(blobName, 60);\n          } catch {\n            // Fall back to stored URL if re-signing fails\n          }\n        }\n\n        const resp = NextResponse.redirect(finalUrl, 302);\n        resp.headers.set('Cache-Control', 'no-store, no-cache, must-revalidate');\n        resp.headers.set('Pragma', 'no-cache');\n        return resp;\n      }\n      if (status === 'error') {\n        return NextResponse.json({ error: 'Render failed' }, { status: 500 });\n      }\n      await sleep(1500);\n    }\n\n    // Timed out waiting â€” advise client to retry soon and provide status endpoint\n  const res = NextResponse.json(\n  { status: lastStatus || 'pending', statusUrl: `/api/render/${jobId}/status` },\n      { status: 202 },\n    );\n    res.headers.set('Retry-After', '3');\n  res.headers.set('Cache-Control', 'no-store, no-cache, must-revalidate');\n  res.headers.set('Pragma', 'no-cache');\n    return res;\n  } catch (e: any) {\n    return NextResponse.json({ error: e?.message || 'Unknown error' }, { status: 500 });\n  }\n}\n","size_bytes":3856},"app/api/render/[jobId]/status/route.ts":{"content":"import { NextRequest, NextResponse } from 'next/server';\nimport { createServerClient } from '@supabase/ssr';\nimport { generateSASUrl } from '@/lib/azure-blob';\n\nexport const dynamic = 'force-dynamic';\nexport const runtime = 'nodejs';\n\nfunction getSupabaseServiceRole() {\n\tconst url = process.env.NEXT_PUBLIC_SUPABASE_URL!;\n\tconst key = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\n\treturn createServerClient(url, key, {\n\t\tcookies: { getAll() { return []; }, setAll() {} },\n\t});\n}\n\nexport async function GET(_req: NextRequest, ctx: { params: Promise<{ jobId: string }> | { jobId: string } }) {\n\ttry {\n\t\tconst supabase = getSupabaseServiceRole();\n\t\tconst { jobId } = await ctx.params;\n\t\tconst { data, error } = await supabase\n\t\t\t.from('video_renders')\n\t.select('status, url, blob_name, error_message')\n\t\t\t.eq('id', jobId)\n\t\t\t.maybeSingle();\n\t\tif (error) return NextResponse.json({ error: error.message }, { status: 500 });\n\t\tif (!data) return NextResponse.json({ error: 'Not found' }, { status: 404 });\n\t\t\t\t\t\tconst { status, url, blob_name, error_message } = data as { status: string; url: string | null; blob_name?: string | null; error_message?: string | null };\n\t\t\t\tlet finalUrl = url || null;\n\t\t\t\t\t\tif (status === 'done') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet blobName: string | null = blob_name || null;\n\t\t\t\t\t\t\t\tif (!blobName && url) {\n\t\t\t\t\t\t\t\t\tconst u = new URL(url);\n\t\t\t\t\t\t\t\t\tif (u.hostname.endsWith('.blob.core.windows.net')) {\n\t\t\t\t\t\t\t\t\t\tconst parts = u.pathname.split('/').filter(Boolean);\n\t\t\t\t\t\t\t\t\t\tif (parts.length >= 2 && parts[0] === 'videos') {\n\t\t\t\t\t\t\t\t\t\t\tblobName = decodeURIComponent(parts.slice(1).join('/'));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (blobName) finalUrl = generateSASUrl(blobName, 60);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// leave finalUrl as-is on parse/generation errors\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn NextResponse.json({ status, url: finalUrl, error: error_message || undefined });\n\t} catch (e: any) {\n\t\treturn NextResponse.json({ error: e.message || 'Unknown error' }, { status: 500 });\n\t}\n}\n","size_bytes":2036},"replit.md":{"content":"# Overview\n\nChatVideo is a Next.js application that allows users to create viral-style videos from chat conversations. The platform converts text message scripts into animated video content suitable for social media platforms like TikTok, Instagram Reels, and YouTube Shorts. Users can design chat conversations with customizable themes, characters, and styling, then render them as MP4 videos using Remotion for video generation.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Frontend Architecture\n\nThe application uses Next.js 14 with React Server Components and TypeScript. The UI is built with shadcn/ui components for a consistent design system, using Tailwind CSS for styling with a custom pink-accent theme. The main editor interface allows users to create and preview chat conversations in real-time using Remotion Player for instant preview without backend processing.\n\nState management is handled through React hooks with local state for the editor components. The application supports both authenticated and unauthenticated users, with protected routes for the main editor functionality.\n\n## Video Generation System\n\nThe video rendering uses a hybrid approach with two phases:\n- **Preview Mode**: Client-side preview using Remotion Player for instant feedback\n- **Production Rendering**: Backend worker system for final video generation\n\nThe Remotion configuration includes custom chat message components that simulate iPhone-style messaging interfaces with animated typing effects, bubble appearances, and realistic timing. Videos are rendered at mobile-optimized dimensions (390x844) suitable for vertical social media content.\n\n## Authentication & Authorization\n\nUser authentication is managed through Supabase Auth with session-based middleware. The middleware handles automatic redirects for protected routes and preserves the original destination when redirecting unauthenticated users to login. Auth state is managed client-side with automatic session refresh.\n\n## Data Storage & Management\n\nUser data including saved scripts, character configurations, and render job status are stored in Supabase. The application supports saving and loading chat scripts with full character and message data persistence. Video files are stored in Azure Blob Storage with time-limited SAS URLs for secure access.\n\n## Worker Architecture\n\nVideo rendering is handled by a separate worker system that can operate in two modes:\n- **Queue-based**: Using Redis/BullMQ for job queuing (production)\n- **Polling-based**: Direct Supabase polling for simpler deployment scenarios\n\nThe worker uses Remotion's headless renderer with Chromium to generate final videos, uploading completed files to Azure Blob Storage and updating job status in Supabase.\n\n# External Dependencies\n\n## Core Services\n- **Supabase**: Primary database, authentication, and real-time subscriptions\n- **Azure Blob Storage**: Video file storage with SAS token-based access\n- **Redis/BullMQ**: Optional job queue system for scalable rendering\n\n## Video & Media Processing\n- **Remotion**: Video composition and rendering engine\n- **@sparticuz/chromium**: Optimized Chromium build for serverless environments\n- **@remotion/player**: Client-side video preview component\n\n## UI & Styling\n- **shadcn/ui**: Component library built on Radix UI primitives\n- **Tailwind CSS**: Utility-first CSS framework with custom design tokens\n- **Lucide React**: Icon library for consistent iconography\n\n## Development & Deployment\n- **Vercel**: Hosting platform with optimized Next.js deployment\n- **TypeScript**: Type safety and enhanced development experience\n- **Geist Font**: Modern font stack for improved typography","size_bytes":3723},"lib/dist/azure-blob.js":{"content":"const { BlobServiceClient, generateBlobSASQueryParameters, BlobSASPermissions, SASProtocol, StorageSharedKeyCredential } = require('@azure/storage-blob');\nconst { extname } = require('path');\nconst { createReadStream } = require('fs');\n\nlet blobServiceClient = null;\n\nfunction getBlobServiceClient() {\n  if (blobServiceClient) return blobServiceClient;\n  const connStr = process.env.AZURE_STORAGE_CONNECTION_STRING;\n  if (!connStr) throw new Error('AZURE_STORAGE_CONNECTION_STRING env var required');\n  blobServiceClient = BlobServiceClient.fromConnectionString(connStr);\n  return blobServiceClient;\n}\n\nasync function uploadToAzureBlob(filePath, blobName, containerName = 'videos') {\n  const client = getBlobServiceClient();\n  const container = client.getContainerClient(containerName);\n  await container.createIfNotExists();\n  if (!blobName.includes('.')) {\n    blobName += extname(filePath) || '.mp4';\n  }\n  const blockBlob = container.getBlockBlobClient(blobName);\n  const stream = createReadStream(filePath);\n  await blockBlob.uploadStream(stream, 4 * 1024 * 1024, 5, { blobHTTPHeaders: { blobContentType: 'video/mp4' } });\n  return blockBlob.name;\n}\n\nfunction generateSASUrl(blobName, expiryMinutes = 60, containerName = 'videos') {\n  const accountName = process.env.AZURE_STORAGE_ACCOUNT_NAME;\n  const accountKey = process.env.AZURE_STORAGE_ACCOUNT_KEY;\n  if (!accountName || !accountKey) throw new Error('AZURE_STORAGE_ACCOUNT_NAME & AZURE_STORAGE_ACCOUNT_KEY required');\n  const sharedKeyCredential = new StorageSharedKeyCredential(accountName, accountKey);\n  const expiresOn = new Date(Date.now() + expiryMinutes * 60 * 1000);\n  const sas = generateBlobSASQueryParameters({\n    containerName,\n    blobName,\n    permissions: BlobSASPermissions.parse('r'),\n    startsOn: new Date(Date.now() - 5 * 60 * 1000),\n    expiresOn,\n    protocol: SASProtocol.Https,\n  }, sharedKeyCredential).toString();\n  return `https://${accountName}.blob.core.windows.net/${containerName}/${encodeURIComponent(blobName)}?${sas}`;\n}\n\nmodule.exports = { uploadToAzureBlob, generateSASUrl };","size_bytes":2073},"lib/dist/queue.js":{"content":"const { Queue } = require('bullmq');\n\nconst RENDER_QUEUE_NAME = 'video-render-jobs';\n\nlet queue = null;\n\nfunction getRenderQueue() {\n  if (!queue) {\n    if (!process.env.REDIS_URL) {\n      throw new Error('REDIS_URL env var required for queue');\n    }\n    queue = new Queue(RENDER_QUEUE_NAME, {\n      connection: {\n        url: process.env.REDIS_URL,\n      },\n      defaultJobOptions: {\n        removeOnComplete: 1000,\n        removeOnFail: 1000,\n        attempts: 3,\n        backoff: {\n          type: 'exponential',\n          delay: 5000,\n        },\n      },\n    });\n  }\n  return queue;\n}\n\nmodule.exports = { getRenderQueue, RENDER_QUEUE_NAME };","size_bytes":647},"remotion/themes.ts":{"content":"export interface ChatTheme {\n  name: string;\n  colors: {\n    sent: string;\n    received: string;\n    sentText: string;\n    receivedText: string;\n    background: string;\n    headerBackground: string;\n    headerBorder: string;\n    headerText: string;\n    statusBar: string;\n    typingBubbleSent: string;\n    typingBubbleReceived: string;\n    typingDotSent: string;\n    typingDotReceived: string;\n    keyboardBackground: string;\n    keyboardBorder: string;\n    keyboardKey: string;\n    keyboardKeyActive: string;\n    inputBackground: string;\n    inputText: string;\n    deliveredText: string;\n  };\n  bubble: {\n    maxWidth: string;\n    padding: string;\n    fontSize: number;\n    lineHeight: number;\n    fontFamily: string;\n    borderRadius: {\n      sent: {\n        topLeft: (first: boolean) => number;\n        topRight: (first: boolean) => number;\n        bottomLeft: (last: boolean) => number;\n        bottomRight: (last: boolean) => number;\n      };\n      received: {\n        topLeft: (first: boolean) => number;\n        topRight: (first: boolean) => number;\n        bottomLeft: (last: boolean) => number;\n        bottomRight: (last: boolean) => number;\n      };\n    };\n    shadow: {\n      sent: string;\n      received: string;\n    };\n    letterSpacing: number;\n    marginBottom: number;\n  };\n  header: {\n    height: number;\n    fontSize: number;\n    fontWeight: number;\n  };\n  statusBar: {\n    height: number;\n    fontSize: number;\n    fontWeight: number;\n  };\n  keyboard: {\n    height: number;\n    keyBorderRadius: number;\n    keyFontSize: number;\n    keyFontWeight: number;\n  };\n}\n\nexport const themes: Record<string, ChatTheme> = {\n  imessage: {\n    name: 'iMessage',\n    colors: {\n      sent: '#007AFF',\n      received: '#E5E5EA',\n      sentText: '#ffffff',\n      receivedText: '#000000',\n      background: '#FFFFFF',\n      headerBackground: '#F2F2F7',\n      headerBorder: '#C7C7CC',\n      headerText: '#007AFF',\n      statusBar: '#000000',\n      typingBubbleSent: '#007AFF',\n      typingBubbleReceived: '#E5E5EA',\n      typingDotSent: '#ffffff',\n      typingDotReceived: '#6E6E73',\n      keyboardBackground: '#D1D4DA',\n      keyboardBorder: '#B4B7BD',\n      keyboardKey: '#ffffff',\n      keyboardKeyActive: '#8E8E93',\n      inputBackground: '#FFFFFF',\n      inputText: '#000000',\n      deliveredText: '#8E8E93',\n    },\n    bubble: {\n      maxWidth: '78%',\n      padding: '8px 14px',\n      fontSize: 17,\n      lineHeight: 1.25,\n  fontFamily: 'SF Pro Text, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\", sans-serif',\n      borderRadius: {\n        sent: {\n          topLeft: (first) => first ? 18 : 6,\n          topRight: (first) => 18,\n          bottomLeft: (last) => 18,\n          bottomRight: (last) => last ? 18 : 6,\n        },\n        received: {\n          topLeft: (first) => 18,\n          topRight: (first) => first ? 18 : 6,\n          bottomLeft: (last) => last ? 18 : 6,\n          bottomRight: (last) => 18,\n        },\n      },\n      shadow: {\n        sent: '0 1px 1px rgba(0,0,0,.25)',\n        received: '0 1px 1px rgba(0,0,0,.15)',\n      },\n    letterSpacing: -0.2,\n    marginBottom: 8,\n    },\n    header: {\n      height: 52,\n      fontSize: 17,\n      fontWeight: 600,\n    },\n    statusBar: {\n      height: 44,\n      fontSize: 15,\n      fontWeight: 600,\n    },\n    keyboard: {\n      height: 300,\n      keyBorderRadius: 6,\n      keyFontSize: 14,\n      keyFontWeight: 500,\n    },\n  },\n\n  whatsapp: {\n    name: 'WhatsApp',\n    colors: {\n      sent: '#25D366',\n      received: '#FFFFFF',\n      sentText: '#ffffff',\n      receivedText: '#000000',\n      background: '#E5DDD5',\n      headerBackground: '#075E54',\n      headerBorder: '#054640',\n      headerText: '#ffffff',\n      statusBar: '#ffffff',\n      typingBubbleSent: '#25D366',\n      typingBubbleReceived: '#FFFFFF',\n      typingDotSent: '#ffffff',\n      typingDotReceived: '#9E9E9E',\n      keyboardBackground: '#F0F0F0',\n      keyboardBorder: '#CCCCCC',\n      keyboardKey: '#ffffff',\n      keyboardKeyActive: '#DDDDDD',\n      inputBackground: '#FFFFFF',\n      inputText: '#000000',\n      deliveredText: '#9E9E9E',\n    },\n    bubble: {\n      maxWidth: '75%',\n      padding: '6px 12px',\n      fontSize: 16,\n      lineHeight: 1.3,\n  fontFamily: 'Roboto, \"Helvetica Neue\", Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\", sans-serif',\n      borderRadius: {\n        sent: {\n          topLeft: (first) => 8,\n          topRight: (first) => first ? 8 : 3,\n          bottomLeft: (last) => 8,\n          bottomRight: (last) => last ? 8 : 3,\n        },\n        received: {\n          topLeft: (first) => first ? 8 : 3,\n          topRight: (first) => 8,\n          bottomLeft: (last) => last ? 8 : 3,\n          bottomRight: (last) => 8,\n        },\n      },\n      shadow: {\n        sent: '0 1px 2px rgba(0,0,0,.2)',\n        received: '0 1px 2px rgba(0,0,0,.1)',\n      },\n      letterSpacing: 0,\n  marginBottom: 8,\n    },\n    header: {\n      height: 56,\n      fontSize: 18,\n      fontWeight: 500,\n    },\n    statusBar: {\n      height: 44,\n      fontSize: 15,\n      fontWeight: 500,\n    },\n    keyboard: {\n      height: 280,\n      keyBorderRadius: 4,\n      keyFontSize: 15,\n      keyFontWeight: 400,\n    },\n  },\n\n  snapchat: {\n    name: 'Snapchat',\n    colors: {\n      sent: '#FFFC00',\n      received: '#F5F5F5',\n      sentText: '#000000',\n      receivedText: '#000000',\n      background: '#FFFFFF',\n      headerBackground: '#FFFC00',\n      headerBorder: '#E6E300',\n      headerText: '#000000',\n      statusBar: '#000000',\n      typingBubbleSent: '#FFFC00',\n      typingBubbleReceived: '#F5F5F5',\n      typingDotSent: '#000000',\n      typingDotReceived: '#9E9E9E',\n      keyboardBackground: '#F8F8F8',\n      keyboardBorder: '#E0E0E0',\n      keyboardKey: '#ffffff',\n      keyboardKeyActive: '#FFFC00',\n      inputBackground: '#FFFFFF',\n      inputText: '#000000',\n      deliveredText: '#9E9E9E',\n    },\n    bubble: {\n      maxWidth: '80%',\n      padding: '10px 16px',\n      fontSize: 16,\n      lineHeight: 1.4,\n  fontFamily: 'Avenir Next, \"Helvetica Neue\", Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\", sans-serif',\n      borderRadius: {\n        sent: {\n          topLeft: (first) => 20,\n          topRight: (first) => first ? 20 : 8,\n          bottomLeft: (last) => 20,\n          bottomRight: (last) => last ? 20 : 8,\n        },\n        received: {\n          topLeft: (first) => first ? 20 : 8,\n          topRight: (first) => 20,\n          bottomLeft: (last) => last ? 20 : 8,\n          bottomRight: (last) => 20,\n        },\n      },\n      shadow: {\n        sent: '0 2px 8px rgba(255, 252, 0, 0.3)',\n        received: '0 1px 4px rgba(0,0,0,.1)',\n      },\n      letterSpacing: 0.2,\n  marginBottom: 10,\n    },\n    header: {\n      height: 50,\n      fontSize: 18,\n      fontWeight: 700,\n    },\n    statusBar: {\n      height: 44,\n      fontSize: 15,\n      fontWeight: 600,\n    },\n    keyboard: {\n      height: 290,\n      keyBorderRadius: 8,\n      keyFontSize: 16,\n      keyFontWeight: 500,\n    },\n  },\n};\n\nexport const getTheme = (themeName: string): ChatTheme => {\n  return themes[themeName] || themes.imessage;\n};","size_bytes":7200},"tailwind.config.js":{"content":"/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  darkMode: [\"class\"],\n  content: [\n    './pages/**/*.{ts,tsx}',\n    './components/**/*.{ts,tsx}',\n    './app/**/*.{ts,tsx}',\n    './src/**/*.{ts,tsx}',\n  ],\n  theme: {\n    container: {\n      center: true,\n      padding: \"2rem\",\n      screens: {\n        \"2xl\": \"1400px\",\n      },\n    },\n    extend: {\n      colors: {\n        border: \"var(--border)\",\n        input: \"var(--input)\",\n        ring: \"var(--ring)\",\n        background: \"var(--background)\",\n        foreground: \"var(--foreground)\",\n        primary: {\n          DEFAULT: \"var(--primary)\",\n          foreground: \"var(--primary-foreground)\",\n        },\n        secondary: {\n          DEFAULT: \"var(--secondary)\",\n          foreground: \"var(--secondary-foreground)\",\n        },\n        destructive: {\n          DEFAULT: \"var(--destructive)\",\n          foreground: \"var(--destructive-foreground)\",\n        },\n        muted: {\n          DEFAULT: \"var(--muted)\",\n          foreground: \"var(--muted-foreground)\",\n        },\n        accent: {\n          DEFAULT: \"var(--accent)\",\n          foreground: \"var(--accent-foreground)\",\n        },\n        popover: {\n          DEFAULT: \"var(--popover)\",\n          foreground: \"var(--popover-foreground)\",\n        },\n        card: {\n          DEFAULT: \"var(--card)\",\n          foreground: \"var(--card-foreground)\",\n        },\n      },\n      borderRadius: {\n        lg: \"var(--radius)\",\n        md: \"calc(var(--radius) - 2px)\",\n        sm: \"calc(var(--radius) - 4px)\",\n      },\n      keyframes: {\n        \"accordion-down\": {\n          from: { height: 0 },\n          to: { height: \"var(--radix-accordion-content-height)\" },\n        },\n        \"accordion-up\": {\n          from: { height: \"var(--radix-accordion-content-height)\" },\n          to: { height: 0 },\n        },\n      },\n      animation: {\n        \"accordion-down\": \"accordion-down 0.2s ease-out\",\n        \"accordion-up\": \"accordion-up 0.2s ease-out\",\n      },\n    },\n  },\n  plugins: [require(\"tailwindcss-animate\")],\n}","size_bytes":2030},"lib/store.ts":{"content":"import { create } from 'zustand'\n\ninterface Character {\n  id: string\n  name: string\n  color: string\n  avatar?: string\n}\n\ninterface Message {\n  id: string\n  characterId: string\n  text: string\n  timestamp: number\n}\n\ninterface RenderProgress {\n  isRendering: boolean\n  progress: number\n  status: 'idle' | 'pending' | 'rendering' | 'done' | 'error'\n  jobId?: string\n  downloadUrl?: string\n  error?: string\n}\n\ninterface AppState {\n  // UI State\n  isSidebarCollapsed: boolean\n  activeTab: 'editor' | 'projects' | 'renders' | 'settings'\n  theme: 'dark' | 'light'\n  \n  // Composition State\n  characters: Character[]\n  messages: Message[]\n  contactName: string\n  selectedTheme: 'imessage' | 'whatsapp' | 'snapchat'\n  \n  // Render State\n  renderProgress: RenderProgress\n  \n  // User State\n  user: any\n  \n  // Actions\n  setSidebarCollapsed: (collapsed: boolean) => void\n  setActiveTab: (tab: 'editor' | 'projects' | 'renders' | 'settings') => void\n  setTheme: (theme: 'dark' | 'light') => void\n  \n  // Composition Actions\n  setContactName: (name: string) => void\n  setSelectedTheme: (theme: 'imessage' | 'whatsapp' | 'snapchat') => void\n  addMessage: () => void\n  updateMessage: (id: string, text: string) => void\n  toggleMessageSpeaker: (id: string, speaker: 'them' | 'you') => void\n  deleteMessage: (id: string) => void\n  setCharacters: (characters: Character[]) => void\n  setMessages: (messages: Message[]) => void\n  \n  // Render Actions\n  setRenderProgress: (progress: Partial<RenderProgress>) => void\n  resetRender: () => void\n  \n  // User Actions\n  setUser: (user: any) => void\n}\n\nexport const useAppStore = create<AppState>((set, get) => ({\n  // Initial UI State\n  isSidebarCollapsed: false,\n  activeTab: 'editor',\n  theme: 'light',\n  \n  // Initial Composition State\n  characters: [\n    { id: \"them\", name: \"Contact\", color: \"bg-blue-500\" },\n    { id: \"you\", name: \"You\", color: \"bg-green-500\" },\n  ],\n  messages: [],\n  contactName: \"Contact\",\n  selectedTheme: 'imessage',\n  \n  // Initial Render State\n  renderProgress: {\n    isRendering: false,\n    progress: 0,\n    status: 'idle'\n  },\n  \n  // Initial User State\n  user: null,\n  \n  // UI Actions\n  setSidebarCollapsed: (collapsed) => set({ isSidebarCollapsed: collapsed }),\n  setActiveTab: (tab) => set({ activeTab: tab }),\n  setTheme: (theme) => set({ theme }),\n  \n  // Composition Actions\n  setContactName: (name) => {\n    set({ contactName: name })\n    // Also update the \"them\" character name\n    const { characters } = get()\n    const updatedCharacters = characters.map(c => \n      c.id === \"them\" ? { ...c, name } : c\n    )\n    set({ characters: updatedCharacters })\n  },\n  \n  setSelectedTheme: (theme) => set({ selectedTheme: theme }),\n  \n  addMessage: () => {\n    const newMessage: Message = {\n      id: Date.now().toString(),\n      characterId: \"them\",\n      text: \"\",\n      timestamp: Date.now()\n    }\n    set(state => ({ messages: [...state.messages, newMessage] }))\n  },\n  \n  updateMessage: (id, text) => {\n    set(state => ({\n      messages: state.messages.map(m => m.id === id ? { ...m, text } : m)\n    }))\n  },\n  \n  toggleMessageSpeaker: (id, speaker) => {\n    set(state => ({\n      messages: state.messages.map(m => \n        m.id === id ? { ...m, characterId: speaker } : m\n      )\n    }))\n  },\n  \n  deleteMessage: (id) => {\n    set(state => ({\n      messages: state.messages.filter(m => m.id !== id)\n    }))\n  },\n  \n  setCharacters: (characters) => set({ characters }),\n  setMessages: (messages) => set({ messages }),\n  \n  // Render Actions\n  setRenderProgress: (progress) => {\n    set(state => ({\n      renderProgress: { ...state.renderProgress, ...progress }\n    }))\n  },\n  \n  resetRender: () => {\n    set({\n      renderProgress: {\n        isRendering: false,\n        progress: 0,\n        status: 'idle'\n      }\n    })\n  },\n  \n  // User Actions\n  setUser: (user) => set({ user })\n}))","size_bytes":3849},"components/editor/ControlPanel.tsx":{"content":"\"use client\"\n\nimport { motion } from \"framer-motion\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Label } from \"@/components/ui/label\"\nimport { Textarea } from \"@/components/ui/textarea\"\nimport { Plus, Trash2, Sparkles } from \"lucide-react\"\nimport { useAppStore } from \"@/lib/store\"\nimport { useToast } from \"@/hooks/use-toast\"\nimport { useEffect, useRef } from \"react\"\nimport { createClient } from \"@/lib/supabase/client\"\n\n// Theme selection is fixed to iMessage per new design\n\nexport function ControlPanel() {\n  const {\n    contactName,\n    setContactName,\n    selectedTheme,\n    messages,\n    addMessage,\n    updateMessage,\n    toggleMessageSpeaker,\n    deleteMessage,\n    setRenderProgress,\n    resetRender\n  } = useAppStore()\n  \n  const { toast } = useToast()\n  const pollTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n  const isMountedRef = useRef(true)\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      isMountedRef.current = false\n      if (pollTimeoutRef.current) {\n        clearTimeout(pollTimeoutRef.current)\n        pollTimeoutRef.current = null\n      }\n    }\n  }, [])\n\n  const handleRender = async () => {\n    // First, ensure the user is authenticated; otherwise redirect to login\n    try {\n      const supabase = createClient()\n      const { data: { user } } = await supabase.auth.getUser()\n      if (!user) {\n        const redirect = encodeURIComponent('/editor')\n        window.location.href = `/auth/login?redirect=${redirect}`\n        return\n      }\n    } catch {\n      // On any auth check error, fall back to login redirect as a safe default\n      const redirect = encodeURIComponent('/editor')\n      window.location.href = `/auth/login?redirect=${redirect}`\n      return\n    }\n\n    if (messages.length === 0) {\n      toast({\n        title: \"No messages\",\n        description: \"Add some messages first!\",\n        variant: \"destructive\"\n      })\n      return\n    }\n\n    setRenderProgress({\n      isRendering: true,\n      status: 'pending',\n      progress: 0\n    })\n\n    try {\n      const response = await fetch('/api/generate-video', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          characters: [\n            { id: \"them\", name: contactName, color: \"bg-blue-500\" },\n            { id: \"you\", name: \"You\", color: \"bg-green-500\" },\n          ],\n          messages,\n          theme: selectedTheme,\n          contactName,\n          isPro: false\n        }),\n      })\n\n      if (response.status === 401) {\n\n        const redirect = encodeURIComponent('/editor')\n        window.location.href = `/auth/login?redirect=${redirect}`\n        return\n      }\n\n      if (response.status === 202) {\n        const { jobId, statusUrl } = await response.json()\n        setRenderProgress({ jobId, status: 'rendering' })\n        \n        // Start polling for status\n        pollRenderStatus(jobId)\n      } else if (response.ok) {\n        // Direct download (rare path) -> open in new tab using blob URL\n        const blob = await response.blob()\n        const url = URL.createObjectURL(blob)\n        window.open(url, '_blank', 'noopener,noreferrer')\n        // We intentionally do not revoke immediately to allow the tab to load\n        setTimeout(() => URL.revokeObjectURL(url), 30000)\n        resetRender()\n      }\n    } catch (error) {\n      console.error('Render error:', error)\n      setRenderProgress({\n        status: 'error',\n        error: 'Failed to start render'\n      })\n    }\n  }\n\n  const pollRenderStatus = async (jobId: string) => {\n    const poll = async () => {\n      // Check if component is still mounted\n      if (!isMountedRef.current) {\n        return\n      }\n\n      try {\n        const response = await fetch(`/api/render/${jobId}/status`)\n        if (response.ok) {\n          const { status, url, error } = await response.json()\n          \n          // Check again if component is still mounted before updating state\n          if (!isMountedRef.current) {\n            return\n          }\n\n          if (status === 'done' && url) {\n            setRenderProgress({ status: 'done', downloadUrl: url })\n            return\n          }\n          \n          if (status === 'error') {\n            setRenderProgress({ status: 'error', error })\n            return\n          }\n          \n          // Continue polling only if component is still mounted\n          if (isMountedRef.current) {\n            pollTimeoutRef.current = setTimeout(poll, 2000)\n          }\n        }\n      } catch (error) {\n        // Only update state if component is still mounted\n        if (isMountedRef.current) {\n          setRenderProgress({ \n            status: 'error', \n            error: 'Failed to check render status' \n          })\n        }\n      }\n    }\n    \n    poll()\n  }\n\n  return (\n  <div className=\"p-6 space-y-6 h-full pb-28 md:pb-6\">\n      {/* Header */}\n      <motion.div\n        initial={{ y: -20, opacity: 0 }}\n        animate={{ y: 0, opacity: 1 }}\n        transition={{ delay: 0.1 }}\n      >\n        <div className=\"space-y-2\">\n          <h1 className=\"text-3xl md:text-4xl font-extrabold leading-tight tracking-tight text-foreground\">\n            CREATE A FAKE\n            <br />\n            <span className=\"\">iMESSAGE VIDEO</span>\n          </h1>\n          <p className=\"text-muted-foreground text-sm\">\n            Type in any story youâ€™d like to be told in the video\n          </p>\n        </div>\n      </motion.div>\n\n      {/* Contact Name */}\n      <motion.div\n        initial={{ y: -20, opacity: 0 }}\n        animate={{ y: 0, opacity: 1 }}\n        transition={{ delay: 0.2 }}\n        className=\"space-y-3\"\n      >\n        <Label className=\"text-sm font-semibold text-foreground\">Name</Label>\n        <div className=\"flex items-center gap-3 p-3 bg-card rounded-lg border border-border\">\n          <div className=\"w-9 h-9 rounded-full bg-gradient-to-br from-blue-400 to-blue-600 flex items-center justify-center text-white font-medium text-xs\">\n            {contactName.split(\" \").map(p => p[0]).join(\"\").slice(0, 2).toUpperCase() || \"C\"}\n          </div>\n          <Input\n            value={contactName}\n            onChange={(e) => setContactName(e.target.value)}\n            className=\"border-0 bg-transparent focus-visible:ring-0 shadow-none text-foreground placeholder:text-muted-foreground text-sm\"\n            placeholder=\"Enter contact name\"\n          />\n        </div>\n      </motion.div>\n\n      {/* Messages */}\n      <motion.div\n        initial={{ y: -20, opacity: 0 }}\n        animate={{ y: 0, opacity: 1 }}\n        transition={{ delay: 0.3 }}\n        className=\"space-y-4 flex-1 overflow-y-auto\"\n      >\n        <div className=\"flex items-center justify-between\">\n          <Label className=\"text-sm font-semibold text-foreground\">Conversation</Label>\n          <Button\n            onClick={addMessage}\n            size=\"sm\"\n            variant=\"outline\"\n            className=\"border-border text-muted-foreground hover:text-foreground hover:border-muted-foreground\"\n          >\n            <Plus className=\"w-4 h-4 mr-1\" />\n            Add\n          </Button>\n        </div>\n        \n  <div className=\"space-y-3 max-h-[28rem] md:max-h-[30rem] overflow-y-auto pr-1\">\n          {messages.map((message, index) => {\n            const isThem = message.characterId === \"them\"\n            \n            return (\n              <motion.div\n                key={message.id}\n                initial={{ x: -20, opacity: 0 }}\n                animate={{ x: 0, opacity: 1 }}\n                transition={{ delay: 0.1 * index }}\n                className={\n                  `rounded-lg border border-border bg-card relative flex items-stretch gap-0`\n                }\n              >\n                {/* Left accent bar */}\n                <div className={`w-[3px] rounded-l-lg ${isThem ? 'bg-blue-500' : 'bg-green-500'}`} />\n                {/* Text area */}\n                <div className=\"flex-1 p-3\">\n                  <Textarea\n                    value={message.text}\n                    onChange={(e) => updateMessage(message.id, e.target.value)}\n                    placeholder={isThem ? \"Type here...\" : \"Type here...\"}\n                    className=\"resize-none border-0 bg-transparent focus-visible:ring-0 shadow-none text-foreground min-h-[72px] text-sm\"\n                  />\n                </div>\n                {/* Controls */}\n                <div className=\"pr-3 py-3 flex flex-col items-end gap-2 w-[112px]\">\n                  <div className=\"inline-flex p-1 bg-muted rounded-full\">\n                    <button\n                      onClick={() => toggleMessageSpeaker(message.id, \"them\")}\n                      className={`px-3 py-1 text-xs font-medium rounded-full transition ${\n                        isThem ? \"bg-blue-500 text-white\" : \"text-muted-foreground hover:text-foreground\"\n                      }`}\n                    >\n                      Them\n                    </button>\n                    <button\n                      onClick={() => toggleMessageSpeaker(message.id, \"you\")}\n                      className={`px-3 py-1 text-xs font-medium rounded-full transition ${\n                        !isThem ? \"bg-green-500 text-white\" : \"text-muted-foreground hover:text-foreground\"\n                      }`}\n                    >\n                      You\n                    </button>\n                  </div>\n                  <Button\n                    onClick={() => deleteMessage(message.id)}\n                    size=\"icon\"\n                    variant=\"ghost\"\n                    className=\"text-red-600 hover:text-red-600/80 hover:bg-red-100 w-8 h-8\"\n                  >\n                    <Trash2 className=\"w-4 h-4\" />\n                  </Button>\n                </div>\n              </motion.div>\n            )\n          })}\n          \n          {messages.length === 0 && (\n            <div className=\"text-center py-8 text-muted-foreground\">\n              <p className=\"text-sm\">No messages yet</p>\n              <p className=\"text-xs mt-1\">Click \"Add\" to create your first message</p>\n            </div>\n          )}\n        </div>\n      </motion.div>\n\n      {/* Generate Button - desktop */}\n      <motion.div\n        initial={{ y: 20, opacity: 0 }}\n        animate={{ y: 0, opacity: 1 }}\n        transition={{ delay: 0.6 }}\n        className=\"pt-4 border-t border-border hidden md:block\"\n      >\n        <Button\n          onClick={handleRender}\n          disabled={messages.length === 0}\n          className=\"w-full h-12 bg-gradient-to-r from-purple-500 via-pink-500 to-red-500 hover:from-purple-600 hover:via-pink-600 hover:to-red-600 text-white font-semibold text-base shadow-lg\"\n        >\n          <Sparkles className=\"w-5 h-5 mr-2\" />\n          Generate Video\n        </Button>\n      </motion.div>\n\n      {/* Sticky Generate Button - mobile */}\n      <div className=\"md:hidden fixed bottom-20 left-0 right-0 z-40 px-4\">\n        <Button\n          onClick={handleRender}\n          disabled={messages.length === 0}\n          className=\"w-full h-12 bg-gradient-to-r from-purple-500 via-pink-500 to-red-500 hover:from-purple-600 hover:via-pink-600 hover:to-red-600 text-white font-semibold text-base shadow-lg\"\n        >\n          <Sparkles className=\"w-5 h-5 mr-2\" />\n          Generate Video\n        </Button>\n      </div>\n    </div>\n  )\n}","size_bytes":11361},"components/editor/DownloadModal.tsx":{"content":"\"use client\"\n\nimport { motion, AnimatePresence } from \"framer-motion\"\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from \"@/components/ui/dialog\"\nimport { Button } from \"@/components/ui/button\"\nimport { Progress } from \"@/components/ui/progress\"\nimport { CheckCircle, Download, AlertCircle, Loader2 } from \"lucide-react\"\nimport { useAppStore } from \"@/lib/store\"\n\nexport function DownloadModal() {\n  const { renderProgress, resetRender } = useAppStore()\n  const { isRendering, status, progress, downloadUrl, error } = renderProgress\n\n  const createAndClickDownload = (url: string, filename: string) => {\n    const a = document.createElement('a')\n    a.href = url\n    a.download = filename\n    a.rel = 'noopener'\n    a.style.display = 'none'\n    document.body.appendChild(a)\n    a.click()\n    setTimeout(() => a.remove(), 0)\n  }\n\n  const handleDownload = async () => {\n    if (!downloadUrl) return\n    try {\n      const u = new URL(downloadUrl)\n      const isAzure = u.hostname.endsWith('.blob.core.windows.net')\n      if (isAzure) {\n        const pathParts = u.pathname.split('/').filter(Boolean)\n        if (pathParts.length >= 2 && pathParts[0] === 'videos') {\n          const blobName = decodeURIComponent(pathParts.slice(1).join('/'))\n          // Prefer proxy streaming endpoint to hide storage host and force download\n          const proxyUrl = `/api/download?blobName=${encodeURIComponent(blobName)}&filename=${encodeURIComponent('chat-video.mp4')}`\n          createAndClickDownload(proxyUrl, 'chat-video.mp4')\n          return\n        }\n      }\n      // Fallback to original URL if not Azure or re-sign failed\n      createAndClickDownload(downloadUrl, 'chat-video.mp4')\n    } catch {\n      // Any parsing/fetch issues -> fallback\n      createAndClickDownload(downloadUrl, 'chat-video.mp4')\n    }\n  }\n\n  const handleClose = () => {\n    // Only allow closing when done or error, not during rendering\n    if (status === 'done' || status === 'error') {\n      resetRender()\n    }\n  }\n\n  const canClose = status === 'done' || status === 'error'\n\n  const getStatusIcon = () => {\n    switch (status) {\n      case 'pending':\n      case 'rendering':\n        return <Loader2 className=\"w-8 h-8 text-blue-500 animate-spin\" />\n      case 'done':\n        return <CheckCircle className=\"w-8 h-8 text-green-500\" />\n      case 'error':\n        return <AlertCircle className=\"w-8 h-8 text-red-500\" />\n      default:\n        return <Loader2 className=\"w-8 h-8 text-blue-500 animate-spin\" />\n    }\n  }\n\n  const getStatusMessage = () => {\n    switch (status) {\n      case 'pending':\n        return 'Starting render...'\n      case 'rendering':\n        return 'Creating your video...'\n      case 'done':\n        return 'Video is ready!'\n      case 'error':\n        return error || 'Something went wrong'\n      default:\n        return 'Processing...'\n    }\n  }\n\n  const getProgressValue = () => {\n    switch (status) {\n      case 'pending':\n        return 10\n      case 'rendering':\n        return Math.max(20, Math.min(90, progress))\n      case 'done':\n        return 100\n      case 'error':\n        return 0\n      default:\n        return 0\n    }\n  }\n\n  return (\n    <Dialog open={isRendering} onOpenChange={canClose ? handleClose : undefined}>\n      <DialogContent className=\"sm:max-w-md bg-card border-border text-foreground\">\n        <DialogHeader>\n          <DialogTitle className=\"text-center text-xl font-semibold\">\n            {status === 'done' ? 'Download Ready' : 'Generating Video'}\n          </DialogTitle>\n        </DialogHeader>\n        \n        <motion.div \n          className=\"flex flex-col items-center space-y-6 py-6\"\n          initial={{ opacity: 0, y: 20 }}\n          animate={{ opacity: 1, y: 0 }}\n          transition={{ duration: 0.3 }}\n        >\n          {/* Status Icon */}\n          <motion.div\n            key={status}\n            initial={{ scale: 0 }}\n            animate={{ scale: 1 }}\n            transition={{ type: \"spring\", stiffness: 200, damping: 15 }}\n          >\n            {getStatusIcon()}\n          </motion.div>\n\n          {/* Status Message */}\n          <motion.div \n            className=\"text-center space-y-2\"\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            transition={{ delay: 0.1 }}\n          >\n            <p className=\"text-lg font-medium\">\n              {getStatusMessage()}\n            </p>\n            \n            {status !== 'error' && status !== 'done' && (\n              <p className=\"text-sm text-muted-foreground\">\n                This usually takes 30-60 seconds\n              </p>\n            )}\n          </motion.div>\n\n          {/* Progress Bar */}\n          <AnimatePresence>\n            {status !== 'done' && status !== 'error' && (\n              <motion.div \n                className=\"w-full space-y-2\"\n                initial={{ opacity: 0, scale: 0.8 }}\n                animate={{ opacity: 1, scale: 1 }}\n                exit={{ opacity: 0, scale: 0.8 }}\n                transition={{ duration: 0.3 }}\n              >\n                <Progress \n                  value={getProgressValue()} \n                  className=\"w-full h-2 bg-muted\"\n                />\n                <p className=\"text-center text-xs text-muted-foreground\">\n                  {getProgressValue()}% complete\n                </p>\n              </motion.div>\n            )}\n          </AnimatePresence>\n\n          {/* Action Buttons */}\n          <motion.div \n            className=\"flex gap-3 pt-4\"\n            initial={{ opacity: 0, y: 10 }}\n            animate={{ opacity: 1, y: 0 }}\n            transition={{ delay: 0.3 }}\n          >\n            {status === 'done' && (\n              <Button\n                onClick={handleDownload}\n                className=\"bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white px-6\"\n              >\n                <Download className=\"w-4 h-4 mr-2\" />\n                Download Video\n              </Button>\n            )}\n            \n            {status === 'error' && (\n              <Button\n                onClick={handleClose}\n                variant=\"outline\"\n                className=\"border-border text-muted-foreground hover:text-foreground hover:border-muted-foreground\"\n              >\n                Try Again\n              </Button>\n            )}\n            \n            {/* Only show close/cancel button when appropriate */}\n            {canClose && (\n              <Button\n                onClick={handleClose}\n                variant=\"outline\"\n                className=\"border-border text-muted-foreground hover:text-foreground hover:border-muted-foreground\"\n              >\n                {status === 'done' ? 'Close' : 'Cancel'}\n              </Button>\n            )}\n            \n            {/* Show a disabled button during rendering to indicate process is ongoing */}\n            {!canClose && (\n              <Button\n                disabled\n                variant=\"outline\"\n                className=\"border-border text-muted-foreground cursor-not-allowed opacity-50\"\n              >\n                Processing...\n              </Button>\n            )}\n          </motion.div>\n        </motion.div>\n      </DialogContent>\n    </Dialog>\n  )\n}","size_bytes":7246},"components/editor/EditorView.tsx":{"content":"\"use client\"\n\nimport { motion } from \"framer-motion\"\nimport { ControlPanel } from \"./ControlPanel\"\nimport { PreviewPanel } from \"./PreviewPanel\"\nimport { DownloadModal } from \"./DownloadModal\"\nimport { useAppStore } from \"@/lib/store\"\nimport { useState } from \"react\"\n\nexport function EditorView() {\n  const { renderProgress } = useAppStore()\n  const [mobileTab, setMobileTab] = useState<'edit' | 'preview'>('edit')\n\n  return (\n    <div className=\"h-full flex flex-col md:flex-row\">\n      {/* Mobile Tab Switcher */}\n      <div className=\"md:hidden sticky top-0 z-10 bg-background border-b border-border\">\n        <div className=\"grid grid-cols-2\">\n          <button\n            className={`py-3 text-sm font-medium ${mobileTab === 'edit' ? 'text-foreground border-b-2 border-primary' : 'text-muted-foreground'}`}\n            onClick={() => setMobileTab('edit')}\n          >\n            Edit\n          </button>\n          <button\n            className={`py-3 text-sm font-medium ${mobileTab === 'preview' ? 'text-foreground border-b-2 border-primary' : 'text-muted-foreground'}`}\n            onClick={() => setMobileTab('preview')}\n          >\n            Preview\n          </button>\n        </div>\n      </div>\n      {/* Control Panel - Left Side */}\n      <motion.div\n        initial={{ x: -100, opacity: 0 }}\n        animate={{ x: 0, opacity: 1 }}\n        transition={{ duration: 0.5 }}\n        className={`w-full md:w-[40rem] md:border-r border-border bg-card overflow-y-auto md:block ${mobileTab === 'edit' ? 'block' : 'hidden'}`}\n      >\n        <ControlPanel />\n      </motion.div>\n\n      {/* Preview Panel - Right Side */}\n      <motion.div\n        initial={{ x: 100, opacity: 0 }}\n        animate={{ x: 0, opacity: 1 }}\n        transition={{ duration: 0.5, delay: 0.1 }}\n        className={`flex-1 flex items-center justify-center bg-background md:block ${mobileTab === 'preview' ? 'block' : 'hidden'}`}\n      >\n        <PreviewPanel />\n      </motion.div>\n\n      {/* Download Modal */}\n      {renderProgress.isRendering && <DownloadModal />}\n    </div>\n  )\n}","size_bytes":2068},"components/editor/PreviewPanel.tsx":{"content":"\"use client\"\n\nimport { motion } from \"framer-motion\"\nimport { Player } from \"@remotion/player\"\nimport { MessageConversation } from \"@/remotion/MessageConversation\"\nimport { useAppStore } from \"@/lib/store\"\nimport { Smartphone, Play, Pause } from \"lucide-react\"\nimport { useState, useMemo, useRef, useCallback } from \"react\"\n\nexport function PreviewPanel() {\n  const { \n    messages, \n    characters, \n    contactName, \n    selectedTheme \n  } = useAppStore()\n  \n  const [isPlaying, setIsPlaying] = useState(false)\n  const playerRef = useRef<any>(null)\n\n  const inputProps = useMemo(() => ({\n    messages: messages.map((m, index) => ({\n      id: index + 1,\n      text: m.text || \"(empty message)\",\n      sent: m.characterId === \"you\",\n      time: new Date(m.timestamp).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })\n    })),\n    characters: [\n      { id: \"them\", name: contactName, color: \"bg-blue-500\" },\n      { id: \"you\", name: \"You\", color: \"bg-green-500\" },\n    ],\n    theme: selectedTheme,\n    contactName,\n    isPro: false,\n    alwaysShowKeyboard: true\n  }), [messages, characters, contactName, selectedTheme])\n\n  const durationInFrames = Math.max(300, messages.length * 120) // At least 10 seconds, +4 seconds per message\n\n  const handlePlayPause = useCallback(() => {\n    if (playerRef.current) {\n      if (isPlaying) {\n        playerRef.current.pause()\n        setIsPlaying(false)\n      } else {\n        playerRef.current.play()\n        setIsPlaying(true)\n      }\n    }\n  }, [isPlaying])\n\n  const handlePlayerPlayStateChange = useCallback((playing: boolean) => {\n    setIsPlaying(playing)\n  }, [])\n\n  return (\n    <div className=\"flex flex-col items-center justify-center h-full p-4 md:p-8\">\n      <motion.div\n        initial={{ scale: 0.8, opacity: 0 }}\n        animate={{ scale: 1, opacity: 1 }}\n        transition={{ duration: 0.6 }}\n        className=\"space-y-6\"\n      >\n        {/* Header hidden to match screenshot */}\n\n        {/* Phone Frame with Preview */}\n        <motion.div whileHover={{ scale: 1.02 }} transition={{ duration: 0.3 }} className=\"relative\">\n          {/* Composition viewport only (MessageConversation includes its own phone) */}\n          <div className=\"relative w-[320px] h-[600px]\">\n            {messages.length > 0 ? (\n              <Player\n                ref={playerRef}\n                component={MessageConversation}\n                durationInFrames={durationInFrames}\n                fps={30}\n                compositionWidth={390}\n                compositionHeight={844}\n                inputProps={inputProps}\n                controls={false}\n                autoPlay={false}\n                loop\n                style={{ width: '100%', height: '100%', objectFit: 'contain', background: 'transparent', backgroundColor: 'transparent' }}\n              />\n            ) : (\n              <div className=\"flex flex-col items-center justify-center h-full text-muted-foreground\">\n                <Smartphone className=\"w-16 h-16 mb-4 opacity-50\" />\n                <p className=\"text-sm text-center px-8\">Add messages to see your video preview</p>\n              </div>\n            )}\n          </div>\n          {/* Play/Pause Button Overlay */}\n          {messages.length > 0 && (\n            <motion.button\n              initial={{ scale: 0 }}\n              animate={{ scale: 1 }}\n              whileHover={{ scale: 1.1 }}\n              whileTap={{ scale: 0.9 }}\n              onClick={handlePlayPause}\n              className=\"absolute inset-0 flex items-center justify-center\"\n            >\n              <div className=\"w-16 h-16 bg-black/20 backdrop-blur rounded-full flex items-center justify-center shadow-lg\">\n                {isPlaying ? (\n                  <Pause className=\"w-8 h-8 text-white\" />\n                ) : (\n                  <Play className=\"w-8 h-8 text-white ml-1\" />\n                )}\n              </div>\n            </motion.button>\n          )}\n        </motion.div>\n\n        {/* Low-res preview label */}\n        <div className=\"w-full flex items-center justify-center\">\n          <div className=\"px-4 py-2 rounded-full bg-black text-white/90 text-sm shadow-sm\">Low-res preview</div>\n        </div>\n      </motion.div>\n    </div>\n  )\n}","size_bytes":4229},"components/layout/MainLayout.tsx":{"content":"\"use client\"\n\nimport { motion } from \"framer-motion\"\nimport { Navbar } from \"./Navbar\"\nimport { EditorView } from \"../editor/EditorView\"\nimport { ProjectsView } from \"../projects/ProjectsView\"\nimport { RendersView } from \"../renders/RendersView\"\nimport { SettingsView } from \"../settings/SettingsView\"\nimport { useAppStore } from \"@/lib/store\"\nimport { useEffect } from \"react\"\nimport { createClient } from \"@/lib/supabase/client\"\n\nexport function MainLayout() {\n  const { activeTab, setUser } = useAppStore()\n  const supabase = createClient()\n\n  useEffect(() => {\n    const fetchUser = async () => {\n      const { data: { user } } = await supabase.auth.getUser()\n      setUser(user)\n    }\n    fetchUser()\n\n    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {\n      setUser(session?.user ?? null)\n    })\n\n    return () => subscription.unsubscribe()\n  }, [setUser])\n\n  const renderContent = () => {\n    switch (activeTab) {\n      case 'editor':\n        return <EditorView />\n      case 'projects':\n        return <ProjectsView />\n      case 'renders':\n        return <RendersView />\n      case 'settings':\n        return <SettingsView />\n      default:\n        return <EditorView />\n    }\n  }\n\n  return (\n    <div className=\"min-h-screen bg-background text-foreground\">\n      <Navbar />\n      <div className=\"flex h-[calc(100vh-4rem)]\">\n        <motion.main\n          key={activeTab}\n          initial={{ opacity: 0, y: 20 }}\n          animate={{ opacity: 1, y: 0 }}\n          transition={{ duration: 0.3 }}\n          className=\"flex-1 overflow-auto md:overflow-hidden pb-24 md:pb-0\"\n        >\n          {renderContent()}\n        </motion.main>\n      </div>\n    </div>\n  )\n}","size_bytes":1714},"components/layout/Navbar.tsx":{"content":"\"use client\"\n\nimport { motion } from \"framer-motion\"\nimport { Button } from \"@/components/ui/button\"\nimport Image from \"next/image\"\nimport { \n  Menu, \n  User, \n  Settings, \n  LogOut,\n  MessageSquare \n} from \"lucide-react\"\nimport { useAppStore } from \"@/lib/store\"\nimport { createClient } from \"@/lib/supabase/client\"\nimport { useRouter } from \"next/navigation\"\n\nexport function Navbar() {\n  const { \n    isSidebarCollapsed, \n    setSidebarCollapsed, \n    user, \n    setUser \n  } = useAppStore()\n  \n  const router = useRouter()\n  const supabase = createClient()\n\n  const handleSignOut = async () => {\n    await supabase.auth.signOut()\n    setUser(null)\n    router.push(\"/\")\n  }\n\n  return (\n    <motion.nav\n      initial={{ y: -100, opacity: 0 }}\n      animate={{ y: 0, opacity: 1 }}\n      transition={{ duration: 0.5 }}\n      className=\"h-16 border-b border-border bg-card backdrop-blur supports-[backdrop-filter]:bg-card/95 px-4 flex items-center justify-between relative z-50\"\n    >\n      {/* Left Section */}\n      <div className=\"flex items-center gap-4\">\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          onClick={() => setSidebarCollapsed(!isSidebarCollapsed)}\n          className=\"text-muted-foreground hover:text-foreground hover:bg-accent md:hidden\"\n        >\n          <Menu className=\"w-5 h-5\" />\n        </Button>\n        \n        <motion.div \n          className=\"flex items-center gap-3\"\n          whileHover={{ scale: 1.05 }}\n        >\n          <Image src=\"/logo.png\" alt=\"logo\" width={140} height={36} />\n        </motion.div>\n      </div>\n\n      {/* Right Section */}\n      <div className=\"flex items-center gap-3\">\n        {user && (\n          <>\n            <div className=\"hidden sm:flex items-center gap-2 text-sm text-muted-foreground\">\n              <span>Welcome back,</span>\n              <span className=\"text-foreground font-medium\">\n                {user.user_metadata?.full_name || user.email?.split(\"@\")[0] || \"User\"}\n              </span>\n            </div>\n            \n            <div className=\"flex items-center gap-1\">\n              <Button\n                variant=\"ghost\"\n                size=\"icon\"\n                className=\"text-muted-foreground hover:text-foreground hover:bg-accent\"\n              >\n                <Settings className=\"w-4 h-4\" />\n              </Button>\n              \n              <Button\n                variant=\"ghost\"\n                size=\"icon\"\n                onClick={handleSignOut}\n                className=\"text-muted-foreground hover:text-foreground hover:bg-accent\"\n              >\n                <LogOut className=\"w-4 h-4\" />\n              </Button>\n            </div>\n          </>\n        )}\n        \n        {!user && (\n          <Button\n            variant=\"outline\"\n            size=\"sm\"\n            className=\"border-border text-muted-foreground hover:text-foreground hover:border-muted-foreground\"\n            onClick={() => router.push(\"/auth/login\")}\n          >\n            Sign In\n          </Button>\n        )}\n      </div>\n    </motion.nav>\n  )\n}","size_bytes":3060},"components/layout/Sidebar.tsx":{"content":"\"use client\"\n\nimport { motion } from \"framer-motion\"\nimport { Button } from \"@/components/ui/button\"\nimport { \n  Video, \n  FolderOpen, \n  Settings, \n  Plus,\n  Zap,\n  Star\n} from \"lucide-react\"\nimport { useAppStore } from \"@/lib/store\"\nimport { cn } from \"@/lib/utils\"\n\nconst navItems = [\n  { id: 'editor', label: 'Editor', icon: Video },\n  { id: 'projects', label: 'Projects', icon: FolderOpen },\n  { id: 'renders', label: 'Renders', icon: Zap },\n  { id: 'settings', label: 'Settings', icon: Settings },\n] as const\n\nexport function Sidebar() {\n  const { \n    isSidebarCollapsed, \n    activeTab, \n    setActiveTab \n  } = useAppStore()\n\n  const sidebarVariants = {\n    expanded: { width: 280, opacity: 1 },\n    collapsed: { width: 0, opacity: 0 }\n  }\n\n  return (\n    <>\n      {/* Desktop Sidebar */}\n      <motion.aside\n        variants={sidebarVariants}\n        animate={isSidebarCollapsed ? \"collapsed\" : \"expanded\"}\n        transition={{ duration: 0.3 }}\n        className=\"hidden md:flex flex-col bg-card border-r border-border overflow-hidden relative\"\n      >\n        <div className=\"p-6 space-y-6 h-full flex flex-col\">\n          {/* Create New Button */}\n          <motion.div\n            initial={{ scale: 0.9, opacity: 0 }}\n            animate={{ scale: 1, opacity: 1 }}\n            transition={{ delay: 0.1 }}\n          >\n            <Button \n              className=\"w-full bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white shadow-lg\"\n              size=\"lg\"\n              onClick={() => setActiveTab('editor')}\n            >\n              <Plus className=\"w-4 h-4 mr-2\" />\n              Create New\n            </Button>\n          </motion.div>\n\n          {/* Navigation */}\n          <nav className=\"space-y-2 flex-1\">\n            {navItems.map((item, index) => (\n              <motion.div\n                key={item.id}\n                initial={{ x: -20, opacity: 0 }}\n                animate={{ x: 0, opacity: 1 }}\n                transition={{ delay: 0.1 + index * 0.1 }}\n              >\n                <Button\n                  variant=\"ghost\"\n                  className={cn(\n                    \"w-full justify-start text-muted-foreground hover:text-foreground hover:bg-accent transition-colors\",\n                    activeTab === item.id && \"bg-accent text-foreground\"\n                  )}\n                  onClick={() => setActiveTab(item.id)}\n                >\n                  <item.icon className=\"w-4 h-4 mr-3\" />\n                  {item.label}\n                </Button>\n              </motion.div>\n            ))}\n          </nav>\n\n          {/* Upgrade Section */}\n          <motion.div\n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.6 }}\n            className=\"p-4 rounded-xl bg-gradient-to-br from-purple-100 to-pink-100 border border-border\"\n          >\n            <div className=\"flex items-center gap-2 mb-2\">\n              <Star className=\"w-4 h-4 text-yellow-500\" />\n              <span className=\"text-sm font-semibold text-foreground\">Go Pro</span>\n            </div>\n            <p className=\"text-xs text-muted-foreground mb-3\">\n              Unlock unlimited renders and premium features\n            </p>\n            <Button \n              size=\"sm\" \n              className=\"w-full bg-gradient-to-r from-yellow-400 to-orange-400 text-black hover:from-yellow-500 hover:to-orange-500 font-medium\"\n            >\n              Upgrade Now\n            </Button>\n          </motion.div>\n        </div>\n      </motion.aside>\n\n      {/* Mobile Bottom Navigation */}\n      <motion.div\n        initial={{ y: 100, opacity: 0 }}\n        animate={{ y: 0, opacity: 1 }}\n        transition={{ delay: 0.3 }}\n        className=\"md:hidden fixed bottom-0 left-0 right-0 z-50 bg-card border-t border-border p-4\"\n      >\n        <div className=\"flex items-center justify-around\">\n          {navItems.slice(0, 4).map((item) => (\n            <Button\n              key={item.id}\n              variant=\"ghost\"\n              size=\"icon\"\n              className={cn(\n                \"text-muted-foreground hover:text-foreground\",\n                activeTab === item.id && \"text-foreground bg-accent\"\n              )}\n              onClick={() => setActiveTab(item.id)}\n            >\n              <item.icon className=\"w-5 h-5\" />\n            </Button>\n          ))}\n        </div>\n      </motion.div>\n    </>\n  )\n}","size_bytes":4449},"components/projects/ProjectsView.tsx":{"content":"\"use client\"\n\nimport { motion } from \"framer-motion\"\nimport { FolderOpen } from \"lucide-react\"\n\nexport function ProjectsView() {\n  return (\n    <motion.div\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      className=\"h-full p-8 overflow-y-auto\"\n    >\n      <div className=\"max-w-4xl mx-auto\">\n        <h1 className=\"text-3xl font-bold text-foreground mb-6\">Projects</h1>\n        <div className=\"bg-card rounded-xl p-12 text-center border border-border\">\n          <FolderOpen className=\"w-16 h-16 text-muted-foreground mx-auto mb-4\" />\n          <h2 className=\"text-xl font-semibold text-foreground mb-2\">No projects yet</h2>\n          <p className=\"text-muted-foreground\">\n            Your saved projects will appear here. Start creating to build your library!\n          </p>\n        </div>\n      </div>\n    </motion.div>\n  )\n}","size_bytes":846},"components/renders/RendersView.tsx":{"content":"\"use client\"\n\nimport { motion } from \"framer-motion\"\nimport { Zap } from \"lucide-react\"\n\nexport function RendersView() {\n  return (\n    <motion.div\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      className=\"h-full p-8 overflow-y-auto\"\n    >\n      <div className=\"max-w-4xl mx-auto\">\n        <h1 className=\"text-3xl font-bold text-foreground mb-6\">Renders</h1>\n        <div className=\"bg-card rounded-xl p-12 text-center border border-border\">\n          <Zap className=\"w-16 h-16 text-muted-foreground mx-auto mb-4\" />\n          <h2 className=\"text-xl font-semibold text-foreground mb-2\">No renders yet</h2>\n          <p className=\"text-muted-foreground\">\n            Your completed video renders will be listed here for easy access.\n          </p>\n        </div>\n      </div>\n    </motion.div>\n  )\n}","size_bytes":819},"components/settings/SettingsView.tsx":{"content":"\"use client\"\n\nimport { motion } from \"framer-motion\"\nimport { Settings } from \"lucide-react\"\n\nexport function SettingsView() {\n  return (\n    <motion.div\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      className=\"h-full p-8 overflow-y-auto\"\n    >\n      <div className=\"max-w-4xl mx-auto\">\n        <h1 className=\"text-3xl font-bold text-foreground mb-6\">Settings</h1>\n        <div className=\"bg-card rounded-xl p-12 text-center border border-border\">\n          <Settings className=\"w-16 h-16 text-muted-foreground mx-auto mb-4\" />\n          <h2 className=\"text-xl font-semibold text-foreground mb-2\">Settings</h2>\n          <p className=\"text-muted-foreground\">\n            App preferences and configuration options will be available here.\n          </p>\n        </div>\n      </div>\n    </motion.div>\n  )\n}","size_bytes":825},"components/ui/progress.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as ProgressPrimitive from \"@radix-ui/react-progress\"\nimport { cn } from \"@/lib/utils\"\n\nconst Progress = React.forwardRef<\n  React.ElementRef<typeof ProgressPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\n>(({ className, value, ...props }, ref) => (\n  <ProgressPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative h-4 w-full overflow-hidden rounded-full bg-secondary\",\n      className\n    )}\n    {...props}\n  >\n    <ProgressPrimitive.Indicator\n      className=\"h-full w-full flex-1 bg-primary transition-all\"\n      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}\n    />\n  </ProgressPrimitive.Root>\n))\nProgress.displayName = ProgressPrimitive.Root.displayName\n\nexport { Progress }","size_bytes":789},"lib/emoji-util.ts":{"content":"","size_bytes":0},"lib/emoji.tsx":{"content":"","size_bytes":0},"remotion/emoji.ts":{"content":"import twemoji from 'twemoji';\n/**\n * Converts a text string into HTML with emoji images using Twemoji, ensuring consistent emoji rendering\n * in headless environments where system color emoji fonts might be unavailable.\n */\nexport const renderEmojiHTML = (text: string): string => {\n  if (!text) return '';\n  try {\n    return twemoji.parse(text, {\n      folder: 'svg',\n      ext: '.svg',\n      base: 'https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/',\n      attributes: () => ({\n        draggable: 'false',\n        height: '1em',\n        width: '1em',\n        style: 'display:inline-block;vertical-align:-0.125em;'\n      })\n    });\n  } catch {\n    return text;\n  }\n};\n","size_bytes":675},"components/landing/HomeCard.tsx":{"content":"\"use client\"\n\nimport Image from \"next/image\"\nimport Link from \"next/link\"\nimport { ReactNode } from \"react\"\n\ntype Props = {\n  title: string\n  description: string\n  href: string\n  gradient: string // tailwind gradient classes\n  icon: ReactNode\n  imageSrc?: string\n}\n\nexport function HomeCard({ title, description, href, gradient, icon, imageSrc }: Props) {\n  return (\n    <Link href={href} className=\"group block\">\n      <div className={`relative overflow-hidden rounded-2xl border border-border ${gradient} p-5 md:p-6 shadow-sm`}>\n        <div className=\"flex items-center gap-4\">\n          <div className=\"rounded-lg bg-white/80 p-2 text-foreground shadow-sm\">\n            {icon}\n          </div>\n          <div className=\"flex-1\">\n            <h3 className=\"text-xl md:text-2xl font-bold text-foreground\">{title}</h3>\n            <p className=\"text-xs md:text-sm text-foreground/80 mt-1 max-w-xl\">{description}</p>\n          </div>\n          {imageSrc && (\n            <div className=\"hidden sm:block relative\">\n              <div className=\"relative  rounded-2xl shadow-lg shadow-black/10 overflow-hidden w-28 h-20 md:w-20 md:h-24 translate-x-2 group-hover:translate-x-3 transition-transform\">\n                <Image src={imageSrc} alt=\"Preview\" fill className=\"object-contain\" />\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n    </Link>\n  )\n}\n","size_bytes":1383},"components/landing/HomeSidebar.tsx":{"content":"\"use client\"\n\nimport Image from \"next/image\"\nimport Link from \"next/link\"\nimport { Button } from \"@/components/ui/button\"\nimport { ChevronRight, Plus, Megaphone, Zap, Users, Disc, Linkedin , Instagram } from \"lucide-react\"\n\nexport function HomeSidebar() {\n  return (\n    <aside className=\"hidden md:flex w-[280px] shrink-0 flex-col gap-4 border-r border-border bg-card p-4\">\n\n      <Button className=\"w-full bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white\" size=\"lg\">\n        <Plus className=\"w-4 h-4 mr-2\" /> Create new\n      </Button>\n\n      <Link href=\"#\" className=\"flex items-center justify-between rounded-lg border border-border bg-background px-3 py-3 text-sm hover:border-muted-foreground\">\n        <span className=\"flex items-center gap-2\"><Megaphone className=\"w-4 h-4\" /> Content Publisher</span>\n        <ChevronRight className=\"w-4 h-4\" />\n      </Link>\n\n   \n\n      <Link href=\"#\" className=\" flex items-center gap-2 rounded-lg border border-border bg-background px-3 py-3 text-sm hover:border-muted-foreground\">\n        <Linkedin className=\"w-4 h-4\" /> My  Linkedin\n      </Link>\n\n      <Link href=\"https://www.instagram.com/italha.0/\" target=\"_blank\" className=\"flex items-center gap-2 rounded-lg border border-border bg-background px-3 py-3 text-sm hover:border-muted-foreground\">\n        <Instagram className=\"w-4 h-4\" /> My  Instagram\n      </Link>\n\n      <div className=\"mt-auto flex items-center justify-between gap-2 rounded-lg border border-border bg-background px-3 py-2 text-xs\">\n        <span className=\"flex items-center gap-2\"><Zap className=\"w-4 h-4\" /> 0</span>\n        <Link href=\"#\" className=\"underline\">Upgrade now</Link>\n      </div>\n\n      <div className=\"mt-2 rounded-xl border border-border bg-gradient-to-br from-purple-100 to-pink-100 p-4\">\n        <div className=\"text-base font-semibold\">Get more credits</div>\n        <p className=\"mt-1 text-xs text-muted-foreground\">Get access to all features and create more viral clips</p>\n        <Button className=\"mt-3 w-full bg-gradient-to-r from-yellow-400 to-orange-400 text-black hover:from-yellow-500 hover:to-orange-500\">Upgrade Now</Button>\n      </div>\n    </aside>\n  )\n}\n","size_bytes":2211},"prebundled/bundle/296.bundle.js":{"content":"/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n// src/errors.ts\nclass IsAnImageError extends Error {\n  imageType;\n  dimensions;\n  mimeType;\n  sizeInBytes;\n  fileName;\n  constructor({\n    dimensions,\n    imageType,\n    message,\n    mimeType,\n    sizeInBytes,\n    fileName\n  }) {\n    super(message);\n    this.name = \"IsAnImageError\";\n    this.imageType = imageType;\n    this.dimensions = dimensions;\n    this.mimeType = mimeType;\n    this.sizeInBytes = sizeInBytes;\n    this.fileName = fileName;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, IsAnImageError);\n    }\n  }\n}\n\nclass IsAPdfError extends Error {\n  mimeType;\n  sizeInBytes;\n  fileName;\n  constructor({\n    message,\n    mimeType,\n    sizeInBytes,\n    fileName\n  }) {\n    super(message);\n    this.name = \"IsAPdfError\";\n    this.mimeType = mimeType;\n    this.sizeInBytes = sizeInBytes;\n    this.fileName = fileName;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, IsAPdfError);\n    }\n  }\n}\n\nclass IsAnUnsupportedFileTypeError extends Error {\n  mimeType;\n  sizeInBytes;\n  fileName;\n  constructor({\n    message,\n    mimeType,\n    sizeInBytes,\n    fileName\n  }) {\n    super(message);\n    this.name = \"IsAnUnsupportedFileTypeError\";\n    this.mimeType = mimeType;\n    this.sizeInBytes = sizeInBytes;\n    this.fileName = fileName;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, IsAnUnsupportedFileTypeError);\n    }\n  }\n}\n\nclass MediaParserAbortError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"MediaParserAbortError\";\n    this.cause = undefined;\n  }\n}\n\n// src/log.ts\nvar logLevels = [\"trace\", \"verbose\", \"info\", \"warn\", \"error\"];\nvar getNumberForLogLevel = (level) => {\n  return logLevels.indexOf(level);\n};\nvar isEqualOrBelowLogLevel = (currentLevel, level) => {\n  return getNumberForLogLevel(currentLevel) <= getNumberForLogLevel(level);\n};\nvar Log = {\n  trace: (logLevel, ...args) => {\n    if (isEqualOrBelowLogLevel(logLevel, \"trace\")) {\n      return console.log(...args);\n    }\n  },\n  verbose: (logLevel, ...args) => {\n    if (isEqualOrBelowLogLevel(logLevel, \"verbose\")) {\n      return console.log(...args);\n    }\n  },\n  info: (logLevel, ...args) => {\n    if (isEqualOrBelowLogLevel(logLevel, \"info\")) {\n      return console.log(...args);\n    }\n  },\n  warn: (logLevel, ...args) => {\n    if (isEqualOrBelowLogLevel(logLevel, \"warn\")) {\n      return console.warn(...args);\n    }\n  },\n  error: (...args) => {\n    return console.error(...args);\n  }\n};\n\n// src/readers/fetch/get-body-and-reader.ts\nvar getLengthAndReader = async ({\n  canLiveWithoutContentLength,\n  res,\n  ownController,\n  requestedWithoutRange\n}) => {\n  const length = res.headers.get(\"content-length\");\n  const contentLength = length === null ? null : parseInt(length, 10);\n  if (requestedWithoutRange || canLiveWithoutContentLength && contentLength === null) {\n    const buffer = await res.arrayBuffer();\n    const encoded = new Uint8Array(buffer);\n    let streamCancelled = false;\n    const stream = new ReadableStream({\n      start(controller) {\n        if (ownController.signal.aborted) {\n          return;\n        }\n        if (streamCancelled) {\n          return;\n        }\n        try {\n          controller.enqueue(encoded);\n          controller.close();\n        } catch {}\n      },\n      cancel() {\n        streamCancelled = true;\n      }\n    });\n    return {\n      contentLength: encoded.byteLength,\n      reader: {\n        reader: stream.getReader(),\n        abort: () => {\n          ownController.abort();\n          return Promise.resolve();\n        }\n      },\n      needsContentRange: false\n    };\n  }\n  if (!res.body) {\n    throw new Error(\"No body\");\n  }\n  const reader = res.body.getReader();\n  return {\n    reader: {\n      reader,\n      abort: () => {\n        ownController.abort();\n        return Promise.resolve();\n      }\n    },\n    contentLength,\n    needsContentRange: true\n  };\n};\n\n// src/readers/fetch/resolve-url.ts\nvar resolveUrl = (src) => {\n  try {\n    const resolvedUrl = typeof window !== \"undefined\" && typeof window.location !== \"undefined\" ? new URL(src, window.location.origin) : new URL(src);\n    return resolvedUrl;\n  } catch {\n    return src;\n  }\n};\n\n// src/readers/from-fetch.ts\nfunction parseContentRange(input) {\n  const matches = input.match(/^(\\w+) ((\\d+)-(\\d+)|\\*)\\/(\\d+|\\*)$/);\n  if (!matches)\n    return null;\n  const [, unit, , start, end, size] = matches;\n  const range = {\n    unit,\n    start: start != null ? Number(start) : null,\n    end: end != null ? Number(end) : null,\n    size: size === \"*\" ? null : Number(size)\n  };\n  if (range.start === null && range.end === null && range.size === null) {\n    return null;\n  }\n  return range;\n}\nvar validateContentRangeAndDetectIfSupported = ({\n  requestedRange,\n  parsedContentRange,\n  statusCode\n}) => {\n  if (statusCode === 206) {\n    return { supportsContentRange: true };\n  }\n  if (typeof requestedRange === \"number\" && parsedContentRange?.start !== requestedRange) {\n    if (requestedRange === 0) {\n      return { supportsContentRange: false };\n    }\n    throw new Error(`Range header (${requestedRange}) does not match content-range header (${parsedContentRange?.start})`);\n  }\n  if (requestedRange !== null && typeof requestedRange !== \"number\" && (parsedContentRange?.start !== requestedRange[0] || parsedContentRange?.end !== requestedRange[1])) {\n    throw new Error(`Range header (${requestedRange}) does not match content-range header (${parsedContentRange?.start})`);\n  }\n  return { supportsContentRange: true };\n};\nvar makeFetchRequest = async ({\n  range,\n  src,\n  controller\n}) => {\n  const resolvedUrl = resolveUrl(src);\n  const resolvedUrlString = resolvedUrl.toString();\n  if (!resolvedUrlString.startsWith(\"https://\") && !resolvedUrlString.startsWith(\"blob:\") && !resolvedUrlString.startsWith(\"http://\")) {\n    return Promise.reject(new Error(`${resolvedUrlString} is not a URL - needs to start with http:// or https:// or blob:. If you want to read a local file, pass \\`reader: nodeReader\\` to parseMedia().`));\n  }\n  const ownController = new AbortController;\n  const cache = typeof navigator !== \"undefined\" && navigator.userAgent.includes(\"Cloudflare-Workers\") ? undefined : \"no-store\";\n  const requestedRange = range === null ? 0 : range;\n  const asString = typeof resolvedUrl === \"string\" ? resolvedUrl : resolvedUrl.pathname;\n  const requestWithoutRange = asString.endsWith(\".m3u8\");\n  const canLiveWithoutContentLength = asString.endsWith(\".m3u8\") || asString.endsWith(\".ts\");\n  const headers = requestedRange === 0 && requestWithoutRange ? {} : typeof requestedRange === \"number\" ? {\n    Range: `bytes=${requestedRange}-`\n  } : {\n    Range: `bytes=${`${requestedRange[0]}-${requestedRange[1]}`}`\n  };\n  const res = await fetch(resolvedUrl, {\n    headers,\n    signal: ownController.signal,\n    cache\n  });\n  const contentRange = res.headers.get(\"content-range\");\n  const parsedContentRange = contentRange ? parseContentRange(contentRange) : null;\n  if (!res.ok) {\n    throw new Error(`Server returned status code ${res.status} for ${resolvedUrl} and range ${requestedRange}`);\n  }\n  const { supportsContentRange } = validateContentRangeAndDetectIfSupported({\n    requestedRange,\n    parsedContentRange,\n    statusCode: res.status\n  });\n  if (controller) {\n    controller._internals.signal.addEventListener(\"abort\", () => {\n      ownController.abort(new MediaParserAbortError(\"Aborted by user\"));\n    }, { once: true });\n  }\n  const contentDisposition = res.headers.get(\"content-disposition\");\n  const name = contentDisposition?.match(/filename=\"([^\"]+)\"/)?.[1];\n  const { contentLength, needsContentRange, reader } = await getLengthAndReader({\n    canLiveWithoutContentLength,\n    res,\n    ownController,\n    requestedWithoutRange: requestWithoutRange\n  });\n  const contentType = res.headers.get(\"content-type\");\n  return {\n    contentLength,\n    needsContentRange,\n    reader,\n    name,\n    contentType,\n    supportsContentRange\n  };\n};\nvar cacheKey = ({\n  src,\n  range\n}) => {\n  return `${src}-${JSON.stringify(range)}`;\n};\nvar makeFetchRequestOrGetCached = ({\n  range,\n  src,\n  controller,\n  logLevel,\n  prefetchCache\n}) => {\n  const key = cacheKey({ src, range });\n  const cached = prefetchCache.get(key);\n  if (cached) {\n    Log.verbose(logLevel, `Reading from preload cache for ${key}`);\n    return cached;\n  }\n  Log.verbose(logLevel, `Fetching ${key}`);\n  const result = makeFetchRequest({ range, src, controller });\n  prefetchCache.set(key, result);\n  return result;\n};\nvar fetchReadContent = async ({\n  src,\n  range,\n  controller,\n  logLevel,\n  prefetchCache\n}) => {\n  if (typeof src !== \"string\" && src instanceof URL === false) {\n    throw new Error(\"src must be a string when using `fetchReader`\");\n  }\n  const fallbackName = src.toString().split(\"/\").pop();\n  const res = makeFetchRequestOrGetCached({\n    range,\n    src,\n    controller,\n    logLevel,\n    prefetchCache\n  });\n  const key = cacheKey({ src, range });\n  prefetchCache.delete(key);\n  const {\n    reader,\n    contentLength,\n    needsContentRange,\n    name,\n    supportsContentRange,\n    contentType\n  } = await res;\n  if (controller) {\n    controller._internals.signal.addEventListener(\"abort\", () => {\n      reader.reader.cancel().catch(() => {});\n    }, { once: true });\n  }\n  return {\n    reader,\n    contentLength,\n    contentType,\n    name: name ?? fallbackName,\n    supportsContentRange,\n    needsContentRange\n  };\n};\nvar fetchPreload = ({\n  src,\n  range,\n  logLevel,\n  prefetchCache\n}) => {\n  if (typeof src !== \"string\" && src instanceof URL === false) {\n    throw new Error(\"src must be a string when using `fetchReader`\");\n  }\n  const key = cacheKey({ src, range });\n  if (prefetchCache.has(key)) {\n    return prefetchCache.get(key);\n  }\n  makeFetchRequestOrGetCached({\n    range,\n    src,\n    controller: null,\n    logLevel,\n    prefetchCache\n  });\n};\nvar fetchReadWholeAsText = async (src) => {\n  if (typeof src !== \"string\" && src instanceof URL === false) {\n    throw new Error(\"src must be a string when using `fetchReader`\");\n  }\n  const res = await fetch(src);\n  if (!res.ok) {\n    throw new Error(`Failed to fetch ${src} (HTTP code: ${res.status})`);\n  }\n  return res.text();\n};\nvar fetchCreateAdjacentFileSource = (relativePath, src) => {\n  if (typeof src !== \"string\" && src instanceof URL === false) {\n    throw new Error(\"src must be a string or URL when using `fetchReader`\");\n  }\n  return new URL(relativePath, src).toString();\n};\n\n// src/readers/from-web-file.ts\nvar webFileReadContent = ({ src, range, controller }) => {\n  if (typeof src === \"string\" || src instanceof URL) {\n    throw new Error(\"`inputTypeFileReader` only supports `File` objects\");\n  }\n  const part = range === null ? src : typeof range === \"number\" ? src.slice(range) : src.slice(range[0], range[1] + 1);\n  const stream = part.stream();\n  const streamReader = stream.getReader();\n  if (controller) {\n    controller._internals.signal.addEventListener(\"abort\", () => {\n      streamReader.cancel();\n    }, { once: true });\n  }\n  return Promise.resolve({\n    reader: {\n      reader: streamReader,\n      async abort() {\n        try {\n          await streamReader.cancel();\n        } catch {}\n        return Promise.resolve();\n      }\n    },\n    contentLength: src.size,\n    name: src instanceof File ? src.name : src.toString(),\n    supportsContentRange: true,\n    contentType: src.type,\n    needsContentRange: true\n  });\n};\nvar webFileReadWholeAsText = () => {\n  throw new Error(\"`webFileReader` cannot read auxiliary files.\");\n};\nvar webFileCreateAdjacentFileSource = () => {\n  throw new Error(\"`webFileReader` cannot create adjacent file sources.\");\n};\n\n// src/readers/web.ts\nvar webReader = {\n  read: (params) => {\n    if (params.src instanceof Blob) {\n      return webFileReadContent(params);\n    }\n    return fetchReadContent(params);\n  },\n  createAdjacentFileSource: (relativePath, src) => {\n    if (src instanceof Blob) {\n      return webFileCreateAdjacentFileSource(relativePath, src);\n    }\n    return fetchCreateAdjacentFileSource(relativePath, src);\n  },\n  readWholeAsText: (src) => {\n    if (src instanceof Blob) {\n      return webFileReadWholeAsText(src);\n    }\n    return fetchReadWholeAsText(src);\n  },\n  preload: ({ range, src, logLevel, prefetchCache }) => {\n    if (src instanceof Blob) {\n      return;\n    }\n    return fetchPreload({ range, src, logLevel, prefetchCache });\n  }\n};\n\n// src/containers/m3u/select-stream.ts\nvar selectAssociatedPlaylists = async ({\n  playlists,\n  fn,\n  skipAudioTracks\n}) => {\n  if (playlists.length < 1) {\n    return Promise.resolve([]);\n  }\n  const streams = await fn({ associatedPlaylists: playlists });\n  if (!Array.isArray(streams)) {\n    throw new Error(\"Expected an array of associated playlists\");\n  }\n  const selectedStreams = [];\n  for (const stream of streams) {\n    if (stream.isAudio && skipAudioTracks) {\n      continue;\n    }\n    if (!playlists.find((playlist) => playlist.src === stream.src)) {\n      throw new Error(`The associated playlist ${JSON.stringify(streams)} cannot be selected because it was not in the list of selectable playlists`);\n    }\n    selectedStreams.push(stream);\n  }\n  return selectedStreams;\n};\nvar defaultSelectM3uAssociatedPlaylists = ({ associatedPlaylists }) => {\n  if (associatedPlaylists.length === 1) {\n    return associatedPlaylists;\n  }\n  return associatedPlaylists.filter((playlist) => playlist.default);\n};\nvar selectStream = async ({\n  streams,\n  fn\n}) => {\n  if (streams.length < 1) {\n    throw new Error(\"No streams found\");\n  }\n  const selectedStreamId = await fn({ streams });\n  const selectedStream = streams.find((stream) => stream.id === selectedStreamId);\n  if (!selectedStream) {\n    throw new Error(`No stream with the id ${selectedStreamId} found`);\n  }\n  return Promise.resolve(selectedStream);\n};\nvar defaultSelectM3uStreamFn = ({ streams }) => {\n  return Promise.resolve(streams[0].id);\n};\n\n// src/with-resolvers.ts\nvar withResolvers = function() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve, reject };\n};\n\n// src/controller/emitter.ts\nclass MediaParserEmitter {\n  listeners = {\n    pause: [],\n    resume: [],\n    abort: [],\n    seek: []\n  };\n  readyPromise;\n  #markAsReady;\n  constructor() {\n    const { promise, resolve } = withResolvers();\n    this.readyPromise = promise;\n    this.#markAsReady = resolve;\n  }\n  markAsReady = () => {\n    this.#markAsReady();\n  };\n  addEventListener = (name, callback) => {\n    this.listeners[name].push(callback);\n  };\n  removeEventListener = (name, callback) => {\n    this.listeners[name] = this.listeners[name].filter((l) => l !== callback);\n  };\n  dispatchEvent(dispatchName, context) {\n    this.listeners[dispatchName].forEach((callback) => {\n      callback({ detail: context });\n    });\n  }\n  dispatchPause = () => {\n    this.readyPromise = this.readyPromise.then(() => {\n      this.dispatchEvent(\"pause\", undefined);\n    });\n  };\n  dispatchResume = () => {\n    this.readyPromise = this.readyPromise.then(() => {\n      this.dispatchEvent(\"resume\", undefined);\n    });\n  };\n  dispatchAbort = (reason) => {\n    this.readyPromise = this.readyPromise.then(() => {\n      this.dispatchEvent(\"abort\", { reason });\n    });\n  };\n  dispatchSeek = (seek) => {\n    this.readyPromise = this.readyPromise.then(() => {\n      this.dispatchEvent(\"seek\", { seek });\n    });\n  };\n}\n\n// src/controller/pause-signal.ts\nvar makePauseSignal = (emitter) => {\n  const waiterFns = [];\n  let paused = false;\n  return {\n    pause: () => {\n      if (paused) {\n        return;\n      }\n      emitter.dispatchPause();\n      paused = true;\n    },\n    resume: () => {\n      if (!paused) {\n        return;\n      }\n      paused = false;\n      for (const waiterFn of waiterFns) {\n        waiterFn();\n      }\n      waiterFns.length = 0;\n      emitter.dispatchResume();\n    },\n    waitUntilResume: () => {\n      return new Promise((resolve) => {\n        if (!paused) {\n          resolve();\n        } else {\n          waiterFns.push(resolve);\n        }\n      });\n    }\n  };\n};\n\n// src/controller/performed-seeks-stats.ts\nvar performedSeeksStats = () => {\n  const performedSeeks = [];\n  const markLastSeekAsUserInitiated = () => {\n    if (performedSeeks.length > 0) {\n      performedSeeks[performedSeeks.length - 1].type = \"user-initiated\";\n    }\n  };\n  return {\n    recordSeek: (seek) => {\n      performedSeeks.push(seek);\n    },\n    getPerformedSeeks: () => {\n      return performedSeeks;\n    },\n    markLastSeekAsUserInitiated\n  };\n};\n\n// src/controller/seek-signal.ts\nvar makeSeekSignal = (emitter) => {\n  let seek = null;\n  return {\n    seek: (seekRequest) => {\n      seek = seekRequest;\n      emitter.dispatchSeek(seekRequest);\n    },\n    getSeek() {\n      return seek;\n    },\n    clearSeekIfStillSame(previousSeek) {\n      if (seek === previousSeek) {\n        seek = null;\n        return { hasChanged: false };\n      }\n      return { hasChanged: true };\n    }\n  };\n};\n\n// src/controller/media-parser-controller.ts\nvar mediaParserController = () => {\n  const abortController = new AbortController;\n  const emitter = new MediaParserEmitter;\n  const pauseSignal = makePauseSignal(emitter);\n  const seekSignal = makeSeekSignal(emitter);\n  const performedSeeksSignal = performedSeeksStats();\n  const checkForAbortAndPause = async () => {\n    if (abortController.signal.aborted) {\n      const err = new MediaParserAbortError(\"Aborted\");\n      if (abortController.signal.reason) {\n        err.cause = abortController.signal.reason;\n      }\n      throw err;\n    }\n    await pauseSignal.waitUntilResume();\n  };\n  let seekingHintResolution = null;\n  let simulateSeekResolution = null;\n  const getSeekingHints = () => {\n    if (!seekingHintResolution) {\n      throw new Error(\"The mediaParserController() was not yet used in a parseMedia() call\");\n    }\n    return seekingHintResolution();\n  };\n  const simulateSeek = (seekInSeconds) => {\n    if (!simulateSeekResolution) {\n      throw new Error(\"The mediaParserController() was not yet used in a parseMedia() call\");\n    }\n    return simulateSeekResolution(seekInSeconds);\n  };\n  const attachSeekingHintResolution = (callback) => {\n    if (seekingHintResolution) {\n      throw new Error(\"The mediaParserController() was used in multiple parseMedia() calls. Create a separate controller for each call.\");\n    }\n    seekingHintResolution = callback;\n  };\n  const attachSimulateSeekResolution = (callback) => {\n    if (simulateSeekResolution) {\n      throw new Error(\"The mediaParserController() was used in multiple parseMedia() calls. Create a separate controller for each call.\");\n    }\n    simulateSeekResolution = callback;\n  };\n  return {\n    abort: (reason) => {\n      abortController.abort(reason);\n      emitter.dispatchAbort(reason);\n    },\n    seek: seekSignal.seek,\n    simulateSeek,\n    pause: pauseSignal.pause,\n    resume: pauseSignal.resume,\n    addEventListener: emitter.addEventListener,\n    removeEventListener: emitter.removeEventListener,\n    getSeekingHints,\n    _internals: {\n      signal: abortController.signal,\n      checkForAbortAndPause,\n      seekSignal,\n      markAsReadyToEmitEvents: emitter.markAsReady,\n      performedSeeksSignal,\n      attachSeekingHintResolution,\n      attachSimulateSeekResolution\n    }\n  };\n};\n\n// src/containers/m3u/get-streams.ts\nvar isIndependentSegments = (structure) => {\n  if (structure === null || structure.type !== \"m3u\") {\n    return false;\n  }\n  return structure.boxes.some((box) => box.type === \"m3u-independent-segments\" || box.type === \"m3u-stream-info\");\n};\nvar getM3uStreams = ({\n  structure,\n  originalSrc,\n  readerInterface\n}) => {\n  if (structure === null || structure.type !== \"m3u\") {\n    return null;\n  }\n  const boxes = [];\n  for (let i = 0;i < structure.boxes.length; i++) {\n    const str = structure.boxes[i];\n    if (str.type === \"m3u-stream-info\") {\n      const next = structure.boxes[i + 1];\n      if (next.type !== \"m3u-text-value\") {\n        throw new Error(\"Expected m3u-text-value\");\n      }\n      const associatedPlaylists = [];\n      if (str.audio) {\n        const match = structure.boxes.filter((box) => {\n          return box.type === \"m3u-media-info\" && box.groupId === str.audio;\n        });\n        for (const audioTrack of match) {\n          associatedPlaylists.push({\n            autoselect: audioTrack.autoselect,\n            channels: audioTrack.channels,\n            default: audioTrack.default,\n            groupId: audioTrack.groupId,\n            language: audioTrack.language,\n            name: audioTrack.name,\n            src: readerInterface.createAdjacentFileSource(audioTrack.uri, originalSrc),\n            id: associatedPlaylists.length,\n            isAudio: true\n          });\n        }\n      }\n      boxes.push({\n        src: readerInterface.createAdjacentFileSource(next.value, originalSrc),\n        averageBandwidthInBitsPerSec: str.averageBandwidthInBitsPerSec,\n        bandwidthInBitsPerSec: str.bandwidthInBitsPerSec,\n        codecs: str.codecs,\n        dimensions: str.dimensions,\n        associatedPlaylists\n      });\n    }\n  }\n  if (boxes.length === 0) {\n    return null;\n  }\n  const sorted = boxes.slice().sort((a, b) => {\n    const aResolution = a.dimensions ? a.dimensions.width * a.dimensions.height : 0;\n    const bResolution = b.dimensions ? b.dimensions.width * b.dimensions.height : 0;\n    if (aResolution === bResolution) {\n      const bandwidthA = a.averageBandwidthInBitsPerSec ?? a.bandwidthInBitsPerSec ?? 0;\n      const bandwidthB = b.averageBandwidthInBitsPerSec ?? b.bandwidthInBitsPerSec ?? 0;\n      return bandwidthB - bandwidthA;\n    }\n    return bResolution - aResolution;\n  });\n  return sorted.map((box, index) => ({ ...box, id: index }));\n};\nvar m3uHasStreams = (state) => {\n  const structure = state.structure.getStructureOrNull();\n  if (!structure) {\n    return false;\n  }\n  if (structure.type !== \"m3u\") {\n    return true;\n  }\n  return state.m3u.hasFinishedManifest();\n};\n\n// src/state/iso-base-media/precomputed-moof.ts\nvar precomputedMoofState = () => {\n  let moofBoxes = [];\n  return {\n    getMoofBoxes: () => moofBoxes,\n    setMoofBoxes: (boxes) => {\n      moofBoxes = boxes;\n    }\n  };\n};\nvar toMoofBox = (box) => {\n  if (box.type !== \"regular-box\") {\n    throw new Error(\"expected regular bpx\");\n  }\n  return {\n    offset: box.offset,\n    trafBoxes: box.children.filter((c) => c.type === \"regular-box\" && c.boxType === \"traf\"),\n    size: box.boxSize\n  };\n};\nvar deduplicateMoofBoxesByOffset = (moofBoxes) => {\n  return moofBoxes.filter((m, i, arr) => i === arr.findIndex((t) => t.offset === m.offset));\n};\n\n// src/containers/iso-base-media/traversal.ts\nvar getMoovFromFromIsoStructure = (structure) => {\n  const moovBox = structure.boxes.find((s) => s.type === \"moov-box\");\n  if (!moovBox || moovBox.type !== \"moov-box\") {\n    return null;\n  }\n  return moovBox;\n};\nvar getMoovBoxFromState = ({\n  structureState,\n  isoState,\n  mp4HeaderSegment,\n  mayUsePrecomputed\n}) => {\n  const got = isoState.moov.getMoovBoxAndPrecomputed();\n  if (got && (mayUsePrecomputed || !got.precomputed)) {\n    return got.moovBox;\n  }\n  if (mp4HeaderSegment) {\n    return getMoovFromFromIsoStructure(mp4HeaderSegment);\n  }\n  const structure = structureState.getIsoStructure();\n  return getMoovFromFromIsoStructure(structure);\n};\nvar getMoofBoxes = (main) => {\n  const moofBoxes = main.filter((s) => s.type === \"regular-box\" && s.boxType === \"moof\");\n  return moofBoxes.map((m) => toMoofBox(m));\n};\nvar getMvhdBox = (moovBox) => {\n  const mvHdBox = moovBox.children.find((s) => s.type === \"mvhd-box\");\n  if (!mvHdBox || mvHdBox.type !== \"mvhd-box\") {\n    return null;\n  }\n  return mvHdBox;\n};\nvar getTraks = (moovBox) => {\n  return moovBox.children.filter((s) => s.type === \"trak-box\");\n};\nvar getTkhdBox = (trakBox) => {\n  const tkhdBox = trakBox.children.find((s) => s.type === \"tkhd-box\");\n  return tkhdBox;\n};\nvar getMdiaBox = (trakBox) => {\n  const mdiaBox = trakBox.children.find((s) => s.type === \"regular-box\" && s.boxType === \"mdia\");\n  if (!mdiaBox || mdiaBox.type !== \"regular-box\") {\n    return null;\n  }\n  return mdiaBox;\n};\nvar getMdhdBox = (trakBox) => {\n  const mdiaBox = getMdiaBox(trakBox);\n  if (!mdiaBox) {\n    return null;\n  }\n  const mdhdBox = mdiaBox.children.find((c) => c.type === \"mdhd-box\");\n  return mdhdBox;\n};\nvar getStblBox = (trakBox) => {\n  const mdiaBox = getMdiaBox(trakBox);\n  if (!mdiaBox) {\n    return null;\n  }\n  const minfBox = mdiaBox.children.find((s) => s.type === \"regular-box\" && s.boxType === \"minf\");\n  if (!minfBox || minfBox.type !== \"regular-box\") {\n    return null;\n  }\n  const stblBox = minfBox.children.find((s) => s.type === \"regular-box\" && s.boxType === \"stbl\");\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  return stblBox;\n};\nvar getStsdBox = (trakBox) => {\n  const stblBox = getStblBox(trakBox);\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  const stsdBox = stblBox.children.find((s) => s.type === \"stsd-box\");\n  return stsdBox;\n};\nvar getVideoDescriptors = (trakBox) => {\n  const stsdBox = getStsdBox(trakBox);\n  if (!stsdBox) {\n    return null;\n  }\n  const descriptors = stsdBox.samples.map((s) => {\n    return s.type === \"video\" ? s.descriptors.map((d) => {\n      return d.type === \"avcc-box\" ? d.privateData : d.type === \"hvcc-box\" ? d.privateData : null;\n    }) : [];\n  });\n  return descriptors.flat(1).filter(Boolean)[0] ?? null;\n};\nvar getStcoBox = (trakBox) => {\n  const stblBox = getStblBox(trakBox);\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  const stcoBox = stblBox.children.find((s) => s.type === \"stco-box\");\n  return stcoBox;\n};\nvar getSttsBox = (trakBox) => {\n  const stblBox = getStblBox(trakBox);\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  const sttsBox = stblBox.children.find((s) => s.type === \"stts-box\");\n  return sttsBox;\n};\nvar getCttsBox = (trakBox) => {\n  const stblBox = getStblBox(trakBox);\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  const cttsBox = stblBox.children.find((s) => s.type === \"ctts-box\");\n  return cttsBox;\n};\nvar getStszBox = (trakBox) => {\n  const stblBox = getStblBox(trakBox);\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  const stszBox = stblBox.children.find((s) => s.type === \"stsz-box\");\n  return stszBox;\n};\nvar getStscBox = (trakBox) => {\n  const stblBox = getStblBox(trakBox);\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  const stcoBox = stblBox.children.find((b) => b.type === \"stsc-box\");\n  return stcoBox;\n};\nvar getStssBox = (trakBox) => {\n  const stblBox = getStblBox(trakBox);\n  if (!stblBox || stblBox.type !== \"regular-box\") {\n    return null;\n  }\n  const stssBox = stblBox.children.find((b) => b.type === \"stss-box\");\n  return stssBox;\n};\nvar getTfdtBox = (segment) => {\n  if (segment.type !== \"regular-box\" || segment.boxType !== \"traf\") {\n    throw new Error(\"Expected traf-box\");\n  }\n  const tfhdBox = segment.children.find((c) => c.type === \"tfdt-box\");\n  if (!tfhdBox || tfhdBox.type !== \"tfdt-box\") {\n    throw new Error(\"Expected tfhd-box\");\n  }\n  return tfhdBox;\n};\nvar getTfhdBox = (segment) => {\n  if (segment.type !== \"regular-box\" || segment.boxType !== \"traf\") {\n    throw new Error(\"Expected traf-box\");\n  }\n  const tfhdBox = segment.children.find((c) => c.type === \"tfhd-box\");\n  if (!tfhdBox || tfhdBox.type !== \"tfhd-box\") {\n    throw new Error(\"Expected tfhd-box\");\n  }\n  return tfhdBox;\n};\nvar getTrunBoxes = (segment) => {\n  if (segment.type !== \"regular-box\" || segment.boxType !== \"traf\") {\n    throw new Error(\"Expected traf-box\");\n  }\n  const trunBoxes = segment.children.filter((c) => c.type === \"trun-box\");\n  return trunBoxes;\n};\nvar getMvexBox = (moovAtom) => {\n  const mvexBox = moovAtom.children.find((s) => s.type === \"regular-box\" && s.boxType === \"mvex\");\n  if (!mvexBox || mvexBox.type !== \"regular-box\") {\n    return null;\n  }\n  return mvexBox;\n};\nvar getTrexBoxes = (moovAtom) => {\n  const mvexBox = getMvexBox(moovAtom);\n  if (!mvexBox) {\n    return [];\n  }\n  const trexBoxes = mvexBox.children.filter((c) => c.type === \"trex-box\");\n  return trexBoxes;\n};\nvar getTfraBoxesFromMfraBoxChildren = (mfraBoxChildren) => {\n  const tfraBoxes = mfraBoxChildren.filter((b) => b.type === \"tfra-box\");\n  return tfraBoxes;\n};\nvar getTfraBoxes = (structure) => {\n  const mfraBox = structure.find((b) => b.type === \"regular-box\" && b.boxType === \"mfra\");\n  if (!mfraBox) {\n    return [];\n  }\n  return getTfraBoxesFromMfraBoxChildren(mfraBox.children);\n};\nvar getTrakBoxByTrackId = (moovBox, trackId) => {\n  const trakBoxes = getTraks(moovBox);\n  return trakBoxes.find((t) => {\n    const tkhd = getTkhdBox(t);\n    if (!tkhd) {\n      return false;\n    }\n    return tkhd.trackId === trackId;\n  }) ?? null;\n};\nvar getElstBox = (trakBox) => {\n  const edtsBox = trakBox.children.find((s) => s.type === \"regular-box\" && s.boxType === \"edts\");\n  if (!edtsBox || edtsBox.type !== \"regular-box\") {\n    return null;\n  }\n  const elstBox = edtsBox.children.find((s) => s.type === \"elst-box\");\n  return elstBox;\n};\n\n// src/containers/riff/traversal.ts\nvar isRiffAvi = (structure) => {\n  return structure.boxes.some((box) => box.type === \"riff-header\" && box.fileType === \"AVI\");\n};\nvar getHdlrBox = (structure) => {\n  return structure.boxes.find((box) => box.type === \"list-box\" && box.listType === \"hdrl\");\n};\nvar getAvihBox = (structure) => {\n  const hdlrBox = getHdlrBox(structure);\n  if (!hdlrBox) {\n    return null;\n  }\n  return hdlrBox.children.find((box) => box.type === \"avih-box\");\n};\nvar getStrlBoxes = (structure) => {\n  const hdlrBox = getHdlrBox(structure);\n  if (!hdlrBox) {\n    return [];\n  }\n  return hdlrBox.children.filter((box) => box.type === \"list-box\" && box.listType === \"strl\");\n};\nvar getStrhBox = (strlBoxChildren) => {\n  return strlBoxChildren.find((box) => box.type === \"strh-box\");\n};\n\n// src/is-audio-structure.ts\nvar isAudioStructure = (structure) => {\n  if (structure.type === \"mp3\") {\n    return true;\n  }\n  if (structure.type === \"wav\") {\n    return true;\n  }\n  if (structure.type === \"aac\") {\n    return true;\n  }\n  if (structure.type === \"flac\") {\n    return true;\n  }\n  if (structure.type === \"iso-base-media\") {\n    return false;\n  }\n  if (structure.type === \"matroska\") {\n    return false;\n  }\n  if (structure.type === \"transport-stream\") {\n    return false;\n  }\n  if (structure.type === \"riff\") {\n    return false;\n  }\n  if (structure.type === \"m3u\") {\n    return false;\n  }\n  throw new Error(`Unhandled structure type: ${structure}`);\n};\n\n// src/get-fps.ts\nvar calculateFps = ({\n  sttsBox,\n  timeScale,\n  durationInSamples\n}) => {\n  let totalSamples = 0;\n  for (const sample of sttsBox.sampleDistribution) {\n    totalSamples += sample.sampleCount;\n  }\n  if (totalSamples === 0) {\n    return null;\n  }\n  const durationInSeconds = durationInSamples / timeScale;\n  const fps = totalSamples / durationInSeconds;\n  return fps;\n};\nvar trakBoxContainsAudio = (trakBox) => {\n  const stsd = getStsdBox(trakBox);\n  if (!stsd) {\n    return false;\n  }\n  const videoSample = stsd.samples.find((s) => s.type === \"audio\");\n  if (!videoSample || videoSample.type !== \"audio\") {\n    return false;\n  }\n  return true;\n};\nvar trakBoxContainsVideo = (trakBox) => {\n  const stsd = getStsdBox(trakBox);\n  if (!stsd) {\n    return false;\n  }\n  const videoSample = stsd.samples.find((s) => s.type === \"video\");\n  if (!videoSample || videoSample.type !== \"video\") {\n    return false;\n  }\n  return true;\n};\nvar getTimescaleAndDuration = (trakBox) => {\n  const mdhdBox = getMdhdBox(trakBox);\n  if (mdhdBox) {\n    return { timescale: mdhdBox.timescale, duration: mdhdBox.duration };\n  }\n  return null;\n};\nvar getFpsFromMp4TrakBox = (trakBox) => {\n  const timescaleAndDuration = getTimescaleAndDuration(trakBox);\n  if (!timescaleAndDuration) {\n    return null;\n  }\n  const sttsBox = getSttsBox(trakBox);\n  if (!sttsBox) {\n    return null;\n  }\n  return calculateFps({\n    sttsBox,\n    timeScale: timescaleAndDuration.timescale,\n    durationInSamples: timescaleAndDuration.duration\n  });\n};\nvar getFpsFromIsoMaseMedia = (state) => {\n  const moovBox = getMoovBoxFromState({\n    structureState: state.structure,\n    isoState: state.iso,\n    mp4HeaderSegment: state.m3uPlaylistContext?.mp4HeaderSegment ?? null,\n    mayUsePrecomputed: true\n  });\n  if (!moovBox) {\n    return null;\n  }\n  const trackBoxes = getTraks(moovBox);\n  const trackBox = trackBoxes.find(trakBoxContainsVideo);\n  if (!trackBox) {\n    return null;\n  }\n  return getFpsFromMp4TrakBox(trackBox);\n};\nvar getFpsFromAvi = (structure) => {\n  const strl = getStrlBoxes(structure);\n  for (const s of strl) {\n    const strh = getStrhBox(s.children);\n    if (!strh) {\n      throw new Error(\"No strh box\");\n    }\n    if (strh.fccType === \"auds\") {\n      continue;\n    }\n    return strh.rate;\n  }\n  return null;\n};\nvar getFps = (state) => {\n  const segments = state.structure.getStructure();\n  if (segments.type === \"iso-base-media\") {\n    return getFpsFromIsoMaseMedia(state);\n  }\n  if (segments.type === \"riff\") {\n    return getFpsFromAvi(segments);\n  }\n  if (segments.type === \"matroska\") {\n    return null;\n  }\n  if (segments.type === \"transport-stream\") {\n    return null;\n  }\n  if (segments.type === \"m3u\") {\n    return null;\n  }\n  if (segments.type === \"mp3\" || segments.type === \"wav\" || segments.type === \"flac\" || segments.type === \"aac\") {\n    return null;\n  }\n  throw new Error(\"Cannot get fps, not implemented: \" + segments);\n};\nvar hasFpsSuitedForSlowFps = (state) => {\n  try {\n    return getFps(state) !== null;\n  } catch {\n    return false;\n  }\n};\nvar hasFps = (state) => {\n  const structure = state.structure.getStructure();\n  if (isAudioStructure(structure)) {\n    return true;\n  }\n  if (structure.type === \"matroska\") {\n    return true;\n  }\n  if (structure.type === \"transport-stream\") {\n    return true;\n  }\n  if (structure.type === \"m3u\") {\n    return true;\n  }\n  return hasFpsSuitedForSlowFps(state);\n};\n\n// src/get-sample-aspect-ratio.ts\nvar getStsdVideoConfig = (trakBox) => {\n  const stsdBox = getStsdBox(trakBox);\n  if (!stsdBox) {\n    return null;\n  }\n  const videoConfig = stsdBox.samples.find((s) => s.type === \"video\");\n  if (!videoConfig || videoConfig.type !== \"video\") {\n    return null;\n  }\n  return videoConfig;\n};\nvar getAvccBox = (trakBox) => {\n  const videoConfig = getStsdVideoConfig(trakBox);\n  if (!videoConfig) {\n    return null;\n  }\n  const avccBox = videoConfig.descriptors.find((c) => c.type === \"avcc-box\");\n  if (!avccBox || avccBox.type !== \"avcc-box\") {\n    return null;\n  }\n  return avccBox;\n};\nvar getVpccBox = (trakBox) => {\n  const videoConfig = getStsdVideoConfig(trakBox);\n  if (!videoConfig) {\n    return null;\n  }\n  const vpccBox = videoConfig.descriptors.find((c) => c.type === \"vpcc-box\");\n  if (!vpccBox || vpccBox.type !== \"vpcc-box\") {\n    return null;\n  }\n  return vpccBox;\n};\nvar getAv1CBox = (trakBox) => {\n  const videoConfig = getStsdVideoConfig(trakBox);\n  if (!videoConfig) {\n    return null;\n  }\n  const av1cBox = videoConfig.descriptors.find((c) => c.type === \"av1C-box\");\n  if (!av1cBox || av1cBox.type !== \"av1C-box\") {\n    return null;\n  }\n  return av1cBox;\n};\nvar getPaspBox = (trakBox) => {\n  const videoConfig = getStsdVideoConfig(trakBox);\n  if (!videoConfig) {\n    return null;\n  }\n  const paspBox = videoConfig.descriptors.find((c) => c.type === \"pasp-box\");\n  if (!paspBox || paspBox.type !== \"pasp-box\") {\n    return null;\n  }\n  return paspBox;\n};\nvar getHvccBox = (trakBox) => {\n  const videoConfig = getStsdVideoConfig(trakBox);\n  if (!videoConfig) {\n    return null;\n  }\n  const hvccBox = videoConfig.descriptors.find((c) => c.type === \"hvcc-box\");\n  if (!hvccBox || hvccBox.type !== \"hvcc-box\") {\n    return null;\n  }\n  return hvccBox;\n};\nvar getSampleAspectRatio = (trakBox) => {\n  const paspBox = getPaspBox(trakBox);\n  if (!paspBox) {\n    return {\n      numerator: 1,\n      denominator: 1\n    };\n  }\n  return {\n    numerator: paspBox.hSpacing,\n    denominator: paspBox.vSpacing\n  };\n};\nvar getColrBox = (videoSample) => {\n  const colrBox = videoSample.descriptors.find((c) => c.type === \"colr-box\");\n  if (!colrBox || colrBox.type !== \"colr-box\") {\n    return null;\n  }\n  return colrBox;\n};\nvar applyTkhdBox = (aspectRatioApplied, tkhdBox) => {\n  if (tkhdBox === null || tkhdBox.rotation === 0) {\n    return {\n      displayAspectWidth: aspectRatioApplied.width,\n      displayAspectHeight: aspectRatioApplied.height,\n      width: aspectRatioApplied.width,\n      height: aspectRatioApplied.height,\n      rotation: 0\n    };\n  }\n  return {\n    width: tkhdBox.width,\n    height: tkhdBox.height,\n    rotation: tkhdBox.rotation,\n    displayAspectWidth: aspectRatioApplied.width,\n    displayAspectHeight: aspectRatioApplied.height\n  };\n};\nvar applyAspectRatios = ({\n  dimensions,\n  sampleAspectRatio,\n  displayAspectRatio\n}) => {\n  if (displayAspectRatio.numerator === 0) {\n    return dimensions;\n  }\n  if (displayAspectRatio.denominator === 0) {\n    return dimensions;\n  }\n  const newWidth = Math.round(dimensions.width * sampleAspectRatio.numerator / sampleAspectRatio.denominator);\n  const newHeight = Math.floor(newWidth / (displayAspectRatio.numerator / displayAspectRatio.denominator));\n  return {\n    width: Math.floor(newWidth),\n    height: newHeight\n  };\n};\nfunction gcd(a, b) {\n  return b === 0 ? a : gcd(b, a % b);\n}\nfunction reduceFraction(numerator, denominator) {\n  const greatestCommonDivisor = gcd(Math.abs(numerator), Math.abs(denominator));\n  return {\n    numerator: numerator / greatestCommonDivisor,\n    denominator: denominator / greatestCommonDivisor\n  };\n}\nvar getDisplayAspectRatio = ({\n  sampleAspectRatio,\n  nativeDimensions\n}) => {\n  const num = Math.round(nativeDimensions.width * sampleAspectRatio.numerator);\n  const den = Math.round(nativeDimensions.height * sampleAspectRatio.denominator);\n  return reduceFraction(num, den);\n};\n\n// src/containers/avc/color.ts\nvar getMatrixCoefficientsFromIndex = (index) => {\n  if (index === 0) {\n    return \"rgb\";\n  }\n  if (index === 1) {\n    return \"bt709\";\n  }\n  if (index === 5) {\n    return \"bt470bg\";\n  }\n  if (index === 6) {\n    return \"smpte170m\";\n  }\n  if (index === 9) {\n    return \"bt2020-ncl\";\n  }\n  return null;\n};\nvar getTransferCharacteristicsFromIndex = (index) => {\n  if (index === 1) {\n    return \"bt709\";\n  }\n  if (index === 6) {\n    return \"smpte170m\";\n  }\n  if (index === 8) {\n    return \"linear\";\n  }\n  if (index === 13) {\n    return \"iec61966-2-1\";\n  }\n  if (index === 16) {\n    return \"pq\";\n  }\n  if (index === 18) {\n    return \"hlg\";\n  }\n  return null;\n};\nvar getPrimariesFromIndex = (index) => {\n  if (index === 1) {\n    return \"bt709\";\n  }\n  if (index === 5) {\n    return \"bt470bg\";\n  }\n  if (index === 6) {\n    return \"smpte170m\";\n  }\n  if (index === 9) {\n    return \"bt2020\";\n  }\n  if (index === 12) {\n    return \"smpte432\";\n  }\n  return null;\n};\n\n// src/containers/webm/segments/all-segments.ts\nvar matroskaElements = {\n  Header: \"0x1a45dfa3\",\n  EBMLMaxIDLength: \"0x42f2\",\n  EBMLVersion: \"0x4286\",\n  EBMLReadVersion: \"0x42f7\",\n  EBMLMaxSizeLength: \"0x42f3\",\n  DocType: \"0x4282\",\n  DocTypeVersion: \"0x4287\",\n  DocTypeReadVersion: \"0x4285\",\n  Segment: \"0x18538067\",\n  SeekHead: \"0x114d9b74\",\n  Seek: \"0x4dbb\",\n  SeekID: \"0x53ab\",\n  SeekPosition: \"0x53ac\",\n  Info: \"0x1549a966\",\n  SegmentUUID: \"0x73a4\",\n  SegmentFilename: \"0x7384\",\n  PrevUUID: \"0x3cb923\",\n  PrevFilename: \"0x3c83ab\",\n  NextUUID: \"0x3eb923\",\n  NextFilename: \"0x3e83bb\",\n  SegmentFamily: \"0x4444\",\n  ChapterTranslate: \"0x6924\",\n  ChapterTranslateID: \"0x69a5\",\n  ChapterTranslateCodec: \"0x69bf\",\n  ChapterTranslateEditionUID: \"0x69fc\",\n  TimestampScale: \"0x2ad7b1\",\n  Duration: \"0x4489\",\n  DateUTC: \"0x4461\",\n  Title: \"0x7ba9\",\n  MuxingApp: \"0x4d80\",\n  WritingApp: \"0x5741\",\n  Cluster: \"0x1f43b675\",\n  Timestamp: \"0xe7\",\n  SilentTracks: \"0x5854\",\n  SilentTrackNumber: \"0x58d7\",\n  Position: \"0xa7\",\n  PrevSize: \"0xab\",\n  SimpleBlock: \"0xa3\",\n  BlockGroup: \"0xa0\",\n  Block: \"0xa1\",\n  BlockVirtual: \"0xa2\",\n  BlockAdditions: \"0x75a1\",\n  BlockMore: \"0xa6\",\n  BlockAdditional: \"0xa5\",\n  BlockAddID: \"0xee\",\n  BlockDuration: \"0x9b\",\n  ReferencePriority: \"0xfa\",\n  ReferenceBlock: \"0xfb\",\n  ReferenceVirtual: \"0xfd\",\n  CodecState: \"0xa4\",\n  DiscardPadding: \"0x75a2\",\n  Slices: \"0x8e\",\n  TimeSlice: \"0xe8\",\n  LaceNumber: \"0xcc\",\n  FrameNumber: \"0xcd\",\n  BlockAdditionID: \"0xcb\",\n  Delay: \"0xce\",\n  SliceDuration: \"0xcf\",\n  ReferenceFrame: \"0xc8\",\n  ReferenceOffset: \"0xc9\",\n  ReferenceTimestamp: \"0xca\",\n  EncryptedBlock: \"0xaf\",\n  Tracks: \"0x1654ae6b\",\n  TrackEntry: \"0xae\",\n  TrackNumber: \"0xd7\",\n  TrackUID: \"0x73c5\",\n  TrackType: \"0x83\",\n  FlagEnabled: \"0xb9\",\n  FlagDefault: \"0x88\",\n  FlagForced: \"0x55aa\",\n  FlagHearingImpaired: \"0x55ab\",\n  FlagVisualImpaired: \"0x55ac\",\n  FlagTextDescriptions: \"0x55ad\",\n  FlagOriginal: \"0x55ae\",\n  FlagCommentary: \"0x55af\",\n  FlagLacing: \"0x9c\",\n  MinCache: \"0x6de7\",\n  MaxCache: \"0x6df8\",\n  DefaultDuration: \"0x23e383\",\n  DefaultDecodedFieldDuration: \"0x234e7a\",\n  TrackTimestampScale: \"0x23314f\",\n  TrackOffset: \"0x537f\",\n  MaxBlockAdditionID: \"0x55ee\",\n  BlockAdditionMapping: \"0x41e4\",\n  BlockAddIDValue: \"0x41f0\",\n  BlockAddIDName: \"0x41a4\",\n  BlockAddIDType: \"0x41e7\",\n  BlockAddIDExtraData: \"0x41ed\",\n  Name: \"0x536e\",\n  Language: \"0x22b59c\",\n  LanguageBCP47: \"0x22b59d\",\n  CodecID: \"0x86\",\n  CodecPrivate: \"0x63a2\",\n  CodecName: \"0x258688\",\n  AttachmentLink: \"0x7446\",\n  CodecSettings: \"0x3a9697\",\n  CodecInfoURL: \"0x3b4040\",\n  CodecDownloadURL: \"0x26b240\",\n  CodecDecodeAll: \"0xaa\",\n  TrackOverlay: \"0x6fab\",\n  CodecDelay: \"0x56aa\",\n  SeekPreRoll: \"0x56bb\",\n  TrackTranslate: \"0x6624\",\n  TrackTranslateTrackID: \"0x66a5\",\n  TrackTranslateCodec: \"0x66bf\",\n  TrackTranslateEditionUID: \"0x66fc\",\n  Video: \"0xe0\",\n  FlagInterlaced: \"0x9a\",\n  FieldOrder: \"0x9d\",\n  StereoMode: \"0x53b8\",\n  AlphaMode: \"0x53c0\",\n  OldStereoMode: \"0x53b9\",\n  PixelWidth: \"0xb0\",\n  PixelHeight: \"0xba\",\n  PixelCropBottom: \"0x54aa\",\n  PixelCropTop: \"0x54bb\",\n  PixelCropLeft: \"0x54cc\",\n  PixelCropRight: \"0x54dd\",\n  DisplayWidth: \"0x54b0\",\n  DisplayHeight: \"0x54ba\",\n  DisplayUnit: \"0x54b2\",\n  AspectRatioType: \"0x54b3\",\n  UncompressedFourCC: \"0x2eb524\",\n  GammaValue: \"0x2fb523\",\n  FrameRate: \"0x2383e3\",\n  Colour: \"0x55b0\",\n  MatrixCoefficients: \"0x55b1\",\n  BitsPerChannel: \"0x55b2\",\n  ChromaSubsamplingHorz: \"0x55b3\",\n  ChromaSubsamplingVert: \"0x55b4\",\n  CbSubsamplingHorz: \"0x55b5\",\n  CbSubsamplingVert: \"0x55b6\",\n  ChromaSitingHorz: \"0x55b7\",\n  ChromaSitingVert: \"0x55b8\",\n  Range: \"0x55b9\",\n  TransferCharacteristics: \"0x55ba\",\n  Primaries: \"0x55bb\",\n  MaxCLL: \"0x55bc\",\n  MaxFALL: \"0x55bd\",\n  MasteringMetadata: \"0x55d0\",\n  PrimaryRChromaticityX: \"0x55d1\",\n  PrimaryRChromaticityY: \"0x55d2\",\n  PrimaryGChromaticityX: \"0x55d3\",\n  PrimaryGChromaticityY: \"0x55d4\",\n  PrimaryBChromaticityX: \"0x55d5\",\n  PrimaryBChromaticityY: \"0x55d6\",\n  WhitePointChromaticityX: \"0x55d7\",\n  WhitePointChromaticityY: \"0x55d8\",\n  LuminanceMax: \"0x55d9\",\n  LuminanceMin: \"0x55da\",\n  Projection: \"0x7670\",\n  ProjectionType: \"0x7671\",\n  ProjectionPrivate: \"0x7672\",\n  ProjectionPoseYaw: \"0x7673\",\n  ProjectionPosePitch: \"0x7674\",\n  ProjectionPoseRoll: \"0x7675\",\n  Audio: \"0xe1\",\n  SamplingFrequency: \"0xb5\",\n  OutputSamplingFrequency: \"0x78b5\",\n  Channels: \"0x9f\",\n  ChannelPositions: \"0x7d7b\",\n  BitDepth: \"0x6264\",\n  Emphasis: \"0x52f1\",\n  TrackOperation: \"0xe2\",\n  TrackCombinePlanes: \"0xe3\",\n  TrackPlane: \"0xe4\",\n  TrackPlaneUID: \"0xe5\",\n  TrackPlaneType: \"0xe6\",\n  TrackJoinBlocks: \"0xe9\",\n  TrackJoinUID: \"0xed\",\n  TrickTrackUID: \"0xc0\",\n  TrickTrackSegmentUID: \"0xc1\",\n  TrickTrackFlag: \"0xc6\",\n  TrickMasterTrackUID: \"0xc7\",\n  TrickMasterTrackSegmentUID: \"0xc4\",\n  ContentEncodings: \"0x6d80\",\n  ContentEncoding: \"0x6240\",\n  ContentEncodingOrder: \"0x5031\",\n  ContentEncodingScope: \"0x5032\",\n  ContentEncodingType: \"0x5033\",\n  ContentCompression: \"0x5034\",\n  ContentCompAlgo: \"0x4254\",\n  ContentCompSettings: \"0x4255\",\n  ContentEncryption: \"0x5035\",\n  ContentEncAlgo: \"0x47e1\",\n  ContentEncKeyID: \"0x47e2\",\n  ContentEncAESSettings: \"0x47e7\",\n  AESSettingsCipherMode: \"0x47e8\",\n  ContentSignature: \"0x47e3\",\n  ContentSigKeyID: \"0x47e4\",\n  ContentSigAlgo: \"0x47e5\",\n  ContentSigHashAlgo: \"0x47e6\",\n  Cues: \"0x1c53bb6b\",\n  CuePoint: \"0xbb\",\n  CueTime: \"0xb3\",\n  CueTrackPositions: \"0xb7\",\n  CueTrack: \"0xf7\",\n  CueClusterPosition: \"0xf1\",\n  CueRelativePosition: \"0xf0\",\n  CueDuration: \"0xb2\",\n  CueBlockNumber: \"0x5378\",\n  CueCodecState: \"0xea\",\n  CueReference: \"0xdb\",\n  CueRefTime: \"0x96\",\n  CueRefCluster: \"0x97\",\n  CueRefNumber: \"0x535f\",\n  CueRefCodecState: \"0xeb\",\n  Attachments: \"0x1941a469\",\n  AttachedFile: \"0x61a7\",\n  FileDescription: \"0x467e\",\n  FileName: \"0x466e\",\n  FileMediaType: \"0x4660\",\n  FileData: \"0x465c\",\n  FileUID: \"0x46ae\",\n  FileReferral: \"0x4675\",\n  FileUsedStartTime: \"0x4661\",\n  FileUsedEndTime: \"0x4662\",\n  Chapters: \"0x1043a770\",\n  EditionEntry: \"0x45b9\",\n  EditionUID: \"0x45bc\",\n  EditionFlagHidden: \"0x45bd\",\n  EditionFlagDefault: \"0x45db\",\n  EditionFlagOrdered: \"0x45dd\",\n  EditionDisplay: \"0x4520\",\n  EditionString: \"0x4521\",\n  EditionLanguageIETF: \"0x45e4\",\n  ChapterAtom: \"0xb6\",\n  ChapterUID: \"0x73c4\",\n  ChapterStringUID: \"0x5654\",\n  ChapterTimeStart: \"0x91\",\n  ChapterTimeEnd: \"0x92\",\n  ChapterFlagHidden: \"0x98\",\n  ChapterFlagEnabled: \"0x4598\",\n  ChapterSegmentUUID: \"0x6e67\",\n  ChapterSkipType: \"0x4588\",\n  ChapterSegmentEditionUID: \"0x6ebc\",\n  ChapterPhysicalEquiv: \"0x63c3\",\n  ChapterTrack: \"0x8f\",\n  ChapterTrackUID: \"0x89\",\n  ChapterDisplay: \"0x80\",\n  ChapString: \"0x85\",\n  ChapLanguage: \"0x437c\",\n  ChapLanguageBCP47: \"0x437d\",\n  ChapCountry: \"0x437e\",\n  ChapProcess: \"0x6944\",\n  ChapProcessCodecID: \"0x6955\",\n  ChapProcessPrivate: \"0x450d\",\n  ChapProcessCommand: \"0x6911\",\n  ChapProcessTime: \"0x6922\",\n  ChapProcessData: \"0x6933\",\n  Tags: \"0x1254c367\",\n  Tag: \"0x7373\",\n  Targets: \"0x63c0\",\n  TargetTypeValue: \"0x68ca\",\n  TargetType: \"0x63ca\",\n  TagTrackUID: \"0x63c5\",\n  TagEditionUID: \"0x63c9\",\n  TagChapterUID: \"0x63c4\",\n  TagAttachmentUID: \"0x63c6\",\n  SimpleTag: \"0x67c8\",\n  TagName: \"0x45a3\",\n  TagLanguage: \"0x447a\",\n  TagLanguageBCP47: \"0x447b\",\n  TagDefault: \"0x4484\",\n  TagDefaultBogus: \"0x44b4\",\n  TagString: \"0x4487\",\n  TagBinary: \"0x4485\",\n  Void: \"0xec\",\n  Crc32: \"0xbf\"\n};\nvar matroskaIds = Object.values(matroskaElements);\nvar knownIdsWithOneLength = matroskaIds.filter((id) => id.length === 4);\nvar knownIdsWithTwoLength = matroskaIds.filter((id) => id.length === 6);\nvar knownIdsWithThreeLength = matroskaIds.filter((id) => id.length === 8);\nvar ebmlVersion = {\n  name: \"EBMLVersion\",\n  type: \"uint\"\n};\nvar ebmlReadVersion = {\n  name: \"EBMLReadVersion\",\n  type: \"uint\"\n};\nvar ebmlMaxIdLength = {\n  name: \"EBMLMaxIDLength\",\n  type: \"uint\"\n};\nvar ebmlMaxSizeLength = {\n  name: \"EBMLMaxSizeLength\",\n  type: \"uint\"\n};\nvar docType = {\n  name: \"DocType\",\n  type: \"string\"\n};\nvar docTypeVersion = {\n  name: \"DocTypeVersion\",\n  type: \"uint\"\n};\nvar docTypeReadVersion = {\n  name: \"DocTypeReadVersion\",\n  type: \"uint\"\n};\nvar voidEbml = {\n  name: \"Void\",\n  type: \"uint8array\"\n};\nvar matroskaHeader = {\n  name: \"Header\",\n  type: \"children\"\n};\nvar seekId = {\n  name: \"SeekID\",\n  type: \"hex-string\"\n};\nvar _name = {\n  name: \"Name\",\n  type: \"string\"\n};\nvar minCache = {\n  name: \"MinCache\",\n  type: \"uint\"\n};\nvar maxCache = {\n  name: \"MaxCache\",\n  type: \"uint\"\n};\nvar seekPosition = {\n  name: \"SeekPosition\",\n  type: \"uint\"\n};\nvar seek = {\n  name: \"Seek\",\n  type: \"children\"\n};\nvar seekHead = {\n  name: \"SeekHead\",\n  type: \"children\"\n};\nvar trackType = {\n  name: \"TrackType\",\n  type: \"uint\"\n};\nvar widthType = {\n  name: \"PixelWidth\",\n  type: \"uint\"\n};\nvar heightType = {\n  name: \"PixelHeight\",\n  type: \"uint\"\n};\nvar muxingApp = {\n  name: \"MuxingApp\",\n  type: \"string\"\n};\nvar duration = {\n  name: \"Duration\",\n  type: \"float\"\n};\nvar timestampScale = {\n  name: \"TimestampScale\",\n  type: \"uint\"\n};\nvar infoType = {\n  name: \"Info\",\n  type: \"children\"\n};\nvar titleType = {\n  name: \"Title\",\n  type: \"string\"\n};\nvar tagTrackUidType = {\n  name: \"TagTrackUID\",\n  type: \"hex-string\"\n};\nvar samplingFrequency = {\n  name: \"SamplingFrequency\",\n  type: \"float\"\n};\nvar channels = {\n  name: \"Channels\",\n  type: \"uint\"\n};\nvar alphaMode = {\n  name: \"AlphaMode\",\n  type: \"uint\"\n};\nvar interlaced = {\n  name: \"FlagInterlaced\",\n  type: \"uint\"\n};\nvar bitDepth = {\n  name: \"BitDepth\",\n  type: \"uint\"\n};\nvar displayWidth = {\n  name: \"DisplayWidth\",\n  type: \"uint\"\n};\nvar displayHeight = {\n  name: \"DisplayHeight\",\n  type: \"uint\"\n};\nvar displayUnit = {\n  name: \"DisplayUnit\",\n  type: \"uint\"\n};\nvar flagLacing = {\n  name: \"FlagLacing\",\n  type: \"uint\"\n};\nvar tagSegment = {\n  name: \"Tag\",\n  type: \"children\"\n};\nvar tags = {\n  name: \"Tags\",\n  type: \"children\"\n};\nvar trackNumber = {\n  name: \"TrackNumber\",\n  type: \"uint\"\n};\nvar trackUID = {\n  name: \"TrackUID\",\n  type: \"hex-string\"\n};\nvar color = {\n  name: \"Colour\",\n  type: \"children\"\n};\nvar transferCharacteristics = {\n  name: \"TransferCharacteristics\",\n  type: \"uint\"\n};\nvar matrixCoefficients = {\n  name: \"MatrixCoefficients\",\n  type: \"uint\"\n};\nvar primaries = {\n  name: \"Primaries\",\n  type: \"uint\"\n};\nvar range = {\n  name: \"Range\",\n  type: \"uint\"\n};\nvar ChromaSitingHorz = {\n  name: \"ChromaSitingHorz\",\n  type: \"uint\"\n};\nvar ChromaSitingVert = {\n  name: \"ChromaSitingVert\",\n  type: \"uint\"\n};\nvar language = {\n  name: \"Language\",\n  type: \"string\"\n};\nvar defaultDuration = {\n  name: \"DefaultDuration\",\n  type: \"uint\"\n};\nvar codecPrivate = {\n  name: \"CodecPrivate\",\n  type: \"uint8array\"\n};\nvar blockAdditionsSegment = {\n  name: \"BlockAdditions\",\n  type: \"uint8array\"\n};\nvar maxBlockAdditionIdSegment = {\n  name: \"MaxBlockAdditionID\",\n  type: \"uint\"\n};\nvar audioSegment = {\n  name: \"Audio\",\n  type: \"children\"\n};\nvar videoSegment = {\n  name: \"Video\",\n  type: \"children\"\n};\nvar flagDefault = {\n  name: \"FlagDefault\",\n  type: \"uint\"\n};\nvar referenceBlock = {\n  name: \"ReferenceBlock\",\n  type: \"uint\"\n};\nvar blockDurationSegment = {\n  name: \"BlockDuration\",\n  type: \"uint\"\n};\nvar codecName = {\n  name: \"CodecName\",\n  type: \"string\"\n};\nvar trackTimestampScale = {\n  name: \"TrackTimestampScale\",\n  type: \"float\"\n};\nvar trackEntry = {\n  name: \"TrackEntry\",\n  type: \"children\"\n};\nvar tracks = {\n  name: \"Tracks\",\n  type: \"children\"\n};\nvar block = {\n  name: \"Block\",\n  type: \"uint8array\"\n};\nvar simpleBlock = {\n  name: \"SimpleBlock\",\n  type: \"uint8array\"\n};\nvar blockGroup = {\n  name: \"BlockGroup\",\n  type: \"children\"\n};\nvar targetsType = {\n  name: \"Targets\",\n  type: \"children\"\n};\nvar simpleTagType = {\n  name: \"SimpleTag\",\n  type: \"children\"\n};\nvar tagNameType = {\n  name: \"TagName\",\n  type: \"string\"\n};\nvar tagStringType = {\n  name: \"TagString\",\n  type: \"string\"\n};\nvar ebmlMap = {\n  [matroskaElements.Header]: matroskaHeader,\n  [matroskaElements.DocType]: docType,\n  [matroskaElements.Targets]: targetsType,\n  [matroskaElements.SimpleTag]: simpleTagType,\n  [matroskaElements.TagName]: tagNameType,\n  [matroskaElements.TagString]: tagStringType,\n  [matroskaElements.DocTypeVersion]: docTypeVersion,\n  [matroskaElements.DocTypeReadVersion]: docTypeReadVersion,\n  [matroskaElements.EBMLVersion]: ebmlVersion,\n  [matroskaElements.EBMLReadVersion]: ebmlReadVersion,\n  [matroskaElements.EBMLMaxIDLength]: ebmlMaxIdLength,\n  [matroskaElements.EBMLMaxSizeLength]: ebmlMaxSizeLength,\n  [matroskaElements.Void]: voidEbml,\n  [matroskaElements.Cues]: {\n    name: \"Cues\",\n    type: \"children\"\n  },\n  [matroskaElements.CuePoint]: {\n    name: \"CuePoint\",\n    type: \"children\"\n  },\n  [matroskaElements.CueTime]: {\n    name: \"CueTime\",\n    type: \"uint\"\n  },\n  [matroskaElements.CueTrackPositions]: {\n    name: \"CueTrackPositions\",\n    type: \"children\"\n  },\n  [matroskaElements.CueClusterPosition]: {\n    name: \"CueClusterPosition\",\n    type: \"uint\"\n  },\n  [matroskaElements.CueRelativePosition]: {\n    name: \"CueRelativePosition\",\n    type: \"uint\"\n  },\n  [matroskaElements.CueBlockNumber]: {\n    name: \"CueBlockNumber\",\n    type: \"uint\"\n  },\n  [matroskaElements.CueTrack]: {\n    name: \"CueTrack\",\n    type: \"uint\"\n  },\n  [matroskaElements.DateUTC]: {\n    name: \"DateUTC\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.TrackTimestampScale]: trackTimestampScale,\n  [matroskaElements.CodecDelay]: {\n    name: \"CodecDelay\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.SeekPreRoll]: {\n    name: \"SeekPreRoll\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.DiscardPadding]: {\n    name: \"DiscardPadding\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.OutputSamplingFrequency]: {\n    name: \"OutputSamplingFrequency\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.CodecName]: codecName,\n  [matroskaElements.Position]: {\n    name: \"Position\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.SliceDuration]: {\n    name: \"SliceDuration\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.TagTrackUID]: tagTrackUidType,\n  [matroskaElements.SeekHead]: seekHead,\n  [matroskaElements.Seek]: seek,\n  [matroskaElements.SeekID]: seekId,\n  [matroskaElements.Name]: _name,\n  [matroskaElements.MinCache]: minCache,\n  [matroskaElements.MaxCache]: maxCache,\n  [matroskaElements.SeekPosition]: seekPosition,\n  [matroskaElements.Crc32]: {\n    name: \"Crc32\",\n    type: \"uint8array\"\n  },\n  [matroskaElements.MuxingApp]: muxingApp,\n  [matroskaElements.WritingApp]: {\n    name: \"WritingApp\",\n    type: \"string\"\n  },\n  [matroskaElements.SegmentUUID]: {\n    name: \"SegmentUUID\",\n    type: \"string\"\n  },\n  [matroskaElements.Duration]: duration,\n  [matroskaElements.CodecID]: {\n    name: \"CodecID\",\n    type: \"string\"\n  },\n  [matroskaElements.TrackType]: trackType,\n  [matroskaElements.PixelWidth]: widthType,\n  [matroskaElements.PixelHeight]: heightType,\n  [matroskaElements.TimestampScale]: timestampScale,\n  [matroskaElements.Info]: infoType,\n  [matroskaElements.Title]: titleType,\n  [matroskaElements.SamplingFrequency]: samplingFrequency,\n  [matroskaElements.Channels]: channels,\n  [matroskaElements.AlphaMode]: alphaMode,\n  [matroskaElements.FlagInterlaced]: interlaced,\n  [matroskaElements.BitDepth]: bitDepth,\n  [matroskaElements.DisplayHeight]: displayHeight,\n  [matroskaElements.DisplayWidth]: displayWidth,\n  [matroskaElements.DisplayUnit]: displayUnit,\n  [matroskaElements.FlagLacing]: flagLacing,\n  [matroskaElements.Tags]: tags,\n  [matroskaElements.Tag]: tagSegment,\n  [matroskaElements.TrackNumber]: trackNumber,\n  [matroskaElements.TrackUID]: trackUID,\n  [matroskaElements.Colour]: color,\n  [matroskaElements.Language]: language,\n  [matroskaElements.DefaultDuration]: defaultDuration,\n  [matroskaElements.CodecPrivate]: codecPrivate,\n  [matroskaElements.BlockDuration]: blockDurationSegment,\n  [matroskaElements.BlockAdditions]: blockAdditionsSegment,\n  [matroskaElements.MaxBlockAdditionID]: maxBlockAdditionIdSegment,\n  [matroskaElements.Audio]: audioSegment,\n  [matroskaElements.Video]: videoSegment,\n  [matroskaElements.FlagDefault]: flagDefault,\n  [matroskaElements.ReferenceBlock]: referenceBlock,\n  [matroskaElements.TrackEntry]: trackEntry,\n  [matroskaElements.Timestamp]: {\n    name: \"Timestamp\",\n    type: \"uint\"\n  },\n  [matroskaElements.Tracks]: tracks,\n  [matroskaElements.Block]: block,\n  [matroskaElements.SimpleBlock]: simpleBlock,\n  [matroskaElements.BlockGroup]: blockGroup,\n  [matroskaElements.Segment]: {\n    name: \"Segment\",\n    type: \"children\"\n  },\n  [matroskaElements.Cluster]: {\n    name: \"Cluster\",\n    type: \"children\"\n  },\n  [matroskaElements.TransferCharacteristics]: transferCharacteristics,\n  [matroskaElements.MatrixCoefficients]: matrixCoefficients,\n  [matroskaElements.Primaries]: primaries,\n  [matroskaElements.Range]: range,\n  [matroskaElements.ChromaSitingHorz]: ChromaSitingHorz,\n  [matroskaElements.ChromaSitingVert]: ChromaSitingVert\n};\n\n// src/file-types/detect-file-type.ts\nvar webmPattern = new Uint8Array([26, 69, 223, 163]);\nvar matchesPattern = (pattern) => {\n  return (data) => {\n    return pattern.every((value, index) => data[index] === value);\n  };\n};\nvar isRiffAvi2 = (data) => {\n  const riffPattern = new Uint8Array([82, 73, 70, 70]);\n  if (!matchesPattern(riffPattern)(data.subarray(0, 4))) {\n    return false;\n  }\n  const fileType = data.subarray(8, 12);\n  const aviPattern = new Uint8Array([65, 86, 73, 32]);\n  return matchesPattern(aviPattern)(fileType);\n};\nvar isRiffWave = (data) => {\n  const riffPattern = new Uint8Array([82, 73, 70, 70]);\n  if (!matchesPattern(riffPattern)(data.subarray(0, 4))) {\n    return false;\n  }\n  const fileType = data.subarray(8, 12);\n  const wavePattern = new Uint8Array([87, 65, 86, 69]);\n  return matchesPattern(wavePattern)(fileType);\n};\nvar isWebm = (data) => {\n  return matchesPattern(webmPattern)(data.subarray(0, 4));\n};\nvar isIsoBaseMedia = (data) => {\n  const isoBaseMediaMp4Pattern = new TextEncoder().encode(\"ftyp\");\n  return matchesPattern(isoBaseMediaMp4Pattern)(data.subarray(4, 8));\n};\nvar isTransportStream = (data) => {\n  return data[0] === 71 && data[188] === 71;\n};\nvar isMp3 = (data) => {\n  const mpegPattern = new Uint8Array([255, 243]);\n  const mpegPattern2 = new Uint8Array([255, 251]);\n  const id3v4Pattern = new Uint8Array([73, 68, 51, 4]);\n  const id3v3Pattern = new Uint8Array([73, 68, 51, 3]);\n  const id3v2Pattern = new Uint8Array([73, 68, 51, 2]);\n  const subarray = data.subarray(0, 4);\n  return matchesPattern(mpegPattern)(subarray) || matchesPattern(mpegPattern2)(subarray) || matchesPattern(id3v4Pattern)(subarray) || matchesPattern(id3v3Pattern)(subarray) || matchesPattern(id3v2Pattern)(subarray);\n};\nvar isAac = (data) => {\n  const aacPattern = new Uint8Array([255, 241]);\n  return matchesPattern(aacPattern)(data.subarray(0, 2));\n};\nvar isFlac = (data) => {\n  const flacPattern = new Uint8Array([102, 76, 97, 67]);\n  return matchesPattern(flacPattern)(data.subarray(0, 4));\n};\nvar isM3u = (data) => {\n  return new TextDecoder(\"utf-8\").decode(data.slice(0, 7)) === \"#EXTM3U\";\n};\n\n// src/file-types/bmp.ts\nfunction getBmpDimensions(bmpData) {\n  if (bmpData.length < 26) {\n    return null;\n  }\n  const view = new DataView(bmpData.buffer, bmpData.byteOffset);\n  return {\n    width: view.getUint32(18, true),\n    height: Math.abs(view.getInt32(22, true))\n  };\n}\nvar isBmp = (data) => {\n  const bmpPattern = new Uint8Array([66, 77]);\n  if (matchesPattern(bmpPattern)(data.subarray(0, 2))) {\n    const bmp = getBmpDimensions(data);\n    return { dimensions: bmp, type: \"bmp\" };\n  }\n  return null;\n};\n\n// src/file-types/gif.ts\nvar getGifDimensions = (data) => {\n  const view = new DataView(data.buffer, data.byteOffset);\n  const width = view.getUint16(6, true);\n  const height = view.getUint16(8, true);\n  return { width, height };\n};\nvar isGif = (data) => {\n  const gifPattern = new Uint8Array([71, 73, 70, 56]);\n  if (matchesPattern(gifPattern)(data.subarray(0, 4))) {\n    return { type: \"gif\", dimensions: getGifDimensions(data) };\n  }\n  return null;\n};\n\n// src/file-types/jpeg.ts\nfunction getJpegDimensions(data) {\n  let offset = 0;\n  function readUint16BE(o) {\n    return data[o] << 8 | data[o + 1];\n  }\n  if (readUint16BE(offset) !== 65496) {\n    return null;\n  }\n  offset += 2;\n  while (offset < data.length) {\n    if (data[offset] === 255) {\n      const marker = data[offset + 1];\n      if (marker === 192 || marker === 194) {\n        const height = readUint16BE(offset + 5);\n        const width = readUint16BE(offset + 7);\n        return { width, height };\n      }\n      const length = readUint16BE(offset + 2);\n      offset += length + 2;\n    } else {\n      offset++;\n    }\n  }\n  return null;\n}\nvar isJpeg = (data) => {\n  const jpegPattern = new Uint8Array([255, 216]);\n  const jpeg = matchesPattern(jpegPattern)(data.subarray(0, 2));\n  if (!jpeg) {\n    return null;\n  }\n  const dim = getJpegDimensions(data);\n  return { dimensions: dim, type: \"jpeg\" };\n};\n\n// src/file-types/pdf.ts\nvar isPdf = (data) => {\n  if (data.length < 4) {\n    return null;\n  }\n  const pdfPattern = new Uint8Array([37, 80, 68, 70]);\n  return matchesPattern(pdfPattern)(data.subarray(0, 4)) ? { type: \"pdf\" } : null;\n};\n\n// src/file-types/png.ts\nfunction getPngDimensions(pngData) {\n  if (pngData.length < 24) {\n    return null;\n  }\n  const view = new DataView(pngData.buffer, pngData.byteOffset);\n  const pngSignature = [137, 80, 78, 71, 13, 10, 26, 10];\n  for (let i = 0;i < 8; i++) {\n    if (pngData[i] !== pngSignature[i]) {\n      return null;\n    }\n  }\n  return {\n    width: view.getUint32(16, false),\n    height: view.getUint32(20, false)\n  };\n}\nvar isPng = (data) => {\n  const pngPattern = new Uint8Array([137, 80, 78, 71]);\n  if (matchesPattern(pngPattern)(data.subarray(0, 4))) {\n    const png = getPngDimensions(data);\n    return { dimensions: png, type: \"png\" };\n  }\n  return null;\n};\n\n// src/file-types/webp.ts\nfunction getWebPDimensions(bytes) {\n  if (bytes.length < 30) {\n    return null;\n  }\n  if (bytes[0] !== 82 || bytes[1] !== 73 || bytes[2] !== 70 || bytes[3] !== 70 || bytes[8] !== 87 || bytes[9] !== 69 || bytes[10] !== 66 || bytes[11] !== 80) {\n    return null;\n  }\n  if (bytes[12] === 86 && bytes[13] === 80 && bytes[14] === 56) {\n    if (bytes[15] === 32) {\n      return {\n        width: bytes[26] | bytes[27] << 8 & 16383,\n        height: bytes[28] | bytes[29] << 8 & 16383\n      };\n    }\n  }\n  if (bytes[12] === 86 && bytes[13] === 80 && bytes[14] === 56 && bytes[15] === 76) {\n    return {\n      width: 1 + (bytes[21] | (bytes[22] & 63) << 8),\n      height: 1 + ((bytes[22] & 192) >> 6 | bytes[23] << 2 | (bytes[24] & 15) << 10)\n    };\n  }\n  if (bytes[12] === 86 && bytes[13] === 80 && bytes[14] === 56 && bytes[15] === 88) {\n    return {\n      width: 1 + (bytes[24] | bytes[25] << 8 | bytes[26] << 16),\n      height: 1 + (bytes[27] | bytes[28] << 8 | bytes[29] << 16)\n    };\n  }\n  return null;\n}\nvar isWebp = (data) => {\n  const webpPattern = new Uint8Array([82, 73, 70, 70]);\n  if (matchesPattern(webpPattern)(data.subarray(0, 4))) {\n    return {\n      type: \"webp\",\n      dimensions: getWebPDimensions(data)\n    };\n  }\n  return null;\n};\n\n// src/file-types/index.ts\nvar detectFileType = (data) => {\n  if (isRiffWave(data)) {\n    return { type: \"wav\" };\n  }\n  if (isRiffAvi2(data)) {\n    return { type: \"riff\" };\n  }\n  if (isAac(data)) {\n    return { type: \"aac\" };\n  }\n  if (isFlac(data)) {\n    return { type: \"flac\" };\n  }\n  if (isM3u(data)) {\n    return { type: \"m3u\" };\n  }\n  const webp = isWebp(data);\n  if (webp) {\n    return webp;\n  }\n  if (isWebm(data)) {\n    return { type: \"webm\" };\n  }\n  if (isIsoBaseMedia(data)) {\n    return { type: \"iso-base-media\" };\n  }\n  if (isTransportStream(data)) {\n    return { type: \"transport-stream\" };\n  }\n  if (isMp3(data)) {\n    return { type: \"mp3\" };\n  }\n  const gif = isGif(data);\n  if (gif) {\n    return gif;\n  }\n  const png = isPng(data);\n  if (png) {\n    return png;\n  }\n  const pdf = isPdf(data);\n  if (pdf) {\n    return pdf;\n  }\n  const bmp = isBmp(data);\n  if (bmp) {\n    return bmp;\n  }\n  const jpeg = isJpeg(data);\n  if (jpeg) {\n    return jpeg;\n  }\n  return { type: \"unknown\" };\n};\n\n// src/iterator/polyfilled-arraybuffer.ts\nclass ResizableBuffer {\n  buffer;\n  uintarray;\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.uintarray = new Uint8Array(buffer);\n  }\n  resize(newLength) {\n    if (typeof this.buffer.resize === \"function\") {\n      this.buffer.resize(newLength);\n    } else {\n      const newBuffer = new ArrayBuffer(newLength);\n      new Uint8Array(newBuffer).set(new Uint8Array(this.buffer).subarray(0, Math.min(this.buffer.byteLength, newLength)));\n      this.buffer = newBuffer;\n      this.uintarray = new Uint8Array(newBuffer);\n    }\n  }\n}\n\n// src/iterator/buffer-manager.ts\nvar makeBufferWithMaxBytes = (initialData, maxBytes) => {\n  const maxByteLength = Math.min(maxBytes, 2 ** 31);\n  try {\n    const buf = new ArrayBuffer(initialData.byteLength, {\n      maxByteLength\n    });\n    return new ResizableBuffer(buf);\n  } catch (e) {\n    if (e instanceof RangeError && maxBytes > 2 ** 27) {\n      return new ResizableBuffer(new ArrayBuffer(initialData.byteLength, {\n        maxByteLength: 2 ** 27\n      }));\n    }\n    throw e;\n  }\n};\nvar bufferManager = ({\n  initialData,\n  maxBytes,\n  counter,\n  logLevel\n}) => {\n  const buf = makeBufferWithMaxBytes(initialData, maxBytes);\n  if (!buf.buffer.resize) {\n    Log.warn(logLevel, \"`ArrayBuffer.resize` is not supported in this Runtime. Using slow polyfill.\");\n  }\n  buf.uintarray.set(initialData);\n  let view = new DataView(buf.uintarray.buffer);\n  const destroy = () => {\n    buf.uintarray = new Uint8Array(0);\n    buf.resize(0);\n  };\n  const flushBytesRead = (force, mode) => {\n    const bytesToRemove = counter.getDiscardedOffset();\n    if (bytesToRemove < 3000000 && !force) {\n      return { bytesRemoved: 0, removedData: null };\n    }\n    if (view.byteLength < bytesToRemove && !force) {\n      return { bytesRemoved: 0, removedData: null };\n    }\n    counter.discardBytes(bytesToRemove);\n    const removedData = mode === \"download\" ? buf.uintarray.slice(0, bytesToRemove) : null;\n    const newData = buf.uintarray.slice(bytesToRemove);\n    buf.uintarray.set(newData);\n    buf.resize(newData.byteLength);\n    view = new DataView(buf.uintarray.buffer);\n    return { bytesRemoved: bytesToRemove, removedData };\n  };\n  const skipTo = (offset) => {\n    const becomesSmaller = offset < counter.getOffset();\n    if (becomesSmaller) {\n      const toDecrement = counter.getOffset() - offset;\n      if (toDecrement > counter.getDiscardedOffset()) {\n        throw new Error(\"Cannot count backwards, data has already been flushed\");\n      }\n      counter.decrement(toDecrement);\n    }\n    const currentOffset = counter.getOffset();\n    counter.increment(offset - currentOffset);\n  };\n  const addData = (newData) => {\n    const oldLength = buf.buffer.byteLength;\n    const newLength = oldLength + newData.byteLength;\n    if (newLength < oldLength) {\n      throw new Error(\"Cannot decrement size\");\n    }\n    if (newLength > (maxBytes ?? Infinity)) {\n      throw new Error(`Exceeded maximum byte length ${maxBytes} with ${newLength}`);\n    }\n    buf.resize(newLength);\n    buf.uintarray = new Uint8Array(buf.buffer);\n    buf.uintarray.set(newData, oldLength);\n    view = new DataView(buf.uintarray.buffer);\n  };\n  const replaceData = (newData, seekTo) => {\n    buf.resize(newData.byteLength);\n    buf.uintarray = new Uint8Array(buf.buffer);\n    buf.uintarray.set(newData);\n    view = new DataView(buf.uintarray.buffer);\n    counter.setDiscardedOffset(seekTo);\n    counter.decrement(counter.getOffset());\n    counter.increment(seekTo);\n  };\n  return {\n    getView: () => view,\n    getUint8Array: () => buf.uintarray,\n    destroy,\n    addData,\n    skipTo,\n    removeBytesRead: flushBytesRead,\n    replaceData\n  };\n};\n\n// src/iterator/offset-counter.ts\nvar makeOffsetCounter = (initial) => {\n  let offset = initial;\n  let discardedBytes = 0;\n  return {\n    getOffset: () => offset,\n    discardBytes: (bytes) => {\n      discardedBytes += bytes;\n    },\n    increment: (bytes) => {\n      if (bytes < 0) {\n        throw new Error(\"Cannot increment by a negative amount: \" + bytes);\n      }\n      offset += bytes;\n    },\n    getDiscardedBytes: () => discardedBytes,\n    setDiscardedOffset: (bytes) => {\n      discardedBytes = bytes;\n    },\n    getDiscardedOffset: () => offset - discardedBytes,\n    decrement: (bytes) => {\n      if (bytes < 0) {\n        throw new Error(\"Cannot decrement by a negative amount: \" + bytes);\n      }\n      offset -= bytes;\n    }\n  };\n};\n\n// src/iterator/buffer-iterator.ts\nvar getArrayBufferIterator = ({\n  initialData,\n  maxBytes,\n  logLevel\n}) => {\n  const counter = makeOffsetCounter(0);\n  const {\n    getUint8Array,\n    getView,\n    addData,\n    destroy,\n    removeBytesRead,\n    skipTo,\n    replaceData\n  } = bufferManager({ initialData, maxBytes, counter, logLevel });\n  const startCheckpoint = () => {\n    const checkpoint = counter.getOffset();\n    return {\n      returnToCheckpoint: () => {\n        counter.decrement(counter.getOffset() - checkpoint);\n      }\n    };\n  };\n  const getSlice = (amount) => {\n    const value = getUint8Array().slice(counter.getDiscardedOffset(), counter.getDiscardedOffset() + amount);\n    counter.increment(value.length);\n    return value;\n  };\n  const discard = (length) => {\n    counter.increment(length);\n  };\n  const readUntilNullTerminator = () => {\n    const bytes = [];\n    let byte;\n    while ((byte = getUint8()) !== 0) {\n      bytes.push(byte);\n    }\n    counter.decrement(1);\n    return new TextDecoder().decode(new Uint8Array(bytes));\n  };\n  const readUntilLineEnd = () => {\n    const bytes = [];\n    while (true) {\n      if (bytesRemaining() === 0) {\n        return null;\n      }\n      const byte = getUint8();\n      bytes.push(byte);\n      if (byte === 10) {\n        break;\n      }\n    }\n    const str = new TextDecoder().decode(new Uint8Array(bytes)).trim();\n    return str;\n  };\n  const getUint8 = () => {\n    const val = getView().getUint8(counter.getDiscardedOffset());\n    counter.increment(1);\n    return val;\n  };\n  const getEightByteNumber = (littleEndian = false) => {\n    if (littleEndian) {\n      const one = getUint8();\n      const two = getUint8();\n      const three = getUint8();\n      const four = getUint8();\n      const five = getUint8();\n      const six = getUint8();\n      const seven = getUint8();\n      const eight = getUint8();\n      return (eight << 56 | seven << 48 | six << 40 | five << 32 | four << 24 | three << 16 | two << 8 | one) >>> 0;\n    }\n    function byteArrayToBigInt(byteArray) {\n      let result = BigInt(0);\n      for (let i = 0;i < byteArray.length; i++) {\n        result = (result << BigInt(8)) + BigInt(byteArray[i]);\n      }\n      return result;\n    }\n    const bigInt = byteArrayToBigInt([\n      getUint8(),\n      getUint8(),\n      getUint8(),\n      getUint8(),\n      getUint8(),\n      getUint8(),\n      getUint8(),\n      getUint8()\n    ]);\n    return Number(bigInt);\n  };\n  const getFourByteNumber = () => {\n    const unsigned = getUint8() << 24 | getUint8() << 16 | getUint8() << 8 | getUint8();\n    return unsigned >>> 0;\n  };\n  const getPaddedFourByteNumber = () => {\n    let lastInt = 128;\n    while (lastInt = getUint8(), lastInt === 128) {}\n    return lastInt;\n  };\n  const getUint32 = () => {\n    const val = getView().getUint32(counter.getDiscardedOffset());\n    counter.increment(4);\n    return val;\n  };\n  const getSyncSafeInt32 = () => {\n    const val = getView().getUint32(counter.getDiscardedOffset());\n    counter.increment(4);\n    return (val & 2130706432) >> 3 | (val & 8323072) >> 2 | (val & 32512) >> 1 | val & 127;\n  };\n  const getUint64 = (littleEndian = false) => {\n    const val = getView().getBigUint64(counter.getDiscardedOffset(), littleEndian);\n    counter.increment(8);\n    return val;\n  };\n  const getInt64 = (littleEndian = false) => {\n    const val = getView().getBigInt64(counter.getDiscardedOffset(), littleEndian);\n    counter.increment(8);\n    return val;\n  };\n  const startBox = (size) => {\n    const startOffset = counter.getOffset();\n    return {\n      discardRest: () => discard(size - (counter.getOffset() - startOffset)),\n      expectNoMoreBytes: () => {\n        const remaining = size - (counter.getOffset() - startOffset);\n        if (remaining !== 0) {\n          throw new Error(\"expected 0 bytes, got \" + remaining);\n        }\n      }\n    };\n  };\n  const getUint32Le = () => {\n    const val = getView().getUint32(counter.getDiscardedOffset(), true);\n    counter.increment(4);\n    return val;\n  };\n  const getInt32Le = () => {\n    const val = getView().getInt32(counter.getDiscardedOffset(), true);\n    counter.increment(4);\n    return val;\n  };\n  const getInt32 = () => {\n    const val = getView().getInt32(counter.getDiscardedOffset());\n    counter.increment(4);\n    return val;\n  };\n  const bytesRemaining = () => {\n    return getUint8Array().byteLength - counter.getDiscardedOffset();\n  };\n  const readExpGolomb = () => {\n    if (!bitReadingMode) {\n      throw new Error(\"Not in bit reading mode\");\n    }\n    let zerosCount = 0;\n    while (getBits(1) === 0) {\n      zerosCount++;\n    }\n    let suffix = 0;\n    for (let i = 0;i < zerosCount; i++) {\n      suffix = suffix << 1 | getBits(1);\n    }\n    return (1 << zerosCount) - 1 + suffix;\n  };\n  const peekB = (length) => {\n    Log.info(\"info\", [...getSlice(length)].map((b) => b.toString(16).padStart(2, \"0\")));\n    counter.decrement(length);\n  };\n  const peekD = (length) => {\n    Log.info(\"info\", [...getSlice(length)].map((b) => b.toString(16).padStart(2, \"0\")));\n    counter.decrement(length);\n  };\n  const leb128 = () => {\n    let result = 0;\n    let shift = 0;\n    let byte;\n    do {\n      byte = getBits(8);\n      result |= (byte & 127) << shift;\n      shift += 7;\n    } while (byte >= 128);\n    return result;\n  };\n  let bitIndex = 0;\n  const stopReadingBits = () => {\n    bitIndex = 0;\n    bitReadingMode = false;\n  };\n  let byteToShift = 0;\n  let bitReadingMode = false;\n  const startReadingBits = () => {\n    bitReadingMode = true;\n    byteToShift = getUint8();\n  };\n  const getFlacCodecNumber = () => {\n    let ones = 0;\n    let bits = 0;\n    while ((++bits || true) && getBits(1) === 1) {\n      ones++;\n    }\n    if (ones === 0) {\n      return getBits(7);\n    }\n    const bitArray = [];\n    const firstByteBits = 8 - ones - 1;\n    for (let i = 0;i < firstByteBits; i++) {\n      bitArray.unshift(getBits(1));\n    }\n    const extraBytes = ones - 1;\n    for (let i = 0;i < extraBytes; i++) {\n      for (let j = 0;j < 8; j++) {\n        const val = getBits(1);\n        if (j < 2) {\n          continue;\n        }\n        bitArray.unshift(val);\n      }\n    }\n    const encoded = bitArray.reduce((acc, bit, index) => {\n      return acc | bit << index;\n    }, 0);\n    return encoded;\n  };\n  const getBits = (bits) => {\n    let result = 0;\n    let bitsCollected = 0;\n    while (bitsCollected < bits) {\n      if (bitIndex >= 8) {\n        bitIndex = 0;\n        byteToShift = getUint8();\n      }\n      const remainingBitsInByte = 8 - bitIndex;\n      const bitsToReadNow = Math.min(bits - bitsCollected, remainingBitsInByte);\n      const mask = (1 << bitsToReadNow) - 1;\n      const shift = remainingBitsInByte - bitsToReadNow;\n      result <<= bitsToReadNow;\n      result |= byteToShift >> shift & mask;\n      bitsCollected += bitsToReadNow;\n      bitIndex += bitsToReadNow;\n    }\n    return result;\n  };\n  return {\n    startReadingBits,\n    stopReadingBits,\n    skipTo,\n    addData,\n    counter,\n    peekB,\n    peekD,\n    getBits,\n    bytesRemaining,\n    leb128,\n    removeBytesRead,\n    discard,\n    getEightByteNumber,\n    getFourByteNumber,\n    getSlice,\n    getAtom: () => {\n      const atom = getSlice(4);\n      return new TextDecoder().decode(atom);\n    },\n    detectFileType: () => {\n      return detectFileType(getUint8Array());\n    },\n    getPaddedFourByteNumber,\n    getMatroskaSegmentId: () => {\n      if (bytesRemaining() === 0) {\n        return null;\n      }\n      const first = getSlice(1);\n      const firstOneString = `0x${Array.from(new Uint8Array(first)).map((b) => {\n        return b.toString(16).padStart(2, \"0\");\n      }).join(\"\")}`;\n      if (knownIdsWithOneLength.includes(firstOneString)) {\n        return firstOneString;\n      }\n      if (bytesRemaining() === 0) {\n        return null;\n      }\n      const firstTwo = getSlice(1);\n      const firstTwoString = `${firstOneString}${Array.from(new Uint8Array(firstTwo)).map((b) => {\n        return b.toString(16).padStart(2, \"0\");\n      }).join(\"\")}`;\n      if (knownIdsWithTwoLength.includes(firstTwoString)) {\n        return firstTwoString;\n      }\n      if (bytesRemaining() === 0) {\n        return null;\n      }\n      const firstThree = getSlice(1);\n      const firstThreeString = `${firstTwoString}${Array.from(new Uint8Array(firstThree)).map((b) => {\n        return b.toString(16).padStart(2, \"0\");\n      }).join(\"\")}`;\n      if (knownIdsWithThreeLength.includes(firstThreeString)) {\n        return firstThreeString;\n      }\n      if (bytesRemaining() === 0) {\n        return null;\n      }\n      const segmentId = getSlice(1);\n      return `${firstThreeString}${Array.from(new Uint8Array(segmentId)).map((b) => {\n        return b.toString(16).padStart(2, \"0\");\n      }).join(\"\")}`;\n    },\n    getVint: () => {\n      if (bytesRemaining() === 0) {\n        return null;\n      }\n      const firstByte = getUint8();\n      const totalLength = firstByte;\n      if (totalLength === 0) {\n        return 0;\n      }\n      let actualLength = 0;\n      while ((totalLength >> 7 - actualLength & 1) === 0) {\n        actualLength++;\n      }\n      if (bytesRemaining() < actualLength) {\n        return null;\n      }\n      const slice = getSlice(actualLength);\n      const d = [firstByte, ...Array.from(new Uint8Array(slice))];\n      actualLength += 1;\n      let value = 0;\n      value = totalLength & 255 >> actualLength;\n      for (let i = 1;i < actualLength; i++) {\n        value = value << 8 | d[i];\n      }\n      if (value === -1) {\n        return Infinity;\n      }\n      return value;\n    },\n    getUint8,\n    getEBML: () => {\n      const val = getUint8();\n      const actualValue = val & 127;\n      return actualValue;\n    },\n    getInt8: () => {\n      const val = getView().getInt8(counter.getDiscardedOffset());\n      counter.increment(1);\n      return val;\n    },\n    getUint16: () => {\n      const val = getView().getUint16(counter.getDiscardedOffset());\n      counter.increment(2);\n      return val;\n    },\n    getUint16Le: () => {\n      const val = getView().getUint16(counter.getDiscardedOffset(), true);\n      counter.increment(2);\n      return val;\n    },\n    getUint24: () => {\n      const val1 = getView().getUint8(counter.getDiscardedOffset());\n      const val2 = getView().getUint8(counter.getDiscardedOffset() + 1);\n      const val3 = getView().getUint8(counter.getDiscardedOffset() + 2);\n      counter.increment(3);\n      return val1 << 16 | val2 << 8 | val3;\n    },\n    getInt24: () => {\n      const val1 = getView().getInt8(counter.getDiscardedOffset());\n      const val2 = getView().getUint8(counter.getDiscardedOffset() + 1);\n      const val3 = getView().getUint8(counter.getDiscardedOffset() + 2);\n      counter.increment(3);\n      return val1 << 16 | val2 << 8 | val3;\n    },\n    getInt16: () => {\n      const val = getView().getInt16(counter.getDiscardedOffset());\n      counter.increment(2);\n      return val;\n    },\n    getUint32,\n    getUint64,\n    getInt64,\n    getFixedPointUnsigned1616Number: () => {\n      const val = getUint32();\n      return val / 2 ** 16;\n    },\n    getFixedPointSigned1616Number: () => {\n      const val = getInt32();\n      return val / 2 ** 16;\n    },\n    getFixedPointSigned230Number: () => {\n      const val = getInt32();\n      return val / 2 ** 30;\n    },\n    getPascalString: () => {\n      const val = getSlice(32);\n      return [...Array.from(new Uint8Array(val))];\n    },\n    getUint(length) {\n      const bytes = getSlice(length);\n      const numbers = [...Array.from(new Uint8Array(bytes))];\n      return numbers.reduce((acc, byte, index) => acc + (byte << 8 * (numbers.length - index - 1)), 0);\n    },\n    getByteString(length, trimTrailingZeroes) {\n      let bytes = getSlice(length);\n      while (trimTrailingZeroes && bytes[bytes.length - 1] === 0) {\n        bytes = bytes.slice(0, -1);\n      }\n      return new TextDecoder().decode(bytes).trim();\n    },\n    planBytes: (size) => {\n      const currentOffset = counter.getOffset();\n      return {\n        discardRest: () => {\n          const toDiscard = size - (counter.getOffset() - currentOffset);\n          if (toDiscard < 0) {\n            throw new Error(\"read too many bytes\");\n          }\n          return getSlice(toDiscard);\n        }\n      };\n    },\n    getFloat64: () => {\n      const val = getView().getFloat64(counter.getDiscardedOffset());\n      counter.increment(8);\n      return val;\n    },\n    readUntilNullTerminator,\n    getFloat32: () => {\n      const val = getView().getFloat32(counter.getDiscardedOffset());\n      counter.increment(4);\n      return val;\n    },\n    getUint32Le,\n    getInt32Le,\n    getInt32,\n    destroy,\n    startBox,\n    readExpGolomb,\n    startCheckpoint,\n    getFlacCodecNumber,\n    readUntilLineEnd,\n    getSyncSafeInt32,\n    replaceData\n  };\n};\n\n// src/containers/webm/av1-codec-private.ts\nvar parseAv1PrivateData = (data, colrAtom) => {\n  const iterator = getArrayBufferIterator({\n    initialData: data,\n    maxBytes: data.byteLength,\n    logLevel: \"error\"\n  });\n  iterator.startReadingBits();\n  if (iterator.getBits(1) !== 1) {\n    iterator.destroy();\n    throw new Error(\"Expected av1 private data to be version 1\");\n  }\n  const version = iterator.getBits(7);\n  if (version !== 1) {\n    iterator.destroy();\n    throw new Error(`Expected av1 private data to be version 1, got ${version}`);\n  }\n  let str = \"av01.\";\n  const seqProfile = iterator.getBits(3);\n  str += seqProfile;\n  str += \".\";\n  const seq_level_idx = iterator.getBits(5);\n  const seq_tier_0 = iterator.getBits(1);\n  str += String(seq_level_idx).padStart(2, \"0\");\n  str += seq_tier_0 ? \"H\" : \"M\";\n  str += \".\";\n  const high_bitdepth = iterator.getBits(1);\n  const twelve_bit = iterator.getBits(1);\n  const bitDepth2 = high_bitdepth && seqProfile === 2 ? twelve_bit ? 12 : 10 : high_bitdepth ? 10 : 8;\n  str += bitDepth2.toString().padStart(2, \"0\");\n  str += \".\";\n  const mono_chrome = iterator.getBits(1);\n  str += mono_chrome ? \"1\" : \"0\";\n  str += \".\";\n  const subsampling_x = iterator.getBits(1);\n  str += subsampling_x ? \"1\" : \"0\";\n  const subsampling_y = iterator.getBits(1);\n  str += subsampling_y ? \"1\" : \"0\";\n  const chroma_sample_position = iterator.getBits(2);\n  str += subsampling_x && subsampling_y ? chroma_sample_position === 1 ? \"1\" : \"0\" : \"0\";\n  str += \".\";\n  if (colrAtom && colrAtom.colorType === \"transfer-characteristics\") {\n    str += colrAtom.primaries.toString().padStart(2, \"0\");\n    str += \".\";\n    str += colrAtom.transfer.toString().padStart(2, \"0\");\n    str += \".\";\n    str += colrAtom.matrixIndex.toString().padStart(2, \"0\");\n    str += \".\";\n    str += colrAtom.fullRangeFlag ? \"1\" : \"0\";\n  } else {\n    str += \"01\";\n    str += \".\";\n    str += \"01\";\n    str += \".\";\n    str += \"01\";\n    str += \".\";\n    str += \"0\";\n  }\n  const suffix = \".0.110.01.01.01.0\";\n  if (str.endsWith(suffix)) {\n    str = str.slice(0, -suffix.length);\n  }\n  iterator.destroy();\n  return str;\n};\n\n// src/get-video-codec.ts\nvar getVideoCodec = (state) => {\n  const track = getTracks(state, true);\n  return track.find((t) => t.type === \"video\")?.codecEnum ?? null;\n};\nvar hasVideoCodec = (state) => {\n  return getHasTracks(state, true);\n};\nvar getVideoPrivateData = (trakBox) => {\n  const videoSample = getStsdVideoConfig(trakBox);\n  const avccBox = getAvccBox(trakBox);\n  const hvccBox = getHvccBox(trakBox);\n  const av1cBox = getAv1CBox(trakBox);\n  if (!videoSample) {\n    return null;\n  }\n  if (avccBox) {\n    return { type: \"avc-sps-pps\", data: avccBox.privateData };\n  }\n  if (hvccBox) {\n    return { type: \"hvcc-data\", data: hvccBox.privateData };\n  }\n  if (av1cBox) {\n    return { type: \"av1c-data\", data: av1cBox.privateData };\n  }\n  return null;\n};\nvar getIsoBmColrConfig = (trakBox) => {\n  const videoSample = getStsdVideoConfig(trakBox);\n  if (!videoSample) {\n    return null;\n  }\n  const colrAtom = getColrBox(videoSample);\n  if (!colrAtom) {\n    return null;\n  }\n  if (colrAtom.colorType !== \"transfer-characteristics\") {\n    return null;\n  }\n  return {\n    fullRange: colrAtom.fullRangeFlag,\n    matrix: getMatrixCoefficientsFromIndex(colrAtom.matrixIndex),\n    primaries: getPrimariesFromIndex(colrAtom.primaries),\n    transfer: getTransferCharacteristicsFromIndex(colrAtom.transfer)\n  };\n};\nvar getVideoCodecString = (trakBox) => {\n  const videoSample = getStsdVideoConfig(trakBox);\n  const avccBox = getAvccBox(trakBox);\n  if (!videoSample) {\n    return null;\n  }\n  if (avccBox) {\n    return `${videoSample.format}.${avccBox.configurationString}`;\n  }\n  const hvccBox = getHvccBox(trakBox);\n  if (hvccBox) {\n    return `${videoSample.format}.${hvccBox.configurationString}`;\n  }\n  const av1cBox = getAv1CBox(trakBox);\n  if (av1cBox) {\n    const colrAtom = getColrBox(videoSample);\n    return parseAv1PrivateData(av1cBox.privateData, colrAtom);\n  }\n  const vpccBox = getVpccBox(trakBox);\n  if (vpccBox) {\n    return `${videoSample.format}.${vpccBox.codecString}`;\n  }\n  return videoSample.format;\n};\n\n// src/normalize-video-rotation.ts\nvar normalizeVideoRotation = (rotation) => {\n  return (rotation % 360 + 360) % 360;\n};\n\n// src/webcodecs-timescale.ts\nvar WEBCODECS_TIMESCALE = 1e6;\n\n// src/containers/iso-base-media/color-to-webcodecs-colors.ts\nvar mediaParserAdvancedColorToWebCodecsColor = (color2) => {\n  return {\n    transfer: color2.transfer,\n    matrix: color2.matrix,\n    primaries: color2.primaries,\n    fullRange: color2.fullRange\n  };\n};\n\n// src/aac-codecprivate.ts\nvar getSampleRateFromSampleFrequencyIndex = (samplingFrequencyIndex) => {\n  switch (samplingFrequencyIndex) {\n    case 0:\n      return 96000;\n    case 1:\n      return 88200;\n    case 2:\n      return 64000;\n    case 3:\n      return 48000;\n    case 4:\n      return 44100;\n    case 5:\n      return 32000;\n    case 6:\n      return 24000;\n    case 7:\n      return 22050;\n    case 8:\n      return 16000;\n    case 9:\n      return 12000;\n    case 10:\n      return 11025;\n    case 11:\n      return 8000;\n    case 12:\n      return 7350;\n    default:\n      throw new Error(`Unexpected sampling frequency index ${samplingFrequencyIndex}`);\n  }\n};\nvar getConfigForSampleRate = (sampleRate) => {\n  if (sampleRate === 96000) {\n    return 0;\n  }\n  if (sampleRate === 88200) {\n    return 1;\n  }\n  if (sampleRate === 64000) {\n    return 2;\n  }\n  if (sampleRate === 48000) {\n    return 3;\n  }\n  if (sampleRate === 44100) {\n    return 4;\n  }\n  if (sampleRate === 32000) {\n    return 5;\n  }\n  if (sampleRate === 24000) {\n    return 6;\n  }\n  if (sampleRate === 22050) {\n    return 7;\n  }\n  if (sampleRate === 16000) {\n    return 8;\n  }\n  if (sampleRate === 12000) {\n    return 9;\n  }\n  if (sampleRate === 11025) {\n    return 10;\n  }\n  if (sampleRate === 8000) {\n    return 11;\n  }\n  if (sampleRate === 7350) {\n    return 12;\n  }\n  throw new Error(`Unexpected sample rate ${sampleRate}`);\n};\nvar createAacCodecPrivate = ({\n  audioObjectType,\n  sampleRate,\n  channelConfiguration,\n  codecPrivate: codecPrivate2\n}) => {\n  if (codecPrivate2 !== null && codecPrivate2.length > 2) {\n    return codecPrivate2;\n  }\n  const bits = `${audioObjectType.toString(2).padStart(5, \"0\")}${getConfigForSampleRate(sampleRate).toString(2).padStart(4, \"0\")}${channelConfiguration.toString(2).padStart(4, \"0\")}000`;\n  if (bits.length !== 16) {\n    throw new Error(\"Invalid AAC codec private \" + bits.length);\n  }\n  if (channelConfiguration === 0 || channelConfiguration > 7) {\n    throw new Error(\"Invalid channel configuration \" + channelConfiguration);\n  }\n  const firstByte = parseInt(bits.slice(0, 8), 2);\n  const secondByte = parseInt(bits.slice(8, 16), 2);\n  return new Uint8Array([firstByte, secondByte]);\n};\nvar parseAacCodecPrivate = (bytes) => {\n  if (bytes.length < 2) {\n    throw new Error(\"Invalid AAC codec private length\");\n  }\n  const bits = [...bytes].map((b) => b.toString(2).padStart(8, \"0\")).join(\"\");\n  let offset = 0;\n  const audioObjectType = parseInt(bits.slice(offset, offset + 5), 2);\n  offset += 5;\n  const samplingFrequencyIndex = parseInt(bits.slice(offset, offset + 4), 2);\n  offset += 4;\n  if (samplingFrequencyIndex === 15) {\n    offset += 24;\n  }\n  const channelConfiguration = parseInt(bits.slice(offset, offset + 4), 2);\n  offset += 4;\n  if (audioObjectType === 5) {\n    const extensionSamplingFrequencyIndex = parseInt(bits.slice(offset, offset + 4), 2);\n    offset += 4;\n    const newAudioObjectType = parseInt(bits.slice(offset, offset + 5), 2);\n    offset += 5;\n    return {\n      audioObjectType: newAudioObjectType,\n      sampleRate: getSampleRateFromSampleFrequencyIndex(extensionSamplingFrequencyIndex),\n      channelConfiguration\n    };\n  }\n  const sampleRate = getSampleRateFromSampleFrequencyIndex(samplingFrequencyIndex);\n  return {\n    audioObjectType,\n    sampleRate,\n    channelConfiguration\n  };\n};\nvar mapAudioObjectTypeToCodecString = (audioObjectType) => {\n  switch (audioObjectType) {\n    case 1:\n      return \"mp4a.40.2\";\n    case 2:\n      return \"mp4a.40.5\";\n    case 3:\n      return \"mp4a.40.29\";\n    case 4:\n      return \"mp4a.40.1\";\n    case 5:\n      return \"mp4a.40.3\";\n    case 6:\n      return \"mp4a.40.4\";\n    case 17:\n      return \"mp4a.40.17\";\n    case 23:\n      return \"mp4a.40.23\";\n    default:\n      throw new Error(`Unexpected audio object type ${audioObjectType}`);\n  }\n};\n\n// src/containers/iso-base-media/get-actual-number-of-channels.ts\nvar getActualDecoderParameters = ({\n  audioCodec,\n  codecPrivate: codecPrivate2,\n  numberOfChannels,\n  sampleRate\n}) => {\n  if (audioCodec !== \"aac\") {\n    return {\n      numberOfChannels,\n      sampleRate,\n      codecPrivate: codecPrivate2\n    };\n  }\n  if (codecPrivate2 === null) {\n    return { numberOfChannels, sampleRate, codecPrivate: codecPrivate2 };\n  }\n  if (codecPrivate2.type !== \"aac-config\") {\n    throw new Error(\"Expected AAC codec private data\");\n  }\n  const parsed = parseAacCodecPrivate(codecPrivate2.data);\n  const actual = createAacCodecPrivate({\n    ...parsed,\n    codecPrivate: codecPrivate2.data\n  });\n  return {\n    numberOfChannels: parsed.channelConfiguration,\n    sampleRate: parsed.sampleRate,\n    codecPrivate: { type: \"aac-config\", data: actual }\n  };\n};\n\n// src/containers/iso-base-media/get-video-codec-from-iso-track.ts\nvar getVideoCodecFromIsoTrak = (trakBox) => {\n  const stsdBox = getStsdBox(trakBox);\n  if (stsdBox && stsdBox.type === \"stsd-box\") {\n    const videoSample = stsdBox.samples.find((s) => s.type === \"video\");\n    if (videoSample && videoSample.type === \"video\") {\n      if (videoSample.format === \"hvc1\" || videoSample.format === \"hev1\") {\n        return \"h265\";\n      }\n      if (videoSample.format === \"avc1\") {\n        return \"h264\";\n      }\n      if (videoSample.format === \"av01\") {\n        return \"av1\";\n      }\n      if (videoSample.format === \"vp09\") {\n        return \"vp9\";\n      }\n      if (videoSample.format === \"ap4h\") {\n        return \"prores\";\n      }\n      if (videoSample.format === \"ap4x\") {\n        return \"prores\";\n      }\n      if (videoSample.format === \"apch\") {\n        return \"prores\";\n      }\n      if (videoSample.format === \"apcn\") {\n        return \"prores\";\n      }\n      if (videoSample.format === \"apcs\") {\n        return \"prores\";\n      }\n      if (videoSample.format === \"apco\") {\n        return \"prores\";\n      }\n      if (videoSample.format === \"aprh\") {\n        return \"prores\";\n      }\n      if (videoSample.format === \"aprn\") {\n        return \"prores\";\n      }\n    }\n  }\n  throw new Error(\"Could not find video codec\");\n};\n\n// src/containers/iso-base-media/mdat/get-editlist.ts\nvar findTrackStartTimeInSeconds = ({\n  movieTimeScale,\n  trakBox\n}) => {\n  const elstBox = getElstBox(trakBox);\n  if (!elstBox) {\n    return 0;\n  }\n  const { entries } = elstBox;\n  let dwellTime = 0;\n  for (const entry of entries) {\n    const { editDuration, mediaTime } = entry;\n    if (mediaTime !== -1) {\n      continue;\n    }\n    dwellTime += editDuration;\n  }\n  return dwellTime / movieTimeScale;\n};\nvar findTrackMediaTimeOffsetInTrackTimescale = ({\n  trakBox\n}) => {\n  const elstBox = getElstBox(trakBox);\n  if (!elstBox) {\n    return 0;\n  }\n  const { entries } = elstBox;\n  let dwellTime = 0;\n  for (const entry of entries) {\n    const { mediaTime } = entry;\n    if (mediaTime === -1) {\n      continue;\n    }\n    dwellTime += mediaTime;\n  }\n  return dwellTime;\n};\n\n// src/containers/iso-base-media/make-track.ts\nvar makeBaseMediaTrack = (trakBox, startTimeInSeconds) => {\n  const tkhdBox = getTkhdBox(trakBox);\n  const videoDescriptors = getVideoDescriptors(trakBox);\n  const timescaleAndDuration = getTimescaleAndDuration(trakBox);\n  if (!tkhdBox) {\n    throw new Error(\"Expected tkhd box in trak box\");\n  }\n  if (!timescaleAndDuration) {\n    throw new Error(\"Expected timescale and duration in trak box\");\n  }\n  if (trakBoxContainsAudio(trakBox)) {\n    const numberOfChannels = getNumberOfChannelsFromTrak(trakBox);\n    if (numberOfChannels === null) {\n      throw new Error(\"Could not find number of channels\");\n    }\n    const sampleRate = getSampleRate(trakBox);\n    if (sampleRate === null) {\n      throw new Error(\"Could not find sample rate\");\n    }\n    const { codecString, description } = getAudioCodecStringFromTrak(trakBox);\n    const codecPrivate2 = getCodecPrivateFromTrak(trakBox) ?? description ?? null;\n    const codecEnum = getAudioCodecFromTrack(trakBox);\n    const actual = getActualDecoderParameters({\n      audioCodec: codecEnum,\n      codecPrivate: codecPrivate2 ?? null,\n      numberOfChannels,\n      sampleRate\n    });\n    return {\n      type: \"audio\",\n      trackId: tkhdBox.trackId,\n      originalTimescale: timescaleAndDuration.timescale,\n      codec: codecString,\n      numberOfChannels: actual.numberOfChannels,\n      sampleRate: actual.sampleRate,\n      description: actual.codecPrivate?.data ?? undefined,\n      codecData: actual.codecPrivate,\n      codecEnum,\n      startInSeconds: startTimeInSeconds,\n      timescale: WEBCODECS_TIMESCALE,\n      trackMediaTimeOffsetInTrackTimescale: findTrackMediaTimeOffsetInTrackTimescale({\n        trakBox\n      })\n    };\n  }\n  if (!trakBoxContainsVideo(trakBox)) {\n    return {\n      type: \"other\",\n      trackId: tkhdBox.trackId,\n      originalTimescale: timescaleAndDuration.timescale,\n      trakBox,\n      startInSeconds: startTimeInSeconds,\n      timescale: WEBCODECS_TIMESCALE,\n      trackMediaTimeOffsetInTrackTimescale: findTrackMediaTimeOffsetInTrackTimescale({\n        trakBox\n      })\n    };\n  }\n  const videoSample = getStsdVideoConfig(trakBox);\n  if (!videoSample) {\n    throw new Error(\"No video sample\");\n  }\n  const sampleAspectRatio = getSampleAspectRatio(trakBox);\n  const aspectRatioApplied = applyAspectRatios({\n    dimensions: videoSample,\n    sampleAspectRatio,\n    displayAspectRatio: getDisplayAspectRatio({\n      sampleAspectRatio,\n      nativeDimensions: videoSample\n    })\n  });\n  const { displayAspectHeight, displayAspectWidth, height, rotation, width } = applyTkhdBox(aspectRatioApplied, tkhdBox);\n  const codec = getVideoCodecString(trakBox);\n  if (!codec) {\n    throw new Error(\"Could not find video codec\");\n  }\n  const privateData = getVideoPrivateData(trakBox);\n  const advancedColor = getIsoBmColrConfig(trakBox) ?? {\n    fullRange: null,\n    matrix: null,\n    primaries: null,\n    transfer: null\n  };\n  const track = {\n    m3uStreamFormat: null,\n    type: \"video\",\n    trackId: tkhdBox.trackId,\n    description: videoDescriptors ?? undefined,\n    originalTimescale: timescaleAndDuration.timescale,\n    codec,\n    sampleAspectRatio: getSampleAspectRatio(trakBox),\n    width,\n    height,\n    codedWidth: videoSample.width,\n    codedHeight: videoSample.height,\n    displayAspectWidth,\n    displayAspectHeight,\n    rotation: normalizeVideoRotation(0 - rotation),\n    codecData: privateData,\n    colorSpace: mediaParserAdvancedColorToWebCodecsColor(advancedColor),\n    advancedColor,\n    codecEnum: getVideoCodecFromIsoTrak(trakBox),\n    fps: getFpsFromMp4TrakBox(trakBox),\n    startInSeconds: startTimeInSeconds,\n    timescale: WEBCODECS_TIMESCALE,\n    trackMediaTimeOffsetInTrackTimescale: findTrackMediaTimeOffsetInTrackTimescale({\n      trakBox\n    })\n  };\n  return track;\n};\n\n// src/containers/avc/codec-string.ts\nvar getCodecStringFromSpsAndPps = (sps) => {\n  return `avc1.${sps.spsData.profile.toString(16).padStart(2, \"0\")}${sps.spsData.compatibility.toString(16).padStart(2, \"0\")}${sps.spsData.level.toString(16).padStart(2, \"0\")}`;\n};\n\n// src/combine-uint8-arrays.ts\nvar combineUint8Arrays = (arrays) => {\n  if (arrays.length === 0) {\n    return new Uint8Array([]);\n  }\n  if (arrays.length === 1) {\n    return arrays[0];\n  }\n  let totalLength = 0;\n  for (const array of arrays) {\n    totalLength += array.length;\n  }\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n};\n\n// src/truthy.ts\nfunction truthy(value) {\n  return Boolean(value);\n}\n\n// src/containers/avc/create-sps-pps-data.ts\nfunction serializeUint16(value) {\n  const buffer = new ArrayBuffer(2);\n  const view = new DataView(buffer);\n  view.setUint16(0, value);\n  return new Uint8Array(buffer);\n}\nvar createSpsPpsData = (avc1Profile) => {\n  return combineUint8Arrays([\n    new Uint8Array([\n      1,\n      avc1Profile.sps.spsData.profile,\n      avc1Profile.sps.spsData.compatibility,\n      avc1Profile.sps.spsData.level,\n      255,\n      225\n    ]),\n    serializeUint16(avc1Profile.sps.sps.length),\n    avc1Profile.sps.sps,\n    new Uint8Array([1]),\n    serializeUint16(avc1Profile.pps.pps.length),\n    avc1Profile.pps.pps,\n    [66, 77, 88].some((b) => avc1Profile.sps.spsData.profile === b) ? null : new Uint8Array([253, 248, 248, 0])\n  ].filter(truthy));\n};\n\n// src/add-avc-profile-to-track.ts\nvar addAvcProfileToTrack = (track, avc1Profile) => {\n  if (avc1Profile === null) {\n    return track;\n  }\n  return {\n    ...track,\n    codec: getCodecStringFromSpsAndPps(avc1Profile.sps),\n    codecData: { type: \"avc-sps-pps\", data: createSpsPpsData(avc1Profile) },\n    description: undefined\n  };\n};\n\n// src/containers/riff/timescale.ts\nvar MEDIA_PARSER_RIFF_TIMESCALE = 1e6;\n\n// src/containers/riff/get-tracks-from-avi.ts\nvar TO_BE_OVERRIDDEN_LATER = \"to-be-overriden-later\";\nvar getNumberOfTracks = (structure) => {\n  const avihBox = getAvihBox(structure);\n  if (avihBox) {\n    return avihBox.streams;\n  }\n  throw new Error(\"No avih box found\");\n};\nvar makeAviAudioTrack = ({\n  strf,\n  index\n}) => {\n  if (strf.formatTag !== 255) {\n    throw new Error(`Unsupported audio format ${strf.formatTag}`);\n  }\n  return {\n    type: \"audio\",\n    codec: \"mp4a.40.2\",\n    codecData: { type: \"aac-config\", data: new Uint8Array([18, 16]) },\n    codecEnum: \"aac\",\n    description: new Uint8Array([18, 16]),\n    numberOfChannels: strf.numberOfChannels,\n    sampleRate: strf.sampleRate,\n    originalTimescale: MEDIA_PARSER_RIFF_TIMESCALE,\n    trackId: index,\n    startInSeconds: 0,\n    timescale: WEBCODECS_TIMESCALE,\n    trackMediaTimeOffsetInTrackTimescale: 0\n  };\n};\nvar makeAviVideoTrack = ({\n  strh,\n  strf,\n  index\n}) => {\n  if (strh.handler !== \"H264\") {\n    throw new Error(`Unsupported video codec ${strh.handler}`);\n  }\n  return {\n    codecData: null,\n    codec: TO_BE_OVERRIDDEN_LATER,\n    codecEnum: \"h264\",\n    codedHeight: strf.height,\n    codedWidth: strf.width,\n    width: strf.width,\n    height: strf.height,\n    type: \"video\",\n    displayAspectHeight: strf.height,\n    originalTimescale: MEDIA_PARSER_RIFF_TIMESCALE,\n    description: undefined,\n    m3uStreamFormat: null,\n    trackId: index,\n    colorSpace: {\n      fullRange: null,\n      matrix: null,\n      primaries: null,\n      transfer: null\n    },\n    advancedColor: {\n      fullRange: null,\n      matrix: null,\n      primaries: null,\n      transfer: null\n    },\n    displayAspectWidth: strf.width,\n    rotation: 0,\n    sampleAspectRatio: {\n      numerator: 1,\n      denominator: 1\n    },\n    fps: strh.rate / strh.scale,\n    startInSeconds: 0,\n    timescale: WEBCODECS_TIMESCALE,\n    trackMediaTimeOffsetInTrackTimescale: 0\n  };\n};\nvar getTracksFromAvi = (structure, state) => {\n  const tracks2 = [];\n  const boxes = getStrlBoxes(structure);\n  let i = 0;\n  for (const box of boxes) {\n    const strh = getStrhBox(box.children);\n    if (!strh) {\n      continue;\n    }\n    const { strf } = strh;\n    if (strf.type === \"strf-box-video\") {\n      tracks2.push(addAvcProfileToTrack(makeAviVideoTrack({ strh, strf, index: i }), state.riff.getAvcProfile()));\n    } else if (strh.fccType === \"auds\") {\n      tracks2.push(makeAviAudioTrack({ strf, index: i }));\n    } else {\n      throw new Error(`Unsupported track type ${strh.fccType}`);\n    }\n    i++;\n  }\n  return tracks2;\n};\nvar hasAllTracksFromAvi = (state) => {\n  try {\n    const structure = state.structure.getRiffStructure();\n    const numberOfTracks = getNumberOfTracks(structure);\n    const tracks2 = getTracksFromAvi(structure, state);\n    return tracks2.length === numberOfTracks && !tracks2.find((t) => t.type === \"video\" && t.codec === TO_BE_OVERRIDDEN_LATER);\n  } catch {\n    return false;\n  }\n};\n\n// src/containers/transport-stream/traversal.ts\nvar findProgramAssociationTableOrThrow = (structure) => {\n  const box = structure.boxes.find((b) => b.type === \"transport-stream-pat-box\");\n  if (!box) {\n    throw new Error(\"No PAT box found\");\n  }\n  return box;\n};\nvar findProgramMapOrNull = (structure) => {\n  const box = structure.boxes.find((b) => b.type === \"transport-stream-pmt-box\");\n  if (!box) {\n    return null;\n  }\n  return box;\n};\nvar findProgramMapTableOrThrow = (structure) => {\n  const box = findProgramMapOrNull(structure);\n  if (!box) {\n    throw new Error(\"No PMT box found\");\n  }\n  return box;\n};\nvar getProgramForId = (structure, packetIdentifier) => {\n  const box = findProgramAssociationTableOrThrow(structure);\n  const entry = box.pat.find((e) => e.programMapIdentifier === packetIdentifier);\n  return entry ?? null;\n};\nvar getStreamForId = (structure, packetIdentifier) => {\n  const box = findProgramMapTableOrThrow(structure);\n  const entry = box.streams.find((e) => e.pid === packetIdentifier);\n  return entry ?? null;\n};\n\n// src/containers/transport-stream/get-tracks.ts\nvar filterStreamsBySupportedTypes = (streams) => {\n  return streams.filter((stream) => stream.streamType === 27 || stream.streamType === 15);\n};\nvar getTracksFromTransportStream = (parserState) => {\n  const structure = parserState.structure.getTsStructure();\n  const programMapTable = findProgramMapTableOrThrow(structure);\n  const parserTracks = parserState.callbacks.tracks.getTracks();\n  const mapped = filterStreamsBySupportedTypes(programMapTable.streams).map((stream) => {\n    return parserTracks.find((track) => track.trackId === stream.pid);\n  }).filter(truthy);\n  if (mapped.length !== filterStreamsBySupportedTypes(programMapTable.streams).length) {\n    throw new Error(\"Not all tracks found\");\n  }\n  return mapped;\n};\nvar hasAllTracksFromTransportStream = (parserState) => {\n  try {\n    getTracksFromTransportStream(parserState);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n// src/make-hvc1-codec-strings.ts\nvar getHvc1CodecString = (data) => {\n  const configurationVersion = data.getUint8();\n  if (configurationVersion !== 1) {\n    throw new Error(`Unsupported HVCC version ${configurationVersion}`);\n  }\n  const generalProfileSpaceTierFlagAndIdc = data.getUint8();\n  let generalProfileCompatibility = data.getUint32();\n  const generalProfileSpace = generalProfileSpaceTierFlagAndIdc >> 6;\n  const generalTierFlag = (generalProfileSpaceTierFlagAndIdc & 32) >> 5;\n  const generalProfileIdc = generalProfileSpaceTierFlagAndIdc & 31;\n  const generalConstraintIndicator = data.getSlice(6);\n  const generalLevelIdc = data.getUint8();\n  let profileId = 0;\n  for (let i = 0;i < 32; i++) {\n    profileId |= generalProfileCompatibility & 1;\n    if (i === 31)\n      break;\n    profileId <<= 1;\n    generalProfileCompatibility >>= 1;\n  }\n  const profileSpaceChar = generalProfileSpace === 0 ? \"\" : generalProfileSpace === 1 ? \"A\" : generalProfileSpace === 2 ? \"B\" : \"C\";\n  const generalTierChar = generalTierFlag === 0 ? \"L\" : \"H\";\n  let hasByte = false;\n  let generalConstraintString = \"\";\n  for (let i = 5;i >= 0; i--) {\n    if (generalConstraintIndicator[i] || hasByte) {\n      generalConstraintString = generalConstraintIndicator[i].toString(16) + generalConstraintString;\n      hasByte = true;\n    }\n  }\n  return `${profileSpaceChar}${generalProfileIdc.toString(16)}.${profileId.toString(16)}.${generalTierChar}${generalLevelIdc}${generalConstraintString ? \".\" : \"\"}${generalConstraintString}`;\n};\n\n// src/containers/webm/traversal.ts\nvar getMainSegment = (segments) => {\n  return segments.find((s) => s.type === \"Segment\") ?? null;\n};\nvar getTrackCodec = (track) => {\n  const child = track.value.find((b) => b.type === \"CodecID\");\n  return child ?? null;\n};\nvar getTrackTimestampScale = (track) => {\n  const child = track.value.find((b) => b.type === \"TrackTimestampScale\");\n  if (!child) {\n    return null;\n  }\n  if (child.type !== \"TrackTimestampScale\") {\n    throw new Error(\"Expected TrackTimestampScale\");\n  }\n  return child.value;\n};\nvar getTrackId = (track) => {\n  const trackId = track.value.find((b) => b.type === \"TrackNumber\");\n  if (!trackId || trackId.type !== \"TrackNumber\") {\n    throw new Error(\"Expected track number segment\");\n  }\n  return trackId.value.value;\n};\nvar getCodecSegment = (track) => {\n  const codec = track.value.find((b) => b.type === \"CodecID\");\n  if (!codec || codec.type !== \"CodecID\") {\n    return null;\n  }\n  return codec;\n};\nvar getColourSegment = (track) => {\n  const videoSegment2 = getVideoSegment(track);\n  if (!videoSegment2) {\n    return null;\n  }\n  const colour = videoSegment2.value.find((b) => b.type === \"Colour\");\n  if (!colour || colour.type !== \"Colour\") {\n    return null;\n  }\n  return colour;\n};\nvar getTransferCharacteristicsSegment = (color2) => {\n  if (!color2 || color2.type !== \"Colour\") {\n    return null;\n  }\n  const box = color2.value.find((b) => b.type === \"TransferCharacteristics\");\n  if (!box || box.type !== \"TransferCharacteristics\") {\n    return null;\n  }\n  return box;\n};\nvar getMatrixCoefficientsSegment = (color2) => {\n  if (!color2 || color2.type !== \"Colour\") {\n    return null;\n  }\n  const box = color2.value.find((b) => b.type === \"MatrixCoefficients\");\n  if (!box || box.type !== \"MatrixCoefficients\") {\n    return null;\n  }\n  return box;\n};\nvar getPrimariesSegment = (color2) => {\n  if (!color2 || color2.type !== \"Colour\") {\n    return null;\n  }\n  const box = color2.value.find((b) => b.type === \"Primaries\");\n  if (!box || box.type !== \"Primaries\") {\n    return null;\n  }\n  return box;\n};\nvar getRangeSegment = (color2) => {\n  if (!color2 || color2.type !== \"Colour\") {\n    return null;\n  }\n  const box = color2.value.find((b) => b.type === \"Range\");\n  if (!box || box.type !== \"Range\") {\n    return null;\n  }\n  return box;\n};\nvar getDisplayHeightSegment = (track) => {\n  const videoSegment2 = getVideoSegment(track);\n  if (!videoSegment2) {\n    return null;\n  }\n  const displayHeight2 = videoSegment2.value.find((b) => b.type === \"DisplayHeight\");\n  if (!displayHeight2 || displayHeight2.type !== \"DisplayHeight\") {\n    return null;\n  }\n  return displayHeight2;\n};\nvar getTrackTypeSegment = (track) => {\n  const trackType2 = track.value.find((b) => b.type === \"TrackType\");\n  if (!trackType2 || trackType2.type !== \"TrackType\") {\n    return null;\n  }\n  return trackType2;\n};\nvar getWidthSegment = (track) => {\n  const videoSegment2 = getVideoSegment(track);\n  if (!videoSegment2) {\n    return null;\n  }\n  const width = videoSegment2.value.find((b) => b.type === \"PixelWidth\");\n  if (!width || width.type !== \"PixelWidth\") {\n    return null;\n  }\n  return width;\n};\nvar getHeightSegment = (track) => {\n  const videoSegment2 = getVideoSegment(track);\n  if (!videoSegment2) {\n    return null;\n  }\n  const height = videoSegment2.value.find((b) => b.type === \"PixelHeight\");\n  if (!height || height.type !== \"PixelHeight\") {\n    return null;\n  }\n  return height;\n};\nvar getDisplayWidthSegment = (track) => {\n  const videoSegment2 = getVideoSegment(track);\n  if (!videoSegment2) {\n    return null;\n  }\n  const displayWidth2 = videoSegment2.value.find((b) => b.type === \"DisplayWidth\");\n  if (!displayWidth2 || displayWidth2.type !== \"DisplayWidth\") {\n    return null;\n  }\n  return displayWidth2;\n};\nvar getTracksSegment = (segment) => {\n  const tracksSegment = segment.value.find((b) => b.type === \"Tracks\");\n  if (!tracksSegment) {\n    return null;\n  }\n  return tracksSegment;\n};\nvar getTrackWithUid = (segment, trackUid) => {\n  const tracksSegment = getTracksSegment(segment);\n  if (!tracksSegment) {\n    return null;\n  }\n  const trackEntries = tracksSegment.value.filter((t) => t.type === \"TrackEntry\");\n  const trackEntry2 = trackEntries.find((entry) => {\n    return entry?.value.find((t) => t.type === \"TrackUID\" && t.value === trackUid);\n  });\n  if (!trackEntry2) {\n    return null;\n  }\n  return trackEntry2.value.find((t) => t.type === \"TrackNumber\")?.value.value ?? null;\n};\nvar getVideoSegment = (track) => {\n  const videoSegment2 = track.value.find((b) => b.type === \"Video\");\n  if (!videoSegment2 || videoSegment2.type !== \"Video\") {\n    return null;\n  }\n  return videoSegment2 ?? null;\n};\nvar getAudioSegment = (track) => {\n  const audioSegment2 = track.value.find((b) => b.type === \"Audio\");\n  if (!audioSegment2 || audioSegment2.type !== \"Audio\") {\n    return null;\n  }\n  return audioSegment2 ?? null;\n};\nvar getSampleRate2 = (track) => {\n  const audioSegment2 = getAudioSegment(track);\n  if (!audioSegment2) {\n    return null;\n  }\n  const samplingFrequency2 = audioSegment2.value.find((b) => b.type === \"SamplingFrequency\");\n  if (!samplingFrequency2 || samplingFrequency2.type !== \"SamplingFrequency\") {\n    return null;\n  }\n  return samplingFrequency2.value.value;\n};\nvar getNumberOfChannels = (track) => {\n  const audioSegment2 = getAudioSegment(track);\n  if (!audioSegment2) {\n    throw new Error(\"Could not find audio segment\");\n  }\n  const channels2 = audioSegment2.value.find((b) => b.type === \"Channels\");\n  if (!channels2 || channels2.type !== \"Channels\") {\n    return 1;\n  }\n  return channels2.value.value;\n};\nvar getBitDepth = (track) => {\n  const audioSegment2 = getAudioSegment(track);\n  if (!audioSegment2) {\n    return null;\n  }\n  const bitDepth2 = audioSegment2.value.find((b) => b.type === \"BitDepth\");\n  if (!bitDepth2 || bitDepth2.type !== \"BitDepth\") {\n    return null;\n  }\n  return bitDepth2.value.value;\n};\nvar getPrivateData = (track) => {\n  const privateData = track.value.find((b) => b.type === \"CodecPrivate\");\n  if (!privateData || privateData.type !== \"CodecPrivate\") {\n    return null;\n  }\n  return privateData.value;\n};\n\n// src/containers/webm/color.ts\nvar parseColorSegment = (colourSegment) => {\n  const transferCharacteristics2 = getTransferCharacteristicsSegment(colourSegment);\n  const matrixCoefficients2 = getMatrixCoefficientsSegment(colourSegment);\n  const primaries2 = getPrimariesSegment(colourSegment);\n  const range2 = getRangeSegment(colourSegment);\n  return {\n    transfer: transferCharacteristics2 ? getTransferCharacteristicsFromIndex(transferCharacteristics2.value.value) : null,\n    matrix: matrixCoefficients2 ? getMatrixCoefficientsFromIndex(matrixCoefficients2.value.value) : null,\n    primaries: primaries2 ? getPrimariesFromIndex(primaries2.value.value) : null,\n    fullRange: transferCharacteristics2?.value.value && matrixCoefficients2?.value.value ? null : range2 ? Boolean(range2?.value.value) : null\n  };\n};\n\n// src/containers/webm/description.ts\nvar getAudioDescription = (track) => {\n  const codec = getCodecSegment(track);\n  if (!codec || codec.value !== \"A_VORBIS\") {\n    return;\n  }\n  const privateData = getPrivateData(track);\n  if (!privateData) {\n    return;\n  }\n  if (privateData[0] !== 2) {\n    throw new Error(\"Expected vorbis private data version 2\");\n  }\n  let offset = 1;\n  let vorbisInfoLength = 0;\n  let vorbisSkipLength = 0;\n  while ((privateData[offset] & 255) === 255) {\n    vorbisInfoLength += 255;\n    offset++;\n  }\n  vorbisInfoLength += privateData[offset++] & 255;\n  while ((privateData[offset] & 255) === 255) {\n    vorbisSkipLength += 255;\n    offset++;\n  }\n  vorbisSkipLength += privateData[offset++] & 255;\n  if (privateData[offset] !== 1) {\n    throw new Error(\"Error parsing vorbis codec private\");\n  }\n  const vorbisInfo = privateData.slice(offset, offset + vorbisInfoLength);\n  offset += vorbisInfoLength;\n  if (privateData[offset] !== 3) {\n    throw new Error(\"Error parsing vorbis codec private\");\n  }\n  const vorbisComments = privateData.slice(offset, offset + vorbisSkipLength);\n  offset += vorbisSkipLength;\n  if (privateData[offset] !== 5) {\n    throw new Error(\"Error parsing vorbis codec private\");\n  }\n  const vorbisBooks = privateData.slice(offset);\n  const bufferIterator = getArrayBufferIterator({\n    initialData: vorbisInfo.slice(0),\n    maxBytes: vorbisInfo.length,\n    logLevel: \"error\"\n  });\n  bufferIterator.getUint8();\n  const vorbis = bufferIterator.getByteString(6, false);\n  if (vorbis !== \"vorbis\") {\n    throw new Error(\"Error parsing vorbis codec private\");\n  }\n  const vorbisVersion = bufferIterator.getUint32Le();\n  if (vorbisVersion !== 0) {\n    throw new Error(\"Error parsing vorbis codec private\");\n  }\n  const vorbisDescription = new Uint8Array([\n    2,\n    vorbisInfo.length,\n    vorbisComments.length,\n    ...vorbisInfo,\n    ...vorbisComments,\n    ...vorbisBooks\n  ]);\n  return vorbisDescription;\n};\n\n// src/containers/webm/segments/track-entry.ts\nvar trackTypeToString = (trackType2) => {\n  switch (trackType2) {\n    case 1:\n      return \"video\";\n    case 2:\n      return \"audio\";\n    case 3:\n      return \"complex\";\n    case 4:\n      return \"subtitle\";\n    case 5:\n      return \"button\";\n    case 6:\n      return \"control\";\n    case 7:\n      return \"metadata\";\n    default:\n      throw new Error(`Unknown track type: ${trackType2}`);\n  }\n};\n\n// src/containers/webm/make-track.ts\nvar NO_CODEC_PRIVATE_SHOULD_BE_DERIVED_FROM_SPS = \"no-codec-private-should-be-derived-from-sps\";\nvar getDescription = (track) => {\n  const codec = getCodecSegment(track);\n  if (!codec) {\n    return;\n  }\n  if (codec.value === \"V_MPEG4/ISO/AVC\" || codec.value === \"V_MPEGH/ISO/HEVC\") {\n    const priv = getPrivateData(track);\n    if (priv) {\n      return priv;\n    }\n  }\n  return;\n};\nvar getMatroskaVideoCodecEnum = ({\n  codecSegment: codec\n}) => {\n  if (codec.value === \"V_VP8\") {\n    return \"vp8\";\n  }\n  if (codec.value === \"V_VP9\") {\n    return \"vp9\";\n  }\n  if (codec.value === \"V_MPEG4/ISO/AVC\") {\n    return \"h264\";\n  }\n  if (codec.value === \"V_AV1\") {\n    return \"av1\";\n  }\n  if (codec.value === \"V_MPEGH/ISO/HEVC\") {\n    return \"h265\";\n  }\n  throw new Error(`Unknown codec: ${codec.value}`);\n};\nvar getMatroskaVideoCodecString = ({\n  track,\n  codecSegment: codec\n}) => {\n  if (codec.value === \"V_VP8\") {\n    return \"vp8\";\n  }\n  if (codec.value === \"V_VP9\") {\n    const priv = getPrivateData(track);\n    if (priv) {\n      throw new Error(\"@remotion/media-parser cannot handle the private data for VP9. Do you have an example file you could send so we can implement it? https://remotion.dev/report\");\n    }\n    return \"vp09.00.10.08\";\n  }\n  if (codec.value === \"V_MPEG4/ISO/AVC\") {\n    const priv = getPrivateData(track);\n    if (priv) {\n      return `avc1.${priv[1].toString(16).padStart(2, \"0\")}${priv[2].toString(16).padStart(2, \"0\")}${priv[3].toString(16).padStart(2, \"0\")}`;\n    }\n    return NO_CODEC_PRIVATE_SHOULD_BE_DERIVED_FROM_SPS;\n  }\n  if (codec.value === \"V_MPEGH/ISO/HEVC\") {\n    const priv = getPrivateData(track);\n    const iterator = getArrayBufferIterator({\n      initialData: priv,\n      maxBytes: priv.length,\n      logLevel: \"error\"\n    });\n    return \"hvc1.\" + getHvc1CodecString(iterator);\n  }\n  if (codec.value === \"V_AV1\") {\n    const priv = getPrivateData(track);\n    if (!priv) {\n      throw new Error(\"Expected private data in AV1 track\");\n    }\n    return parseAv1PrivateData(priv, null);\n  }\n  throw new Error(`Unknown codec: ${codec.value}`);\n};\nvar getMatroskaAudioCodecEnum = ({\n  track\n}) => {\n  const codec = getCodecSegment(track);\n  if (!codec) {\n    throw new Error(\"Expected codec segment\");\n  }\n  if (codec.value === \"A_OPUS\") {\n    return \"opus\";\n  }\n  if (codec.value === \"A_VORBIS\") {\n    return \"vorbis\";\n  }\n  if (codec.value === \"A_PCM/INT/LIT\") {\n    const bitDepth2 = getBitDepth(track);\n    if (bitDepth2 === null) {\n      throw new Error(\"Expected bit depth\");\n    }\n    if (bitDepth2 === 8) {\n      return \"pcm-u8\";\n    }\n    if (bitDepth2 === 16) {\n      return \"pcm-s16\";\n    }\n    if (bitDepth2 === 24) {\n      return \"pcm-s24\";\n    }\n    throw new Error(\"Unknown audio format\");\n  }\n  if (codec.value === \"A_AAC\") {\n    return `aac`;\n  }\n  if (codec.value === \"A_MPEG/L3\") {\n    return \"mp3\";\n  }\n  throw new Error(`Unknown codec: ${codec.value}`);\n};\nvar getMatroskaAudioCodecString = (track) => {\n  const codec = getCodecSegment(track);\n  if (!codec) {\n    throw new Error(\"Expected codec segment\");\n  }\n  if (codec.value === \"A_OPUS\") {\n    return \"opus\";\n  }\n  if (codec.value === \"A_VORBIS\") {\n    return \"vorbis\";\n  }\n  if (codec.value === \"A_PCM/INT/LIT\") {\n    const bitDepth2 = getBitDepth(track);\n    if (bitDepth2 === null) {\n      throw new Error(\"Expected bit depth\");\n    }\n    if (bitDepth2 === 8) {\n      return \"pcm-u8\";\n    }\n    return \"pcm-s\" + bitDepth2;\n  }\n  if (codec.value === \"A_AAC\") {\n    const priv = getPrivateData(track);\n    const iterator = getArrayBufferIterator({\n      initialData: priv,\n      maxBytes: priv.length,\n      logLevel: \"error\"\n    });\n    iterator.startReadingBits();\n    const profile = iterator.getBits(5);\n    iterator.stopReadingBits();\n    iterator.destroy();\n    return `mp4a.40.${profile.toString().padStart(2, \"0\")}`;\n  }\n  if (codec.value === \"A_MPEG/L3\") {\n    return \"mp3\";\n  }\n  throw new Error(`Unknown codec: ${codec.value}`);\n};\nvar getTrack = ({\n  timescale,\n  track\n}) => {\n  const trackType2 = getTrackTypeSegment(track);\n  if (!trackType2) {\n    throw new Error(\"Expected track type segment\");\n  }\n  const trackId = getTrackId(track);\n  if (trackTypeToString(trackType2.value.value) === \"video\") {\n    const width = getWidthSegment(track);\n    if (width === null) {\n      throw new Error(\"Expected width segment\");\n    }\n    const height = getHeightSegment(track);\n    if (height === null) {\n      throw new Error(\"Expected height segment\");\n    }\n    const displayHeight2 = getDisplayHeightSegment(track);\n    const displayWidth2 = getDisplayWidthSegment(track);\n    const codec = getCodecSegment(track);\n    if (!codec) {\n      return null;\n    }\n    const codecPrivate2 = getPrivateData(track);\n    const codecString = getMatroskaVideoCodecString({\n      track,\n      codecSegment: codec\n    });\n    const colour = getColourSegment(track);\n    if (!codecString) {\n      return null;\n    }\n    const codecEnum = getMatroskaVideoCodecEnum({\n      codecSegment: codec\n    });\n    const codecData = codecPrivate2 === null ? null : codecEnum === \"h264\" ? { type: \"avc-sps-pps\", data: codecPrivate2 } : codecEnum === \"av1\" ? {\n      type: \"av1c-data\",\n      data: codecPrivate2\n    } : codecEnum === \"h265\" ? {\n      type: \"hvcc-data\",\n      data: codecPrivate2\n    } : codecEnum === \"vp8\" ? {\n      type: \"unknown-data\",\n      data: codecPrivate2\n    } : codecEnum === \"vp9\" ? {\n      type: \"unknown-data\",\n      data: codecPrivate2\n    } : null;\n    const advancedColor = colour ? parseColorSegment(colour) : {\n      fullRange: null,\n      matrix: null,\n      primaries: null,\n      transfer: null\n    };\n    return {\n      m3uStreamFormat: null,\n      type: \"video\",\n      trackId,\n      codec: codecString,\n      description: getDescription(track),\n      height: displayHeight2 ? displayHeight2.value.value : height.value.value,\n      width: displayWidth2 ? displayWidth2.value.value : width.value.value,\n      sampleAspectRatio: {\n        numerator: 1,\n        denominator: 1\n      },\n      originalTimescale: timescale,\n      codedHeight: height.value.value,\n      codedWidth: width.value.value,\n      displayAspectHeight: displayHeight2 ? displayHeight2.value.value : height.value.value,\n      displayAspectWidth: displayWidth2 ? displayWidth2.value.value : width.value.value,\n      rotation: 0,\n      codecData,\n      colorSpace: mediaParserAdvancedColorToWebCodecsColor(advancedColor),\n      advancedColor,\n      codecEnum,\n      fps: null,\n      startInSeconds: 0,\n      timescale: WEBCODECS_TIMESCALE,\n      trackMediaTimeOffsetInTrackTimescale: 0\n    };\n  }\n  if (trackTypeToString(trackType2.value.value) === \"audio\") {\n    const sampleRate = getSampleRate2(track);\n    const numberOfChannels = getNumberOfChannels(track);\n    const codecPrivate2 = getPrivateData(track);\n    if (sampleRate === null) {\n      throw new Error(\"Could not find sample rate or number of channels\");\n    }\n    const codecString = getMatroskaAudioCodecString(track);\n    return {\n      type: \"audio\",\n      trackId,\n      codec: codecString,\n      originalTimescale: timescale,\n      numberOfChannels,\n      sampleRate,\n      description: getAudioDescription(track),\n      codecData: codecPrivate2 ? codecString === \"opus\" ? { type: \"ogg-identification\", data: codecPrivate2 } : { type: \"unknown-data\", data: codecPrivate2 } : null,\n      codecEnum: getMatroskaAudioCodecEnum({\n        track\n      }),\n      startInSeconds: 0,\n      timescale: WEBCODECS_TIMESCALE,\n      trackMediaTimeOffsetInTrackTimescale: 0\n    };\n  }\n  return null;\n};\n\n// src/containers/webm/get-ready-tracks.ts\nvar getTracksFromMatroska = ({\n  structureState,\n  webmState\n}) => {\n  const structure = structureState.getMatroskaStructure();\n  const mainSegment = getMainSegment(structure.boxes);\n  if (!mainSegment) {\n    throw new Error(\"No main segment\");\n  }\n  const tracksSegment = getTracksSegment(mainSegment);\n  if (!tracksSegment) {\n    throw new Error(\"No tracks segment\");\n  }\n  const resolvedTracks = [];\n  const missingInfo = [];\n  for (const trackEntrySegment of tracksSegment.value) {\n    if (trackEntrySegment.type === \"Crc32\") {\n      continue;\n    }\n    if (trackEntrySegment.type !== \"TrackEntry\") {\n      throw new Error(\"Expected track entry segment\");\n    }\n    const track = getTrack({\n      track: trackEntrySegment,\n      timescale: webmState.getTimescale()\n    });\n    if (!track) {\n      continue;\n    }\n    if (track.codec === NO_CODEC_PRIVATE_SHOULD_BE_DERIVED_FROM_SPS) {\n      const avc = webmState.getAvcProfileForTrackNumber(track.trackId);\n      if (avc) {\n        resolvedTracks.push({\n          ...track,\n          codec: getCodecStringFromSpsAndPps(avc)\n        });\n      } else {\n        missingInfo.push(track);\n      }\n    } else {\n      resolvedTracks.push(track);\n    }\n  }\n  return { missingInfo, resolved: resolvedTracks };\n};\nvar matroskaHasTracks = ({\n  structureState,\n  webmState\n}) => {\n  const structure = structureState.getMatroskaStructure();\n  const mainSegment = getMainSegment(structure.boxes);\n  if (!mainSegment) {\n    return false;\n  }\n  return getTracksSegment(mainSegment) !== null && getTracksFromMatroska({\n    structureState,\n    webmState\n  }).missingInfo.length === 0;\n};\n\n// src/get-tracks.ts\nvar isoBaseMediaHasTracks = (state, mayUsePrecomputed) => {\n  return Boolean(getMoovBoxFromState({\n    structureState: state.structure,\n    isoState: state.iso,\n    mp4HeaderSegment: state.m3uPlaylistContext?.mp4HeaderSegment ?? null,\n    mayUsePrecomputed\n  }));\n};\nvar getHasTracks = (state, mayUsePrecomputed) => {\n  const structure = state.structure.getStructure();\n  if (structure.type === \"matroska\") {\n    return matroskaHasTracks({\n      structureState: state.structure,\n      webmState: state.webm\n    });\n  }\n  if (structure.type === \"iso-base-media\") {\n    return isoBaseMediaHasTracks(state, mayUsePrecomputed);\n  }\n  if (structure.type === \"riff\") {\n    return hasAllTracksFromAvi(state);\n  }\n  if (structure.type === \"transport-stream\") {\n    return hasAllTracksFromTransportStream(state);\n  }\n  if (structure.type === \"mp3\") {\n    return state.callbacks.tracks.getTracks().length > 0;\n  }\n  if (structure.type === \"wav\") {\n    return state.callbacks.tracks.hasAllTracks();\n  }\n  if (structure.type === \"aac\") {\n    return state.callbacks.tracks.hasAllTracks();\n  }\n  if (structure.type === \"flac\") {\n    return state.callbacks.tracks.hasAllTracks();\n  }\n  if (structure.type === \"m3u\") {\n    return state.callbacks.tracks.hasAllTracks();\n  }\n  throw new Error(\"Unknown container \" + structure);\n};\nvar getCategorizedTracksFromMatroska = (state) => {\n  const { resolved } = getTracksFromMatroska({\n    structureState: state.structure,\n    webmState: state.webm\n  });\n  return resolved;\n};\nvar getTracksFromMoovBox = (moovBox) => {\n  const mediaParserTracks = [];\n  const tracks2 = getTraks(moovBox);\n  for (const trakBox of tracks2) {\n    const mvhdBox = getMvhdBox(moovBox);\n    if (!mvhdBox) {\n      throw new Error(\"Mvhd box is not found\");\n    }\n    const startTime = findTrackStartTimeInSeconds({\n      movieTimeScale: mvhdBox.timeScale,\n      trakBox\n    });\n    const track = makeBaseMediaTrack(trakBox, startTime);\n    if (!track) {\n      continue;\n    }\n    mediaParserTracks.push(track);\n  }\n  return mediaParserTracks;\n};\nvar getTracksFromIsoBaseMedia = ({\n  mayUsePrecomputed,\n  structure,\n  isoState,\n  m3uPlaylistContext\n}) => {\n  const moovBox = getMoovBoxFromState({\n    structureState: structure,\n    isoState,\n    mp4HeaderSegment: m3uPlaylistContext?.mp4HeaderSegment ?? null,\n    mayUsePrecomputed\n  });\n  if (!moovBox) {\n    return [];\n  }\n  return getTracksFromMoovBox(moovBox);\n};\nvar defaultGetTracks = (parserState) => {\n  const tracks2 = parserState.callbacks.tracks.getTracks();\n  if (tracks2.length === 0) {\n    throw new Error(\"No tracks found\");\n  }\n  return tracks2;\n};\nvar getTracks = (state, mayUsePrecomputed) => {\n  const structure = state.structure.getStructure();\n  if (structure.type === \"matroska\") {\n    return getCategorizedTracksFromMatroska(state);\n  }\n  if (structure.type === \"iso-base-media\") {\n    return getTracksFromIsoBaseMedia({\n      isoState: state.iso,\n      m3uPlaylistContext: state.m3uPlaylistContext,\n      structure: state.structure,\n      mayUsePrecomputed\n    });\n  }\n  if (structure.type === \"riff\") {\n    return getTracksFromAvi(structure, state);\n  }\n  if (structure.type === \"transport-stream\") {\n    return getTracksFromTransportStream(state);\n  }\n  if (structure.type === \"mp3\" || structure.type === \"wav\" || structure.type === \"flac\" || structure.type === \"aac\" || structure.type === \"m3u\") {\n    return defaultGetTracks(state);\n  }\n  throw new Error(`Unknown container${structure}`);\n};\n\n// src/get-audio-codec.ts\nvar getAudioCodec = (parserState) => {\n  const tracks2 = getTracks(parserState, true);\n  if (tracks2.length === 0) {\n    throw new Error(\"No tracks yet\");\n  }\n  const audioTrack = tracks2.find((t) => t.type === \"audio\");\n  if (!audioTrack) {\n    return null;\n  }\n  if (audioTrack.type === \"audio\") {\n    return audioTrack.codecEnum;\n  }\n  return null;\n};\nvar hasAudioCodec = (state) => {\n  return getHasTracks(state, true);\n};\nvar getCodecSpecificatorFromEsdsBox = ({\n  child\n}) => {\n  const descriptor = child.descriptors.find((d) => d.type === \"decoder-config-descriptor\");\n  if (!descriptor) {\n    throw new Error(\"No decoder-config-descriptor\");\n  }\n  if (descriptor.type !== \"decoder-config-descriptor\") {\n    throw new Error(\"Expected decoder-config-descriptor\");\n  }\n  if (descriptor.asNumber !== 64) {\n    return {\n      primary: descriptor.asNumber,\n      secondary: null,\n      description: undefined\n    };\n  }\n  const audioSpecificConfig = descriptor.decoderSpecificConfigs.find((d) => {\n    return d.type === \"mp4a-specific-config\" ? d : null;\n  });\n  if (!audioSpecificConfig || audioSpecificConfig.type !== \"mp4a-specific-config\") {\n    throw new Error(\"No audio-specific-config\");\n  }\n  return {\n    primary: descriptor.asNumber,\n    secondary: audioSpecificConfig.audioObjectType,\n    description: audioSpecificConfig.asBytes\n  };\n};\nvar getCodecPrivateFromTrak = (trakBox) => {\n  const stsdBox = getStsdBox(trakBox);\n  if (!stsdBox) {\n    return null;\n  }\n  const audioSample = stsdBox.samples.find((s) => s.type === \"audio\");\n  if (!audioSample || audioSample.type !== \"audio\") {\n    return null;\n  }\n  const esds = audioSample.children.find((b) => b.type === \"esds-box\");\n  if (!esds || esds.type !== \"esds-box\") {\n    return null;\n  }\n  const decoderConfigDescriptor = esds.descriptors.find((d) => d.type === \"decoder-config-descriptor\");\n  if (!decoderConfigDescriptor) {\n    return null;\n  }\n  const mp4a = decoderConfigDescriptor.decoderSpecificConfigs.find((d) => d.type === \"mp4a-specific-config\");\n  if (!mp4a) {\n    return null;\n  }\n  return { type: \"aac-config\", data: mp4a.asBytes };\n};\nvar onSample = (sample, children) => {\n  const child = children.find((c) => c.type === \"esds-box\");\n  if (child && child.type === \"esds-box\") {\n    const ret = getCodecSpecificatorFromEsdsBox({ child });\n    return {\n      format: sample.format,\n      primarySpecificator: ret.primary,\n      secondarySpecificator: ret.secondary,\n      description: ret.description\n    };\n  }\n  return {\n    format: sample.format,\n    primarySpecificator: null,\n    secondarySpecificator: null,\n    description: undefined\n  };\n};\nvar getNumberOfChannelsFromTrak = (trak) => {\n  const stsdBox = getStsdBox(trak);\n  if (!stsdBox) {\n    return null;\n  }\n  const sample = stsdBox.samples.find((s) => s.type === \"audio\");\n  if (!sample || sample.type !== \"audio\") {\n    return null;\n  }\n  return sample.numberOfChannels;\n};\nvar getSampleRate = (trak) => {\n  const stsdBox = getStsdBox(trak);\n  if (!stsdBox) {\n    return null;\n  }\n  const sample = stsdBox.samples.find((s) => s.type === \"audio\");\n  if (!sample || sample.type !== \"audio\") {\n    return null;\n  }\n  return sample.sampleRate;\n};\nvar getAudioCodecFromTrak = (trak) => {\n  const stsdBox = getStsdBox(trak);\n  if (!stsdBox) {\n    return null;\n  }\n  const sample = stsdBox.samples.find((s) => s.type === \"audio\");\n  if (!sample || sample.type !== \"audio\") {\n    return null;\n  }\n  const waveBox = sample.children.find((b) => b.type === \"regular-box\" && b.boxType === \"wave\");\n  if (waveBox && waveBox.type === \"regular-box\" && waveBox.boxType === \"wave\") {\n    const esdsSample = onSample(sample, waveBox.children);\n    if (esdsSample) {\n      return esdsSample;\n    }\n  }\n  const ret = onSample(sample, sample.children);\n  if (ret) {\n    return ret;\n  }\n  return null;\n};\nvar isLpcmAudioCodec = (trak) => {\n  return getAudioCodecFromTrak(trak)?.format === \"lpcm\";\n};\nvar isIn24AudioCodec = (trak) => {\n  return getAudioCodecFromTrak(trak)?.format === \"in24\";\n};\nvar isTwosAudioCodec = (trak) => {\n  return getAudioCodecFromTrak(trak)?.format === \"twos\";\n};\nvar getAudioCodecStringFromTrak = (trak) => {\n  const codec = getAudioCodecFromTrak(trak);\n  if (!codec) {\n    throw new Error(\"Expected codec\");\n  }\n  if (codec.format === \"lpcm\") {\n    return {\n      codecString: \"pcm-s16\",\n      description: codec.description ? { type: \"unknown-data\", data: codec.description } : undefined\n    };\n  }\n  if (codec.format === \"twos\") {\n    return {\n      codecString: \"pcm-s16\",\n      description: codec.description ? { type: \"unknown-data\", data: codec.description } : undefined\n    };\n  }\n  if (codec.format === \"in24\") {\n    return {\n      codecString: \"pcm-s24\",\n      description: codec.description ? { type: \"unknown-data\", data: codec.description } : undefined\n    };\n  }\n  const codecStringWithoutMp3Exception = [\n    codec.format,\n    codec.primarySpecificator ? codec.primarySpecificator.toString(16) : null,\n    codec.secondarySpecificator ? codec.secondarySpecificator.toString().padStart(2, \"0\") : null\n  ].filter(Boolean).join(\".\");\n  const codecString = codecStringWithoutMp3Exception.toLowerCase() === \"mp4a.6b\" || codecStringWithoutMp3Exception.toLowerCase() === \"mp4a.69\" ? \"mp3\" : codecStringWithoutMp3Exception;\n  if (codecString === \"mp3\") {\n    return {\n      codecString,\n      description: codec.description ? {\n        type: \"unknown-data\",\n        data: codec.description\n      } : undefined\n    };\n  }\n  if (codecString.startsWith(\"mp4a.\")) {\n    return {\n      codecString,\n      description: codec.description ? {\n        type: \"aac-config\",\n        data: codec.description\n      } : undefined\n    };\n  }\n  return {\n    codecString,\n    description: codec.description ? {\n      type: \"unknown-data\",\n      data: codec.description\n    } : undefined\n  };\n};\nvar getAudioCodecFromAudioCodecInfo = (codec) => {\n  if (codec.format === \"twos\") {\n    return \"pcm-s16\";\n  }\n  if (codec.format === \"in24\") {\n    return \"pcm-s24\";\n  }\n  if (codec.format === \"lpcm\") {\n    return \"pcm-s16\";\n  }\n  if (codec.format === \"sowt\") {\n    return \"aiff\";\n  }\n  if (codec.format === \"ac-3\") {\n    return \"ac3\";\n  }\n  if (codec.format === \"Opus\") {\n    return \"opus\";\n  }\n  if (codec.format === \"mp4a\") {\n    if (codec.primarySpecificator === 64) {\n      return \"aac\";\n    }\n    if (codec.primarySpecificator === 107) {\n      return \"mp3\";\n    }\n    if (codec.primarySpecificator === null) {\n      return \"aac\";\n    }\n    throw new Error(\"Unknown mp4a codec: \" + codec.primarySpecificator);\n  }\n  throw new Error(`Unknown audio format: ${codec.format}`);\n};\nvar getAudioCodecFromTrack = (track) => {\n  const audioSample = getAudioCodecFromTrak(track);\n  if (!audioSample) {\n    throw new Error(\"Could not find audio sample\");\n  }\n  return getAudioCodecFromAudioCodecInfo(audioSample);\n};\n\n// src/get-container.ts\nvar getContainer = (segments) => {\n  if (segments.type === \"iso-base-media\") {\n    return \"mp4\";\n  }\n  if (segments.type === \"matroska\") {\n    return \"webm\";\n  }\n  if (segments.type === \"transport-stream\") {\n    return \"transport-stream\";\n  }\n  if (segments.type === \"mp3\") {\n    return \"mp3\";\n  }\n  if (segments.type === \"wav\") {\n    return \"wav\";\n  }\n  if (segments.type === \"flac\") {\n    return \"flac\";\n  }\n  if (segments.type === \"riff\") {\n    if (isRiffAvi(segments)) {\n      return \"avi\";\n    }\n    throw new Error(\"Unknown RIFF container \" + segments.type);\n  }\n  if (segments.type === \"aac\") {\n    return \"aac\";\n  }\n  if (segments.type === \"m3u\") {\n    return \"m3u8\";\n  }\n  throw new Error(\"Unknown container \" + segments);\n};\nvar hasContainer = (boxes) => {\n  try {\n    return getContainer(boxes) !== null;\n  } catch {\n    return false;\n  }\n};\n\n// src/get-dimensions.ts\nvar getDimensions = (state) => {\n  const structure = state.structure.getStructureOrNull();\n  if (structure && isAudioStructure(structure)) {\n    return null;\n  }\n  const tracks2 = getTracks(state, true);\n  if (!tracks2.length) {\n    return null;\n  }\n  const firstVideoTrack = tracks2.find((t) => t.type === \"video\");\n  if (!firstVideoTrack) {\n    return null;\n  }\n  return {\n    width: firstVideoTrack.width,\n    height: firstVideoTrack.height,\n    rotation: firstVideoTrack.rotation,\n    unrotatedHeight: firstVideoTrack.displayAspectHeight,\n    unrotatedWidth: firstVideoTrack.displayAspectWidth\n  };\n};\nvar hasDimensions = (state) => {\n  const structure = state.structure.getStructureOrNull();\n  if (structure && isAudioStructure(structure)) {\n    return true;\n  }\n  try {\n    return getDimensions(state) !== null;\n  } catch {\n    return false;\n  }\n};\n\n// src/containers/flac/get-duration-from-flac.ts\nvar getDurationFromFlac = (parserState) => {\n  const structure = parserState.structure.getFlacStructure();\n  const streaminfo = structure.boxes.find((b) => b.type === \"flac-streaminfo\");\n  if (!streaminfo) {\n    throw new Error(\"Streaminfo not found\");\n  }\n  return streaminfo.totalSamples / streaminfo.sampleRate;\n};\n\n// src/containers/iso-base-media/are-samples-complete.ts\nvar areSamplesComplete = ({\n  moofBoxes,\n  tfraBoxes\n}) => {\n  if (moofBoxes.length === 0) {\n    return true;\n  }\n  return tfraBoxes.length > 0 && tfraBoxes.every((t) => t.entries.length === moofBoxes.length);\n};\n\n// src/samples-from-moof.ts\nvar getSamplesFromTraf = (trafSegment, moofOffset, trexBoxes) => {\n  if (trafSegment.type !== \"regular-box\" || trafSegment.boxType !== \"traf\") {\n    throw new Error(\"Expected traf-box\");\n  }\n  const tfhdBox = getTfhdBox(trafSegment);\n  const trexBox = trexBoxes.find((t) => t.trackId === tfhdBox?.trackId) ?? null;\n  const defaultTrackSampleDuration = tfhdBox?.defaultSampleDuration || trexBox?.defaultSampleDuration || null;\n  const defaultTrackSampleSize = tfhdBox?.defaultSampleSize || trexBox?.defaultSampleSize || null;\n  const defaultTrackSampleFlags = tfhdBox?.defaultSampleFlags ?? trexBox?.defaultSampleFlags ?? null;\n  const tfdtBox = getTfdtBox(trafSegment);\n  const trunBoxes = getTrunBoxes(trafSegment);\n  let time = 0;\n  let offset = 0;\n  let dataOffset = 0;\n  const samples = [];\n  for (const trunBox of trunBoxes) {\n    let i = -1;\n    if (trunBox.dataOffset) {\n      dataOffset = trunBox.dataOffset;\n      offset = 0;\n    }\n    for (const sample of trunBox.samples) {\n      i++;\n      const duration2 = sample.sampleDuration || defaultTrackSampleDuration;\n      if (duration2 === null) {\n        throw new Error(\"Expected duration\");\n      }\n      const size = sample.sampleSize ?? defaultTrackSampleSize;\n      if (size === null) {\n        throw new Error(\"Expected size\");\n      }\n      const isFirstSample = i === 0;\n      const sampleFlags = sample.sampleFlags ? sample.sampleFlags : isFirstSample && trunBox.firstSampleFlags !== null ? trunBox.firstSampleFlags : defaultTrackSampleFlags;\n      if (sampleFlags === null) {\n        throw new Error(\"Expected sample flags\");\n      }\n      const keyframe = !(sampleFlags >> 16 & 1);\n      const dts = time + (tfdtBox?.baseMediaDecodeTime ?? 0);\n      const samplePosition = {\n        offset: offset + (moofOffset ?? 0) + (dataOffset ?? 0),\n        decodingTimestamp: dts,\n        timestamp: dts + (sample.sampleCompositionTimeOffset ?? 0),\n        duration: duration2,\n        isKeyframe: keyframe,\n        size,\n        chunk: 0,\n        bigEndian: false,\n        chunkSize: null\n      };\n      samples.push(samplePosition);\n      offset += size;\n      time += duration2;\n    }\n  }\n  return samples;\n};\nvar getSamplesFromMoof = ({\n  moofBox,\n  trackId,\n  trexBoxes\n}) => {\n  const mapped = moofBox.trafBoxes.map((traf) => {\n    const tfhdBox = getTfhdBox(traf);\n    if (!tfhdBox || tfhdBox.trackId !== trackId) {\n      return [];\n    }\n    return getSamplesFromTraf(traf, moofBox.offset, trexBoxes);\n  });\n  return mapped.flat(1);\n};\n\n// src/containers/iso-base-media/collect-sample-positions-from-moof-boxes.ts\nvar collectSamplePositionsFromMoofBoxes = ({\n  moofBoxes,\n  tkhdBox,\n  isComplete,\n  trexBoxes\n}) => {\n  const samplePositions = moofBoxes.map((m, index) => {\n    const isLastFragment = index === moofBoxes.length - 1 && isComplete;\n    return {\n      isLastFragment,\n      samples: getSamplesFromMoof({\n        moofBox: m,\n        trackId: tkhdBox.trackId,\n        trexBoxes\n      })\n    };\n  });\n  return { samplePositions, isComplete };\n};\n\n// src/get-sample-positions.ts\nvar getSamplePositions = ({\n  stcoBox,\n  stszBox,\n  stscBox,\n  stssBox,\n  sttsBox,\n  cttsBox\n}) => {\n  const sttsDeltas = [];\n  for (const distribution of sttsBox.sampleDistribution) {\n    for (let i = 0;i < distribution.sampleCount; i++) {\n      sttsDeltas.push(distribution.sampleDelta);\n    }\n  }\n  const cttsEntries = [];\n  for (const entry of cttsBox?.entries ?? [\n    { sampleCount: sttsDeltas.length, sampleOffset: 0 }\n  ]) {\n    for (let i = 0;i < entry.sampleCount; i++) {\n      cttsEntries.push(entry.sampleOffset);\n    }\n  }\n  let dts = 0;\n  const chunks = stcoBox.entries;\n  const samples = [];\n  let samplesPerChunk = 1;\n  for (let i = 0;i < chunks.length; i++) {\n    const hasEntry = stscBox.entries.get(i + 1);\n    if (hasEntry !== undefined) {\n      samplesPerChunk = hasEntry;\n    }\n    let offsetInThisChunk = 0;\n    for (let j = 0;j < samplesPerChunk; j++) {\n      const size = stszBox.countType === \"fixed\" ? stszBox.sampleSize : stszBox.entries[samples.length];\n      const isKeyframe = stssBox ? stssBox.sampleNumber.has(samples.length + 1) : true;\n      const delta = sttsDeltas[samples.length];\n      const ctsOffset = cttsEntries[samples.length];\n      const cts = dts + ctsOffset;\n      samples.push({\n        offset: Number(chunks[i]) + offsetInThisChunk,\n        size,\n        isKeyframe,\n        decodingTimestamp: dts,\n        timestamp: cts,\n        duration: delta,\n        chunk: i,\n        bigEndian: false,\n        chunkSize: null\n      });\n      dts += delta;\n      offsetInThisChunk += size;\n    }\n  }\n  return samples;\n};\n\n// src/get-sample-positions-from-mp4.ts\nvar getGroupedSamplesPositionsFromMp4 = ({\n  trakBox,\n  bigEndian\n}) => {\n  const stscBox = getStscBox(trakBox);\n  const stszBox = getStszBox(trakBox);\n  const stcoBox = getStcoBox(trakBox);\n  if (!stscBox) {\n    throw new Error(\"Expected stsc box in trak box\");\n  }\n  if (!stcoBox) {\n    throw new Error(\"Expected stco box in trak box\");\n  }\n  if (!stszBox) {\n    throw new Error(\"Expected stsz box in trak box\");\n  }\n  if (stszBox.countType !== \"fixed\") {\n    throw new Error(\"Only supporting fixed count type in stsz box\");\n  }\n  const samples = [];\n  let timestamp = 0;\n  const stscKeys = Array.from(stscBox.entries.keys());\n  for (let i = 0;i < stcoBox.entries.length; i++) {\n    const entry = stcoBox.entries[i];\n    const chunk = i + 1;\n    const stscEntry = stscKeys.findLast((e) => e <= chunk);\n    if (stscEntry === undefined) {\n      throw new Error(\"should not be\");\n    }\n    const samplesPerChunk = stscBox.entries.get(stscEntry);\n    if (samplesPerChunk === undefined) {\n      throw new Error(\"should not be\");\n    }\n    samples.push({\n      chunk,\n      timestamp,\n      decodingTimestamp: timestamp,\n      offset: Number(entry),\n      size: stszBox.sampleSize * samplesPerChunk,\n      duration: samplesPerChunk,\n      isKeyframe: true,\n      bigEndian,\n      chunkSize: stszBox.sampleSize\n    });\n    timestamp += samplesPerChunk;\n  }\n  return samples;\n};\n\n// src/containers/iso-base-media/should-group-audio-samples.ts\nvar shouldGroupAudioSamples = (trakBox) => {\n  const isLpcm = isLpcmAudioCodec(trakBox);\n  const isIn24 = isIn24AudioCodec(trakBox);\n  const isTwos = isTwosAudioCodec(trakBox);\n  if (isLpcm || isIn24 || isTwos) {\n    return {\n      bigEndian: isTwos || isIn24\n    };\n  }\n  return null;\n};\n\n// src/containers/iso-base-media/collect-sample-positions-from-trak.ts\nvar collectSamplePositionsFromTrak = (trakBox) => {\n  const shouldGroupSamples = shouldGroupAudioSamples(trakBox);\n  const timescaleAndDuration = getTimescaleAndDuration(trakBox);\n  if (shouldGroupSamples) {\n    return getGroupedSamplesPositionsFromMp4({\n      trakBox,\n      bigEndian: shouldGroupSamples.bigEndian\n    });\n  }\n  const stszBox = getStszBox(trakBox);\n  const stcoBox = getStcoBox(trakBox);\n  const stscBox = getStscBox(trakBox);\n  const stssBox = getStssBox(trakBox);\n  const sttsBox = getSttsBox(trakBox);\n  const cttsBox = getCttsBox(trakBox);\n  if (!stszBox) {\n    throw new Error(\"Expected stsz box in trak box\");\n  }\n  if (!stcoBox) {\n    throw new Error(\"Expected stco box in trak box\");\n  }\n  if (!stscBox) {\n    throw new Error(\"Expected stsc box in trak box\");\n  }\n  if (!sttsBox) {\n    throw new Error(\"Expected stts box in trak box\");\n  }\n  if (!timescaleAndDuration) {\n    throw new Error(\"Expected timescale and duration in trak box\");\n  }\n  const samplePositions = getSamplePositions({\n    stcoBox,\n    stscBox,\n    stszBox,\n    stssBox,\n    sttsBox,\n    cttsBox\n  });\n  return samplePositions;\n};\n\n// src/containers/iso-base-media/get-sample-positions-from-track.ts\nvar getSamplePositionsFromTrack = ({\n  trakBox,\n  moofBoxes,\n  moofComplete,\n  trexBoxes\n}) => {\n  const tkhdBox = getTkhdBox(trakBox);\n  if (!tkhdBox) {\n    throw new Error(\"Expected tkhd box in trak box\");\n  }\n  if (moofBoxes.length > 0) {\n    const { samplePositions } = collectSamplePositionsFromMoofBoxes({\n      moofBoxes,\n      tkhdBox,\n      isComplete: moofComplete,\n      trexBoxes\n    });\n    return {\n      samplePositions: samplePositions.map((s) => s.samples).flat(1),\n      isComplete: moofComplete\n    };\n  }\n  return {\n    samplePositions: collectSamplePositionsFromTrak(trakBox),\n    isComplete: true\n  };\n};\n\n// src/containers/m3u/get-playlist.ts\nvar getAllPlaylists = ({\n  structure,\n  src\n}) => {\n  const isIndependent = isIndependentSegments(structure);\n  if (!isIndependent) {\n    return [\n      {\n        type: \"m3u-playlist\",\n        boxes: structure.boxes,\n        src\n      }\n    ];\n  }\n  const playlists = structure.boxes.filter((box) => box.type === \"m3u-playlist\");\n  return playlists;\n};\nvar getPlaylist = (structure, src) => {\n  const allPlaylists = getAllPlaylists({ structure, src });\n  const playlists = allPlaylists.find((box) => box.src === src);\n  if (!playlists) {\n    throw new Error(`Expected m3u-playlist with src ${src}`);\n  }\n  return playlists;\n};\nvar getDurationFromPlaylist = (playlist) => {\n  const duration2 = playlist.boxes.filter((box) => box.type === \"m3u-extinf\");\n  if (duration2.length === 0) {\n    throw new Error(\"Expected duration in m3u playlist\");\n  }\n  return duration2.reduce((acc, d) => acc + d.value, 0);\n};\n\n// src/containers/m3u/get-duration-from-m3u.ts\nvar getDurationFromM3u = (state) => {\n  const playlists = getAllPlaylists({\n    structure: state.structure.getM3uStructure(),\n    src: state.src\n  });\n  return Math.max(...playlists.map((p) => {\n    return getDurationFromPlaylist(p);\n  }));\n};\n\n// src/containers/mp3/get-frame-length.ts\nvar getUnroundedMpegFrameLength = ({\n  samplesPerFrame,\n  bitrateKbit,\n  samplingFrequency: samplingFrequency2,\n  padding,\n  layer\n}) => {\n  if (layer === 1) {\n    throw new Error(\"MPEG Layer I is not supported\");\n  }\n  return samplesPerFrame / 8 * bitrateKbit / samplingFrequency2 * 1000 + (padding ? layer === 1 ? 4 : 1 : 0);\n};\nvar getAverageMpegFrameLength = ({\n  samplesPerFrame,\n  bitrateKbit,\n  samplingFrequency: samplingFrequency2,\n  layer\n}) => {\n  const withoutPadding = getUnroundedMpegFrameLength({\n    bitrateKbit,\n    layer,\n    padding: false,\n    samplesPerFrame,\n    samplingFrequency: samplingFrequency2\n  });\n  const rounded = Math.floor(withoutPadding);\n  const rest = withoutPadding % 1;\n  return rest * (rounded + 1) + (1 - rest) * rounded;\n};\nvar getMpegFrameLength = ({\n  samplesPerFrame,\n  bitrateKbit,\n  samplingFrequency: samplingFrequency2,\n  padding,\n  layer\n}) => {\n  return Math.floor(getUnroundedMpegFrameLength({\n    bitrateKbit,\n    layer,\n    padding,\n    samplesPerFrame,\n    samplingFrequency: samplingFrequency2\n  }));\n};\n\n// src/containers/mp3/samples-per-mpeg-file.ts\nvar getSamplesPerMpegFrame = ({\n  mpegVersion,\n  layer\n}) => {\n  if (mpegVersion === 1) {\n    if (layer === 1) {\n      return 384;\n    }\n    if (layer === 2 || layer === 3) {\n      return 1152;\n    }\n  }\n  if (mpegVersion === 2) {\n    if (layer === 1) {\n      return 384;\n    }\n    if (layer === 2) {\n      return 1152;\n    }\n    if (layer === 3) {\n      return 576;\n    }\n  }\n  throw new Error(\"Invalid MPEG layer\");\n};\n\n// src/containers/mp3/get-duration.ts\nvar getDurationFromMp3Xing = ({\n  xingData,\n  samplesPerFrame\n}) => {\n  const xingFrames = xingData.numberOfFrames;\n  if (!xingFrames) {\n    throw new Error(\"Cannot get duration of VBR MP3 file - no frames\");\n  }\n  const { sampleRate } = xingData;\n  if (!sampleRate) {\n    throw new Error(\"Cannot get duration of VBR MP3 file - no sample rate\");\n  }\n  const xingSamples = xingFrames * samplesPerFrame;\n  return xingSamples / sampleRate;\n};\nvar getDurationFromMp3 = (state) => {\n  const mp3Info = state.mp3.getMp3Info();\n  const mp3BitrateInfo = state.mp3.getMp3BitrateInfo();\n  if (!mp3Info || !mp3BitrateInfo) {\n    return null;\n  }\n  const samplesPerFrame = getSamplesPerMpegFrame({\n    layer: mp3Info.layer,\n    mpegVersion: mp3Info.mpegVersion\n  });\n  if (mp3BitrateInfo.type === \"variable\") {\n    return getDurationFromMp3Xing({\n      xingData: mp3BitrateInfo.xingData,\n      samplesPerFrame\n    });\n  }\n  const frameLengthInBytes = getMpegFrameLength({\n    bitrateKbit: mp3BitrateInfo.bitrateInKbit,\n    padding: false,\n    samplesPerFrame,\n    samplingFrequency: mp3Info.sampleRate,\n    layer: mp3Info.layer\n  });\n  const frames = Math.floor((state.contentLength - state.mediaSection.getMediaSectionAssertOnlyOne().start) / frameLengthInBytes);\n  const samples = frames * samplesPerFrame;\n  const durationInSeconds = samples / mp3Info.sampleRate;\n  return durationInSeconds;\n};\n\n// src/containers/riff/get-duration.ts\nvar getDurationFromAvi = (structure) => {\n  const strl = getStrlBoxes(structure);\n  const lengths = [];\n  for (const s of strl) {\n    const strh = getStrhBox(s.children);\n    if (!strh) {\n      throw new Error(\"No strh box\");\n    }\n    const samplesPerSecond = strh.rate / strh.scale;\n    const streamLength = strh.length / samplesPerSecond;\n    lengths.push(streamLength);\n  }\n  return Math.max(...lengths);\n};\n\n// src/containers/wav/get-duration-from-wav.ts\nvar getDurationFromWav = (state) => {\n  const structure = state.structure.getWavStructure();\n  const fmt = structure.boxes.find((b) => b.type === \"wav-fmt\");\n  if (!fmt) {\n    throw new Error(\"Expected fmt box\");\n  }\n  const dataBox = structure.boxes.find((b) => b.type === \"wav-data\");\n  if (!dataBox) {\n    throw new Error(\"Expected data box\");\n  }\n  const durationInSeconds = dataBox.dataSize / (fmt.sampleRate * fmt.blockAlign);\n  return durationInSeconds;\n};\n\n// src/state/iso-base-media/precomputed-tfra.ts\nvar precomputedTfraState = () => {\n  let tfraBoxes = [];\n  return {\n    getTfraBoxes: () => tfraBoxes,\n    setTfraBoxes: (boxes) => {\n      tfraBoxes = boxes;\n    }\n  };\n};\nvar deduplicateTfraBoxesByOffset = (tfraBoxes) => {\n  return tfraBoxes.filter((m, i, arr) => i === arr.findIndex((t) => t.offset === m.offset));\n};\n\n// src/get-duration.ts\nvar getDurationFromMatroska = (segments) => {\n  const mainSegment = segments.find((s) => s.type === \"Segment\");\n  if (!mainSegment || mainSegment.type !== \"Segment\") {\n    return null;\n  }\n  const { value: children } = mainSegment;\n  if (!children) {\n    return null;\n  }\n  const infoSegment = children.find((s) => s.type === \"Info\");\n  const relevantBoxes = [\n    ...mainSegment.value,\n    ...infoSegment && infoSegment.type === \"Info\" ? infoSegment.value : []\n  ];\n  const timestampScale2 = relevantBoxes.find((s) => s.type === \"TimestampScale\");\n  if (!timestampScale2 || timestampScale2.type !== \"TimestampScale\") {\n    return null;\n  }\n  const duration2 = relevantBoxes.find((s) => s.type === \"Duration\");\n  if (!duration2 || duration2.type !== \"Duration\") {\n    return null;\n  }\n  return duration2.value.value / timestampScale2.value.value * 1000;\n};\nvar getDurationFromIsoBaseMedia = (parserState) => {\n  const structure = parserState.structure.getIsoStructure();\n  const moovBox = getMoovBoxFromState({\n    structureState: parserState.structure,\n    isoState: parserState.iso,\n    mp4HeaderSegment: parserState.m3uPlaylistContext?.mp4HeaderSegment ?? null,\n    mayUsePrecomputed: true\n  });\n  if (!moovBox) {\n    return null;\n  }\n  const moofBoxes = getMoofBoxes(structure.boxes);\n  const mfra = parserState.iso.mfra.getIfAlreadyLoaded();\n  const tfraBoxes = deduplicateTfraBoxesByOffset([\n    ...mfra ? getTfraBoxesFromMfraBoxChildren(mfra) : [],\n    ...getTfraBoxes(structure.boxes)\n  ]);\n  if (!areSamplesComplete({ moofBoxes, tfraBoxes })) {\n    return null;\n  }\n  const mvhdBox = getMvhdBox(moovBox);\n  if (!mvhdBox) {\n    return null;\n  }\n  if (mvhdBox.type !== \"mvhd-box\") {\n    throw new Error(\"Expected mvhd-box\");\n  }\n  if (mvhdBox.durationInSeconds > 0) {\n    return mvhdBox.durationInSeconds;\n  }\n  const tracks2 = getTracks(parserState, true);\n  const allSamples = tracks2.map((t) => {\n    const { originalTimescale: ts } = t;\n    const trakBox = getTrakBoxByTrackId(moovBox, t.trackId);\n    if (!trakBox) {\n      return null;\n    }\n    const { samplePositions, isComplete } = getSamplePositionsFromTrack({\n      trakBox,\n      moofBoxes,\n      moofComplete: areSamplesComplete({ moofBoxes, tfraBoxes }),\n      trexBoxes: getTrexBoxes(moovBox)\n    });\n    if (!isComplete) {\n      return null;\n    }\n    if (samplePositions.length === 0) {\n      return null;\n    }\n    const highest = samplePositions?.map((sp) => (sp.timestamp + sp.duration) / ts).reduce((a, b) => Math.max(a, b), 0);\n    return highest ?? 0;\n  });\n  if (allSamples.every((s) => s === null)) {\n    return null;\n  }\n  const highestTimestamp = Math.max(...allSamples.filter((s) => s !== null));\n  return highestTimestamp;\n};\nvar getDuration = (parserState) => {\n  const structure = parserState.structure.getStructure();\n  if (structure.type === \"matroska\") {\n    return getDurationFromMatroska(structure.boxes);\n  }\n  if (structure.type === \"iso-base-media\") {\n    return getDurationFromIsoBaseMedia(parserState);\n  }\n  if (structure.type === \"riff\") {\n    return getDurationFromAvi(structure);\n  }\n  if (structure.type === \"transport-stream\") {\n    return null;\n  }\n  if (structure.type === \"mp3\") {\n    return getDurationFromMp3(parserState);\n  }\n  if (structure.type === \"wav\") {\n    return getDurationFromWav(parserState);\n  }\n  if (structure.type === \"aac\") {\n    return null;\n  }\n  if (structure.type === \"flac\") {\n    return getDurationFromFlac(parserState);\n  }\n  if (structure.type === \"m3u\") {\n    return getDurationFromM3u(parserState);\n  }\n  throw new Error(\"Has no duration \" + structure);\n};\nvar hasDuration = (parserState) => {\n  const structure = parserState.structure.getStructureOrNull();\n  if (structure === null) {\n    return false;\n  }\n  return getHasTracks(parserState, true);\n};\nvar hasSlowDuration = (parserState) => {\n  try {\n    if (!hasDuration(parserState)) {\n      return false;\n    }\n    return getDuration(parserState) !== null;\n  } catch {\n    return false;\n  }\n};\n\n// src/get-is-hdr.ts\nvar isVideoTrackHdr = (track) => {\n  return track.advancedColor.matrix === \"bt2020-ncl\" && (track.advancedColor.transfer === \"hlg\" || track.advancedColor.transfer === \"pq\") && track.advancedColor.primaries === \"bt2020\";\n};\nvar getIsHdr = (state) => {\n  const tracks2 = getTracks(state, true);\n  return tracks2.some((track) => track.type === \"video\" && isVideoTrackHdr(track));\n};\nvar hasHdr = (state) => {\n  return getHasTracks(state, true);\n};\n\n// src/containers/iso-base-media/get-keyframes.ts\nvar getKeyframesFromIsoBaseMedia = (state) => {\n  const tracks2 = getTracksFromIsoBaseMedia({\n    isoState: state.iso,\n    m3uPlaylistContext: state.m3uPlaylistContext,\n    structure: state.structure,\n    mayUsePrecomputed: true\n  });\n  const videoTracks = tracks2.filter((t) => t.type === \"video\");\n  const structure = state.structure.getIsoStructure();\n  const moofBoxes = getMoofBoxes(structure.boxes);\n  const tfraBoxes = getTfraBoxes(structure.boxes);\n  const moov = getMoovFromFromIsoStructure(structure);\n  if (!moov) {\n    return [];\n  }\n  const allSamples = videoTracks.map((t) => {\n    const { originalTimescale: ts } = t;\n    const trakBox = getTrakBoxByTrackId(moov, t.trackId);\n    if (!trakBox) {\n      return [];\n    }\n    const { samplePositions, isComplete } = getSamplePositionsFromTrack({\n      trakBox,\n      moofBoxes,\n      moofComplete: areSamplesComplete({\n        moofBoxes,\n        tfraBoxes\n      }),\n      trexBoxes: getTrexBoxes(moov)\n    });\n    if (!isComplete) {\n      return [];\n    }\n    const keyframes = samplePositions.filter((k) => {\n      return k.isKeyframe;\n    }).map((k) => {\n      return {\n        trackId: t.trackId,\n        presentationTimeInSeconds: k.timestamp / ts,\n        decodingTimeInSeconds: k.decodingTimestamp / ts,\n        positionInBytes: k.offset,\n        sizeInBytes: k.size\n      };\n    });\n    return keyframes;\n  });\n  return allSamples.flat();\n};\n\n// src/get-keyframes.ts\nvar getKeyframes = (state) => {\n  const structure = state.structure.getStructure();\n  if (structure.type === \"iso-base-media\") {\n    return getKeyframesFromIsoBaseMedia(state);\n  }\n  return null;\n};\nvar hasKeyframes = (parserState) => {\n  const structure = parserState.structure.getStructure();\n  if (structure.type === \"iso-base-media\") {\n    return getHasTracks(parserState, true);\n  }\n  return true;\n};\n\n// src/containers/flac/get-metadata-from-flac.ts\nvar getMetadataFromFlac = (structure) => {\n  const box = structure.boxes.find((b) => b.type === \"flac-vorbis-comment\");\n  if (!box) {\n    return null;\n  }\n  return box.fields;\n};\n\n// src/containers/mp3/get-metadata-from-mp3.ts\nvar getMetadataFromMp3 = (mp3Structure) => {\n  const findHeader = mp3Structure.boxes.find((b) => b.type === \"id3-header\");\n  return findHeader ? findHeader.metatags : null;\n};\n\n// src/containers/wav/get-metadata-from-wav.ts\nvar getMetadataFromWav = (structure) => {\n  const list = structure.boxes.find((b) => b.type === \"wav-list\");\n  if (!list) {\n    return null;\n  }\n  return list.metadata;\n};\n\n// src/metadata/metadata-from-iso.ts\nvar mapToKey = (index) => {\n  if (index === \"ï¿½ART\") {\n    return \"artist\";\n  }\n  if (index === \"ï¿½alb\") {\n    return \"album\";\n  }\n  if (index === \"ï¿½cmt\") {\n    return \"comment\";\n  }\n  if (index === \"ï¿½day\") {\n    return \"releaseDate\";\n  }\n  if (index === \"ï¿½gen\") {\n    return \"genre\";\n  }\n  if (index === \"ï¿½nam\") {\n    return \"title\";\n  }\n  if (index === \"ï¿½too\") {\n    return \"encoder\";\n  }\n  if (index === \"ï¿½wrt\") {\n    return \"writer\";\n  }\n  if (index === \"ï¿½cpy\") {\n    return \"copyright\";\n  }\n  if (index === \"ï¿½dir\") {\n    return \"director\";\n  }\n  if (index === \"ï¿½prd\") {\n    return \"producer\";\n  }\n  if (index === \"ï¿½des\") {\n    return \"description\";\n  }\n  return null;\n};\nvar parseIlstBoxWithoutKeys = (ilstBox) => {\n  return ilstBox.entries.map((entry) => {\n    const key = mapToKey(entry.index);\n    if (!key) {\n      return null;\n    }\n    if (entry.value.type === \"unknown\") {\n      return null;\n    }\n    return {\n      trackId: null,\n      key,\n      value: entry.value.value\n    };\n  }).filter(truthy);\n};\nvar parseIsoMetaBox = (meta, trackId) => {\n  const ilstBox = meta.children.find((b) => b.type === \"ilst-box\");\n  const keysBox = meta.children.find((b) => b.type === \"keys-box\");\n  if (!ilstBox || !keysBox) {\n    if (ilstBox) {\n      return parseIlstBoxWithoutKeys(ilstBox);\n    }\n    return [];\n  }\n  const entries = [];\n  for (let i = 0;i < ilstBox.entries.length; i++) {\n    const ilstEntry = ilstBox.entries[i];\n    const keysEntry = keysBox.entries[i];\n    if (ilstEntry.value.type !== \"unknown\") {\n      const value = typeof ilstEntry.value.value === \"string\" && ilstEntry.value.value.endsWith(\"\\x00\") ? ilstEntry.value.value.slice(0, -1) : ilstEntry.value.value;\n      entries.push({\n        key: keysEntry.value,\n        value,\n        trackId\n      });\n    }\n  }\n  return entries;\n};\nvar getMetadataFromIsoBase = (state) => {\n  const moov = getMoovBoxFromState({\n    structureState: state.structure,\n    isoState: state.iso,\n    mp4HeaderSegment: state.m3uPlaylistContext?.mp4HeaderSegment ?? null,\n    mayUsePrecomputed: true\n  });\n  if (!moov) {\n    return [];\n  }\n  const traks = getTraks(moov);\n  const meta = moov.children.find((b) => b.type === \"regular-box\" && b.boxType === \"meta\");\n  const udta = moov.children.find((b) => b.type === \"regular-box\" && b.boxType === \"udta\");\n  const metaInUdta = udta?.children.find((b) => {\n    return b.type === \"regular-box\" && b.boxType === \"meta\";\n  });\n  const metaInTracks = traks.map((t) => {\n    const metaBox = t.children.find((child) => child.type === \"regular-box\" && child.boxType === \"meta\");\n    if (metaBox) {\n      const tkhd = getTkhdBox(t);\n      if (!tkhd) {\n        throw new Error(\"No tkhd box found\");\n      }\n      return parseIsoMetaBox(metaBox, tkhd.trackId);\n    }\n    return null;\n  }).filter(truthy);\n  return [\n    ...meta ? parseIsoMetaBox(meta, null) : [],\n    ...metaInUdta ? parseIsoMetaBox(metaInUdta, null) : [],\n    ...metaInTracks.flat(1)\n  ];\n};\n\n// src/metadata/metadata-from-matroska.ts\nvar removeEndZeroes = (value) => {\n  return value.endsWith(\"\\x00\") ? removeEndZeroes(value.slice(0, -1)) : value;\n};\nvar parseSimpleTagIntoEbml = (children, trackId) => {\n  const tagName = children.find((c) => c.type === \"TagName\");\n  const tagString = children.find((c) => c.type === \"TagString\");\n  if (!tagName || !tagString) {\n    return null;\n  }\n  return {\n    trackId,\n    key: tagName.value.toLowerCase(),\n    value: removeEndZeroes(tagString.value)\n  };\n};\nvar getMetadataFromMatroska = (structure) => {\n  const entries = [];\n  for (const segment of structure.boxes) {\n    if (segment.type !== \"Segment\") {\n      continue;\n    }\n    const tags2 = segment.value.filter((s) => s.type === \"Tags\");\n    for (const tag of tags2) {\n      for (const child of tag.value) {\n        if (child.type !== \"Tag\") {\n          continue;\n        }\n        let trackId = null;\n        const target = child.value.find((c) => c.type === \"Targets\");\n        if (target) {\n          const tagTrackId = target.value.find((c) => c.type === \"TagTrackUID\")?.value;\n          if (tagTrackId) {\n            trackId = getTrackWithUid(segment, tagTrackId);\n          }\n        }\n        const simpleTags = child.value.filter((s) => s.type === \"SimpleTag\");\n        for (const simpleTag of simpleTags) {\n          const parsed = parseSimpleTagIntoEbml(simpleTag.value, trackId);\n          if (parsed) {\n            entries.push(parsed);\n          }\n        }\n      }\n    }\n  }\n  return entries;\n};\n\n// src/metadata/metadata-from-riff.ts\nvar getMetadataFromRiff = (structure) => {\n  const boxes = structure.boxes.find((b) => b.type === \"list-box\" && b.listType === \"INFO\");\n  if (!boxes) {\n    return [];\n  }\n  const { children } = boxes;\n  return children.map((child) => {\n    if (child.type !== \"isft-box\") {\n      return null;\n    }\n    return {\n      trackId: null,\n      key: \"encoder\",\n      value: child.software\n    };\n  }).filter(truthy);\n};\n\n// src/metadata/get-metadata.ts\nvar getMetadata = (state) => {\n  const structure = state.structure.getStructure();\n  if (structure.type === \"matroska\") {\n    return getMetadataFromMatroska(structure);\n  }\n  if (structure.type === \"riff\") {\n    return getMetadataFromRiff(structure);\n  }\n  if (structure.type === \"transport-stream\" || structure.type === \"m3u\") {\n    return [];\n  }\n  if (structure.type === \"mp3\") {\n    const tags2 = getMetadataFromMp3(structure);\n    return tags2 ?? [];\n  }\n  if (structure.type === \"wav\") {\n    return getMetadataFromWav(structure) ?? [];\n  }\n  if (structure.type === \"aac\") {\n    return [];\n  }\n  if (structure.type === \"flac\") {\n    return getMetadataFromFlac(structure) ?? [];\n  }\n  if (structure.type === \"iso-base-media\") {\n    return getMetadataFromIsoBase(state);\n  }\n  throw new Error(\"Unknown container \" + structure);\n};\nvar hasMetadata = (structure) => {\n  if (structure.type === \"mp3\") {\n    return getMetadataFromMp3(structure) !== null;\n  }\n  if (structure.type === \"wav\") {\n    return getMetadataFromWav(structure) !== null;\n  }\n  if (structure.type === \"m3u\" || structure.type === \"transport-stream\" || structure.type === \"aac\") {\n    return true;\n  }\n  if (structure.type === \"flac\") {\n    return getMetadataFromFlac(structure) !== null;\n  }\n  if (structure.type === \"iso-base-media\") {\n    return false;\n  }\n  if (structure.type === \"matroska\") {\n    return false;\n  }\n  if (structure.type === \"riff\") {\n    return false;\n  }\n  throw new Error(\"Unknown container \" + structure);\n};\n\n// src/get-location.ts\nfunction parseLocation(locationString) {\n  const locationPattern = /^([+-]\\d{2}\\.?\\d{0,10})([+-]\\d{3}\\.?\\d{0,10})([+-]\\d+(\\.\\d+)?)?\\/$/;\n  const match = locationString.match(locationPattern);\n  if (!match) {\n    return null;\n  }\n  const latitude = parseFloat(match[1]);\n  const longitude = parseFloat(match[2]);\n  const altitude = match[3] ? parseFloat(match[3]) : null;\n  return {\n    latitude,\n    longitude,\n    altitude\n  };\n}\nvar getLocation = (state) => {\n  const metadata = getMetadata(state);\n  const locationEntry = metadata.find((entry) => entry.key === \"com.apple.quicktime.location.ISO6709\");\n  const horizontalAccuracy = metadata.find((entry) => entry.key === \"com.apple.quicktime.location.accuracy.horizontal\");\n  if (locationEntry) {\n    const parsed = parseLocation(locationEntry.value);\n    if (parsed === null) {\n      return null;\n    }\n    return {\n      ...parsed,\n      horizontalAccuracy: horizontalAccuracy?.value ? parseFloat(String(horizontalAccuracy.value)) : null\n    };\n  }\n  return null;\n};\n\n// src/get-number-of-audio-channels.ts\nvar getNumberOfAudioChannels = (state) => {\n  return state.callbacks.tracks.getTracks().find((track) => {\n    return track.type === \"audio\";\n  })?.numberOfChannels ?? null;\n};\nvar hasNumberOfAudioChannels = (state) => {\n  return state.callbacks.tracks.hasAllTracks();\n};\n\n// src/get-sample-rate.ts\nvar getSampleRate3 = (state) => {\n  return state.callbacks.tracks.getTracks().find((track) => {\n    return track.type === \"audio\";\n  })?.sampleRate ?? null;\n};\nvar hasSampleRate = (state) => {\n  return state.callbacks.tracks.hasAllTracks();\n};\n\n// src/containers/aac/get-seeking-byte.ts\nvar getSeekingByteForAac = ({\n  time,\n  seekingHints\n}) => {\n  let bestAudioSample;\n  for (const hint of seekingHints.audioSampleMap) {\n    if (hint.timeInSeconds > time) {\n      continue;\n    }\n    if (hint.timeInSeconds + hint.durationInSeconds < time && !seekingHints.lastSampleObserved) {\n      continue;\n    }\n    if (!bestAudioSample) {\n      bestAudioSample = hint;\n      continue;\n    }\n    if (bestAudioSample.timeInSeconds < hint.timeInSeconds) {\n      bestAudioSample = hint;\n    }\n  }\n  if (bestAudioSample) {\n    return {\n      type: \"do-seek\",\n      byte: bestAudioSample.offset,\n      timeInSeconds: bestAudioSample.timeInSeconds\n    };\n  }\n  return { type: \"valid-but-must-wait\" };\n};\n\n// src/containers/flac/get-seeking-byte.ts\nvar getSeekingByteForFlac = ({\n  time,\n  seekingHints\n}) => {\n  let bestAudioSample;\n  for (const hint of seekingHints.audioSampleMap) {\n    if (hint.timeInSeconds > time) {\n      continue;\n    }\n    if (hint.timeInSeconds + hint.durationInSeconds < time && !seekingHints.lastSampleObserved) {\n      continue;\n    }\n    if (!bestAudioSample) {\n      bestAudioSample = hint;\n      continue;\n    }\n    if (bestAudioSample.timeInSeconds < hint.timeInSeconds) {\n      bestAudioSample = hint;\n    }\n  }\n  if (bestAudioSample) {\n    return bestAudioSample;\n  }\n  return null;\n};\n\n// src/containers/iso-base-media/find-keyframe-before-time.ts\nvar findKeyframeBeforeTime = ({\n  samplePositions,\n  time,\n  timescale,\n  mediaSections,\n  logLevel,\n  startInSeconds\n}) => {\n  let videoByte = 0;\n  let videoSample = null;\n  for (const sample of samplePositions) {\n    const ctsInSeconds = sample.timestamp / timescale + startInSeconds;\n    const dtsInSeconds = sample.decodingTimestamp / timescale + startInSeconds;\n    if (!sample.isKeyframe) {\n      continue;\n    }\n    if (!(ctsInSeconds <= time || dtsInSeconds <= time)) {\n      continue;\n    }\n    if (videoByte <= sample.offset) {\n      videoByte = sample.offset;\n      videoSample = sample;\n    }\n  }\n  if (!videoSample) {\n    throw new Error(\"No sample found\");\n  }\n  const mediaSection = mediaSections.find((section) => videoSample.offset >= section.start && videoSample.offset < section.start + section.size);\n  if (!mediaSection) {\n    Log.trace(logLevel, \"Found a sample, but the offset has not yet been marked as a video section yet. Not yet able to seek, but probably once we have started reading the next box.\", videoSample);\n    return null;\n  }\n  return videoSample;\n};\n\n// src/containers/iso-base-media/find-track-to-seek.ts\nvar findAnyTrackWithSamplePositions = (allTracks, struc) => {\n  const moov = getMoovFromFromIsoStructure(struc);\n  if (!moov) {\n    return null;\n  }\n  for (const track of allTracks) {\n    if (track.type === \"video\" || track.type === \"audio\") {\n      const trakBox = getTrakBoxByTrackId(moov, track.trackId);\n      if (!trakBox) {\n        continue;\n      }\n      const { samplePositions } = getSamplePositionsFromTrack({\n        trakBox,\n        moofBoxes: getMoofBoxes(struc.boxes),\n        moofComplete: areSamplesComplete({\n          moofBoxes: getMoofBoxes(struc.boxes),\n          tfraBoxes: getTfraBoxes(struc.boxes)\n        }),\n        trexBoxes: getTrexBoxes(moov)\n      });\n      if (samplePositions.length === 0) {\n        continue;\n      }\n      return { track, samplePositions };\n    }\n  }\n  return null;\n};\nvar findTrackToSeek = (allTracks, structure) => {\n  const firstVideoTrack = allTracks.find((t) => t.type === \"video\");\n  const struc = structure.getIsoStructure();\n  if (!firstVideoTrack) {\n    return findAnyTrackWithSamplePositions(allTracks, struc);\n  }\n  const moov = getMoovFromFromIsoStructure(struc);\n  if (!moov) {\n    return null;\n  }\n  const trakBox = getTrakBoxByTrackId(moov, firstVideoTrack.trackId);\n  if (!trakBox) {\n    return null;\n  }\n  const { samplePositions } = getSamplePositionsFromTrack({\n    trakBox,\n    moofBoxes: getMoofBoxes(struc.boxes),\n    moofComplete: areSamplesComplete({\n      moofBoxes: getMoofBoxes(struc.boxes),\n      tfraBoxes: getTfraBoxes(struc.boxes)\n    }),\n    trexBoxes: getTrexBoxes(moov)\n  });\n  if (samplePositions.length === 0) {\n    return findAnyTrackWithSamplePositions(allTracks, struc);\n  }\n  return { track: firstVideoTrack, samplePositions };\n};\n\n// src/state/video-section.ts\nvar isByteInMediaSection = ({\n  position,\n  mediaSections\n}) => {\n  if (mediaSections.length === 0) {\n    return \"no-section-defined\";\n  }\n  for (const section of mediaSections) {\n    if (position >= section.start && position < section.start + section.size) {\n      return \"in-section\";\n    }\n  }\n  return \"outside-section\";\n};\nvar getCurrentMediaSection = ({\n  offset,\n  mediaSections\n}) => {\n  for (const section of mediaSections) {\n    if (offset >= section.start && offset < section.start + section.size) {\n      return section;\n    }\n  }\n  return null;\n};\nvar mediaSectionState = () => {\n  const mediaSections = [];\n  const addMediaSection = (section) => {\n    const overlaps = mediaSections.some((existingSection) => section.start < existingSection.start + existingSection.size && section.start + section.size > existingSection.start);\n    if (overlaps) {\n      return;\n    }\n    for (let i = mediaSections.length - 1;i >= 0; i--) {\n      const existingSection = mediaSections[i];\n      if (section.start <= existingSection.start && section.start + section.size >= existingSection.start + existingSection.size) {\n        mediaSections.splice(i, 1);\n      }\n    }\n    mediaSections.push(section);\n  };\n  const getMediaSections = () => {\n    return mediaSections;\n  };\n  const isCurrentByteInMediaSection = (iterator) => {\n    const offset = iterator.counter.getOffset();\n    return isByteInMediaSection({\n      position: offset,\n      mediaSections\n    });\n  };\n  const getMediaSectionAssertOnlyOne = () => {\n    if (mediaSections.length !== 1) {\n      throw new Error(\"Expected only one video section\");\n    }\n    return mediaSections[0];\n  };\n  return {\n    addMediaSection,\n    getMediaSections,\n    isCurrentByteInMediaSection,\n    isByteInMediaSection,\n    getCurrentMediaSection,\n    getMediaSectionAssertOnlyOne,\n    mediaSections\n  };\n};\n\n// src/containers/iso-base-media/get-sample-position-bounds.ts\nvar getSamplePositionBounds = (samplePositions, timescale) => {\n  let min = Infinity;\n  let max = -Infinity;\n  for (const samplePosition of samplePositions) {\n    const timestampMin = Math.min(samplePosition.timestamp, samplePosition.decodingTimestamp);\n    const timestampMax = Math.max(samplePosition.timestamp, samplePosition.decodingTimestamp) + (samplePosition.duration ?? 0);\n    if (timestampMin < min) {\n      min = timestampMin;\n    }\n    if (timestampMax > max) {\n      max = timestampMax;\n    }\n  }\n  return { min: min / timescale, max: max / timescale };\n};\n\n// src/containers/iso-base-media/mfra/find-best-segment-from-tfra.ts\nvar findBestSegmentFromTfra = ({\n  mfra,\n  time,\n  firstTrack,\n  timescale\n}) => {\n  const tfra = mfra.find((b) => b.type === \"tfra-box\" && b.trackId === firstTrack.trackId);\n  if (!tfra) {\n    return null;\n  }\n  let bestSegment = null;\n  for (const segment of tfra.entries) {\n    if (segment.time / timescale <= time) {\n      bestSegment = segment;\n    }\n  }\n  if (!bestSegment) {\n    return null;\n  }\n  const currentSegmentIndex = tfra.entries.indexOf(bestSegment);\n  const offsetOfNext = currentSegmentIndex === tfra.entries.length - 1 ? Infinity : tfra.entries[currentSegmentIndex + 1].moofOffset;\n  return {\n    start: bestSegment.moofOffset,\n    end: offsetOfNext\n  };\n};\n\n// src/containers/iso-base-media/get-seeking-byte-from-fragmented-mp4.ts\nvar getSeekingByteFromFragmentedMp4 = async ({\n  info,\n  time,\n  logLevel,\n  currentPosition,\n  isoState,\n  tracks: tracks2,\n  isLastChunkInPlaylist,\n  structure,\n  mp4HeaderSegment\n}) => {\n  const firstVideoTrack = tracks2.find((t) => t.type === \"video\");\n  const firstTrack = firstVideoTrack ?? tracks2.find((t) => t.type === \"audio\");\n  if (!firstTrack) {\n    throw new Error(\"no video and no audio tracks\");\n  }\n  const moov = getMoovBoxFromState({\n    structureState: structure,\n    isoState,\n    mp4HeaderSegment,\n    mayUsePrecomputed: true\n  });\n  if (!moov) {\n    throw new Error(\"No moov atom found\");\n  }\n  const trakBox = getTrakBoxByTrackId(moov, firstTrack.trackId);\n  if (!trakBox) {\n    throw new Error(\"No trak box found\");\n  }\n  const tkhdBox = getTkhdBox(trakBox);\n  if (!tkhdBox) {\n    throw new Error(\"Expected tkhd box in trak box\");\n  }\n  const isComplete = areSamplesComplete({\n    moofBoxes: info.moofBoxes,\n    tfraBoxes: info.tfraBoxes\n  });\n  const { samplePositions: samplePositionsArray } = collectSamplePositionsFromMoofBoxes({\n    moofBoxes: info.moofBoxes,\n    tkhdBox,\n    isComplete,\n    trexBoxes: getTrexBoxes(moov)\n  });\n  Log.trace(logLevel, \"Fragmented MP4 - Checking if we have seeking info for this time range\");\n  for (const positions of samplePositionsArray) {\n    const { min, max } = getSamplePositionBounds(positions.samples, firstTrack.originalTimescale);\n    if (min <= time && (positions.isLastFragment || isLastChunkInPlaylist || time <= max)) {\n      Log.trace(logLevel, `Fragmented MP4 - Found that we have seeking info for this time range: ${min} <= ${time} <= ${max}`);\n      const kf = findKeyframeBeforeTime({\n        samplePositions: positions.samples,\n        time,\n        timescale: firstTrack.originalTimescale,\n        logLevel,\n        mediaSections: info.mediaSections,\n        startInSeconds: firstTrack.startInSeconds\n      });\n      if (kf) {\n        return {\n          type: \"do-seek\",\n          byte: kf.offset,\n          timeInSeconds: Math.min(kf.decodingTimestamp, kf.timestamp) / firstTrack.originalTimescale\n        };\n      }\n    }\n  }\n  const atom = await (info.mfraAlreadyLoaded ? Promise.resolve(info.mfraAlreadyLoaded) : isoState.mfra.triggerLoad());\n  if (atom) {\n    const moofOffset = findBestSegmentFromTfra({\n      mfra: atom,\n      time,\n      firstTrack,\n      timescale: firstTrack.originalTimescale\n    });\n    if (moofOffset !== null && !(moofOffset.start <= currentPosition && currentPosition < moofOffset.end)) {\n      Log.verbose(logLevel, `Fragmented MP4 - Found based on mfra information that we should seek to: ${moofOffset.start} ${moofOffset.end}`);\n      return {\n        type: \"intermediary-seek\",\n        byte: moofOffset.start\n      };\n    }\n  }\n  Log.trace(logLevel, \"Fragmented MP4 - No seeking info found for this time range.\");\n  if (isByteInMediaSection({\n    position: currentPosition,\n    mediaSections: info.mediaSections\n  }) !== \"in-section\") {\n    return {\n      type: \"valid-but-must-wait\"\n    };\n  }\n  Log.trace(logLevel, \"Fragmented MP4 - Inside the wrong video section, skipping to the end of the section\");\n  const mediaSection = getCurrentMediaSection({\n    offset: currentPosition,\n    mediaSections: info.mediaSections\n  });\n  if (!mediaSection) {\n    throw new Error(\"No video section defined\");\n  }\n  return {\n    type: \"intermediary-seek\",\n    byte: mediaSection.start + mediaSection.size\n  };\n};\n\n// src/containers/iso-base-media/get-seeking-byte.ts\nvar getSeekingByteFromIsoBaseMedia = ({\n  info,\n  time,\n  logLevel,\n  currentPosition,\n  isoState,\n  m3uPlaylistContext,\n  structure\n}) => {\n  const tracks2 = getTracksFromIsoBaseMedia({\n    isoState,\n    m3uPlaylistContext,\n    structure,\n    mayUsePrecomputed: false\n  });\n  const hasMoov = Boolean(getMoovBoxFromState({\n    structureState: structure,\n    isoState,\n    mayUsePrecomputed: false,\n    mp4HeaderSegment: m3uPlaylistContext?.mp4HeaderSegment ?? null\n  }));\n  if (!hasMoov) {\n    Log.trace(logLevel, \"No moov box found, must wait\");\n    return Promise.resolve({\n      type: \"valid-but-must-wait\"\n    });\n  }\n  if (info.moofBoxes.length > 0) {\n    return getSeekingByteFromFragmentedMp4({\n      info,\n      time,\n      logLevel,\n      currentPosition,\n      isoState,\n      tracks: tracks2,\n      isLastChunkInPlaylist: m3uPlaylistContext?.isLastChunkInPlaylist ?? false,\n      structure,\n      mp4HeaderSegment: m3uPlaylistContext?.mp4HeaderSegment ?? null\n    });\n  }\n  const trackWithSamplePositions = findTrackToSeek(tracks2, structure);\n  if (!trackWithSamplePositions) {\n    return Promise.resolve({\n      type: \"valid-but-must-wait\"\n    });\n  }\n  const { track, samplePositions } = trackWithSamplePositions;\n  const keyframe = findKeyframeBeforeTime({\n    samplePositions,\n    time,\n    timescale: track.originalTimescale,\n    logLevel,\n    mediaSections: info.mediaSections,\n    startInSeconds: track.startInSeconds\n  });\n  if (keyframe) {\n    return Promise.resolve({\n      type: \"do-seek\",\n      byte: keyframe.offset,\n      timeInSeconds: Math.min(keyframe.decodingTimestamp, keyframe.timestamp) / track.originalTimescale\n    });\n  }\n  return Promise.resolve({\n    type: \"invalid\"\n  });\n};\n\n// src/containers/m3u/get-seeking-byte.ts\nvar clearM3uStateInPrepareForSeek = ({\n  m3uState,\n  logLevel\n}) => {\n  const selectedPlaylists = m3uState.getSelectedPlaylists();\n  for (const playlistUrl of selectedPlaylists) {\n    const streamRun = m3uState.getM3uStreamRun(playlistUrl);\n    if (streamRun) {\n      streamRun.abort();\n    }\n    Log.trace(logLevel, \"Clearing M3U stream run for\", playlistUrl);\n    m3uState.setM3uStreamRun(playlistUrl, null);\n  }\n  m3uState.clearAllChunksProcessed();\n  m3uState.sampleSorter.clearSamples();\n};\nvar getSeekingByteForM3u8 = ({\n  time,\n  currentPosition,\n  m3uState,\n  logLevel\n}) => {\n  clearM3uStateInPrepareForSeek({ m3uState, logLevel });\n  const selectedPlaylists = m3uState.getSelectedPlaylists();\n  for (const playlistUrl of selectedPlaylists) {\n    m3uState.setSeekToSecondsToProcess(playlistUrl, {\n      targetTime: time\n    });\n  }\n  return {\n    type: \"do-seek\",\n    byte: currentPosition,\n    timeInSeconds: time\n  };\n};\n\n// src/containers/mp3/seek/get-approximate-byte-from-bitrate.ts\nvar getApproximateByteFromBitrate = ({\n  mp3BitrateInfo,\n  timeInSeconds,\n  mp3Info,\n  mediaSection,\n  contentLength\n}) => {\n  if (mp3BitrateInfo.type === \"variable\") {\n    return null;\n  }\n  const samplesPerFrame = getSamplesPerMpegFrame({\n    layer: mp3Info.layer,\n    mpegVersion: mp3Info.mpegVersion\n  });\n  const frameLengthInBytes = getMpegFrameLength({\n    bitrateKbit: mp3BitrateInfo.bitrateInKbit,\n    padding: false,\n    samplesPerFrame,\n    samplingFrequency: mp3Info.sampleRate,\n    layer: mp3Info.layer\n  });\n  const frameIndexUnclamped = Math.floor(timeInSeconds * mp3Info.sampleRate / samplesPerFrame);\n  const frames = Math.floor((contentLength - mediaSection.start) / frameLengthInBytes);\n  const frameIndex = Math.min(frames - 1, frameIndexUnclamped);\n  const byteRelativeToMediaSection = frameIndex * frameLengthInBytes;\n  const byteBeforeFrame = byteRelativeToMediaSection + mediaSection.start;\n  return byteBeforeFrame;\n};\n\n// src/containers/mp3/seek/get-byte-from-observed-samples.ts\nvar getByteFromObservedSamples = ({\n  info,\n  timeInSeconds\n}) => {\n  let bestAudioSample;\n  for (const hint of info.audioSampleMap) {\n    if (hint.timeInSeconds > timeInSeconds) {\n      continue;\n    }\n    if (hint.timeInSeconds + hint.durationInSeconds < timeInSeconds && !info.lastSampleObserved) {\n      continue;\n    }\n    if (!bestAudioSample) {\n      bestAudioSample = hint;\n      continue;\n    }\n    if (bestAudioSample.timeInSeconds < hint.timeInSeconds) {\n      bestAudioSample = hint;\n    }\n  }\n  return bestAudioSample;\n};\n\n// src/containers/mp3/parse-xing.ts\nvar SAMPLE_RATES = [44100, 48000, 32000, 99999];\nvar FRAMES_FLAG = 1;\nvar BYTES_FLAG = 2;\nvar TOC_FLAG = 4;\nvar VBR_SCALE_FLAG = 8;\nvar extractI4 = (data, offset) => {\n  let x = 0;\n  x = data[offset];\n  x <<= 8;\n  x |= data[offset + 1];\n  x <<= 8;\n  x |= data[offset + 2];\n  x <<= 8;\n  x |= data[offset + 3];\n  return x;\n};\nvar parseXing = (data) => {\n  const h_id = data[1] >> 3 & 1;\n  const h_sr_index = data[2] >> 2 & 3;\n  const h_mode = data[3] >> 6 & 3;\n  let xingOffset = 0;\n  if (h_id) {\n    if (h_mode !== 3) {\n      xingOffset += 32 + 4;\n    } else {\n      xingOffset += 17 + 4;\n    }\n  } else if (h_mode !== 3) {\n    xingOffset += 17 + 4;\n  } else {\n    xingOffset += 9 + 4;\n  }\n  const expectXing = new TextDecoder(\"utf8\").decode(data.slice(xingOffset, xingOffset + 4));\n  if (expectXing !== \"Xing\") {\n    throw new Error(\"Invalid Xing header\");\n  }\n  let sampleRate = SAMPLE_RATES[h_sr_index];\n  if (h_id === 0) {\n    sampleRate >>= 1;\n  }\n  let offset = xingOffset + 4;\n  const flags = extractI4(data, offset);\n  offset += 4;\n  let numberOfFrames;\n  let fileSize;\n  let tableOfContents;\n  let vbrScale;\n  if (flags & FRAMES_FLAG) {\n    numberOfFrames = extractI4(data, offset);\n    offset += 4;\n  }\n  if (flags & BYTES_FLAG) {\n    fileSize = extractI4(data, offset);\n    offset += 4;\n  }\n  if (flags & TOC_FLAG) {\n    tableOfContents = data.slice(offset, offset + 100);\n    offset += 100;\n  }\n  if (flags & VBR_SCALE_FLAG) {\n    vbrScale = extractI4(data, offset);\n    offset += 4;\n  }\n  if (offset > data.length) {\n    throw new Error(\"xing header was parsed wrong: read beyond available data\");\n  }\n  return {\n    sampleRate,\n    numberOfFrames: numberOfFrames ?? null,\n    fileSize: fileSize ?? null,\n    tableOfContents: tableOfContents ? Array.from(tableOfContents.slice(0, 100)) : null,\n    vbrScale: vbrScale ?? null\n  };\n};\nvar getSeekPointInBytes = ({\n  fileSize,\n  percentBetween0And100,\n  tableOfContents\n}) => {\n  let index = Math.floor(percentBetween0And100);\n  if (index > 99) {\n    index = 99;\n  }\n  const fa = tableOfContents[index];\n  let fb;\n  if (index < 99) {\n    fb = tableOfContents[index + 1];\n  } else {\n    fb = 256;\n  }\n  const fx = fa + (fb - fa) * (percentBetween0And100 - index);\n  const seekPoint = 1 / 256 * fx * fileSize;\n  return Math.floor(seekPoint);\n};\nvar getTimeFromPosition = ({\n  position,\n  fileSize,\n  tableOfContents,\n  durationInSeconds\n}) => {\n  const positionNormalized = position / fileSize * 256;\n  let index = 0;\n  while (index < 99 && tableOfContents[index + 1] <= positionNormalized) {\n    index++;\n  }\n  const fa = tableOfContents[index];\n  const fb = index < 99 ? tableOfContents[index + 1] : 256;\n  const percentWithinSegment = (positionNormalized - fa) / (fb - fa);\n  const percentBetween0And100 = index + percentWithinSegment;\n  return percentBetween0And100 / 100 * durationInSeconds;\n};\n\n// src/containers/mp3/seek/get-seek-point-from-xing.ts\nvar getSeekPointFromXing = ({\n  timeInSeconds,\n  xingData,\n  mp3Info\n}) => {\n  const samplesPerFrame = getSamplesPerMpegFrame({\n    layer: mp3Info.layer,\n    mpegVersion: mp3Info.mpegVersion\n  });\n  const duration2 = getDurationFromMp3Xing({\n    xingData,\n    samplesPerFrame\n  });\n  const totalSamples = timeInSeconds * xingData.sampleRate;\n  const oneFrameSubtracted = totalSamples - samplesPerFrame;\n  const timeToTarget = Math.max(0, oneFrameSubtracted / xingData.sampleRate);\n  if (!xingData.fileSize || !xingData.tableOfContents) {\n    throw new Error(\"Cannot seek of VBR MP3 file\");\n  }\n  return getSeekPointInBytes({\n    fileSize: xingData.fileSize,\n    percentBetween0And100: timeToTarget / duration2 * 100,\n    tableOfContents: xingData.tableOfContents\n  });\n};\n\n// src/containers/mp3/get-seeking-byte.ts\nvar getSeekingByteForMp3 = ({\n  time,\n  info\n}) => {\n  if (info.mp3BitrateInfo === null || info.mp3Info === null || info.mediaSection === null) {\n    return {\n      type: \"valid-but-must-wait\"\n    };\n  }\n  const approximateByte = getApproximateByteFromBitrate({\n    mp3BitrateInfo: info.mp3BitrateInfo,\n    timeInSeconds: time,\n    mp3Info: info.mp3Info,\n    mediaSection: info.mediaSection,\n    contentLength: info.contentLength\n  });\n  const bestAudioSample = getByteFromObservedSamples({\n    info,\n    timeInSeconds: time\n  });\n  const xingSeekPoint = info.mp3BitrateInfo.type === \"variable\" ? getSeekPointFromXing({\n    mp3Info: info.mp3Info,\n    timeInSeconds: time,\n    xingData: info.mp3BitrateInfo.xingData\n  }) : null;\n  const candidates = [\n    approximateByte,\n    bestAudioSample?.offset ?? null,\n    xingSeekPoint\n  ].filter((b) => b !== null);\n  if (candidates.length === 0) {\n    return {\n      type: \"valid-but-must-wait\"\n    };\n  }\n  const byte = Math.max(...candidates);\n  const timeInSeconds = byte === bestAudioSample?.offset ? bestAudioSample.timeInSeconds : time;\n  return {\n    type: \"do-seek\",\n    byte,\n    timeInSeconds\n  };\n};\n\n// src/find-last-keyframe.ts\nfunction findLastKeyframe({\n  keyframes,\n  timeInSeconds\n}) {\n  let bestKeyframe = null;\n  for (const keyframe of keyframes) {\n    if (keyframe.presentationTimeInSeconds > timeInSeconds && keyframe.decodingTimeInSeconds > timeInSeconds) {\n      break;\n    }\n    if (bestKeyframe === null || keyframe.presentationTimeInSeconds > bestKeyframe.presentationTimeInSeconds) {\n      bestKeyframe = keyframe;\n    }\n  }\n  return bestKeyframe;\n}\n\n// src/containers/riff/get-seeking-byte.ts\nvar getSeekingByteForRiff = async ({\n  info,\n  time,\n  riffState,\n  avcState\n}) => {\n  const idx1Entries = await (info.hasIndex ? riffState.lazyIdx1.waitForLoaded() : Promise.resolve(null));\n  if (idx1Entries === null) {\n    const lastKeyframe = findLastKeyframe({\n      keyframes: info.observedKeyframes,\n      timeInSeconds: time\n    });\n    if (lastKeyframe === null) {\n      return {\n        type: \"valid-but-must-wait\"\n      };\n    }\n    riffState.sampleCounter.setSamplesFromSeek(lastKeyframe.sampleCounts);\n    riffState.queuedBFrames.clear();\n    avcState.clear();\n    return {\n      type: \"do-seek\",\n      byte: lastKeyframe.positionInBytes,\n      timeInSeconds: Math.min(lastKeyframe.decodingTimeInSeconds, lastKeyframe.presentationTimeInSeconds)\n    };\n  }\n  if (idx1Entries.videoTrackIndex === null) {\n    throw new Error(\"videoTrackIndex is null\");\n  }\n  if (info.samplesPerSecond === null) {\n    throw new Error(\"samplesPerSecond is null\");\n  }\n  const index = Math.floor(time * info.samplesPerSecond);\n  let bestEntry = null;\n  for (const entry of idx1Entries.entries) {\n    if (entry.sampleCounts[idx1Entries.videoTrackIndex] > index) {\n      continue;\n    }\n    if (bestEntry && entry.sampleCounts[idx1Entries.videoTrackIndex] < bestEntry.sampleCounts[idx1Entries.videoTrackIndex]) {\n      continue;\n    }\n    bestEntry = entry;\n  }\n  if (!bestEntry) {\n    throw new Error(\"No best entry\");\n  }\n  if (info.moviOffset === null) {\n    throw new Error(\"moviOffset is null\");\n  }\n  riffState.sampleCounter.setSamplesFromSeek(bestEntry.sampleCounts);\n  riffState.queuedBFrames.clear();\n  avcState.clear();\n  return {\n    type: \"do-seek\",\n    byte: bestEntry.offset + info.moviOffset - 4,\n    timeInSeconds: bestEntry.sampleCounts[idx1Entries.videoTrackIndex] / info.samplesPerSecond\n  };\n};\n\n// src/convert-audio-or-video-sample.ts\nvar fixFloat = (value) => {\n  if (value % 1 < 0.0000001) {\n    return Math.floor(value);\n  }\n  if (value % 1 > 0.9999999) {\n    return Math.ceil(value);\n  }\n  return value;\n};\nvar convertAudioOrVideoSampleToWebCodecsTimestamps = ({\n  sample,\n  timescale\n}) => {\n  if (timescale === WEBCODECS_TIMESCALE) {\n    return sample;\n  }\n  const { decodingTimestamp: dts, timestamp } = sample;\n  return {\n    decodingTimestamp: fixFloat(dts * (WEBCODECS_TIMESCALE / timescale)),\n    timestamp: fixFloat(timestamp * (WEBCODECS_TIMESCALE / timescale)),\n    duration: sample.duration === undefined ? undefined : fixFloat(sample.duration * (WEBCODECS_TIMESCALE / timescale)),\n    data: sample.data,\n    type: sample.type,\n    offset: sample.offset,\n    ...\"avc\" in sample ? { avc: sample.avc } : {}\n  };\n};\n\n// src/register-track.ts\nvar registerVideoTrack = async ({\n  track,\n  container,\n  logLevel,\n  onVideoTrack,\n  registerVideoSampleCallback,\n  tracks: tracks2\n}) => {\n  if (tracks2.getTracks().find((t) => t.trackId === track.trackId)) {\n    Log.trace(logLevel, `Track ${track.trackId} already registered, skipping`);\n    return null;\n  }\n  if (track.type !== \"video\") {\n    throw new Error(\"Expected video track\");\n  }\n  tracks2.addTrack(track);\n  if (!onVideoTrack) {\n    return null;\n  }\n  const callback = await onVideoTrack({\n    track,\n    container\n  });\n  await registerVideoSampleCallback(track.trackId, callback ?? null);\n  return callback;\n};\nvar registerAudioTrack = async ({\n  track,\n  container,\n  tracks: tracks2,\n  logLevel,\n  onAudioTrack,\n  registerAudioSampleCallback\n}) => {\n  if (tracks2.getTracks().find((t) => t.trackId === track.trackId)) {\n    Log.trace(logLevel, `Track ${track.trackId} already registered, skipping`);\n    return null;\n  }\n  if (track.type !== \"audio\") {\n    throw new Error(\"Expected audio track\");\n  }\n  tracks2.addTrack(track);\n  if (!onAudioTrack) {\n    return null;\n  }\n  const callback = await onAudioTrack({\n    track,\n    container\n  });\n  await registerAudioSampleCallback(track.trackId, callback ?? null);\n  return callback;\n};\nvar registerVideoTrackWhenProfileIsAvailable = ({\n  state,\n  track,\n  container\n}) => {\n  state.riff.registerOnAvcProfileCallback(async (profile) => {\n    await registerVideoTrack({\n      track: addAvcProfileToTrack(track, profile),\n      container,\n      logLevel: state.logLevel,\n      onVideoTrack: state.onVideoTrack,\n      registerVideoSampleCallback: state.callbacks.registerVideoSampleCallback,\n      tracks: state.callbacks.tracks\n    });\n  });\n};\n\n// src/containers/avc/interpret-sps.ts\nvar getDimensionsFromSps = (sps) => {\n  const height = sps.pic_height_in_map_units_minus1;\n  const width = sps.pic_width_in_mbs_minus1;\n  return {\n    height: (height + 1) * 16 - (sps.frame_crop_bottom_offset ?? 0) * 2 - (sps.frame_crop_top_offset ?? 0) * 2,\n    width: (width + 1) * 16 - (sps.frame_crop_right_offset ?? 0) * 2 - (sps.frame_crop_left_offset ?? 0) * 2\n  };\n};\nvar getSampleAspectRatioFromSps = (sps) => {\n  if (sps.vui_parameters?.sar_height && sps.vui_parameters.sar_width) {\n    return {\n      width: sps.vui_parameters.sar_width,\n      height: sps.vui_parameters.sar_height\n    };\n  }\n  return {\n    width: 1,\n    height: 1\n  };\n};\nvar getVideoColorFromSps = (sps) => {\n  const matrixCoefficients2 = sps.vui_parameters?.matrix_coefficients;\n  const transferCharacteristics2 = sps.vui_parameters?.transfer_characteristics;\n  const colorPrimaries = sps.vui_parameters?.colour_primaries;\n  return {\n    matrix: matrixCoefficients2 ? getMatrixCoefficientsFromIndex(matrixCoefficients2) : null,\n    transfer: transferCharacteristics2 ? getTransferCharacteristicsFromIndex(transferCharacteristics2) : null,\n    primaries: colorPrimaries ? getPrimariesFromIndex(colorPrimaries) : null,\n    fullRange: sps.vui_parameters?.video_full_range_flag ?? null\n  };\n};\n\n// src/containers/avc/key.ts\nvar getKeyFrameOrDeltaFromAvcInfo = (infos) => {\n  const keyOrDelta = infos.find((i) => i.type === \"keyframe\" || i.type === \"delta-frame\");\n  if (!keyOrDelta) {\n    throw new Error(\"expected avc to contain info about key or delta\");\n  }\n  return keyOrDelta.type === \"keyframe\" ? \"key\" : keyOrDelta.isBidirectionalFrame ? \"bidirectional\" : \"delta\";\n};\n\n// src/containers/avc/parse-avc.ts\nvar Extended_SAR = 255;\nvar getPoc = (iterator, sps, avcState, isReferencePicture) => {\n  const { pic_order_cnt_type, log2_max_pic_order_cnt_lsb_minus4 } = sps;\n  if (pic_order_cnt_type !== 0) {\n    return null;\n  }\n  const prevPicOrderCntLsb = avcState.getPrevPicOrderCntLsb();\n  const prevPicOrderCntMsb = avcState.getPrevPicOrderCntMsb();\n  if (log2_max_pic_order_cnt_lsb_minus4 === null) {\n    throw new Error(\"log2_max_pic_order_cnt_lsb_minus4 is null\");\n  }\n  const max_pic_order_cnt_lsb = 2 ** (log2_max_pic_order_cnt_lsb_minus4 + 4);\n  const pic_order_cnt_lsb = iterator.getBits(log2_max_pic_order_cnt_lsb_minus4 + 4);\n  let picOrderCntMsb;\n  if (pic_order_cnt_lsb < prevPicOrderCntLsb && prevPicOrderCntLsb - pic_order_cnt_lsb >= max_pic_order_cnt_lsb / 2) {\n    picOrderCntMsb = prevPicOrderCntMsb + max_pic_order_cnt_lsb;\n  } else if (pic_order_cnt_lsb > prevPicOrderCntLsb && pic_order_cnt_lsb - prevPicOrderCntLsb > max_pic_order_cnt_lsb / 2) {\n    picOrderCntMsb = prevPicOrderCntMsb - max_pic_order_cnt_lsb;\n  } else {\n    picOrderCntMsb = prevPicOrderCntMsb;\n  }\n  const poc = picOrderCntMsb + pic_order_cnt_lsb;\n  if (isReferencePicture) {\n    avcState.setPrevPicOrderCntLsb(pic_order_cnt_lsb);\n    avcState.setPrevPicOrderCntMsb(picOrderCntMsb);\n  }\n  return poc;\n};\nvar readVuiParameters = (iterator) => {\n  let sar_width = null;\n  let sar_height = null;\n  let overscan_appropriate_flag = null;\n  let video_format = null;\n  let video_full_range_flag = null;\n  let colour_primaries = null;\n  let transfer_characteristics = null;\n  let matrix_coefficients = null;\n  let chroma_sample_loc_type_top_field = null;\n  let chroma_sample_loc_type_bottom_field = null;\n  const aspect_ratio_info_present_flag = iterator.getBits(1);\n  if (aspect_ratio_info_present_flag) {\n    const aspect_ratio_idc = iterator.getBits(8);\n    if (aspect_ratio_idc === Extended_SAR) {\n      sar_width = iterator.getBits(16);\n      sar_height = iterator.getBits(16);\n    }\n  }\n  const overscan_info_present_flag = iterator.getBits(1);\n  if (overscan_info_present_flag) {\n    overscan_appropriate_flag = iterator.getBits(1);\n  }\n  const video_signal_type_present_flag = iterator.getBits(1);\n  if (video_signal_type_present_flag) {\n    video_format = iterator.getBits(3);\n    video_full_range_flag = Boolean(iterator.getBits(1));\n    const colour_description_present_flag = iterator.getBits(1);\n    if (colour_description_present_flag) {\n      colour_primaries = iterator.getBits(8);\n      transfer_characteristics = iterator.getBits(8);\n      matrix_coefficients = iterator.getBits(8);\n    }\n  }\n  const chroma_loc_info_present_flag = iterator.getBits(1);\n  if (chroma_loc_info_present_flag) {\n    chroma_sample_loc_type_top_field = iterator.readExpGolomb();\n    chroma_sample_loc_type_bottom_field = iterator.readExpGolomb();\n  }\n  return {\n    sar_width,\n    sar_height,\n    overscan_appropriate_flag,\n    chroma_sample_loc_type_bottom_field,\n    chroma_sample_loc_type_top_field,\n    colour_primaries,\n    matrix_coefficients,\n    transfer_characteristics,\n    video_format,\n    video_full_range_flag\n  };\n};\nvar readSps = (iterator) => {\n  const profile = iterator.getUint8();\n  const compatibility = iterator.getUint8();\n  const level = iterator.getUint8();\n  iterator.startReadingBits();\n  const seq_parameter_set_id = iterator.readExpGolomb();\n  let separate_colour_plane_flag = null;\n  let bit_depth_luma_minus8 = null;\n  let bit_depth_chroma_minus8 = null;\n  let qpprime_y_zero_transform_bypass_flag = null;\n  let log2_max_frame_num_minus4 = null;\n  let log2_max_pic_order_cnt_lsb_minus4 = null;\n  let max_num_ref_frames = null;\n  let gaps_in_frame_num_value_allowed_flag = null;\n  let mb_adaptive_frame_field_flag = null;\n  let direct_8x8_inference_flag = null;\n  let frame_crop_left_offset = null;\n  let frame_crop_right_offset = null;\n  let frame_crop_top_offset = null;\n  let frame_crop_bottom_offset = null;\n  let vui_parameters = null;\n  if (profile === 100 || profile === 110 || profile === 122 || profile === 244 || profile === 44 || profile === 83 || profile === 86 || profile === 118 || profile === 128 || profile === 138 || profile === 139 || profile === 134 || profile === 135) {\n    const chromaFormat = iterator.readExpGolomb();\n    if (chromaFormat === 3) {\n      separate_colour_plane_flag = iterator.getBits(1);\n    }\n    bit_depth_luma_minus8 = iterator.readExpGolomb();\n    bit_depth_chroma_minus8 = iterator.readExpGolomb();\n    qpprime_y_zero_transform_bypass_flag = iterator.getBits(1);\n    const seq_scaling_matrix_present_flag = iterator.getBits(1);\n    const seq_scaling_list_present_flag = [];\n    if (seq_scaling_matrix_present_flag) {\n      for (let i = 0;i < (chromaFormat !== 3 ? 8 : 12); i++) {\n        seq_scaling_list_present_flag[i] = iterator.getBits(1);\n        if (seq_scaling_list_present_flag[i]) {\n          if (i < 6) {\n            throw new Error(\"Not implemented\");\n          } else {\n            throw new Error(\"Not implemented\");\n          }\n        }\n      }\n    }\n  }\n  log2_max_frame_num_minus4 = iterator.readExpGolomb();\n  const pic_order_cnt_type = iterator.readExpGolomb();\n  if (pic_order_cnt_type === 0) {\n    log2_max_pic_order_cnt_lsb_minus4 = iterator.readExpGolomb();\n  } else if (pic_order_cnt_type === 1) {\n    throw new Error(\"pic_order_cnt_type = 1 not implemented\");\n  }\n  max_num_ref_frames = iterator.readExpGolomb();\n  gaps_in_frame_num_value_allowed_flag = iterator.getBits(1);\n  const pic_width_in_mbs_minus1 = iterator.readExpGolomb();\n  const pic_height_in_map_units_minus1 = iterator.readExpGolomb();\n  const frame_mbs_only_flag = iterator.getBits(1);\n  if (!frame_mbs_only_flag) {\n    mb_adaptive_frame_field_flag = iterator.getBits(1);\n  }\n  direct_8x8_inference_flag = iterator.getBits(1);\n  const frame_cropping_flag = iterator.getBits(1);\n  if (frame_cropping_flag) {\n    frame_crop_left_offset = iterator.readExpGolomb();\n    frame_crop_right_offset = iterator.readExpGolomb();\n    frame_crop_top_offset = iterator.readExpGolomb();\n    frame_crop_bottom_offset = iterator.readExpGolomb();\n  }\n  const vui_parameters_present_flag = iterator.getBits(1);\n  if (vui_parameters_present_flag) {\n    vui_parameters = readVuiParameters(iterator);\n  }\n  iterator.stopReadingBits();\n  return {\n    profile,\n    compatibility,\n    level,\n    bit_depth_chroma_minus8,\n    bit_depth_luma_minus8,\n    gaps_in_frame_num_value_allowed_flag,\n    log2_max_frame_num_minus4,\n    log2_max_pic_order_cnt_lsb_minus4,\n    max_num_ref_frames,\n    pic_height_in_map_units_minus1,\n    pic_width_in_mbs_minus1,\n    qpprime_y_zero_transform_bypass_flag,\n    separate_colour_plane_flag,\n    seq_parameter_set_id,\n    direct_8x8_inference_flag,\n    frame_crop_bottom_offset,\n    frame_crop_left_offset,\n    frame_crop_right_offset,\n    frame_crop_top_offset,\n    mb_adaptive_frame_field_flag,\n    vui_parameters,\n    pic_order_cnt_type\n  };\n};\nvar findEnd = (buffer) => {\n  let zeroesInARow = 0;\n  for (let i = 0;i < buffer.length; i++) {\n    const val = buffer[i];\n    if (val === 0) {\n      zeroesInARow++;\n      continue;\n    }\n    if (zeroesInARow >= 2 && val === 1) {\n      return i - zeroesInARow;\n    }\n    zeroesInARow = 0;\n  }\n  return null;\n};\nvar inspect = (buffer, avcState) => {\n  const iterator = getArrayBufferIterator({\n    initialData: buffer,\n    maxBytes: buffer.byteLength,\n    logLevel: \"error\"\n  });\n  iterator.startReadingBits();\n  iterator.getBits(1);\n  const nal_ref_idc = iterator.getBits(2);\n  const isReferencePicture = nal_ref_idc !== 0;\n  const type = iterator.getBits(5);\n  if (type === 7) {\n    iterator.stopReadingBits();\n    const end = findEnd(buffer);\n    const data = readSps(iterator);\n    const sps = buffer.slice(0, end === null ? Infinity : end);\n    avcState.setSps(data);\n    if (isReferencePicture) {\n      avcState.setPrevPicOrderCntLsb(0);\n      avcState.setPrevPicOrderCntMsb(0);\n    }\n    return {\n      spsData: data,\n      sps,\n      type: \"avc-profile\"\n    };\n  }\n  if (type === 5) {\n    avcState.setPrevPicOrderCntLsb(0);\n    avcState.setPrevPicOrderCntMsb(0);\n    iterator.readExpGolomb();\n    iterator.readExpGolomb();\n    iterator.readExpGolomb();\n    const sps = avcState.getSps();\n    if (!sps) {\n      throw new Error(\"SPS not found\");\n    }\n    const numberOfBitsForFrameNum = sps.log2_max_frame_num_minus4 + 4;\n    iterator.getBits(numberOfBitsForFrameNum);\n    iterator.readExpGolomb();\n    const { pic_order_cnt_type } = sps;\n    let poc = null;\n    if (pic_order_cnt_type === 0) {\n      poc = getPoc(iterator, sps, avcState, isReferencePicture);\n    }\n    iterator.stopReadingBits();\n    return {\n      type: \"keyframe\",\n      poc\n    };\n  }\n  if (type === 8) {\n    iterator.stopReadingBits();\n    const end = findEnd(buffer);\n    const pps = buffer.slice(0, end === null ? Infinity : end);\n    return {\n      type: \"avc-pps\",\n      pps\n    };\n  }\n  if (type === 1) {\n    iterator.readExpGolomb();\n    const slice_type = iterator.readExpGolomb();\n    const isBidirectionalFrame = slice_type === 6;\n    iterator.readExpGolomb();\n    const sps = avcState.getSps();\n    if (!sps) {\n      throw new Error(\"SPS not found\");\n    }\n    const numberOfBitsForFrameNum = sps.log2_max_frame_num_minus4 + 4;\n    iterator.getBits(numberOfBitsForFrameNum);\n    const { pic_order_cnt_type } = sps;\n    let poc = null;\n    if (pic_order_cnt_type === 0) {\n      poc = getPoc(iterator, sps, avcState, isReferencePicture);\n    }\n    iterator.stopReadingBits();\n    return {\n      type: \"delta-frame\",\n      isBidirectionalFrame,\n      poc\n    };\n  }\n  iterator.destroy();\n  return null;\n};\nvar parseAvc = (buffer, avcState) => {\n  let zeroesInARow = 0;\n  const infos = [];\n  for (let i = 0;i < buffer.length; i++) {\n    const val = buffer[i];\n    if (val === 0) {\n      zeroesInARow++;\n      continue;\n    }\n    if (zeroesInARow >= 2 && val === 1) {\n      zeroesInARow = 0;\n      const info = inspect(buffer.slice(i + 1, i + 100), avcState);\n      if (info) {\n        infos.push(info);\n        if (info.type === \"keyframe\" || info.type === \"delta-frame\") {\n          break;\n        }\n      }\n    }\n    if (val !== 1) {\n      zeroesInARow = 0;\n    }\n  }\n  return infos;\n};\n\n// src/containers/avc/sps-and-pps.ts\nvar getSpsAndPps = (infos) => {\n  const avcProfile = infos.find((i) => i.type === \"avc-profile\");\n  const ppsProfile = infos.find((i) => i.type === \"avc-pps\");\n  if (!avcProfile || !ppsProfile) {\n    throw new Error(\"Expected avcProfile and ppsProfile\");\n  }\n  return { pps: ppsProfile, sps: avcProfile };\n};\n\n// src/containers/transport-stream/handle-avc-packet.ts\nvar MPEG_TIMESCALE = 90000;\nvar handleAvcPacket = async ({\n  streamBuffer,\n  programId,\n  offset,\n  sampleCallbacks,\n  logLevel,\n  onVideoTrack,\n  transportStream,\n  makeSamplesStartAtZero,\n  avcState\n}) => {\n  const avc = parseAvc(streamBuffer.getBuffer(), avcState);\n  const isTrackRegistered = sampleCallbacks.tracks.getTracks().find((t) => {\n    return t.trackId === programId;\n  });\n  if (!isTrackRegistered) {\n    const spsAndPps = getSpsAndPps(avc);\n    const dimensions = getDimensionsFromSps(spsAndPps.sps.spsData);\n    const sampleAspectRatio = getSampleAspectRatioFromSps(spsAndPps.sps.spsData);\n    const startOffset = makeSamplesStartAtZero ? Math.min(streamBuffer.pesHeader.pts, streamBuffer.pesHeader.dts ?? Infinity) : 0;\n    transportStream.startOffset.setOffset({\n      trackId: programId,\n      newOffset: startOffset\n    });\n    const codecPrivate2 = createSpsPpsData(spsAndPps);\n    const advancedColor = getVideoColorFromSps(spsAndPps.sps.spsData);\n    const track = {\n      m3uStreamFormat: null,\n      rotation: 0,\n      trackId: programId,\n      type: \"video\",\n      originalTimescale: MPEG_TIMESCALE,\n      codec: getCodecStringFromSpsAndPps(spsAndPps.sps),\n      codecData: { type: \"avc-sps-pps\", data: codecPrivate2 },\n      fps: null,\n      codedWidth: dimensions.width,\n      codedHeight: dimensions.height,\n      height: dimensions.height,\n      width: dimensions.width,\n      displayAspectWidth: dimensions.width,\n      displayAspectHeight: dimensions.height,\n      codecEnum: \"h264\",\n      description: undefined,\n      sampleAspectRatio: {\n        denominator: sampleAspectRatio.height,\n        numerator: sampleAspectRatio.width\n      },\n      colorSpace: mediaParserAdvancedColorToWebCodecsColor(advancedColor),\n      advancedColor,\n      startInSeconds: 0,\n      timescale: WEBCODECS_TIMESCALE,\n      trackMediaTimeOffsetInTrackTimescale: 0\n    };\n    await registerVideoTrack({\n      track,\n      container: \"transport-stream\",\n      logLevel,\n      onVideoTrack,\n      registerVideoSampleCallback: sampleCallbacks.registerVideoSampleCallback,\n      tracks: sampleCallbacks.tracks\n    });\n  }\n  const type = getKeyFrameOrDeltaFromAvcInfo(avc);\n  const sample = {\n    decodingTimestamp: (streamBuffer.pesHeader.dts ?? streamBuffer.pesHeader.pts) - transportStream.startOffset.getOffset(programId),\n    timestamp: streamBuffer.pesHeader.pts - transportStream.startOffset.getOffset(programId),\n    duration: undefined,\n    data: streamBuffer.getBuffer(),\n    type: type === \"bidirectional\" ? \"delta\" : type,\n    offset\n  };\n  if (type === \"key\") {\n    transportStream.observedPesHeaders.markPtsAsKeyframe(streamBuffer.pesHeader.pts);\n  }\n  const videoSample = convertAudioOrVideoSampleToWebCodecsTimestamps({\n    sample,\n    timescale: MPEG_TIMESCALE\n  });\n  await sampleCallbacks.onVideoSample({\n    videoSample,\n    trackId: programId\n  });\n  transportStream.lastEmittedSample.setLastEmittedSample(sample);\n};\n\n// src/containers/wav/get-seeking-byte.ts\nvar WAVE_SAMPLES_PER_SECOND = 25;\nvar getSeekingByteFromWav = ({\n  info,\n  time\n}) => {\n  const bytesPerSecond = info.sampleRate * info.blockAlign;\n  const durationInSeconds = info.mediaSection.size / bytesPerSecond;\n  const timeRoundedDown = Math.floor(Math.min(time, durationInSeconds - 0.0000001) * WAVE_SAMPLES_PER_SECOND) / WAVE_SAMPLES_PER_SECOND;\n  const byteOffset = bytesPerSecond * timeRoundedDown;\n  return Promise.resolve({\n    type: \"do-seek\",\n    byte: byteOffset + info.mediaSection.start,\n    timeInSeconds: timeRoundedDown\n  });\n};\n\n// src/containers/webm/seek/get-seeking-byte.ts\nvar toSeconds = (timeInTimescale, track) => {\n  return timeInTimescale / track.timescale * 1000;\n};\nvar findBiggestCueBeforeTime = ({\n  cues,\n  time,\n  track\n}) => {\n  let biggestCueBeforeTime;\n  for (const cue of cues) {\n    const cueTimeInSeconds = toSeconds(cue.timeInTimescale, track);\n    if (cueTimeInSeconds < time && (!biggestCueBeforeTime || cueTimeInSeconds > toSeconds(biggestCueBeforeTime.timeInTimescale, track))) {\n      biggestCueBeforeTime = cue;\n    }\n  }\n  return biggestCueBeforeTime;\n};\nvar findKeyframeBeforeTime2 = ({\n  keyframes,\n  time\n}) => {\n  let keyframeBeforeTime;\n  for (const keyframe of keyframes) {\n    if (keyframe.decodingTimeInSeconds < time && (!keyframeBeforeTime || keyframe.decodingTimeInSeconds > keyframeBeforeTime.decodingTimeInSeconds)) {\n      keyframeBeforeTime = keyframe;\n    }\n  }\n  return keyframeBeforeTime ?? null;\n};\nvar getByteFromCues = ({\n  cuesResponse,\n  time,\n  info,\n  logLevel\n}) => {\n  if (!cuesResponse) {\n    Log.trace(logLevel, \"Has no Matroska cues at the moment, cannot use them\");\n    return null;\n  }\n  const { cues, segmentOffset } = cuesResponse;\n  Log.trace(logLevel, \"Has Matroska cues. Will use them to perform a seek.\");\n  const biggestCueBeforeTime = findBiggestCueBeforeTime({\n    cues,\n    time,\n    track: info.track\n  });\n  if (!biggestCueBeforeTime) {\n    return null;\n  }\n  return {\n    byte: biggestCueBeforeTime.clusterPositionInSegment + segmentOffset,\n    timeInSeconds: toSeconds(biggestCueBeforeTime.timeInTimescale, info.track)\n  };\n};\nvar getSeekingByteFromMatroska = async ({\n  time,\n  webmState,\n  info,\n  logLevel,\n  mediaSection\n}) => {\n  if (!info.track) {\n    Log.trace(logLevel, \"No video track found, cannot seek yet\");\n    return {\n      type: \"valid-but-must-wait\"\n    };\n  }\n  const cuesResponse = info.loadedCues ?? await webmState.cues.getLoadedCues();\n  const byteFromObservedKeyframe = findKeyframeBeforeTime2({\n    keyframes: info.keyframes,\n    time\n  });\n  const byteFromCues = getByteFromCues({\n    cuesResponse,\n    time,\n    info,\n    logLevel\n  });\n  const byteFromFirstMediaSection = webmState.getFirstCluster()?.start ?? null;\n  const seekPossibilities = [\n    byteFromCues?.byte ?? null,\n    byteFromObservedKeyframe?.positionInBytes ?? null,\n    byteFromFirstMediaSection\n  ].filter((n) => n !== null);\n  const byteToSeekTo = seekPossibilities.length === 0 ? null : Math.max(...seekPossibilities);\n  if (byteToSeekTo === null) {\n    return {\n      type: \"invalid\"\n    };\n  }\n  mediaSection.addMediaSection({\n    start: byteToSeekTo,\n    size: 1\n  });\n  const timeInSeconds = (() => {\n    if (byteToSeekTo === byteFromObservedKeyframe?.positionInBytes) {\n      return Math.min(byteFromObservedKeyframe.decodingTimeInSeconds, byteFromObservedKeyframe.presentationTimeInSeconds);\n    }\n    if (byteToSeekTo === byteFromCues?.byte) {\n      return byteFromCues.timeInSeconds;\n    }\n    if (byteToSeekTo === byteFromFirstMediaSection) {\n      return 0;\n    }\n    throw new Error(\"Should not happen\");\n  })();\n  return {\n    type: \"do-seek\",\n    byte: byteToSeekTo,\n    timeInSeconds\n  };\n};\n\n// src/state/transport-stream/observed-pes-header.ts\nvar makeObservedPesHeader = () => {\n  const pesHeaders = [];\n  const confirmedAsKeyframe = [];\n  const addPesHeader = (pesHeader) => {\n    if (pesHeaders.find((p) => p.offset === pesHeader.offset)) {\n      return;\n    }\n    pesHeaders.push(pesHeader);\n  };\n  const markPtsAsKeyframe = (pts) => {\n    confirmedAsKeyframe.push(pts);\n  };\n  const getPesKeyframeHeaders = () => {\n    return pesHeaders.filter((p) => confirmedAsKeyframe.includes(p.pts));\n  };\n  const setPesKeyframesFromSeekingHints = (hints) => {\n    for (const pesHeader of hints.observedPesHeaders) {\n      addPesHeader(pesHeader);\n      markPtsAsKeyframe(pesHeader.pts);\n    }\n  };\n  const state = {\n    pesHeaders,\n    addPesHeader,\n    markPtsAsKeyframe,\n    getPesKeyframeHeaders,\n    setPesKeyframesFromSeekingHints\n  };\n  return state;\n};\nvar getLastKeyFrameBeforeTimeInSeconds = ({\n  observedPesHeaders,\n  timeInSeconds,\n  ptsStartOffset\n}) => {\n  return observedPesHeaders.findLast((k) => (k.pts - ptsStartOffset) / MPEG_TIMESCALE <= timeInSeconds);\n};\n\n// src/get-seeking-byte.ts\nvar getSeekingByte = ({\n  info,\n  time,\n  logLevel,\n  currentPosition,\n  isoState,\n  transportStream,\n  webmState,\n  mediaSection,\n  m3uPlaylistContext,\n  structure,\n  riffState,\n  m3uState,\n  avcState\n}) => {\n  if (info.type === \"iso-base-media-seeking-hints\") {\n    return getSeekingByteFromIsoBaseMedia({\n      info,\n      time,\n      logLevel,\n      currentPosition,\n      isoState,\n      structure,\n      m3uPlaylistContext\n    });\n  }\n  if (info.type === \"wav-seeking-hints\") {\n    return getSeekingByteFromWav({\n      info,\n      time\n    });\n  }\n  if (info.type === \"webm-seeking-hints\") {\n    return getSeekingByteFromMatroska({\n      info,\n      time,\n      webmState,\n      logLevel,\n      mediaSection\n    });\n  }\n  if (info.type === \"flac-seeking-hints\") {\n    const byte = getSeekingByteForFlac({\n      seekingHints: info,\n      time\n    });\n    if (byte) {\n      return Promise.resolve({\n        type: \"do-seek\",\n        byte: byte.offset,\n        timeInSeconds: byte.timeInSeconds\n      });\n    }\n    return Promise.resolve({\n      type: \"valid-but-must-wait\"\n    });\n  }\n  if (info.type === \"transport-stream-seeking-hints\") {\n    const lastKeyframeBeforeTimeInSeconds = getLastKeyFrameBeforeTimeInSeconds({\n      observedPesHeaders: info.observedPesHeaders,\n      timeInSeconds: time,\n      ptsStartOffset: info.ptsStartOffset\n    });\n    if (!lastKeyframeBeforeTimeInSeconds) {\n      transportStream.resetBeforeSeek();\n      return Promise.resolve({\n        type: \"do-seek\",\n        byte: 0,\n        timeInSeconds: 0\n      });\n    }\n    const byte = lastKeyframeBeforeTimeInSeconds.offset;\n    transportStream.resetBeforeSeek();\n    return Promise.resolve({\n      type: \"do-seek\",\n      byte,\n      timeInSeconds: Math.min(lastKeyframeBeforeTimeInSeconds.pts, lastKeyframeBeforeTimeInSeconds.dts ?? Infinity) / MPEG_TIMESCALE\n    });\n  }\n  if (info.type === \"riff-seeking-hints\") {\n    return getSeekingByteForRiff({\n      info,\n      time,\n      riffState,\n      avcState\n    });\n  }\n  if (info.type === \"mp3-seeking-hints\") {\n    return Promise.resolve(getSeekingByteForMp3({\n      info,\n      time\n    }));\n  }\n  if (info.type === \"aac-seeking-hints\") {\n    return Promise.resolve(getSeekingByteForAac({\n      time,\n      seekingHints: info\n    }));\n  }\n  if (info.type === \"m3u8-seeking-hints\") {\n    return Promise.resolve(getSeekingByteForM3u8({\n      time,\n      currentPosition,\n      m3uState,\n      logLevel\n    }));\n  }\n  throw new Error(`Unknown seeking info type: ${info}`);\n};\n\n// src/containers/aac/seeking-hints.ts\nvar getSeekingHintsForAac = ({\n  aacState,\n  samplesObserved\n}) => {\n  return {\n    type: \"aac-seeking-hints\",\n    audioSampleMap: aacState.audioSamples.getSamples(),\n    lastSampleObserved: samplesObserved.getLastSampleObserved()\n  };\n};\nvar setSeekingHintsForAac = () => {};\n\n// src/containers/flac/seeking-hints.ts\nvar getSeekingHintsForFlac = ({\n  flacState,\n  samplesObserved\n}) => {\n  return {\n    type: \"flac-seeking-hints\",\n    audioSampleMap: flacState.audioSamples.getSamples(),\n    blockingBitStrategy: flacState.getBlockingBitStrategy() ?? null,\n    lastSampleObserved: samplesObserved.getLastSampleObserved()\n  };\n};\nvar setSeekingHintsForFlac = ({\n  hints,\n  state\n}) => {\n  if (hints.blockingBitStrategy !== null) {\n    state.flac.setBlockingBitStrategy(hints.blockingBitStrategy);\n  }\n  state.flac.audioSamples.setFromSeekingHints(hints.audioSampleMap);\n};\n\n// src/containers/iso-base-media/seeking-hints.ts\nvar getSeekingHintsFromMp4 = ({\n  structureState,\n  isoState,\n  mp4HeaderSegment,\n  mediaSectionState: mediaSectionState2\n}) => {\n  const structure = structureState.getIsoStructure();\n  const moovAtom = getMoovBoxFromState({\n    isoState,\n    mp4HeaderSegment,\n    structureState,\n    mayUsePrecomputed: true\n  });\n  const moofBoxes = deduplicateMoofBoxesByOffset([\n    ...isoState.moof.getMoofBoxes(),\n    ...getMoofBoxes(structure.boxes)\n  ]);\n  const tfraBoxes = deduplicateTfraBoxesByOffset([\n    ...isoState.tfra.getTfraBoxes(),\n    ...getTfraBoxes(structure.boxes)\n  ]);\n  if (!moovAtom) {\n    return null;\n  }\n  return {\n    type: \"iso-base-media-seeking-hints\",\n    moovBox: moovAtom,\n    moofBoxes,\n    tfraBoxes,\n    mediaSections: mediaSectionState2.getMediaSections(),\n    mfraAlreadyLoaded: isoState.mfra.getIfAlreadyLoaded()\n  };\n};\nvar setSeekingHintsForMp4 = ({}) => {};\n\n// src/containers/m3u/seeking-hints.ts\nvar getSeekingHintsForM3u = () => {\n  return {\n    type: \"m3u8-seeking-hints\"\n  };\n};\n\n// src/containers/mp3/seeking-hints.ts\nvar getSeekingHintsForMp3 = ({\n  mp3State,\n  samplesObserved,\n  mediaSectionState: mediaSectionState2,\n  contentLength\n}) => {\n  return {\n    type: \"mp3-seeking-hints\",\n    audioSampleMap: mp3State.audioSamples.getSamples(),\n    lastSampleObserved: samplesObserved.getLastSampleObserved(),\n    mp3BitrateInfo: mp3State.getMp3BitrateInfo(),\n    mp3Info: mp3State.getMp3Info(),\n    mediaSection: mediaSectionState2.getMediaSections()[0] ?? null,\n    contentLength\n  };\n};\nvar setSeekingHintsForMp3 = ({\n  hints,\n  state\n}) => {\n  state.mp3.audioSamples.setFromSeekingHints(hints.audioSampleMap);\n};\n\n// src/containers/riff/has-index.ts\nvar riffHasIndex = (structure) => {\n  return structure.boxes.find((b) => b.type === \"list-box\" && b.listType === \"hdrl\")?.children.find((box) => box.type === \"avih-box\")?.hasIndex ?? false;\n};\n\n// src/containers/riff/seeking-hints.ts\nvar getSeekingHintsForRiff = ({\n  structureState,\n  riffState,\n  mediaSectionState: mediaSectionState2\n}) => {\n  const structure = structureState.getRiffStructure();\n  const strl = getStrlBoxes(structure);\n  let samplesPerSecond = null;\n  for (const s of strl) {\n    const strh = getStrhBox(s.children);\n    if (!strh) {\n      throw new Error(\"No strh box\");\n    }\n    if (strh.strf.type !== \"strf-box-video\") {\n      continue;\n    }\n    samplesPerSecond = strh.rate / strh.scale;\n    break;\n  }\n  return {\n    type: \"riff-seeking-hints\",\n    hasIndex: riffHasIndex(structure),\n    idx1Entries: riffState.lazyIdx1.getIfAlreadyLoaded(),\n    samplesPerSecond,\n    moviOffset: mediaSectionState2.getMediaSections()[0]?.start ?? null,\n    observedKeyframes: riffState.sampleCounter.riffKeys.getKeyframes()\n  };\n};\nvar setSeekingHintsForRiff = ({\n  hints,\n  state\n}) => {\n  state.riff.lazyIdx1.setFromSeekingHints(hints);\n  state.riff.sampleCounter.riffKeys.setFromSeekingHints(hints.observedKeyframes);\n};\n\n// src/containers/transport-stream/seeking-hints.ts\nvar getSeekingHintsFromTransportStream = (transportStream, tracksState) => {\n  const firstVideoTrack = tracksState.getTracks().find((t) => t.type === \"video\");\n  if (!firstVideoTrack) {\n    return null;\n  }\n  return {\n    type: \"transport-stream-seeking-hints\",\n    observedPesHeaders: transportStream.observedPesHeaders.getPesKeyframeHeaders(),\n    ptsStartOffset: transportStream.startOffset.getOffset(firstVideoTrack.trackId),\n    firstVideoTrackId: firstVideoTrack.trackId\n  };\n};\nvar setSeekingHintsForTransportStream = ({\n  hints,\n  state\n}) => {\n  state.transportStream.observedPesHeaders.setPesKeyframesFromSeekingHints(hints);\n  state.transportStream.startOffset.setOffset({\n    trackId: hints.firstVideoTrackId,\n    newOffset: hints.ptsStartOffset\n  });\n};\n\n// src/containers/wav/seeking-hints.ts\nvar getSeekingHintsFromWav = ({\n  structure,\n  mediaSectionState: mediaSectionState2\n}) => {\n  const fmtBox = structure.boxes.find((box) => box.type === \"wav-fmt\");\n  if (!fmtBox) {\n    return null;\n  }\n  const mediaSection = mediaSectionState2.getMediaSections();\n  if (mediaSection.length !== 1) {\n    return null;\n  }\n  return {\n    type: \"wav-seeking-hints\",\n    sampleRate: fmtBox.sampleRate,\n    blockAlign: fmtBox.blockAlign,\n    mediaSection: mediaSection[0]\n  };\n};\nvar setSeekingHintsForWav = ({\n  hints,\n  state\n}) => {\n  state.mediaSection.addMediaSection(hints.mediaSection);\n};\n\n// src/containers/webm/seek/seeking-hints.ts\nvar getSeekingHintsFromMatroska = (tracksState, keyframesState, webmState) => {\n  const tracks2 = tracksState.getTracks();\n  const firstVideoTrack = tracks2.find((track) => track.type === \"video\");\n  const keyframes = keyframesState.getKeyframes();\n  const loadedCues = webmState.cues.getIfAlreadyLoaded();\n  return {\n    type: \"webm-seeking-hints\",\n    track: firstVideoTrack ? {\n      timescale: firstVideoTrack.originalTimescale,\n      trackId: firstVideoTrack.trackId\n    } : null,\n    keyframes,\n    loadedCues,\n    timestampMap: webmState.getTimeStampMapForSeekingHints()\n  };\n};\nvar setSeekingHintsForWebm = ({\n  hints,\n  state\n}) => {\n  state.webm.cues.setFromSeekingHints(hints);\n  state.keyframes.setFromSeekingHints(hints.keyframes);\n  state.webm.setTimeStampMapForSeekingHints(hints.timestampMap);\n};\n\n// src/get-seeking-hints.ts\nvar getSeekingHints = ({\n  structureState,\n  m3uPlaylistContext,\n  mediaSectionState: mediaSectionState2,\n  isoState,\n  transportStream,\n  tracksState,\n  keyframesState,\n  webmState,\n  flacState,\n  samplesObserved,\n  riffState,\n  mp3State,\n  contentLength,\n  aacState\n}) => {\n  const structure = structureState.getStructureOrNull();\n  if (!structure) {\n    return null;\n  }\n  if (structure.type === \"iso-base-media\") {\n    return getSeekingHintsFromMp4({\n      structureState,\n      isoState,\n      mp4HeaderSegment: m3uPlaylistContext?.mp4HeaderSegment ?? null,\n      mediaSectionState: mediaSectionState2\n    });\n  }\n  if (structure.type === \"wav\") {\n    return getSeekingHintsFromWav({\n      structure,\n      mediaSectionState: mediaSectionState2\n    });\n  }\n  if (structure.type === \"matroska\") {\n    return getSeekingHintsFromMatroska(tracksState, keyframesState, webmState);\n  }\n  if (structure.type === \"transport-stream\") {\n    return getSeekingHintsFromTransportStream(transportStream, tracksState);\n  }\n  if (structure.type === \"flac\") {\n    return getSeekingHintsForFlac({\n      flacState,\n      samplesObserved\n    });\n  }\n  if (structure.type === \"riff\") {\n    return getSeekingHintsForRiff({\n      structureState,\n      riffState,\n      mediaSectionState: mediaSectionState2\n    });\n  }\n  if (structure.type === \"mp3\") {\n    return getSeekingHintsForMp3({\n      mp3State,\n      samplesObserved,\n      mediaSectionState: mediaSectionState2,\n      contentLength\n    });\n  }\n  if (structure.type === \"aac\") {\n    return getSeekingHintsForAac({\n      aacState,\n      samplesObserved\n    });\n  }\n  if (structure.type === \"m3u\") {\n    return getSeekingHintsForM3u();\n  }\n  throw new Error(`Seeking is not supported for this format: ${structure}`);\n};\n\n// src/seek-backwards.ts\nvar seekBackwards = async ({\n  iterator,\n  seekTo,\n  readerInterface,\n  src,\n  controller,\n  logLevel,\n  currentReader,\n  prefetchCache\n}) => {\n  const howManyBytesWeCanGoBack = iterator.counter.getDiscardedOffset();\n  if (iterator.counter.getOffset() - howManyBytesWeCanGoBack <= seekTo) {\n    Log.verbose(logLevel, `Seeking back to ${seekTo}`);\n    iterator.skipTo(seekTo);\n    return;\n  }\n  const time = Date.now();\n  Log.verbose(logLevel, `Seeking in video from position ${iterator.counter.getOffset()} -> ${seekTo}. Re-reading because this portion is not available.`);\n  await currentReader.getCurrent().abort();\n  const { reader: newReader } = await readerInterface.read({\n    src,\n    range: seekTo,\n    controller,\n    logLevel,\n    prefetchCache\n  });\n  iterator.replaceData(new Uint8Array([]), seekTo);\n  Log.verbose(logLevel, `Re-reading took ${Date.now() - time}ms. New position: ${iterator.counter.getOffset()}`);\n  currentReader.setCurrent(newReader);\n};\n\n// src/state/need-samples-for-fields.ts\nvar fieldsNeedSamplesMap = {\n  slowDurationInSeconds: true,\n  slowFps: true,\n  slowKeyframes: true,\n  slowNumberOfFrames: true,\n  audioCodec: false,\n  container: false,\n  dimensions: false,\n  durationInSeconds: false,\n  fps: false,\n  internalStats: false,\n  isHdr: false,\n  name: false,\n  rotation: false,\n  size: false,\n  slowStructure: false,\n  tracks: false,\n  unrotatedDimensions: false,\n  videoCodec: false,\n  metadata: false,\n  location: false,\n  mimeType: false,\n  keyframes: false,\n  images: false,\n  numberOfAudioChannels: false,\n  sampleRate: false,\n  slowAudioBitrate: true,\n  slowVideoBitrate: true,\n  m3uStreams: false\n};\nvar needsToIterateOverSamples = ({\n  fields,\n  emittedFields\n}) => {\n  const keys = Object.keys(fields ?? {});\n  const selectedKeys = keys.filter((k) => fields[k]);\n  return selectedKeys.some((k) => fieldsNeedSamplesMap[k] && !emittedFields[k]);\n};\nvar fieldsNeedEverySampleMap = {\n  ...fieldsNeedSamplesMap,\n  slowDurationInSeconds: false\n};\nvar needsToIterateOverEverySample = ({\n  fields,\n  emittedFields\n}) => {\n  const keys = Object.keys(fields ?? {});\n  const selectedKeys = keys.filter((k) => fields[k]);\n  return selectedKeys.some((k) => fieldsNeedEverySampleMap[k] && !emittedFields[k]);\n};\n\n// src/disallow-forward-seek-if-samples-are-needed.ts\nvar disallowForwardSeekIfSamplesAreNeeded = ({\n  seekTo,\n  previousPosition,\n  fields\n}) => {\n  const fieldsNeedingSamples = Object.entries(fields).filter(([, value]) => value).map(([key]) => key).filter((key) => fieldsNeedSamplesMap[key]);\n  if (fieldsNeedingSamples.length > 0) {\n    throw new Error(`Forward seeking is not allowed when the following fields are requested from parseMedia(): ${fieldsNeedingSamples.join(\", \")}. Seek was from 0x${previousPosition.toString(16)} to 0x${seekTo.toString(16)}. Either don't seek forward, or don't request these fields.`);\n  }\n};\n\n// src/seek-forwards.ts\nvar seekForward = async ({\n  seekTo,\n  userInitiated,\n  iterator,\n  fields,\n  logLevel,\n  currentReader,\n  readerInterface,\n  src,\n  controller,\n  discardReadBytes,\n  prefetchCache\n}) => {\n  if (userInitiated) {\n    disallowForwardSeekIfSamplesAreNeeded({\n      fields,\n      seekTo,\n      previousPosition: iterator.counter.getOffset()\n    });\n  }\n  const alreadyHasBuffer = iterator.bytesRemaining() >= seekTo - iterator.counter.getOffset();\n  Log.verbose(logLevel, `Performing seek from ${iterator.counter.getOffset()} to ${seekTo}`);\n  if (alreadyHasBuffer) {\n    iterator.skipTo(seekTo);\n    Log.verbose(logLevel, `Already read ahead enough, skipping forward`);\n    return;\n  }\n  const time = Date.now();\n  Log.verbose(logLevel, `Skipping over video data from position ${iterator.counter.getOffset()} -> ${seekTo}. Re-reading because this portion is not available`);\n  await currentReader.getCurrent().abort();\n  const { reader: newReader } = await readerInterface.read({\n    src,\n    range: seekTo,\n    controller,\n    logLevel,\n    prefetchCache\n  });\n  iterator.skipTo(seekTo);\n  await discardReadBytes(true);\n  Log.verbose(logLevel, `Re-reading took ${Date.now() - time}ms. New position: ${iterator.counter.getOffset()}`);\n  currentReader.setCurrent(newReader);\n};\n\n// src/perform-seek.ts\nvar performSeek = async ({\n  seekTo,\n  userInitiated,\n  controller,\n  mediaSection,\n  iterator,\n  seekInfiniteLoop,\n  logLevel,\n  mode,\n  contentLength,\n  currentReader,\n  readerInterface,\n  src,\n  discardReadBytes,\n  fields,\n  prefetchCache,\n  isoState\n}) => {\n  const byteInMediaSection = isByteInMediaSection({\n    position: seekTo,\n    mediaSections: mediaSection.getMediaSections()\n  });\n  if (byteInMediaSection !== \"in-section\" && userInitiated) {\n    const sections = mediaSection.getMediaSections();\n    const sectionStrings = sections.map((section) => {\n      return `start: ${section.start}, end: ${section.size + section.start}`;\n    });\n    throw new Error(`Cannot seek to a byte that is not in the video section. Seeking to: ${seekTo}, sections: ${sectionStrings.join(\" | \")}`);\n  }\n  seekInfiniteLoop.registerSeek(seekTo);\n  if (seekTo <= iterator.counter.getOffset() && mode === \"download\") {\n    throw new Error(`Seeking backwards is not supported in parseAndDownloadMedia() mode. Current position: ${iterator.counter.getOffset()}, seekTo: ${seekTo}`);\n  }\n  if (seekTo > contentLength) {\n    throw new Error(`Cannot seek beyond the end of the file: ${seekTo} > ${contentLength}`);\n  }\n  if (mode === \"download\") {\n    Log.verbose(logLevel, `Skipping over video data from position ${iterator.counter.getOffset()} -> ${seekTo}. Fetching but not reading all the data inbetween because in download mode`);\n    iterator.discard(seekTo - iterator.counter.getOffset());\n    return;\n  }\n  await controller._internals.checkForAbortAndPause();\n  const alreadyAtByte = iterator.counter.getOffset() === seekTo;\n  if (alreadyAtByte) {\n    Log.verbose(logLevel, `Already at the desired position, seeking done`);\n    controller._internals.performedSeeksSignal.markLastSeekAsUserInitiated();\n    return;\n  }\n  const skippingForward = seekTo > iterator.counter.getOffset();\n  controller._internals.performedSeeksSignal.recordSeek({\n    from: iterator.counter.getOffset(),\n    to: seekTo,\n    type: userInitiated ? \"user-initiated\" : \"internal\"\n  });\n  if (skippingForward) {\n    await seekForward({\n      seekTo,\n      userInitiated,\n      iterator,\n      fields,\n      logLevel,\n      currentReader,\n      readerInterface,\n      src,\n      controller,\n      discardReadBytes,\n      prefetchCache\n    });\n  } else {\n    await seekBackwards({\n      controller,\n      seekTo,\n      iterator,\n      logLevel,\n      currentReader,\n      readerInterface,\n      src,\n      prefetchCache\n    });\n  }\n  if (userInitiated) {\n    isoState.flatSamples.updateAfterSeek(seekTo);\n  }\n  await controller._internals.checkForAbortAndPause();\n};\n\n// src/work-on-seek-request.ts\nvar turnSeekIntoByte = async ({\n  seek: seek2,\n  mediaSectionState: mediaSectionState2,\n  logLevel,\n  iterator,\n  structureState,\n  m3uPlaylistContext,\n  isoState,\n  transportStream,\n  tracksState,\n  webmState,\n  keyframes,\n  flacState,\n  samplesObserved,\n  riffState,\n  mp3State,\n  contentLength,\n  aacState,\n  m3uState,\n  avcState\n}) => {\n  const mediaSections = mediaSectionState2.getMediaSections();\n  if (mediaSections.length === 0) {\n    Log.trace(logLevel, \"No media sections defined, cannot seek yet\");\n    return {\n      type: \"valid-but-must-wait\"\n    };\n  }\n  if (seek2 < 0) {\n    throw new Error(`Cannot seek to a negative time: ${JSON.stringify(seek2)}`);\n  }\n  const seekingHints = getSeekingHints({\n    riffState,\n    samplesObserved,\n    structureState,\n    mediaSectionState: mediaSectionState2,\n    isoState,\n    transportStream,\n    tracksState,\n    keyframesState: keyframes,\n    webmState,\n    flacState,\n    mp3State,\n    contentLength,\n    aacState,\n    m3uPlaylistContext\n  });\n  if (!seekingHints) {\n    Log.trace(logLevel, \"No seeking info, cannot seek yet\");\n    return {\n      type: \"valid-but-must-wait\"\n    };\n  }\n  const seekingByte = await getSeekingByte({\n    info: seekingHints,\n    time: seek2,\n    logLevel,\n    currentPosition: iterator.counter.getOffset(),\n    isoState,\n    transportStream,\n    webmState,\n    mediaSection: mediaSectionState2,\n    m3uPlaylistContext,\n    structure: structureState,\n    riffState,\n    m3uState,\n    avcState\n  });\n  return seekingByte;\n};\nvar getWorkOnSeekRequestOptions = (state) => {\n  return {\n    logLevel: state.logLevel,\n    controller: state.controller,\n    isoState: state.iso,\n    iterator: state.iterator,\n    structureState: state.structure,\n    src: state.src,\n    contentLength: state.contentLength,\n    readerInterface: state.readerInterface,\n    mediaSection: state.mediaSection,\n    m3uPlaylistContext: state.m3uPlaylistContext,\n    mode: state.mode,\n    seekInfiniteLoop: state.seekInfiniteLoop,\n    currentReader: state.currentReader,\n    discardReadBytes: state.discardReadBytes,\n    fields: state.fields,\n    transportStream: state.transportStream,\n    tracksState: state.callbacks.tracks,\n    webmState: state.webm,\n    keyframes: state.keyframes,\n    flacState: state.flac,\n    samplesObserved: state.samplesObserved,\n    riffState: state.riff,\n    mp3State: state.mp3,\n    aacState: state.aac,\n    m3uState: state.m3u,\n    prefetchCache: state.prefetchCache,\n    avcState: state.avc\n  };\n};\nvar workOnSeekRequest = async (options) => {\n  const {\n    logLevel,\n    controller,\n    mediaSection,\n    m3uPlaylistContext,\n    isoState,\n    iterator,\n    structureState,\n    src,\n    contentLength,\n    readerInterface,\n    mode,\n    seekInfiniteLoop,\n    currentReader,\n    discardReadBytes,\n    fields,\n    transportStream,\n    tracksState,\n    webmState,\n    keyframes,\n    flacState,\n    samplesObserved,\n    riffState,\n    mp3State,\n    aacState,\n    prefetchCache,\n    m3uState,\n    avcState\n  } = options;\n  const seek2 = controller._internals.seekSignal.getSeek();\n  if (seek2 === null) {\n    return;\n  }\n  Log.trace(logLevel, `Has seek request for ${src}: ${JSON.stringify(seek2)}`);\n  const resolution = await turnSeekIntoByte({\n    seek: seek2,\n    mediaSectionState: mediaSection,\n    logLevel,\n    iterator,\n    structureState,\n    m3uPlaylistContext,\n    isoState,\n    transportStream,\n    tracksState,\n    webmState,\n    keyframes,\n    flacState,\n    samplesObserved,\n    riffState,\n    mp3State,\n    contentLength,\n    aacState,\n    m3uState,\n    avcState\n  });\n  Log.trace(logLevel, `Seek action: ${JSON.stringify(resolution)}`);\n  if (resolution.type === \"intermediary-seek\") {\n    await performSeek({\n      seekTo: resolution.byte,\n      userInitiated: false,\n      controller,\n      mediaSection,\n      iterator,\n      logLevel,\n      mode,\n      contentLength,\n      seekInfiniteLoop,\n      currentReader,\n      readerInterface,\n      src,\n      discardReadBytes,\n      fields,\n      prefetchCache,\n      isoState\n    });\n    return;\n  }\n  if (resolution.type === \"do-seek\") {\n    await performSeek({\n      seekTo: resolution.byte,\n      userInitiated: true,\n      controller,\n      mediaSection,\n      iterator,\n      logLevel,\n      mode,\n      contentLength,\n      seekInfiniteLoop,\n      currentReader,\n      readerInterface,\n      src,\n      discardReadBytes,\n      fields,\n      prefetchCache,\n      isoState\n    });\n    const { hasChanged } = controller._internals.seekSignal.clearSeekIfStillSame(seek2);\n    if (hasChanged) {\n      Log.trace(logLevel, `Seek request has changed while seeking, seeking again`);\n      await workOnSeekRequest(options);\n    }\n    return;\n  }\n  if (resolution.type === \"invalid\") {\n    throw new Error(`The seek request ${JSON.stringify(seek2)} cannot be processed`);\n  }\n  if (resolution.type === \"valid-but-must-wait\") {\n    Log.trace(logLevel, \"Seek request is valid but cannot be processed yet\");\n  }\n};\n\n// src/emit-available-info.ts\nvar emitAvailableInfo = async ({\n  hasInfo,\n  state\n}) => {\n  const keys = Object.keys(hasInfo);\n  const {\n    emittedFields,\n    fieldsInReturnValue,\n    returnValue,\n    name,\n    callbackFunctions\n  } = state;\n  for (const key of keys) {\n    await workOnSeekRequest(getWorkOnSeekRequestOptions(state));\n    if (key === \"slowStructure\") {\n      if (hasInfo.slowStructure && !emittedFields.slowStructure) {\n        await callbackFunctions.onSlowStructure?.(state.structure.getStructure());\n        if (fieldsInReturnValue.slowStructure) {\n          returnValue.slowStructure = state.structure.getStructure();\n        }\n        emittedFields.slowStructure = true;\n      }\n      continue;\n    }\n    if (key === \"durationInSeconds\") {\n      if (hasInfo.durationInSeconds) {\n        if (!emittedFields.durationInSeconds) {\n          const durationInSeconds = getDuration(state);\n          await callbackFunctions.onDurationInSeconds?.(durationInSeconds);\n          if (fieldsInReturnValue.durationInSeconds) {\n            returnValue.durationInSeconds = durationInSeconds;\n          }\n          emittedFields.durationInSeconds = true;\n        }\n      }\n      continue;\n    }\n    if (key === \"slowDurationInSeconds\") {\n      if (hasInfo.slowDurationInSeconds && !emittedFields.slowDurationInSeconds) {\n        const slowDurationInSeconds = getDuration(state) ?? state.samplesObserved.getSlowDurationInSeconds();\n        await callbackFunctions.onSlowDurationInSeconds?.(slowDurationInSeconds);\n        if (fieldsInReturnValue.slowDurationInSeconds) {\n          returnValue.slowDurationInSeconds = slowDurationInSeconds;\n        }\n        emittedFields.slowDurationInSeconds = true;\n      }\n      continue;\n    }\n    if (key === \"fps\") {\n      if (hasInfo.fps) {\n        if (!emittedFields.fps) {\n          const fps = getFps(state);\n          await callbackFunctions.onFps?.(fps);\n          if (fieldsInReturnValue.fps) {\n            returnValue.fps = fps;\n          }\n          emittedFields.fps = true;\n        }\n        if (!emittedFields.slowFps) {\n          const fps = getFps(state);\n          if (fps) {\n            await callbackFunctions.onSlowFps?.(fps);\n            if (fieldsInReturnValue.slowFps) {\n              returnValue.slowFps = fps;\n            }\n            emittedFields.slowFps = true;\n          }\n        }\n      }\n      continue;\n    }\n    if (key === \"slowFps\") {\n      if (hasInfo.slowFps && !emittedFields.slowFps) {\n        const slowFps = getFps(state) ?? state.samplesObserved.getFps();\n        await callbackFunctions.onSlowFps?.(slowFps);\n        if (fieldsInReturnValue.slowFps) {\n          returnValue.slowFps = slowFps;\n        }\n        emittedFields.slowFps = true;\n      }\n      continue;\n    }\n    if (key === \"dimensions\") {\n      if (hasInfo.dimensions && !emittedFields.dimensions) {\n        const dimensionsQueried = getDimensions(state);\n        const dimensions = dimensionsQueried === null ? null : {\n          height: dimensionsQueried.height,\n          width: dimensionsQueried.width\n        };\n        await callbackFunctions.onDimensions?.(dimensions);\n        if (fieldsInReturnValue.dimensions) {\n          returnValue.dimensions = dimensions;\n        }\n        emittedFields.dimensions = true;\n      }\n      continue;\n    }\n    if (key === \"unrotatedDimensions\") {\n      if (hasInfo.unrotatedDimensions && !emittedFields.unrotatedDimensions) {\n        const dimensionsQueried = getDimensions(state);\n        const unrotatedDimensions = dimensionsQueried === null ? null : {\n          height: dimensionsQueried.unrotatedHeight,\n          width: dimensionsQueried.unrotatedWidth\n        };\n        await callbackFunctions.onUnrotatedDimensions?.(unrotatedDimensions);\n        if (fieldsInReturnValue.unrotatedDimensions) {\n          returnValue.unrotatedDimensions = unrotatedDimensions;\n        }\n        emittedFields.unrotatedDimensions = true;\n      }\n      continue;\n    }\n    if (key === \"rotation\") {\n      if (hasInfo.rotation && !emittedFields.rotation) {\n        const dimensionsQueried = getDimensions(state);\n        const rotation = dimensionsQueried?.rotation ?? 0;\n        await callbackFunctions.onRotation?.(rotation);\n        if (fieldsInReturnValue.rotation) {\n          returnValue.rotation = rotation;\n        }\n        emittedFields.rotation = true;\n      }\n      continue;\n    }\n    if (key === \"videoCodec\") {\n      if (!emittedFields.videoCodec && hasInfo.videoCodec) {\n        const videoCodec = getVideoCodec(state);\n        await callbackFunctions.onVideoCodec?.(videoCodec);\n        if (fieldsInReturnValue.videoCodec) {\n          returnValue.videoCodec = videoCodec;\n        }\n        emittedFields.videoCodec = true;\n      }\n      continue;\n    }\n    if (key === \"audioCodec\") {\n      if (!emittedFields.audioCodec && hasInfo.audioCodec) {\n        const audioCodec = getAudioCodec(state);\n        await callbackFunctions.onAudioCodec?.(audioCodec);\n        if (fieldsInReturnValue.audioCodec) {\n          returnValue.audioCodec = audioCodec;\n        }\n        emittedFields.audioCodec = true;\n      }\n      continue;\n    }\n    if (key === \"tracks\") {\n      if (!emittedFields.tracks && hasInfo.tracks) {\n        const tracks2 = getTracks(state, true);\n        await callbackFunctions.onTracks?.(tracks2);\n        if (fieldsInReturnValue.tracks) {\n          returnValue.tracks = tracks2;\n        }\n        emittedFields.tracks = true;\n      }\n      continue;\n    }\n    if (key === \"internalStats\") {\n      if (hasInfo.internalStats) {\n        const internalStats = state.getInternalStats();\n        if (fieldsInReturnValue.internalStats) {\n          returnValue.internalStats = internalStats;\n        }\n        emittedFields.internalStats = true;\n      }\n      continue;\n    }\n    if (key === \"size\") {\n      if (!emittedFields.size && hasInfo.size) {\n        await callbackFunctions.onSize?.(state.contentLength);\n        if (fieldsInReturnValue.size) {\n          returnValue.size = state.contentLength;\n        }\n        emittedFields.size = true;\n      }\n      continue;\n    }\n    if (key === \"mimeType\") {\n      if (!emittedFields.mimeType && hasInfo.mimeType) {\n        await callbackFunctions.onMimeType?.(state.mimeType);\n        if (fieldsInReturnValue.mimeType) {\n          returnValue.mimeType = state.mimeType;\n        }\n        emittedFields.mimeType = true;\n      }\n      continue;\n    }\n    if (key === \"name\") {\n      if (!emittedFields.name && hasInfo.name) {\n        await callbackFunctions.onName?.(name);\n        if (fieldsInReturnValue.name) {\n          returnValue.name = name;\n        }\n        emittedFields.name = true;\n      }\n      continue;\n    }\n    if (key === \"isHdr\") {\n      if (!returnValue.isHdr && hasInfo.isHdr) {\n        const isHdr = getIsHdr(state);\n        await callbackFunctions.onIsHdr?.(isHdr);\n        if (fieldsInReturnValue.isHdr) {\n          returnValue.isHdr = isHdr;\n        }\n        emittedFields.isHdr = true;\n      }\n      continue;\n    }\n    if (key === \"container\") {\n      if (!returnValue.container && hasInfo.container) {\n        const container = getContainer(state.structure.getStructure());\n        await callbackFunctions.onContainer?.(container);\n        if (fieldsInReturnValue.container) {\n          returnValue.container = container;\n        }\n        emittedFields.container = true;\n      }\n      continue;\n    }\n    if (key === \"metadata\") {\n      if (!emittedFields.metadata && hasInfo.metadata) {\n        const metadata = getMetadata(state);\n        await callbackFunctions.onMetadata?.(metadata);\n        if (fieldsInReturnValue.metadata) {\n          returnValue.metadata = metadata;\n        }\n        emittedFields.metadata = true;\n      }\n      continue;\n    }\n    if (key === \"location\") {\n      if (!emittedFields.location && hasInfo.location) {\n        const location = getLocation(state);\n        await callbackFunctions.onLocation?.(location);\n        if (fieldsInReturnValue.location) {\n          returnValue.location = location;\n        }\n        emittedFields.location = true;\n      }\n      continue;\n    }\n    if (key === \"slowKeyframes\") {\n      if (!emittedFields.slowKeyframes && hasInfo.slowKeyframes) {\n        await callbackFunctions.onSlowKeyframes?.(state.keyframes.getKeyframes());\n        if (fieldsInReturnValue.slowKeyframes) {\n          returnValue.slowKeyframes = state.keyframes.getKeyframes();\n        }\n        emittedFields.slowKeyframes = true;\n      }\n      continue;\n    }\n    if (key === \"slowNumberOfFrames\") {\n      if (!emittedFields.slowNumberOfFrames && hasInfo.slowNumberOfFrames) {\n        await callbackFunctions.onSlowNumberOfFrames?.(state.samplesObserved.getSlowNumberOfFrames());\n        if (fieldsInReturnValue.slowNumberOfFrames) {\n          returnValue.slowNumberOfFrames = state.samplesObserved.getSlowNumberOfFrames();\n        }\n        emittedFields.slowNumberOfFrames = true;\n      }\n      continue;\n    }\n    if (key === \"slowAudioBitrate\") {\n      if (!emittedFields.slowAudioBitrate && hasInfo.slowAudioBitrate) {\n        await callbackFunctions.onSlowAudioBitrate?.(state.samplesObserved.getAudioBitrate());\n        if (fieldsInReturnValue.slowAudioBitrate) {\n          returnValue.slowAudioBitrate = state.samplesObserved.getAudioBitrate();\n        }\n        emittedFields.slowAudioBitrate = true;\n      }\n      continue;\n    }\n    if (key === \"slowVideoBitrate\") {\n      if (!emittedFields.slowVideoBitrate && hasInfo.slowVideoBitrate) {\n        await callbackFunctions.onSlowVideoBitrate?.(state.samplesObserved.getVideoBitrate());\n        if (fieldsInReturnValue.slowVideoBitrate) {\n          returnValue.slowVideoBitrate = state.samplesObserved.getVideoBitrate();\n        }\n        emittedFields.slowVideoBitrate = true;\n      }\n      continue;\n    }\n    if (key === \"keyframes\") {\n      if (!emittedFields.keyframes && hasInfo.keyframes) {\n        await callbackFunctions.onKeyframes?.(getKeyframes(state));\n        if (fieldsInReturnValue.keyframes) {\n          returnValue.keyframes = getKeyframes(state);\n        }\n        emittedFields.keyframes = true;\n      }\n      continue;\n    }\n    if (key === \"images\") {\n      if (!emittedFields.images && hasInfo.images) {\n        await callbackFunctions.onImages?.(state.images.images);\n        if (fieldsInReturnValue.images) {\n          returnValue.images = state.images.images;\n        }\n        emittedFields.images = true;\n      }\n      continue;\n    }\n    if (key === \"sampleRate\") {\n      if (!emittedFields.sampleRate && hasInfo.sampleRate) {\n        const sampleRate = getSampleRate3(state);\n        await callbackFunctions.onSampleRate?.(sampleRate);\n        if (fieldsInReturnValue.sampleRate) {\n          returnValue.sampleRate = sampleRate;\n        }\n        emittedFields.sampleRate = true;\n      }\n      continue;\n    }\n    if (key === \"numberOfAudioChannels\") {\n      if (!emittedFields.numberOfAudioChannels && hasInfo.numberOfAudioChannels) {\n        const numberOfAudioChannels = getNumberOfAudioChannels(state);\n        await callbackFunctions.onNumberOfAudioChannels?.(numberOfAudioChannels);\n        if (fieldsInReturnValue.numberOfAudioChannels) {\n          returnValue.numberOfAudioChannels = numberOfAudioChannels;\n        }\n        emittedFields.numberOfAudioChannels = true;\n      }\n      continue;\n    }\n    if (key === \"m3uStreams\") {\n      if (!emittedFields.m3uStreams && hasInfo.m3uStreams) {\n        const streams = getM3uStreams({\n          structure: state.structure.getStructureOrNull(),\n          originalSrc: state.src,\n          readerInterface: state.readerInterface\n        });\n        await callbackFunctions.onM3uStreams?.(streams);\n        if (fieldsInReturnValue.m3uStreams) {\n          returnValue.m3uStreams = streams;\n        }\n        emittedFields.m3uStreams = true;\n      }\n      continue;\n    }\n    throw new Error(`Unhandled key: ${key}`);\n  }\n  await workOnSeekRequest(getWorkOnSeekRequestOptions(state));\n};\n\n// src/state/may-skip-video-data.ts\nvar getHasCallbacks = (state) => {\n  const hasNoTrackHandlers = !state.callbacks.hasAudioTrackHandlers && !state.callbacks.hasVideoTrackHandlers;\n  if (hasNoTrackHandlers) {\n    return false;\n  }\n  const hasAllTracksAndNoCallbacks = !state.callbacks.tracks.hasAllTracks() || Object.values(state.callbacks.videoSampleCallbacks).length > 0 || Object.values(state.callbacks.audioSampleCallbacks).length > 0;\n  return hasAllTracksAndNoCallbacks;\n};\nvar missesMatroskaTracks = (state) => {\n  const struct = state.structure.getStructureOrNull();\n  if (struct === null) {\n    return false;\n  }\n  if (struct.type !== \"matroska\") {\n    return false;\n  }\n  const mainSegment = getMainSegment(struct.boxes);\n  if (mainSegment === null) {\n    return false;\n  }\n  return getTracksFromMatroska({\n    structureState: state.structure,\n    webmState: state.webm\n  }).missingInfo.length > 0;\n};\nvar maySkipVideoData = ({ state }) => {\n  const hasCallbacks = getHasCallbacks(state);\n  return !hasCallbacks && !needsToIterateOverSamples({\n    emittedFields: state.emittedFields,\n    fields: state.fields\n  }) && !missesMatroskaTracks(state);\n};\nvar maySkipOverSamplesInTheMiddle = ({\n  state\n}) => {\n  const hasCallbacks = getHasCallbacks(state);\n  return !hasCallbacks && !needsToIterateOverEverySample({\n    emittedFields: state.emittedFields,\n    fields: state.fields\n  });\n};\n\n// src/has-all-info.ts\nvar getAvailableInfo = ({\n  state\n}) => {\n  const keys = Object.entries(state.fields).filter(([, value]) => value);\n  const structure = state.structure.getStructureOrNull();\n  const infos = keys.map(([_key]) => {\n    const key = _key;\n    if (key === \"slowStructure\") {\n      return false;\n    }\n    if (key === \"durationInSeconds\") {\n      return Boolean(structure && hasDuration(state));\n    }\n    if (key === \"slowDurationInSeconds\") {\n      const res = Boolean(structure && hasSlowDuration(state));\n      return res;\n    }\n    if (key === \"dimensions\" || key === \"rotation\" || key === \"unrotatedDimensions\") {\n      return Boolean(structure && hasDimensions(state));\n    }\n    if (key === \"fps\") {\n      return Boolean(structure && hasFps(state));\n    }\n    if (key === \"slowFps\") {\n      return Boolean(structure && hasFpsSuitedForSlowFps(state));\n    }\n    if (key === \"isHdr\") {\n      return Boolean(structure && hasHdr(state));\n    }\n    if (key === \"videoCodec\") {\n      return Boolean(structure && hasVideoCodec(state));\n    }\n    if (key === \"audioCodec\") {\n      return Boolean(structure && hasAudioCodec(state));\n    }\n    if (key === \"tracks\") {\n      return Boolean(structure && getHasTracks(state, true));\n    }\n    if (key === \"keyframes\") {\n      return Boolean(structure && hasKeyframes(state));\n    }\n    if (key === \"internalStats\") {\n      return true;\n    }\n    if (key === \"size\") {\n      return true;\n    }\n    if (key === \"mimeType\") {\n      return true;\n    }\n    if (key === \"name\") {\n      return true;\n    }\n    if (key === \"container\") {\n      return Boolean(structure && hasContainer(structure));\n    }\n    if (key === \"metadata\" || key === \"location\" || key === \"images\") {\n      return Boolean(structure && hasMetadata(structure));\n    }\n    if (key === \"slowKeyframes\" || key === \"slowVideoBitrate\" || key === \"slowAudioBitrate\" || key === \"slowNumberOfFrames\") {\n      return false;\n    }\n    if (key === \"numberOfAudioChannels\") {\n      return hasNumberOfAudioChannels(state);\n    }\n    if (key === \"sampleRate\") {\n      return hasSampleRate(state);\n    }\n    if (key === \"m3uStreams\") {\n      return m3uHasStreams(state);\n    }\n    throw new Error(`Unknown field passed: ${key}. Available fields: ${Object.keys(state.fields).join(\", \")}`);\n  });\n  const entries = [];\n  let i = 0;\n  for (const [key] of keys) {\n    entries.push([key, infos[i++]]);\n  }\n  return Object.fromEntries(entries);\n};\nvar hasAllInfo = ({ state }) => {\n  const availableInfo = getAvailableInfo({\n    state\n  });\n  if (!Object.values(availableInfo).every(Boolean)) {\n    return false;\n  }\n  if (maySkipVideoData({ state })) {\n    return true;\n  }\n  if (state.callbacks.canSkipTracksState.canSkipTracks()) {\n    return true;\n  }\n  return false;\n};\n\n// src/emit-all-info.ts\nvar emitAllInfo = async (state) => {\n  const allFields = Object.keys(state.fields).reduce((acc, key) => {\n    if (state.fields?.[key]) {\n      acc[key] = true;\n    }\n    return acc;\n  }, {});\n  await emitAvailableInfo({\n    hasInfo: allFields,\n    state\n  });\n};\nvar triggerInfoEmit = async (state) => {\n  const availableInfo = getAvailableInfo({\n    state\n  });\n  await emitAvailableInfo({\n    hasInfo: availableInfo,\n    state\n  });\n};\n\n// src/check-if-done.ts\nvar checkIfDone = async (state) => {\n  const startCheck = Date.now();\n  const hasAll = hasAllInfo({\n    state\n  });\n  state.timings.timeCheckingIfDone += Date.now() - startCheck;\n  if (hasAll && state.mode === \"query\") {\n    Log.verbose(state.logLevel, \"Got all info, skipping to the end.\");\n    state.increaseSkippedBytes(state.contentLength - state.iterator.counter.getOffset());\n    return true;\n  }\n  if (state.iterator.counter.getOffset() === state.contentLength) {\n    if (state.structure.getStructure().type === \"m3u\" && !state.m3u.getAllChunksProcessedOverall()) {\n      return false;\n    }\n    state.riff.queuedBFrames.flush();\n    if (state.riff.queuedBFrames.hasReleasedFrames()) {\n      return false;\n    }\n    Log.verbose(state.logLevel, \"Reached end of file\");\n    await state.discardReadBytes(true);\n    return true;\n  }\n  if (state.iterator.counter.getOffset() + state.iterator.bytesRemaining() === state.contentLength && state.errored) {\n    Log.verbose(state.logLevel, \"Reached end of file and errorred\");\n    return true;\n  }\n  return false;\n};\n\n// src/make-progress-object.ts\nvar makeProgressObject = (state) => {\n  return {\n    bytes: state.iterator.counter.getOffset(),\n    percentage: state.contentLength ? state.iterator.counter.getOffset() / state.contentLength : null,\n    totalBytes: state.contentLength\n  };\n};\n\n// src/containers/aac/parse-aac.ts\nvar parseAac = async (state) => {\n  const { iterator } = state;\n  const startOffset = iterator.counter.getOffset();\n  iterator.startReadingBits();\n  const syncWord = iterator.getBits(12);\n  if (syncWord !== 4095) {\n    throw new Error(\"Invalid syncword: \" + syncWord);\n  }\n  const id = iterator.getBits(1);\n  if (id !== 0) {\n    throw new Error(\"Only supporting MPEG-4 for .aac\");\n  }\n  const layer = iterator.getBits(2);\n  if (layer !== 0) {\n    throw new Error(\"Only supporting layer 0 for .aac\");\n  }\n  const protectionAbsent = iterator.getBits(1);\n  const audioObjectType = iterator.getBits(2);\n  const samplingFrequencyIndex = iterator.getBits(4);\n  const sampleRate = getSampleRateFromSampleFrequencyIndex(samplingFrequencyIndex);\n  iterator.getBits(1);\n  const channelConfiguration = iterator.getBits(3);\n  const codecPrivate2 = createAacCodecPrivate({\n    audioObjectType,\n    sampleRate,\n    channelConfiguration,\n    codecPrivate: null\n  });\n  iterator.getBits(1);\n  iterator.getBits(1);\n  iterator.getBits(1);\n  iterator.getBits(1);\n  const frameLength = iterator.getBits(13);\n  iterator.getBits(11);\n  iterator.getBits(2);\n  if (!protectionAbsent) {\n    iterator.getBits(16);\n  }\n  iterator.stopReadingBits();\n  iterator.counter.decrement(iterator.counter.getOffset() - startOffset);\n  const data = iterator.getSlice(frameLength);\n  if (state.callbacks.tracks.getTracks().length === 0) {\n    state.mediaSection.addMediaSection({\n      start: startOffset,\n      size: state.contentLength - startOffset\n    });\n    await registerAudioTrack({\n      container: \"aac\",\n      track: {\n        codec: mapAudioObjectTypeToCodecString(audioObjectType),\n        codecEnum: \"aac\",\n        codecData: { type: \"aac-config\", data: codecPrivate2 },\n        description: codecPrivate2,\n        numberOfChannels: channelConfiguration,\n        sampleRate,\n        originalTimescale: WEBCODECS_TIMESCALE,\n        trackId: 0,\n        type: \"audio\",\n        startInSeconds: 0,\n        timescale: WEBCODECS_TIMESCALE,\n        trackMediaTimeOffsetInTrackTimescale: 0\n      },\n      registerAudioSampleCallback: state.callbacks.registerAudioSampleCallback,\n      tracks: state.callbacks.tracks,\n      logLevel: state.logLevel,\n      onAudioTrack: state.onAudioTrack\n    });\n    state.callbacks.tracks.setIsDone(state.logLevel);\n  }\n  const duration2 = 1024 / sampleRate;\n  const { index } = state.aac.addSample({ offset: startOffset, size: frameLength });\n  const timestamp = 1024 / sampleRate * index;\n  state.aac.audioSamples.addSample({\n    timeInSeconds: timestamp,\n    offset: startOffset,\n    durationInSeconds: duration2\n  });\n  const audioSample = convertAudioOrVideoSampleToWebCodecsTimestamps({\n    sample: {\n      duration: duration2,\n      type: \"key\",\n      data,\n      offset: startOffset,\n      decodingTimestamp: timestamp,\n      timestamp\n    },\n    timescale: 1\n  });\n  await state.callbacks.onAudioSample({\n    audioSample,\n    trackId: 0\n  });\n  return Promise.resolve(null);\n};\n\n// src/skip.ts\nvar makeSkip = (skipTo) => ({\n  action: \"skip\",\n  skipTo\n});\nvar makeFetchMoreData = (bytesNeeded) => ({\n  action: \"fetch-more-data\",\n  bytesNeeded\n});\n\n// src/containers/flac/get-block-size.ts\nvar getBlockSize = (iterator) => {\n  const bits = iterator.getBits(4);\n  if (bits === 0) {\n    throw new Error(\"Reserved block size\");\n  }\n  if (bits === 1) {\n    return 192;\n  }\n  if (bits >= 2 && bits <= 5) {\n    return 144 * 2 ** bits;\n  }\n  if (bits === 6) {\n    return \"uncommon-u8\";\n  }\n  if (bits === 7) {\n    return \"uncommon-u16\";\n  }\n  if (bits >= 8 && bits <= 15) {\n    return 2 ** bits;\n  }\n  throw new Error(\"Invalid block size\");\n};\n\n// src/containers/flac/get-channel-count.ts\nvar getChannelCount = (iterator) => {\n  const bits = iterator.getBits(4);\n  if (bits === 0) {\n    return 1;\n  }\n  if (bits === 1) {\n    return 2;\n  }\n  if (bits === 2) {\n    return 3;\n  }\n  if (bits === 3) {\n    return 4;\n  }\n  if (bits === 4) {\n    return 5;\n  }\n  if (bits === 5) {\n    return 6;\n  }\n  if (bits === 6) {\n    return 7;\n  }\n  if (bits === 7) {\n    return 8;\n  }\n  if (bits === 8 || bits === 9 || bits === 10) {\n    return 2;\n  }\n  throw new Error(`Invalid channel count: ${bits.toString(2)}`);\n};\n\n// src/containers/flac/get-sample-rate.ts\nvar getSampleRate4 = (iterator, state) => {\n  const mode = iterator.getBits(4);\n  if (mode === 0) {\n    const structure = state.structure.getFlacStructure();\n    const sampleRate = structure.boxes.find((box) => box.type === \"flac-streaminfo\")?.sampleRate ?? null;\n    if (sampleRate === null) {\n      throw new Error(\"Sample rate not found\");\n    }\n    return sampleRate;\n  }\n  if (mode === 1) {\n    return 88200;\n  }\n  if (mode === 2) {\n    return 176400;\n  }\n  if (mode === 3) {\n    return 192000;\n  }\n  if (mode === 4) {\n    return 8000;\n  }\n  if (mode === 5) {\n    return 16000;\n  }\n  if (mode === 6) {\n    return 22050;\n  }\n  if (mode === 7) {\n    return 24000;\n  }\n  if (mode === 8) {\n    return 32000;\n  }\n  if (mode === 9) {\n    return 44100;\n  }\n  if (mode === 10) {\n    return 48000;\n  }\n  if (mode === 11) {\n    return 96000;\n  }\n  if (mode === 12) {\n    return \"uncommon-u8\";\n  }\n  if (mode === 13) {\n    return \"uncommon-u16\";\n  }\n  if (mode === 14) {\n    return \"uncommon-u16-10\";\n  }\n  throw new Error(`Invalid sample rate mode: ${mode.toString(2)}`);\n};\n\n// src/containers/flac/parse-flac-frame.ts\nfunction calculateCRC8(data) {\n  const polynomial = 7;\n  let crc = 0;\n  for (const byte of data) {\n    crc ^= byte;\n    for (let i = 0;i < 8; i++) {\n      if ((crc & 128) !== 0) {\n        crc = crc << 1 ^ polynomial;\n      } else {\n        crc <<= 1;\n      }\n      crc &= 255;\n    }\n  }\n  return crc;\n}\nvar parseFrameHeader = ({\n  iterator,\n  state\n}) => {\n  if (iterator.bytesRemaining() < 10) {\n    return null;\n  }\n  const startOffset = iterator.counter.getOffset();\n  iterator.discard(2);\n  iterator.startReadingBits();\n  const blockSizeBits = getBlockSize(iterator);\n  const sampleRateBits = getSampleRate4(iterator, state);\n  getChannelCount(iterator);\n  iterator.getBits(3);\n  iterator.getBits(1);\n  const num = iterator.getFlacCodecNumber();\n  const blockSize = blockSizeBits === \"uncommon-u16\" ? iterator.getBits(16) + 1 : blockSizeBits === \"uncommon-u8\" ? iterator.getBits(8) + 1 : blockSizeBits;\n  const sampleRate = sampleRateBits === \"uncommon-u16\" ? iterator.getBits(16) : sampleRateBits === \"uncommon-u16-10\" ? iterator.getBits(16) * 10 : sampleRateBits === \"uncommon-u8\" ? iterator.getBits(8) : sampleRateBits;\n  iterator.stopReadingBits();\n  const size = iterator.counter.getOffset() - startOffset;\n  const crc = iterator.getUint8();\n  iterator.counter.decrement(size + 1);\n  const crcCalculated = calculateCRC8(iterator.getSlice(size));\n  iterator.counter.decrement(size);\n  if (crcCalculated !== crc) {\n    return null;\n  }\n  return { num, blockSize, sampleRate };\n};\nvar emitSample = async ({\n  state,\n  data,\n  offset\n}) => {\n  const iterator = getArrayBufferIterator({\n    initialData: data,\n    maxBytes: data.length,\n    logLevel: \"error\"\n  });\n  const parsed = parseFrameHeader({ iterator, state });\n  if (!parsed) {\n    throw new Error(\"Invalid CRC\");\n  }\n  const { blockSize, num, sampleRate } = parsed;\n  const duration2 = blockSize / sampleRate;\n  const structure = state.structure.getFlacStructure();\n  const streamInfo = structure.boxes.find((box) => box.type === \"flac-streaminfo\");\n  if (!streamInfo) {\n    throw new Error(\"Stream info not found\");\n  }\n  if (streamInfo.minimumBlockSize !== streamInfo.maximumBlockSize) {\n    throw new Error(\"Cannot determine timestamp\");\n  }\n  const timestamp = num * streamInfo.maximumBlockSize / streamInfo.sampleRate;\n  state.flac.audioSamples.addSample({\n    timeInSeconds: timestamp,\n    offset,\n    durationInSeconds: duration2\n  });\n  const audioSample = convertAudioOrVideoSampleToWebCodecsTimestamps({\n    sample: {\n      data,\n      duration: duration2,\n      decodingTimestamp: timestamp,\n      timestamp,\n      type: \"key\",\n      offset\n    },\n    timescale: 1\n  });\n  await state.callbacks.onAudioSample({\n    audioSample,\n    trackId: 0\n  });\n  iterator.destroy();\n};\nvar parseFlacFrame = async ({\n  state,\n  iterator\n}) => {\n  const blockingBit = state.flac.getBlockingBitStrategy();\n  const offset = iterator.counter.getOffset();\n  const { returnToCheckpoint } = iterator.startCheckpoint();\n  iterator.startReadingBits();\n  if (blockingBit === undefined) {\n    const bits = iterator.getBits(15);\n    if (bits !== 32764) {\n      throw new Error(\"Invalid sync code\");\n    }\n    state.flac.setBlockingBitStrategy(iterator.getBits(1));\n  } else if (blockingBit === 1) {\n    const bits = iterator.getBits(16);\n    if (bits !== 65529) {\n      throw new Error(\"Blocking bit changed, it should not\");\n    }\n  } else if (blockingBit === 0) {\n    const bits = iterator.getBits(16);\n    if (bits !== 65528) {\n      throw new Error(\"Blocking bit changed, it should not\");\n    }\n  }\n  const setBlockingBit = state.flac.getBlockingBitStrategy();\n  if (setBlockingBit === undefined) {\n    throw new Error(\"Blocking bit should be set\");\n  }\n  iterator.stopReadingBits();\n  const structure = state.structure.getFlacStructure();\n  const minimumFrameSize = structure.boxes.find((b) => b.type === \"flac-streaminfo\")?.minimumFrameSize ?? null;\n  if (minimumFrameSize === null) {\n    throw new Error(\"Expected flac-streaminfo\");\n  }\n  if (minimumFrameSize !== 0) {\n    iterator.getSlice(minimumFrameSize - 2);\n  }\n  while (true) {\n    if (iterator.counter.getOffset() === state.contentLength) {\n      const size = iterator.counter.getOffset() - offset;\n      returnToCheckpoint();\n      const slice = iterator.getSlice(size);\n      await emitSample({ state, data: slice, offset });\n      break;\n    }\n    if (iterator.bytesRemaining() === 0) {\n      returnToCheckpoint();\n      break;\n    }\n    const nextByte = iterator.getUint8();\n    if (nextByte === 255) {\n      const nextBits = iterator.getUint8();\n      const expected = setBlockingBit === 1 ? 249 : 248;\n      if (nextBits !== expected) {\n        iterator.counter.decrement(1);\n        continue;\n      }\n      iterator.counter.decrement(2);\n      const nextIsLegit = parseFrameHeader({ iterator, state });\n      if (!nextIsLegit) {\n        iterator.discard(1);\n        continue;\n      }\n      const size = iterator.counter.getOffset() - offset;\n      returnToCheckpoint();\n      const data = iterator.getSlice(size);\n      await emitSample({ state, data, offset });\n      break;\n    }\n  }\n  return null;\n};\n\n// src/containers/flac/parse-header.ts\nvar parseFlacHeader = ({\n  state\n}) => {\n  state.structure.getFlacStructure().boxes.push({\n    type: \"flac-header\"\n  });\n  return Promise.resolve(null);\n};\n\n// src/containers/flac/parse-metadata.ts\nvar parseVorbisComment = ({\n  state,\n  iterator,\n  size\n}) => {\n  const { expectNoMoreBytes } = iterator.startBox(size);\n  const box = {\n    type: \"flac-vorbis-comment\",\n    fields: []\n  };\n  const vendorLength = iterator.getUint32Le();\n  const vendorString = iterator.getByteString(vendorLength, true);\n  const numberOfFields = iterator.getUint32Le();\n  box.fields.push({ key: \"vendor\", value: vendorString, trackId: null });\n  for (let i = 0;i < numberOfFields; i++) {\n    const fieldLength = iterator.getUint32Le();\n    const field = iterator.getByteString(fieldLength, true);\n    const [key, value] = field.split(\"=\");\n    box.fields.push({ key: key.toLowerCase(), value, trackId: null });\n  }\n  state.structure.getFlacStructure().boxes.push(box);\n  expectNoMoreBytes();\n  return Promise.resolve(null);\n};\n\n// src/containers/flac/parse-streaminfo.ts\nvar parseStreamInfo = async ({\n  iterator,\n  state\n}) => {\n  const counter = iterator.counter.getOffset();\n  const minimumBlockSize = iterator.getUint16();\n  const maximumBlockSize = iterator.getUint16();\n  const minimumFrameSize = iterator.getUint24();\n  const maximumFrameSize = iterator.getUint24();\n  iterator.startReadingBits();\n  const sampleRate = iterator.getBits(20);\n  const channels2 = iterator.getBits(3) + 1;\n  const bitsPerSample = iterator.getBits(5);\n  const totalSamples = iterator.getBits(36);\n  iterator.getBits(128);\n  iterator.stopReadingBits();\n  const counterNow = iterator.counter.getOffset();\n  const size = counterNow - counter;\n  iterator.counter.decrement(size);\n  const asUint8Array = iterator.getSlice(size);\n  const flacStreamInfo = {\n    type: \"flac-streaminfo\",\n    bitsPerSample,\n    channels: channels2,\n    maximumBlockSize,\n    maximumFrameSize,\n    minimumBlockSize,\n    minimumFrameSize,\n    sampleRate,\n    totalSamples\n  };\n  state.structure.getFlacStructure().boxes.push(flacStreamInfo);\n  await registerAudioTrack({\n    container: \"flac\",\n    track: {\n      codec: \"flac\",\n      type: \"audio\",\n      description: asUint8Array,\n      codecData: { type: \"flac-description\", data: asUint8Array },\n      codecEnum: \"flac\",\n      numberOfChannels: channels2,\n      sampleRate,\n      originalTimescale: WEBCODECS_TIMESCALE,\n      trackId: 0,\n      startInSeconds: 0,\n      timescale: WEBCODECS_TIMESCALE,\n      trackMediaTimeOffsetInTrackTimescale: 0\n    },\n    registerAudioSampleCallback: state.callbacks.registerAudioSampleCallback,\n    tracks: state.callbacks.tracks,\n    logLevel: state.logLevel,\n    onAudioTrack: state.onAudioTrack\n  });\n  state.callbacks.tracks.setIsDone(state.logLevel);\n  return Promise.resolve(null);\n};\n\n// src/containers/flac/parse-unknown-block.ts\nvar parseFlacUnkownBlock = ({\n  iterator,\n  state,\n  size\n}) => {\n  iterator.discard(size);\n  state.structure.getFlacStructure().boxes.push({\n    type: \"flac-header\"\n  });\n  return Promise.resolve(null);\n};\n\n// src/containers/flac/parse-meta.ts\nvar flacTypes = {\n  streaminfo: 0,\n  vorbisComment: 4\n};\nvar parseMetaBlock = ({\n  iterator,\n  state\n}) => {\n  iterator.startReadingBits();\n  const isLastMetadata = iterator.getBits(1);\n  const metaBlockType = iterator.getBits(7);\n  iterator.stopReadingBits();\n  const size = iterator.getUint24();\n  if (isLastMetadata) {\n    state.mediaSection.addMediaSection({\n      start: iterator.counter.getOffset() + size,\n      size: state.contentLength - iterator.counter.getOffset() - size\n    });\n  }\n  if (metaBlockType === flacTypes.streaminfo) {\n    return parseStreamInfo({ iterator, state });\n  }\n  if (metaBlockType === flacTypes.vorbisComment) {\n    return parseVorbisComment({ iterator, state, size });\n  }\n  return parseFlacUnkownBlock({ iterator, state, size });\n};\n\n// src/containers/flac/parse-flac.ts\nvar parseFlac = ({\n  iterator,\n  state\n}) => {\n  const mediaSectionState2 = state.mediaSection.isCurrentByteInMediaSection(iterator);\n  if (mediaSectionState2 === \"in-section\") {\n    if (maySkipVideoData({ state })) {\n      return Promise.resolve(makeSkip(state.contentLength));\n    }\n    return parseFlacFrame({ state, iterator });\n  }\n  const bytes = iterator.getByteString(4, true);\n  if (bytes === \"fLaC\") {\n    return parseFlacHeader({ state, iterator });\n  }\n  iterator.counter.decrement(4);\n  return parseMetaBlock({\n    iterator,\n    state\n  });\n};\n\n// src/state/iso-base-media/cached-sample-positions.ts\nvar calculateSamplePositions = ({\n  state,\n  mediaSectionStart,\n  trackIds\n}) => {\n  const tracks2 = getTracks(state, true);\n  const moofBoxes = getMoofBoxes(state.structure.getIsoStructure().boxes);\n  const tfraBoxes = deduplicateTfraBoxesByOffset([\n    ...state.iso.tfra.getTfraBoxes(),\n    ...getTfraBoxes(state.structure.getIsoStructure().boxes)\n  ]);\n  const moofComplete = areSamplesComplete({ moofBoxes, tfraBoxes });\n  const relevantMoofBox = moofBoxes.find((moofBox) => moofBox.offset + moofBox.size + 8 === mediaSectionStart);\n  if (moofBoxes.length > 0 && !relevantMoofBox) {\n    throw new Error(\"No relevant moof box found\");\n  }\n  const moov = getMoovBoxFromState({\n    structureState: state.structure,\n    isoState: state.iso,\n    mp4HeaderSegment: state.m3uPlaylistContext?.mp4HeaderSegment ?? null,\n    mayUsePrecomputed: true\n  });\n  if (!moov) {\n    throw new Error(\"No moov box found\");\n  }\n  const trackIdAndSamplePositions = [];\n  for (const track of tracks2) {\n    const trakBox = getTrakBoxByTrackId(moov, track.trackId);\n    if (!trackIds.includes(track.trackId)) {\n      Log.verbose(state.logLevel, \"Skipping calculating sample positions for track\", track.trackId);\n      continue;\n    }\n    if (!trakBox) {\n      throw new Error(\"No trak box found\");\n    }\n    const { samplePositions } = getSamplePositionsFromTrack({\n      trakBox,\n      moofBoxes: relevantMoofBox ? [relevantMoofBox] : [],\n      moofComplete,\n      trexBoxes: getTrexBoxes(moov)\n    });\n    trackIdAndSamplePositions.push({\n      trackId: track.trackId,\n      samplePositions\n    });\n  }\n  return trackIdAndSamplePositions;\n};\nvar updateSampleIndicesAfterSeek = ({\n  samplePositionsForMdatStart,\n  seekedByte\n}) => {\n  const currentSampleIndices = {};\n  const keys = Object.keys(samplePositionsForMdatStart).map(Number).sort();\n  const mdat = keys.find((key) => seekedByte >= key);\n  if (!mdat) {\n    return currentSampleIndices;\n  }\n  const samplePositions = samplePositionsForMdatStart[mdat];\n  if (!samplePositions) {\n    return currentSampleIndices;\n  }\n  for (const track of samplePositions) {\n    const currentSampleIndex = track.samplePositions.findIndex((sample) => sample.offset >= seekedByte);\n    if (!currentSampleIndices[mdat]) {\n      currentSampleIndices[mdat] = {};\n    }\n    if (!currentSampleIndices[mdat][track.trackId]) {\n      currentSampleIndices[mdat][track.trackId] = 0;\n    }\n    if (currentSampleIndex === -1) {\n      currentSampleIndices[mdat][track.trackId] = track.samplePositions.length;\n    } else {\n      currentSampleIndices[mdat][track.trackId] = currentSampleIndex;\n    }\n  }\n  return currentSampleIndices;\n};\nvar cachedSamplePositionsState = () => {\n  const samplePositionsForMdatStart = {};\n  let currentSampleIndex = {};\n  return {\n    getSamples: (mdatStart) => {\n      return samplePositionsForMdatStart[mdatStart] ?? null;\n    },\n    setSamples: (mdatStart, samples) => {\n      samplePositionsForMdatStart[mdatStart] = samples;\n    },\n    setCurrentSampleIndex: (mdatStart, trackId, index) => {\n      if (!currentSampleIndex[mdatStart]) {\n        currentSampleIndex[mdatStart] = {};\n      }\n      if (!currentSampleIndex[mdatStart][trackId]) {\n        currentSampleIndex[mdatStart][trackId] = 0;\n      }\n      currentSampleIndex[mdatStart][trackId] = index;\n    },\n    getCurrentSampleIndices: (mdatStart) => {\n      return currentSampleIndex[mdatStart] ?? {};\n    },\n    updateAfterSeek: (seekedByte) => {\n      currentSampleIndex = updateSampleIndicesAfterSeek({\n        samplePositionsForMdatStart,\n        seekedByte\n      });\n    }\n  };\n};\nvar getSampleWithLowestDts = (samplePositions, currentSampleIndexMap) => {\n  const lowestDts = [];\n  for (const track of samplePositions) {\n    const currentSampleIndex = currentSampleIndexMap[track.trackId] ?? 0;\n    const currentSample = track.samplePositions[currentSampleIndex];\n    if (currentSample && (lowestDts.length === 0 || currentSample.decodingTimestamp <= lowestDts[0].samplePosition.decodingTimestamp)) {\n      lowestDts.push({\n        samplePosition: currentSample,\n        trackId: track.trackId,\n        index: currentSampleIndex\n      });\n    }\n  }\n  return lowestDts;\n};\n\n// src/state/iso-base-media/last-moof-box.ts\nvar getLastMoofBox = (boxes) => {\n  if (boxes) {\n    const tfras = boxes.filter((b) => b.type === \"tfra-box\");\n    const lastMoofOffsets = tfras.map((f) => {\n      if (f.entries.length <= 1) {\n        return null;\n      }\n      return f.entries[f.entries.length - 1].moofOffset;\n    });\n    if (lastMoofOffsets.length > 0) {\n      const maxOffset = Math.max(...lastMoofOffsets.filter(truthy));\n      return maxOffset;\n    }\n    return null;\n  }\n};\nvar getMaxFirstMoofOffset = (boxes) => {\n  const tfras = boxes.filter((b) => b.type === \"tfra-box\");\n  const firstMoofOffsets = tfras.map((f) => {\n    return f.entries[0].moofOffset;\n  });\n  return Math.max(...firstMoofOffsets.filter(truthy));\n};\n\n// src/state/can-skip-tracks.ts\nvar needsTracksForField = ({\n  field,\n  structure\n}) => {\n  if (field === \"dimensions\") {\n    if (structure?.type === \"riff\") {\n      return false;\n    }\n    return true;\n  }\n  if (field === \"audioCodec\" || field === \"durationInSeconds\" || field === \"slowDurationInSeconds\" || field === \"slowFps\" || field === \"fps\" || field === \"isHdr\" || field === \"rotation\" || field === \"slowStructure\" || field === \"tracks\" || field === \"unrotatedDimensions\" || field === \"videoCodec\" || field === \"metadata\" || field === \"location\" || field === \"slowKeyframes\" || field === \"slowNumberOfFrames\" || field === \"keyframes\" || field === \"images\" || field === \"sampleRate\" || field === \"numberOfAudioChannels\" || field === \"slowAudioBitrate\" || field === \"slowVideoBitrate\" || field === \"m3uStreams\") {\n    return true;\n  }\n  if (field === \"container\" || field === \"internalStats\" || field === \"mimeType\" || field === \"name\" || field === \"size\") {\n    return false;\n  }\n  throw new Error(`field not implemeted ${field}`);\n};\nvar makeCanSkipTracksState = ({\n  hasAudioTrackHandlers,\n  fields,\n  hasVideoTrackHandlers,\n  structure\n}) => {\n  const doFieldsNeedTracks = () => {\n    const keys = Object.keys(fields ?? {});\n    const selectedKeys = keys.filter((k) => fields[k]);\n    return selectedKeys.some((k) => needsTracksForField({\n      field: k,\n      structure: structure.getStructureOrNull()\n    }));\n  };\n  return {\n    doFieldsNeedTracks,\n    canSkipTracks: () => {\n      if (hasAudioTrackHandlers || hasVideoTrackHandlers) {\n        return false;\n      }\n      return !doFieldsNeedTracks();\n    }\n  };\n};\n\n// src/state/has-tracks-section.ts\nvar makeTracksSectionState = (canSkipTracksState, src) => {\n  const tracks2 = [];\n  let doneWithTracks = false;\n  return {\n    hasAllTracks: () => doneWithTracks,\n    getIsDone: () => doneWithTracks,\n    setIsDone: (logLevel) => {\n      if (doneWithTracks) {\n        throw new Error(\"Error in Media Parser: Tracks have already been parsed\");\n      }\n      Log.verbose(logLevel, \"All tracks have been parsed\");\n      doneWithTracks = true;\n    },\n    addTrack: (track) => {\n      tracks2.push(track);\n    },\n    getTracks: () => {\n      return tracks2;\n    },\n    ensureHasTracksAtEnd: (fields) => {\n      if (canSkipTracksState.canSkipTracks()) {\n        return;\n      }\n      if (!fields.tracks) {\n        return;\n      }\n      if (!doneWithTracks) {\n        throw new Error(\"Error in Media Parser: End of parsing of \" + src + \" has been reached, but no tracks have been found \");\n      }\n    }\n  };\n};\n\n// src/state/structure.ts\nvar structureState = () => {\n  let structure = null;\n  const getStructure = () => {\n    if (structure === null) {\n      throw new Error(\"Expected structure\");\n    }\n    return structure;\n  };\n  return {\n    getStructureOrNull: () => {\n      return structure;\n    },\n    getStructure,\n    setStructure: (value) => {\n      structure = value;\n    },\n    getFlacStructure: () => {\n      const struc = getStructure();\n      if (struc.type !== \"flac\") {\n        throw new Error(\"Invalid structure type\");\n      }\n      return struc;\n    },\n    getIsoStructure: () => {\n      const struc = getStructure();\n      if (struc.type !== \"iso-base-media\") {\n        throw new Error(\"Invalid structure type\");\n      }\n      return struc;\n    },\n    getMp3Structure: () => {\n      const struc = getStructure();\n      if (struc.type !== \"mp3\") {\n        throw new Error(\"Invalid structure type\");\n      }\n      return struc;\n    },\n    getM3uStructure: () => {\n      const struc = getStructure();\n      if (struc.type !== \"m3u\") {\n        throw new Error(\"Invalid structure type\");\n      }\n      return struc;\n    },\n    getRiffStructure: () => {\n      const struc = getStructure();\n      if (struc.type !== \"riff\") {\n        throw new Error(\"Invalid structure type\");\n      }\n      return struc;\n    },\n    getTsStructure: () => {\n      const struc = getStructure();\n      if (struc.type !== \"transport-stream\") {\n        throw new Error(\"Invalid structure type\");\n      }\n      return struc;\n    },\n    getWavStructure: () => {\n      const struc = getStructure();\n      if (struc.type !== \"wav\") {\n        throw new Error(\"Invalid structure type\");\n      }\n      return struc;\n    },\n    getMatroskaStructure: () => {\n      const struc = getStructure();\n      if (struc.type !== \"matroska\") {\n        throw new Error(\"Invalid structure type\");\n      }\n      return struc;\n    }\n  };\n};\n\n// src/containers/iso-base-media/elst.ts\nvar parseElst = ({\n  iterator,\n  size,\n  offset\n}) => {\n  const { expectNoMoreBytes } = iterator.startBox(size - 8);\n  const version = iterator.getUint8();\n  const flags = iterator.getUint24();\n  const entryCount = iterator.getUint32();\n  const entries = [];\n  for (let i = 0;i < entryCount; i++) {\n    const editDuration = Number(version === 1 ? iterator.getUint64() : iterator.getUint32());\n    const mediaTime = Number(version === 1 ? iterator.getUint64() : iterator.getInt32());\n    const mediaRateInteger = iterator.getUint16();\n    const mediaRateFraction = iterator.getUint16();\n    entries.push({\n      editDuration,\n      mediaTime,\n      mediaRateInteger,\n      mediaRateFraction\n    });\n  }\n  expectNoMoreBytes();\n  const result = {\n    type: \"elst-box\",\n    version,\n    flags,\n    entries,\n    boxSize: size,\n    offset\n  };\n  return result;\n};\n\n// src/containers/iso-base-media/esds/decoder-specific-config.ts\nvar parseDecoderSpecificConfig = (iterator) => {\n  const layerTag = iterator.getUint8();\n  const layerSize = iterator.getPaddedFourByteNumber();\n  const start = iterator.counter.getOffset();\n  if (layerTag !== 5) {\n    iterator.discard(layerSize);\n    return {\n      type: \"unknown-decoder-specific-config\"\n    };\n  }\n  const bytes = iterator.getSlice(layerSize);\n  iterator.counter.decrement(layerSize);\n  iterator.startReadingBits();\n  const audioObjectType = iterator.getBits(5);\n  const samplingFrequencyIndex = iterator.getBits(4);\n  if (samplingFrequencyIndex === 15) {\n    iterator.getBits(24);\n  }\n  const channelConfiguration = iterator.getBits(4);\n  iterator.stopReadingBits();\n  const read = iterator.counter.getOffset() - start;\n  if (read < layerSize) {\n    iterator.discard(layerSize - read);\n  }\n  return {\n    type: \"mp4a-specific-config\",\n    audioObjectType,\n    samplingFrequencyIndex,\n    channelConfiguration,\n    asBytes: bytes\n  };\n};\n\n// src/containers/iso-base-media/esds/esds-descriptors.ts\nvar mapToObjectAudioIndicator = (num) => {\n  if (num === 64) {\n    return \"aac\";\n  }\n  if (num === 107) {\n    return \"mp3\";\n  }\n  return \"unknown\";\n};\nvar processDescriptor = ({\n  iterator\n}) => {\n  const tag = iterator.getUint8();\n  if (tag === 4) {\n    const size = iterator.getPaddedFourByteNumber();\n    const initialOffset = iterator.counter.getOffset();\n    const objectTypeIndication = iterator.getUint8();\n    iterator.startReadingBits();\n    const streamType = iterator.getBits(6);\n    const upStream = iterator.getBits(1);\n    iterator.getBits(1);\n    const bufferSizeDB = iterator.getBits(24);\n    iterator.stopReadingBits();\n    const maxBitrate = iterator.getUint32();\n    const avgBitrate = iterator.getUint32();\n    const decoderSpecificConfigs = [];\n    while (size - (iterator.counter.getOffset() - initialOffset) > 0) {\n      const decoderSpecificConfig = parseDecoderSpecificConfig(iterator);\n      decoderSpecificConfigs.push(decoderSpecificConfig);\n    }\n    return {\n      descriptor: {\n        type: \"decoder-config-descriptor\",\n        objectTypeIndication: mapToObjectAudioIndicator(objectTypeIndication),\n        asNumber: objectTypeIndication,\n        bufferSizeDB,\n        streamType,\n        upStream,\n        avgBitrate,\n        maxBitrate,\n        decoderSpecificConfigs\n      }\n    };\n  }\n  if (tag === 6) {\n    const size = iterator.getPaddedFourByteNumber();\n    iterator.discard(size);\n    return {\n      descriptor: {\n        type: \"sl-config-descriptor\"\n      }\n    };\n  }\n  return {\n    descriptor: null\n  };\n};\nvar parseDescriptors = (iterator, maxBytes) => {\n  const descriptors = [];\n  const initialOffset = iterator.counter.getOffset();\n  while (iterator.bytesRemaining() > 0 && iterator.counter.getOffset() - initialOffset < maxBytes) {\n    const { descriptor } = processDescriptor({\n      iterator\n    });\n    if (descriptor) {\n      descriptors.push(descriptor);\n    } else {\n      break;\n    }\n  }\n  return descriptors;\n};\n\n// src/containers/iso-base-media/esds/esds.ts\nvar parseEsds = ({\n  data,\n  size,\n  fileOffset\n}) => {\n  const version = data.getUint8();\n  data.discard(3);\n  const tag = data.getUint8();\n  const sizeOfInstance = data.getPaddedFourByteNumber();\n  const esId = data.getUint16();\n  data.discard(1);\n  const remaining = size - (data.counter.getOffset() - fileOffset);\n  const descriptors = parseDescriptors(data, remaining);\n  const remainingNow = size - (data.counter.getOffset() - fileOffset);\n  data.discard(remainingNow);\n  return {\n    type: \"esds-box\",\n    version,\n    tag,\n    sizeOfInstance,\n    esId,\n    descriptors\n  };\n};\n\n// src/containers/iso-base-media/ftyp.ts\nvar parseFtyp = ({\n  iterator,\n  size,\n  offset\n}) => {\n  const majorBrand = iterator.getByteString(4, false);\n  const minorVersion = iterator.getFourByteNumber();\n  const types = (size - iterator.counter.getOffset()) / 4;\n  const compatibleBrands = [];\n  for (let i = 0;i < types; i++) {\n    compatibleBrands.push(iterator.getByteString(4, false).trim());\n  }\n  const offsetAtEnd = iterator.counter.getOffset();\n  return {\n    type: \"ftyp-box\",\n    majorBrand,\n    minorVersion,\n    compatibleBrands,\n    offset,\n    boxSize: offsetAtEnd - offset\n  };\n};\n\n// src/containers/iso-base-media/get-children.ts\nvar getIsoBaseMediaChildren = async ({\n  size,\n  iterator,\n  logLevel,\n  onlyIfMoovAtomExpected,\n  contentLength\n}) => {\n  const boxes = [];\n  const initial = iterator.counter.getOffset();\n  while (iterator.counter.getOffset() < size + initial) {\n    const parsed = await processBox({\n      iterator,\n      logLevel,\n      onlyIfMoovAtomExpected,\n      onlyIfMdatAtomExpected: null,\n      contentLength\n    });\n    if (parsed.type !== \"box\") {\n      throw new Error(\"Expected box\");\n    }\n    boxes.push(parsed.box);\n  }\n  if (iterator.counter.getOffset() > size + initial) {\n    throw new Error(`read too many bytes - size: ${size}, read: ${iterator.counter.getOffset() - initial}. initial offset: ${initial}`);\n  }\n  return boxes;\n};\n\n// src/containers/iso-base-media/mdhd.ts\nvar parseMdhd = ({\n  data,\n  size,\n  fileOffset\n}) => {\n  const version = data.getUint8();\n  data.discard(3);\n  const creationTime = version === 1 ? Number(data.getUint64()) : data.getUint32();\n  const modificationTime = version === 1 ? Number(data.getUint64()) : data.getUint32();\n  const timescale = data.getUint32();\n  const duration2 = version === 1 ? data.getUint64() : data.getUint32();\n  const language2 = data.getUint16();\n  const quality = data.getUint16();\n  const remaining = size - (data.counter.getOffset() - fileOffset);\n  if (remaining !== 0) {\n    throw new Error(`Expected remaining bytes to be 0, got ${remaining}`);\n  }\n  return {\n    type: \"mdhd-box\",\n    duration: Number(duration2),\n    timescale,\n    version,\n    language: language2,\n    quality,\n    creationTime,\n    modificationTime\n  };\n};\n\n// src/containers/iso-base-media/meta/hdlr.ts\nvar parseHdlr = ({\n  iterator,\n  size,\n  offset\n}) => {\n  const box = iterator.startBox(size - 8);\n  const version = iterator.getUint8();\n  if (version !== 0) {\n    throw new Error(`Unsupported hdlr version: ${version}`);\n  }\n  iterator.discard(3);\n  iterator.discard(4);\n  const hdlrType = iterator.getByteString(4, false);\n  iterator.discard(4);\n  iterator.discard(4);\n  iterator.discard(4);\n  const componentName = iterator.readUntilNullTerminator();\n  box.discardRest();\n  return Promise.resolve({\n    type: \"hdlr-box\",\n    boxSize: size,\n    offset,\n    hdlrType,\n    componentName\n  });\n};\n\n// src/containers/iso-base-media/meta/ilst.ts\nvar parseFromWellKnownType = (wellKnownType, iterator, size) => {\n  if (wellKnownType === 1) {\n    const value = iterator.getByteString(size, false);\n    return { type: \"text\", value };\n  }\n  if (wellKnownType === 21) {\n    if (size === 1) {\n      return { type: \"number\", value: iterator.getInt8() };\n    }\n    if (size === 2) {\n      return { type: \"number\", value: iterator.getInt16() };\n    }\n    if (size === 3) {\n      return { type: \"number\", value: iterator.getInt24() };\n    }\n    if (size === 4) {\n      return { type: \"number\", value: iterator.getInt32() };\n    }\n    if (size === 8) {\n      return { type: \"number\", value: Number(iterator.getInt64()) };\n    }\n    throw new Error(`Weird size for number ${size}`);\n  }\n  if (wellKnownType === 22) {\n    if (size === 1) {\n      return { type: \"number\", value: iterator.getUint8() };\n    }\n    if (size === 2) {\n      return { type: \"number\", value: iterator.getUint16() };\n    }\n    if (size === 3) {\n      return { type: \"number\", value: iterator.getUint24() };\n    }\n    if (size === 4) {\n      return { type: \"number\", value: iterator.getUint32() };\n    }\n    throw new Error(`Weird size for number ${size}`);\n  }\n  if (wellKnownType === 23) {\n    if (size === 4) {\n      return { type: \"number\", value: iterator.getFloat32() };\n    }\n    if (size === 8) {\n      return { type: \"number\", value: iterator.getFloat64() };\n    }\n    throw new Error(`Weird size for number ${size}`);\n  }\n  iterator.discard(size);\n  return { type: \"unknown\", value: null };\n};\nvar parseIlstBox = ({\n  iterator,\n  size,\n  offset\n}) => {\n  const box = iterator.startBox(size - 8);\n  const entries = [];\n  while (iterator.counter.getOffset() < size + offset) {\n    const metadataSize = iterator.getUint32();\n    const index = iterator.getAtom();\n    if (!index.startsWith(\"ï¿½\") && !index.startsWith(\"\\x00\")) {\n      if (index === \"skip\") {\n        iterator.discard(metadataSize - 8);\n        continue;\n      }\n      if (index === \"----\") {\n        iterator.discard(metadataSize - 8);\n        continue;\n      }\n      iterator.discard(metadataSize - 8);\n      continue;\n    }\n    const innerSize = iterator.getUint32();\n    const type = iterator.getAtom();\n    const typeIndicator = iterator.getUint8();\n    if (typeIndicator !== 0) {\n      throw new Error(\"Expected type indicator to be 0\");\n    }\n    const wellKnownType = iterator.getUint24();\n    iterator.discard(4);\n    const value = parseFromWellKnownType(wellKnownType, iterator, innerSize - 16);\n    entries.push({ index, type, wellKnownType, value });\n  }\n  box.discardRest();\n  return {\n    type: \"ilst-box\",\n    boxSize: size,\n    offset,\n    entries\n  };\n};\n\n// src/containers/iso-base-media/mfra/tfra.ts\nvar readTrafNumber = (iterator, lengthSizeOfTrafNum) => {\n  const uintTypeTrafNum = (lengthSizeOfTrafNum + 1) * 8;\n  if (uintTypeTrafNum === 8) {\n    return iterator.getUint8();\n  }\n  if (uintTypeTrafNum === 16) {\n    return iterator.getUint16();\n  }\n  if (uintTypeTrafNum === 32) {\n    return iterator.getUint32();\n  }\n  if (uintTypeTrafNum === 64) {\n    return Number(iterator.getUint64());\n  }\n  throw new Error(\"Invalid traf number size\");\n};\nvar readTrunNumber = (iterator, lengthSizeOfTrunNum) => {\n  const uintTypeTrunNum = (lengthSizeOfTrunNum + 1) * 8;\n  if (uintTypeTrunNum === 8) {\n    return iterator.getUint8();\n  }\n  if (uintTypeTrunNum === 16) {\n    return iterator.getUint16();\n  }\n  if (uintTypeTrunNum === 32) {\n    return iterator.getUint32();\n  }\n  if (uintTypeTrunNum === 64) {\n    return Number(iterator.getUint64());\n  }\n  throw new Error(\"Invalid trun number size\");\n};\nvar readSampleNumber = (iterator, lengthSizeOfSampleNum) => {\n  const uintTypeSampleNum = (lengthSizeOfSampleNum + 1) * 8;\n  if (uintTypeSampleNum === 8) {\n    return iterator.getUint8();\n  }\n  if (uintTypeSampleNum === 16) {\n    return iterator.getUint16();\n  }\n  if (uintTypeSampleNum === 32) {\n    return iterator.getUint32();\n  }\n  if (uintTypeSampleNum === 64) {\n    return Number(iterator.getUint64());\n  }\n  throw new Error(\"Invalid sample number size\");\n};\nvar readTime = (iterator, version) => {\n  if (version === 1) {\n    return Number(iterator.getUint64());\n  }\n  return iterator.getUint32();\n};\nvar readMoofOffset = (iterator, version) => {\n  if (version === 1) {\n    return Number(iterator.getUint64());\n  }\n  return iterator.getUint32();\n};\nvar parseTfraBox = ({\n  iterator,\n  size,\n  offset\n}) => {\n  const box = iterator.startBox(size - 8);\n  const version = iterator.getUint8();\n  iterator.discard(3);\n  const trackId = iterator.getUint32();\n  iterator.getUint24();\n  const tmpByte = iterator.getUint8();\n  const lengthSizeOfTrafNum = tmpByte >> 4 & 3;\n  const lengthSizeOfTrunNum = tmpByte >> 2 & 3;\n  const lengthSizeOfSampleNum = tmpByte & 3;\n  const numberOfEntries = iterator.getUint32();\n  const entries = [];\n  for (let i = 0;i < numberOfEntries; i++) {\n    const time = readTime(iterator, version);\n    const moofOffset = readMoofOffset(iterator, version);\n    const trafNumber = readTrafNumber(iterator, lengthSizeOfTrafNum);\n    const trunNumber = readTrunNumber(iterator, lengthSizeOfTrunNum);\n    const sampleNumber = readSampleNumber(iterator, lengthSizeOfSampleNum);\n    entries.push({\n      time,\n      moofOffset,\n      trafNumber,\n      trunNumber,\n      sampleNumber\n    });\n  }\n  box.expectNoMoreBytes();\n  return {\n    offset,\n    boxSize: size,\n    type: \"tfra-box\",\n    entries,\n    trackId\n  };\n};\n\n// src/containers/iso-base-media/moov/moov.ts\nvar parseMoov = async ({\n  offset,\n  size,\n  onlyIfMoovAtomExpected,\n  iterator,\n  logLevel,\n  contentLength\n}) => {\n  const children = await getIsoBaseMediaChildren({\n    onlyIfMoovAtomExpected,\n    size: size - 8,\n    iterator,\n    logLevel,\n    contentLength\n  });\n  return {\n    offset,\n    boxSize: size,\n    type: \"moov-box\",\n    children\n  };\n};\n\n// src/containers/iso-base-media/to-date.ts\nvar toUnixTimestamp = (value) => {\n  if (value === 0) {\n    return null;\n  }\n  const baseDate = new Date(\"1904-01-01T00:00:00Z\");\n  return Math.floor(value + baseDate.getTime() / 1000) * 1000;\n};\n\n// src/containers/iso-base-media/moov/mvhd.ts\nvar parseMvhd = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const version = iterator.getUint8();\n  iterator.discard(3);\n  const creationTime = version === 1 ? iterator.getUint64() : iterator.getUint32();\n  const modificationTime = version === 1 ? iterator.getUint64() : iterator.getUint32();\n  const timeScale = iterator.getUint32();\n  const durationInUnits = version === 1 ? iterator.getUint64() : iterator.getUint32();\n  const durationInSeconds = Number(durationInUnits) / timeScale;\n  const rateArray = iterator.getSlice(4);\n  const rateView = getArrayBufferIterator({\n    initialData: rateArray,\n    maxBytes: rateArray.length,\n    logLevel: \"error\"\n  });\n  const rate = rateView.getInt8() * 10 + rateView.getInt8() + rateView.getInt8() * 0.1 + rateView.getInt8() * 0.01;\n  const volumeArray = iterator.getSlice(2);\n  const volumeView = getArrayBufferIterator({\n    initialData: volumeArray,\n    maxBytes: volumeArray.length,\n    logLevel: \"error\"\n  });\n  const volume = volumeView.getInt8() + volumeView.getInt8() * 0.1;\n  iterator.discard(2);\n  iterator.discard(4);\n  iterator.discard(4);\n  const matrix = [\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned230Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned230Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned230Number()\n  ];\n  iterator.discard(4 * 6);\n  const nextTrackId = iterator.getUint32();\n  volumeView.destroy();\n  const bytesRemaining = size - (iterator.counter.getOffset() - offset);\n  if (bytesRemaining !== 0) {\n    throw new Error(\"expected 0 bytes \" + bytesRemaining);\n  }\n  return {\n    creationTime: toUnixTimestamp(Number(creationTime)),\n    modificationTime: toUnixTimestamp(Number(modificationTime)),\n    timeScale,\n    durationInUnits: Number(durationInUnits),\n    durationInSeconds,\n    rate,\n    volume,\n    matrix,\n    nextTrackId,\n    type: \"mvhd-box\",\n    boxSize: size,\n    offset\n  };\n};\n\n// src/containers/iso-base-media/moov/trex.ts\nvar parseTrex = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const box = iterator.startBox(size - 8);\n  const version = iterator.getUint8();\n  iterator.discard(3);\n  const trackId = iterator.getUint32();\n  const defaultSampleDescriptionIndex = iterator.getUint32();\n  const defaultSampleDuration = iterator.getUint32();\n  const defaultSampleSize = iterator.getUint32();\n  const defaultSampleFlags = iterator.getUint32();\n  box.expectNoMoreBytes();\n  return {\n    type: \"trex-box\",\n    boxSize: size,\n    offset,\n    trackId,\n    version,\n    defaultSampleDescriptionIndex,\n    defaultSampleDuration,\n    defaultSampleSize,\n    defaultSampleFlags\n  };\n};\n\n// src/containers/iso-base-media/stsd/av1c.ts\nvar parseAv1C = ({\n  data,\n  size\n}) => {\n  return {\n    type: \"av1C-box\",\n    privateData: data.getSlice(size - 8)\n  };\n};\n\n// src/containers/iso-base-media/stsd/avcc.ts\nvar parseAvcc = ({\n  data,\n  size\n}) => {\n  const confVersion = data.getUint8();\n  if (confVersion !== 1) {\n    throw new Error(`Unsupported AVCC version ${confVersion}`);\n  }\n  const profile = data.getUint8();\n  const profileCompatibility = data.getUint8();\n  const level = data.getUint8();\n  const str = `${profile.toString(16).padStart(2, \"0\")}${profileCompatibility.toString(16).padStart(2, \"0\")}${level.toString(16).padStart(2, \"0\")}`;\n  data.counter.decrement(4);\n  const privateData = data.getSlice(size - 8);\n  return {\n    type: \"avcc-box\",\n    privateData,\n    configurationString: str\n  };\n};\n\n// src/containers/iso-base-media/parse-icc-profile.ts\nvar parseIccProfile = (data) => {\n  const iterator = getArrayBufferIterator({\n    initialData: data,\n    maxBytes: data.length,\n    logLevel: \"error\"\n  });\n  const size = iterator.getUint32();\n  if (size !== data.length) {\n    throw new Error(\"Invalid ICC profile size\");\n  }\n  const preferredCMMType = iterator.getByteString(4, false);\n  const profileVersion = iterator.getByteString(4, false);\n  const profileDeviceClass = iterator.getByteString(4, false);\n  const colorSpace = iterator.getByteString(4, false);\n  const pcs = iterator.getByteString(4, false);\n  const dateTime = iterator.getSlice(12);\n  const signature = iterator.getByteString(4, false);\n  if (signature !== \"acsp\") {\n    throw new Error(\"Invalid ICC profile signature\");\n  }\n  const primaryPlatform = iterator.getByteString(4, false);\n  const profileFlags = iterator.getUint32();\n  const deviceManufacturer = iterator.getByteString(4, false);\n  const deviceModel = iterator.getByteString(4, false);\n  const deviceAttributes = iterator.getUint64();\n  const renderingIntent = iterator.getUint32();\n  const pcsIlluminant1 = iterator.getUint32();\n  const pcsIlluminant2 = iterator.getUint32();\n  const pcsIlluminant3 = iterator.getUint32();\n  const profileCreator = iterator.getByteString(4, false);\n  const profileId = iterator.getByteString(16, false);\n  iterator.discard(28);\n  const tagCount = iterator.getUint32();\n  const entries = [];\n  for (let i = 0;i < tagCount; i++) {\n    const entry = {\n      tag: iterator.getByteString(4, false),\n      offset: iterator.getUint32(),\n      size: iterator.getUint32()\n    };\n    entries.push(entry);\n  }\n  let lastOffset = -1;\n  let rXYZ = null;\n  let gXYZ = null;\n  let bXYZ = null;\n  let whitePoint = null;\n  for (const entry of entries) {\n    const found = data.slice(entry.offset, entry.offset + entry.size);\n    if (entry.tag === \"rXYZ\" || entry.tag === \"gXYZ\" || entry.tag === \"bXYZ\" || entry.tag === \"wtpt\") {\n      const it = getArrayBufferIterator({\n        initialData: found,\n        maxBytes: found.length,\n        logLevel: \"error\"\n      });\n      it.discard(4);\n      const x = it.getInt32() / 65536;\n      const y = it.getInt32() / 65536;\n      const z = it.getInt32() / 65536;\n      it.destroy();\n      const point = { x, y, z };\n      if (entry.tag === \"rXYZ\") {\n        rXYZ = point;\n      } else if (entry.tag === \"gXYZ\") {\n        gXYZ = point;\n      } else if (entry.tag === \"bXYZ\") {\n        bXYZ = point;\n      } else if (entry.tag === \"wtpt\") {\n        whitePoint = point;\n      }\n    }\n    if (lastOffset !== -1) {\n      const bytesToAdvance = entry.offset - lastOffset;\n      const bytesToGoBackwards = entry.size - bytesToAdvance;\n      if (bytesToGoBackwards > 0) {\n        iterator.counter.decrement(bytesToGoBackwards);\n      }\n    }\n    lastOffset = entry.offset;\n  }\n  const profile = {\n    size,\n    preferredCMMType,\n    profileVersion,\n    profileDeviceClass,\n    colorSpace,\n    pcs,\n    dateTime,\n    signature,\n    primaryPlatform,\n    profileFlags,\n    deviceManufacturer,\n    deviceModel,\n    deviceAttributes,\n    renderingIntent,\n    pcsIlluminant: [\n      pcsIlluminant1 / 65536,\n      pcsIlluminant2 / 65536,\n      pcsIlluminant3 / 65536\n    ],\n    profileCreator,\n    profileId,\n    entries,\n    bXYZ,\n    gXYZ,\n    rXYZ,\n    whitePoint\n  };\n  iterator.destroy();\n  return profile;\n};\n\n// src/containers/iso-base-media/stsd/colr.ts\nvar parseColorParameterBox = ({\n  iterator,\n  size\n}) => {\n  const byteString = iterator.getByteString(4, false);\n  if (byteString === \"nclx\") {\n    const primaries2 = iterator.getUint16();\n    const transfer = iterator.getUint16();\n    const matrixIndex = iterator.getUint16();\n    iterator.startReadingBits();\n    const fullRangeFlag = Boolean(iterator.getBits(1));\n    iterator.stopReadingBits();\n    return {\n      type: \"colr-box\",\n      colorType: \"transfer-characteristics\",\n      fullRangeFlag,\n      matrixIndex,\n      primaries: primaries2,\n      transfer\n    };\n  }\n  if (byteString === \"nclc\") {\n    const primaries2 = iterator.getUint16();\n    const transfer = iterator.getUint16();\n    const matrixIndex = iterator.getUint16();\n    return {\n      type: \"colr-box\",\n      colorType: \"transfer-characteristics\",\n      fullRangeFlag: false,\n      matrixIndex,\n      primaries: primaries2,\n      transfer\n    };\n  }\n  if (byteString === \"prof\") {\n    const profile = iterator.getSlice(size - 12);\n    return {\n      type: \"colr-box\",\n      colorType: \"icc-profile\",\n      profile,\n      parsed: parseIccProfile(profile)\n    };\n  }\n  throw new Error(\"Unexpected box type \" + byteString);\n};\n\n// src/containers/iso-base-media/stsd/ctts.ts\nvar parseCtts = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const version = iterator.getUint8();\n  if (version !== 0 && version !== 1) {\n    throw new Error(`Unsupported CTTS version ${version}`);\n  }\n  const flags = iterator.getSlice(3);\n  const entryCount = iterator.getUint32();\n  const entries = [];\n  for (let i = 0;i < entryCount; i++) {\n    const sampleCount = iterator.getUint32();\n    const sampleOffset = iterator.getInt32();\n    entries.push({\n      sampleCount,\n      sampleOffset\n    });\n  }\n  return {\n    type: \"ctts-box\",\n    boxSize: size,\n    offset,\n    version,\n    flags: [...flags],\n    entryCount,\n    entries\n  };\n};\n\n// src/containers/iso-base-media/stsd/hvcc.ts\nvar parseHvcc = ({\n  data,\n  size,\n  offset\n}) => {\n  const privateData = data.getSlice(size - 8);\n  data.counter.decrement(size - 8);\n  const constraintString = getHvc1CodecString(data);\n  const remaining = size - (data.counter.getOffset() - offset);\n  data.discard(remaining);\n  return {\n    type: \"hvcc-box\",\n    privateData,\n    configurationString: constraintString\n  };\n};\n\n// src/containers/iso-base-media/stsd/keys.ts\nvar parseKeys = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const box = iterator.startBox(size - 8);\n  const version = iterator.getUint8();\n  iterator.discard(3);\n  const entryCount = iterator.getUint32();\n  const entries = [];\n  for (let i = 0;i < entryCount; i++) {\n    const keySize = iterator.getUint32();\n    const namespace = iterator.getAtom();\n    const value = iterator.getByteString(keySize - 8, false);\n    const entry = {\n      keySize,\n      namespace,\n      value\n    };\n    entries.push(entry);\n  }\n  box.discardRest();\n  return {\n    type: \"keys-box\",\n    boxSize: size,\n    offset,\n    version,\n    entryCount,\n    entries\n  };\n};\n\n// src/containers/iso-base-media/stsd/mebx.ts\nvar parseMebx = async ({\n  offset,\n  size,\n  iterator,\n  logLevel,\n  contentLength\n}) => {\n  iterator.discard(6);\n  const dataReferenceIndex = iterator.getUint16();\n  const children = await getIsoBaseMediaChildren({\n    iterator,\n    size: size - 8,\n    logLevel,\n    onlyIfMoovAtomExpected: null,\n    contentLength\n  });\n  return {\n    type: \"mebx-box\",\n    boxSize: size,\n    offset,\n    dataReferenceIndex,\n    format: \"mebx\",\n    children\n  };\n};\n\n// src/containers/iso-base-media/stsd/pasp.ts\nvar parsePasp = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const hSpacing = iterator.getUint32();\n  const vSpacing = iterator.getUint32();\n  const bytesRemainingInBox = size - (iterator.counter.getOffset() - offset);\n  iterator.discard(bytesRemainingInBox);\n  return {\n    type: \"pasp-box\",\n    boxSize: size,\n    offset,\n    hSpacing,\n    vSpacing\n  };\n};\n\n// src/containers/iso-base-media/stsd/stco.ts\nvar parseStco = ({\n  iterator,\n  offset,\n  size,\n  mode64Bit\n}) => {\n  const version = iterator.getUint8();\n  if (version !== 0) {\n    throw new Error(`Unsupported STSD version ${version}`);\n  }\n  const flags = iterator.getSlice(3);\n  const entryCount = iterator.getUint32();\n  const entries = [];\n  for (let i = 0;i < entryCount; i++) {\n    const bytesRemaining = size - (iterator.counter.getOffset() - offset);\n    if (bytesRemaining < 4) {\n      break;\n    }\n    entries.push(mode64Bit ? iterator.getUint64() : iterator.getUint32());\n  }\n  iterator.discard(size - (iterator.counter.getOffset() - offset));\n  return {\n    type: \"stco-box\",\n    boxSize: size,\n    offset,\n    version,\n    flags: [...flags],\n    entries,\n    entryCount\n  };\n};\n\n// src/containers/iso-base-media/stsd/stsc.ts\nvar parseStsc = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const version = iterator.getUint8();\n  if (version !== 0) {\n    throw new Error(`Unsupported STSD version ${version}`);\n  }\n  const flags = iterator.getSlice(3);\n  const entryCount = iterator.getUint32();\n  const entries = new Map;\n  for (let i = 0;i < entryCount; i++) {\n    const firstChunk = iterator.getUint32();\n    const samplesPerChunk = iterator.getUint32();\n    const sampleDescriptionIndex = iterator.getUint32();\n    if (sampleDescriptionIndex !== 1) {\n      throw new Error(`Expected sampleDescriptionIndex to be 1, but got ${sampleDescriptionIndex}`);\n    }\n    entries.set(firstChunk, samplesPerChunk);\n  }\n  return {\n    type: \"stsc-box\",\n    boxSize: size,\n    offset,\n    version,\n    flags: [...flags],\n    entryCount,\n    entries\n  };\n};\n\n// src/containers/iso-base-media/stsd/samples.ts\nvar videoTags = [\n  \"cvid\",\n  \"jpeg\",\n  \"smc \",\n  \"rle \",\n  \"rpza\",\n  \"kpcd\",\n  \"png \",\n  \"mjpa\",\n  \"mjpb\",\n  \"SVQ1\",\n  \"SVQ3\",\n  \"mp4v\",\n  \"avc1\",\n  \"dvc \",\n  \"dvcp\",\n  \"gif \",\n  \"h263\",\n  \"tiff\",\n  \"raw \",\n  \"2vuY\",\n  \"yuv2\",\n  \"v308\",\n  \"v408\",\n  \"v216\",\n  \"v410\",\n  \"v210\",\n  \"hvc1\",\n  \"hev1\",\n  \"ap4h\",\n  \"av01\",\n  \"vp08\",\n  \"vp09\"\n];\nvar audioTags = [\n  0,\n  \"NONE\",\n  \"raw \",\n  \"twos\",\n  \"sowt\",\n  \"MAC3 \",\n  \"MAC6 \",\n  \"ima4\",\n  \"fl32\",\n  \"lpcm\",\n  \"fl64\",\n  \"in24\",\n  \"in32\",\n  \"ulaw\",\n  \"alaw\",\n  1836253186,\n  1836253201,\n  \"dvca\",\n  \"QDMC\",\n  \"QDM2\",\n  \"Qclp\",\n  1836253269,\n  \".mp3\",\n  \"mp4a\",\n  \"ac-3\",\n  \"Opus\"\n];\nvar processIsoFormatBox = async ({\n  iterator,\n  logLevel,\n  contentLength\n}) => {\n  const fileOffset = iterator.counter.getOffset();\n  const bytesRemaining = iterator.bytesRemaining();\n  const boxSize = iterator.getUint32();\n  if (bytesRemaining < boxSize) {\n    throw new Error(`Expected box size of ${bytesRemaining}, got ${boxSize}`);\n  }\n  const boxFormat = iterator.getAtom();\n  const isVideo = videoTags.includes(boxFormat);\n  const isAudio = audioTags.includes(boxFormat) || audioTags.includes(Number(boxFormat));\n  iterator.discard(6);\n  const dataReferenceIndex = iterator.getUint16();\n  if (!isVideo && !isAudio) {\n    const bytesRemainingInBox = boxSize - (iterator.counter.getOffset() - fileOffset);\n    iterator.discard(bytesRemainingInBox);\n    return {\n      sample: {\n        type: \"unknown\",\n        offset: fileOffset,\n        dataReferenceIndex,\n        size: boxSize,\n        format: boxFormat\n      }\n    };\n  }\n  if (isAudio) {\n    const version = iterator.getUint16();\n    const revisionLevel = iterator.getUint16();\n    const vendor = iterator.getSlice(4);\n    if (version === 0) {\n      const numberOfChannels = iterator.getUint16();\n      const sampleSize = iterator.getUint16();\n      const compressionId = iterator.getUint16();\n      const packetSize = iterator.getUint16();\n      const sampleRate = iterator.getFixedPointUnsigned1616Number();\n      const children = await getIsoBaseMediaChildren({\n        iterator,\n        logLevel,\n        size: boxSize - (iterator.counter.getOffset() - fileOffset),\n        onlyIfMoovAtomExpected: null,\n        contentLength\n      });\n      return {\n        sample: {\n          format: boxFormat,\n          offset: fileOffset,\n          dataReferenceIndex,\n          version,\n          revisionLevel,\n          vendor: [...Array.from(new Uint8Array(vendor))],\n          size: boxSize,\n          type: \"audio\",\n          numberOfChannels,\n          sampleSize,\n          compressionId,\n          packetSize,\n          sampleRate,\n          samplesPerPacket: null,\n          bytesPerPacket: null,\n          bytesPerFrame: null,\n          bitsPerSample: null,\n          children\n        }\n      };\n    }\n    if (version === 1) {\n      const numberOfChannels = iterator.getUint16();\n      const sampleSize = iterator.getUint16();\n      const compressionId = iterator.getInt16();\n      const packetSize = iterator.getUint16();\n      const sampleRate = iterator.getFixedPointUnsigned1616Number();\n      const samplesPerPacket = iterator.getUint32();\n      const bytesPerPacket = iterator.getUint32();\n      const bytesPerFrame = iterator.getUint32();\n      const bytesPerSample = iterator.getUint32();\n      const children = await getIsoBaseMediaChildren({\n        iterator,\n        logLevel,\n        size: boxSize - (iterator.counter.getOffset() - fileOffset),\n        onlyIfMoovAtomExpected: null,\n        contentLength\n      });\n      return {\n        sample: {\n          format: boxFormat,\n          offset: fileOffset,\n          dataReferenceIndex,\n          version,\n          revisionLevel,\n          vendor: [...Array.from(new Uint8Array(vendor))],\n          size: boxSize,\n          type: \"audio\",\n          numberOfChannels,\n          sampleSize,\n          compressionId,\n          packetSize,\n          sampleRate,\n          samplesPerPacket,\n          bytesPerPacket,\n          bytesPerFrame,\n          bitsPerSample: bytesPerSample,\n          children\n        }\n      };\n    }\n    if (version === 2) {\n      iterator.getUint16();\n      const sampleSize = iterator.getUint16();\n      const compressionId = iterator.getUint16();\n      const packetSize = iterator.getUint16();\n      iterator.getFixedPointUnsigned1616Number();\n      iterator.getUint32();\n      const higherSampleRate = iterator.getFloat64();\n      const numAudioChannel = iterator.getUint32();\n      iterator.getUint32();\n      const bitsPerChannel = iterator.getUint32();\n      iterator.getUint32();\n      const bytesPerFrame = iterator.getUint32();\n      const samplesPerPacket = iterator.getUint32();\n      const children = await getIsoBaseMediaChildren({\n        iterator,\n        logLevel,\n        size: boxSize - (iterator.counter.getOffset() - fileOffset),\n        onlyIfMoovAtomExpected: null,\n        contentLength\n      });\n      return {\n        sample: {\n          format: boxFormat,\n          offset: fileOffset,\n          dataReferenceIndex,\n          version,\n          revisionLevel,\n          vendor: [...Array.from(new Uint8Array(vendor))],\n          size: boxSize,\n          type: \"audio\",\n          numberOfChannels: numAudioChannel,\n          sampleSize,\n          compressionId,\n          packetSize,\n          sampleRate: higherSampleRate,\n          samplesPerPacket,\n          bytesPerPacket: null,\n          bytesPerFrame,\n          bitsPerSample: bitsPerChannel,\n          children\n        }\n      };\n    }\n    throw new Error(`Unsupported version ${version}`);\n  }\n  if (isVideo) {\n    const version = iterator.getUint16();\n    const revisionLevel = iterator.getUint16();\n    const vendor = iterator.getSlice(4);\n    const temporalQuality = iterator.getUint32();\n    const spacialQuality = iterator.getUint32();\n    const width = iterator.getUint16();\n    const height = iterator.getUint16();\n    const horizontalResolution = iterator.getFixedPointUnsigned1616Number();\n    const verticalResolution = iterator.getFixedPointUnsigned1616Number();\n    const dataSize = iterator.getUint32();\n    const frameCountPerSample = iterator.getUint16();\n    const compressorName = iterator.getPascalString();\n    const depth = iterator.getUint16();\n    const colorTableId = iterator.getInt16();\n    const bytesRemainingInBox = boxSize - (iterator.counter.getOffset() - fileOffset);\n    const children = bytesRemainingInBox > 8 ? await getIsoBaseMediaChildren({\n      onlyIfMoovAtomExpected: null,\n      iterator,\n      logLevel,\n      size: bytesRemainingInBox,\n      contentLength\n    }) : (iterator.discard(bytesRemainingInBox), []);\n    return {\n      sample: {\n        format: boxFormat,\n        offset: fileOffset,\n        dataReferenceIndex,\n        version,\n        revisionLevel,\n        vendor: [...Array.from(new Uint8Array(vendor))],\n        size: boxSize,\n        type: \"video\",\n        width,\n        height,\n        horizontalResolutionPpi: horizontalResolution,\n        verticalResolutionPpi: verticalResolution,\n        spacialQuality,\n        temporalQuality,\n        dataSize,\n        frameCountPerSample,\n        compressorName,\n        depth,\n        colorTableId,\n        descriptors: children\n      }\n    };\n  }\n  throw new Error(`Unknown sample format ${boxFormat}`);\n};\nvar parseIsoFormatBoxes = async ({\n  maxBytes,\n  logLevel,\n  iterator,\n  contentLength\n}) => {\n  const samples = [];\n  const initialOffset = iterator.counter.getOffset();\n  while (iterator.bytesRemaining() > 0 && iterator.counter.getOffset() - initialOffset < maxBytes) {\n    const { sample } = await processIsoFormatBox({\n      iterator,\n      logLevel,\n      contentLength\n    });\n    if (sample) {\n      samples.push(sample);\n    }\n  }\n  return samples;\n};\n\n// src/containers/iso-base-media/stsd/stsd.ts\nvar parseStsd = async ({\n  offset,\n  size,\n  iterator,\n  logLevel,\n  contentLength\n}) => {\n  const version = iterator.getUint8();\n  if (version !== 0) {\n    throw new Error(`Unsupported STSD version ${version}`);\n  }\n  iterator.discard(3);\n  const numberOfEntries = iterator.getUint32();\n  const bytesRemainingInBox = size - (iterator.counter.getOffset() - offset);\n  const boxes = await parseIsoFormatBoxes({\n    maxBytes: bytesRemainingInBox,\n    logLevel,\n    iterator,\n    contentLength\n  });\n  if (boxes.length !== numberOfEntries) {\n    throw new Error(`Expected ${numberOfEntries} sample descriptions, got ${boxes.length}`);\n  }\n  return {\n    type: \"stsd-box\",\n    boxSize: size,\n    offset,\n    numberOfEntries,\n    samples: boxes\n  };\n};\n\n// src/containers/iso-base-media/stsd/stss.ts\nvar parseStss = ({\n  iterator,\n  offset,\n  boxSize\n}) => {\n  const version = iterator.getUint8();\n  if (version !== 0) {\n    throw new Error(`Unsupported STSS version ${version}`);\n  }\n  const flags = iterator.getSlice(3);\n  const sampleCount = iterator.getUint32();\n  const sampleNumber = new Set;\n  for (let i = 0;i < sampleCount; i++) {\n    sampleNumber.add(iterator.getUint32());\n  }\n  const bytesRemainingInBox = boxSize - (iterator.counter.getOffset() - offset);\n  if (bytesRemainingInBox > 0) {\n    throw new Error(`Unexpected bytes remaining in box stss`);\n  }\n  return {\n    type: \"stss-box\",\n    version,\n    flags: [...flags],\n    sampleNumber,\n    boxSize,\n    offset\n  };\n};\n\n// src/containers/iso-base-media/stsd/stsz.ts\nvar parseStsz = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const version = iterator.getUint8();\n  if (version !== 0) {\n    throw new Error(`Unsupported STSD version ${version}`);\n  }\n  const flags = iterator.getSlice(3);\n  const sampleSize = iterator.getUint32();\n  const sampleCount = iterator.getUint32();\n  if (sampleSize !== 0) {\n    return {\n      type: \"stsz-box\",\n      boxSize: size,\n      offset,\n      version,\n      flags: [...flags],\n      sampleCount,\n      countType: \"fixed\",\n      sampleSize\n    };\n  }\n  const samples = [];\n  for (let i = 0;i < sampleCount; i++) {\n    const bytesRemaining = size - (iterator.counter.getOffset() - offset);\n    if (bytesRemaining < 4) {\n      break;\n    }\n    samples.push(iterator.getUint32());\n  }\n  iterator.discard(size - (iterator.counter.getOffset() - offset));\n  return {\n    type: \"stsz-box\",\n    boxSize: size,\n    offset,\n    version,\n    flags: [...flags],\n    sampleCount,\n    countType: \"variable\",\n    entries: samples\n  };\n};\n\n// src/containers/iso-base-media/stsd/stts.ts\nvar parseStts = ({\n  data,\n  size,\n  fileOffset\n}) => {\n  const initialOffset = data.counter.getOffset();\n  const initialCounter = initialOffset - fileOffset;\n  const version = data.getUint8();\n  if (version !== 0) {\n    throw new Error(`Unsupported STTS version ${version}`);\n  }\n  data.discard(3);\n  const entryCount = data.getUint32();\n  const sampleDistributions = [];\n  for (let i = 0;i < entryCount; i++) {\n    const sampleCount = data.getUint32();\n    const sampleDelta = data.getUint32();\n    const sampleDistribution = {\n      sampleCount,\n      sampleDelta\n    };\n    sampleDistributions.push(sampleDistribution);\n  }\n  const bytesUsed = data.counter.getOffset() - initialOffset + initialCounter;\n  if (bytesUsed !== size) {\n    throw new Error(`Expected stts box to be ${size} bytes, but was ${bytesUsed} bytes`);\n  }\n  return {\n    type: \"stts-box\",\n    sampleDistribution: sampleDistributions\n  };\n};\n\n// src/containers/iso-base-media/stsd/vpcc.ts\nvar getvp09ConfigurationString = ({\n  profile,\n  level,\n  bitDepth: bitDepth2\n}) => {\n  return `${String(profile).padStart(2, \"0\")}.${String(level).padStart(2, \"0\")}.${String(bitDepth2).padStart(2, \"0\")}`;\n};\nvar parseVpcc = ({\n  data,\n  size\n}) => {\n  const box = data.startBox(size - 8);\n  const confVersion = data.getUint8();\n  if (confVersion !== 1) {\n    throw new Error(`Unsupported AVCC version ${confVersion}`);\n  }\n  data.discard(3);\n  const profile = data.getUint8();\n  const level = data.getUint8();\n  data.startReadingBits();\n  const bitDepth2 = data.getBits(4);\n  const chromaSubsampling = data.getBits(3);\n  const videoFullRangeFlag = data.getBits(1);\n  const videoColorPrimaries = data.getBits(8);\n  const videoTransferCharacteristics = data.getBits(8);\n  const videoMatrixCoefficients = data.getBits(8);\n  data.stopReadingBits();\n  const codecInitializationDataSize = data.getUint16();\n  const codecInitializationData = data.getSlice(codecInitializationDataSize);\n  box.expectNoMoreBytes();\n  return {\n    type: \"vpcc-box\",\n    profile,\n    level,\n    bitDepth: bitDepth2,\n    chromaSubsampling,\n    videoFullRangeFlag,\n    videoColorPrimaries,\n    videoTransferCharacteristics,\n    videoMatrixCoefficients,\n    codecInitializationDataSize,\n    codecInitializationData,\n    codecString: getvp09ConfigurationString({ profile, level, bitDepth: bitDepth2 })\n  };\n};\n\n// src/containers/iso-base-media/tfdt.ts\nvar parseTfdt = ({\n  iterator,\n  size,\n  offset\n}) => {\n  const version = iterator.getUint8();\n  iterator.discard(3);\n  const num = version === 0 ? iterator.getUint32() : Number(iterator.getUint64());\n  const bytesRemaining = size - (iterator.counter.getOffset() - offset);\n  if (bytesRemaining !== 0) {\n    throw new Error(\"expected 0 bytes \" + bytesRemaining);\n  }\n  return {\n    type: \"tfdt-box\",\n    version,\n    baseMediaDecodeTime: num,\n    offset\n  };\n};\n\n// src/containers/iso-base-media/tfhd.ts\nvar getTfhd = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const version = iterator.getUint8();\n  const flags = iterator.getUint24();\n  const trackId = iterator.getUint32();\n  const baseDataOffsetPresent = flags & 1;\n  const baseDataOffset = baseDataOffsetPresent ? Number(iterator.getUint64()) : 0;\n  const baseSampleDescriptionIndexPresent = flags & 2;\n  const baseSampleDescriptionIndex = baseSampleDescriptionIndexPresent ? iterator.getUint32() : 0;\n  const defaultSampleDurationPresent = flags & 8;\n  const defaultSampleDuration = defaultSampleDurationPresent ? iterator.getUint32() : 0;\n  const defaultSampleSizePresent = flags & 16;\n  const defaultSampleSize = defaultSampleSizePresent ? iterator.getUint32() : 0;\n  const defaultSampleFlagsPresent = flags & 32;\n  const defaultSampleFlags = defaultSampleFlagsPresent ? iterator.getUint32() : 0;\n  const bytesRemaining = size - (iterator.counter.getOffset() - offset);\n  if (bytesRemaining !== 0) {\n    throw new Error(\"expected 0 bytes \" + bytesRemaining);\n  }\n  return {\n    type: \"tfhd-box\",\n    version,\n    trackId,\n    baseDataOffset,\n    baseSampleDescriptionIndex,\n    defaultSampleDuration,\n    defaultSampleSize,\n    defaultSampleFlags\n  };\n};\n\n// src/containers/iso-base-media/tkhd.ts\nfunction getRotationAngleFromMatrix(matrix) {\n  const [a, b, c, d] = matrix;\n  if (a === 0 && b === 0 && c === 0 && d === 0) {\n    return 0;\n  }\n  if (Math.round(a * a + b * b) !== 1 || Math.round(c * c + d * d) !== 1) {\n    throw new Error(\"The provided matrix is not a valid rotation matrix.\");\n  }\n  const angleRadians = Math.atan2(c, a);\n  const angleDegrees = angleRadians * (180 / Math.PI);\n  return angleDegrees;\n}\nvar applyRotation = ({\n  matrix,\n  width,\n  height\n}) => {\n  const newWidth = matrix[0] * width + matrix[1] * height;\n  const newHeight = matrix[2] * width + matrix[3] * height;\n  return {\n    width: Math.abs(newWidth),\n    height: Math.abs(newHeight)\n  };\n};\nvar parseTkhd = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const version = iterator.getUint8();\n  iterator.discard(3);\n  const creationTime = version === 1 ? iterator.getUint64() : iterator.getUint32();\n  const modificationTime = version === 1 ? iterator.getUint64() : iterator.getUint32();\n  const trackId = iterator.getUint32();\n  iterator.discard(4);\n  const duration2 = version === 1 ? iterator.getUint64() : iterator.getUint32();\n  iterator.discard(4);\n  iterator.discard(4);\n  const layer = iterator.getUint16();\n  const alternateGroup = iterator.getUint16();\n  const volume = iterator.getUint16();\n  iterator.discard(2);\n  const matrix = [\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned230Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned230Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned1616Number(),\n    iterator.getFixedPointSigned230Number()\n  ];\n  const rotationMatrix = [matrix[0], matrix[1], matrix[3], matrix[4]];\n  const widthWithoutRotationApplied = iterator.getFixedPointUnsigned1616Number();\n  const heightWithoutRotationApplied = iterator.getFixedPointSigned1616Number();\n  const { width, height } = applyRotation({\n    matrix: rotationMatrix,\n    width: widthWithoutRotationApplied,\n    height: heightWithoutRotationApplied\n  });\n  const rotation = getRotationAngleFromMatrix(rotationMatrix);\n  return {\n    offset,\n    boxSize: size,\n    type: \"tkhd-box\",\n    creationTime: toUnixTimestamp(Number(creationTime)),\n    modificationTime: toUnixTimestamp(Number(modificationTime)),\n    trackId,\n    duration: Number(duration2),\n    layer,\n    alternateGroup,\n    volume,\n    matrix,\n    width,\n    height,\n    version,\n    rotation,\n    unrotatedWidth: widthWithoutRotationApplied,\n    unrotatedHeight: heightWithoutRotationApplied\n  };\n};\n\n// src/containers/iso-base-media/trak/trak.ts\nvar parseTrak = async ({\n  size,\n  offsetAtStart,\n  iterator,\n  logLevel,\n  contentLength\n}) => {\n  const children = await getIsoBaseMediaChildren({\n    onlyIfMoovAtomExpected: null,\n    size: size - 8,\n    iterator,\n    logLevel,\n    contentLength\n  });\n  return {\n    offset: offsetAtStart,\n    boxSize: size,\n    type: \"trak-box\",\n    children\n  };\n};\n\n// src/containers/iso-base-media/trun.ts\nvar parseTrun = ({\n  iterator,\n  offset,\n  size\n}) => {\n  const version = iterator.getUint8();\n  if (version !== 0 && version !== 1) {\n    throw new Error(`Unsupported TRUN version ${version}`);\n  }\n  const flags = iterator.getUint24();\n  const sampleCount = iterator.getUint32();\n  const dataOffset = flags & 1 ? iterator.getInt32() : null;\n  const firstSampleFlags = flags & 4 ? iterator.getUint32() : null;\n  const samples = [];\n  for (let i = 0;i < sampleCount; i++) {\n    const sampleDuration = flags & 256 ? iterator.getUint32() : null;\n    const sampleSize = flags & 512 ? iterator.getUint32() : null;\n    const sampleFlags = flags & 1024 ? iterator.getUint32() : null;\n    const sampleCompositionTimeOffset = flags & 2048 ? version === 0 ? iterator.getUint32() : iterator.getInt32() : null;\n    samples.push({\n      sampleDuration,\n      sampleSize,\n      sampleFlags,\n      sampleCompositionTimeOffset\n    });\n  }\n  const currentOffset = iterator.counter.getOffset();\n  const left = size - (currentOffset - offset);\n  if (left !== 0) {\n    throw new Error(`Unexpected data left in TRUN box: ${left}`);\n  }\n  return {\n    type: \"trun-box\",\n    version,\n    sampleCount,\n    dataOffset,\n    firstSampleFlags,\n    samples\n  };\n};\n\n// src/containers/iso-base-media/process-box.ts\nvar processBox = async ({\n  iterator,\n  logLevel,\n  onlyIfMoovAtomExpected,\n  onlyIfMdatAtomExpected,\n  contentLength\n}) => {\n  const fileOffset = iterator.counter.getOffset();\n  const { returnToCheckpoint } = iterator.startCheckpoint();\n  const bytesRemaining = iterator.bytesRemaining();\n  const startOff = iterator.counter.getOffset();\n  const boxSizeRaw = iterator.getFourByteNumber();\n  if (boxSizeRaw === 0) {\n    return {\n      type: \"box\",\n      box: {\n        type: \"void-box\",\n        boxSize: 0\n      }\n    };\n  }\n  if (boxSizeRaw === 1 && iterator.bytesRemaining() < 12 || iterator.bytesRemaining() < 4) {\n    iterator.counter.decrement(iterator.counter.getOffset() - fileOffset);\n    throw new Error(`Expected box size of ${bytesRemaining}, got ${boxSizeRaw}. Incomplete boxes are not allowed.`);\n  }\n  const maxSize = contentLength - startOff;\n  const boxType = iterator.getByteString(4, false);\n  const boxSizeUnlimited = boxSizeRaw === 1 ? iterator.getEightByteNumber() : boxSizeRaw;\n  const boxSize = Math.min(boxSizeUnlimited, maxSize);\n  const headerLength = iterator.counter.getOffset() - startOff;\n  if (boxType === \"mdat\") {\n    if (!onlyIfMdatAtomExpected) {\n      return { type: \"nothing\" };\n    }\n    const { mediaSectionState: mediaSectionState2 } = onlyIfMdatAtomExpected;\n    mediaSectionState2.addMediaSection({\n      size: boxSize - headerLength,\n      start: iterator.counter.getOffset()\n    });\n    return { type: \"nothing\" };\n  }\n  if (bytesRemaining < boxSize) {\n    returnToCheckpoint();\n    return {\n      type: \"fetch-more-data\",\n      bytesNeeded: makeFetchMoreData(boxSize - bytesRemaining)\n    };\n  }\n  if (boxType === \"ftyp\") {\n    return {\n      type: \"box\",\n      box: parseFtyp({ iterator, size: boxSize, offset: fileOffset })\n    };\n  }\n  if (boxType === \"elst\") {\n    return {\n      type: \"box\",\n      box: parseElst({\n        iterator,\n        size: boxSize,\n        offset: fileOffset\n      })\n    };\n  }\n  if (boxType === \"colr\") {\n    return {\n      type: \"box\",\n      box: parseColorParameterBox({\n        iterator,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"mvhd\") {\n    const mvhdBox = parseMvhd({\n      iterator,\n      offset: fileOffset,\n      size: boxSize\n    });\n    if (!onlyIfMoovAtomExpected) {\n      throw new Error(\"State is required\");\n    }\n    onlyIfMoovAtomExpected.movieTimeScaleState.setTrackTimescale(mvhdBox.timeScale);\n    return {\n      type: \"box\",\n      box: mvhdBox\n    };\n  }\n  if (boxType === \"tkhd\") {\n    return {\n      type: \"box\",\n      box: parseTkhd({ iterator, offset: fileOffset, size: boxSize })\n    };\n  }\n  if (boxType === \"trun\") {\n    return {\n      type: \"box\",\n      box: parseTrun({ iterator, offset: fileOffset, size: boxSize })\n    };\n  }\n  if (boxType === \"tfdt\") {\n    return {\n      type: \"box\",\n      box: parseTfdt({ iterator, size: boxSize, offset: fileOffset })\n    };\n  }\n  if (boxType === \"stsd\") {\n    return {\n      type: \"box\",\n      box: await parseStsd({\n        offset: fileOffset,\n        size: boxSize,\n        iterator,\n        logLevel,\n        contentLength\n      })\n    };\n  }\n  if (boxType === \"stsz\") {\n    return {\n      type: \"box\",\n      box: parseStsz({\n        iterator,\n        offset: fileOffset,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"stco\" || boxType === \"co64\") {\n    return {\n      type: \"box\",\n      box: parseStco({\n        iterator,\n        offset: fileOffset,\n        size: boxSize,\n        mode64Bit: boxType === \"co64\"\n      })\n    };\n  }\n  if (boxType === \"pasp\") {\n    return {\n      type: \"box\",\n      box: parsePasp({\n        iterator,\n        offset: fileOffset,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"stss\") {\n    return {\n      type: \"box\",\n      box: parseStss({\n        iterator,\n        offset: fileOffset,\n        boxSize\n      })\n    };\n  }\n  if (boxType === \"ctts\") {\n    return {\n      type: \"box\",\n      box: parseCtts({\n        iterator,\n        offset: fileOffset,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"stsc\") {\n    return {\n      type: \"box\",\n      box: parseStsc({\n        iterator,\n        offset: fileOffset,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"mebx\") {\n    return {\n      type: \"box\",\n      box: await parseMebx({\n        offset: fileOffset,\n        size: boxSize,\n        iterator,\n        logLevel,\n        contentLength\n      })\n    };\n  }\n  if (boxType === \"hdlr\") {\n    return {\n      type: \"box\",\n      box: await parseHdlr({ iterator, size: boxSize, offset: fileOffset })\n    };\n  }\n  if (boxType === \"keys\") {\n    return {\n      type: \"box\",\n      box: await parseKeys({ iterator, size: boxSize, offset: fileOffset })\n    };\n  }\n  if (boxType === \"ilst\") {\n    return {\n      type: \"box\",\n      box: await parseIlstBox({\n        iterator,\n        offset: fileOffset,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"tfra\") {\n    return {\n      type: \"box\",\n      box: await parseTfraBox({\n        iterator,\n        offset: fileOffset,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"moov\") {\n    if (!onlyIfMoovAtomExpected) {\n      throw new Error(\"State is required\");\n    }\n    const { tracks: tracks2, isoState } = onlyIfMoovAtomExpected;\n    if (tracks2.hasAllTracks()) {\n      iterator.discard(boxSize - 8);\n      return { type: \"nothing\" };\n    }\n    if (isoState && isoState.moov.getMoovBoxAndPrecomputed() && !isoState.moov.getMoovBoxAndPrecomputed()?.precomputed) {\n      Log.verbose(logLevel, \"Moov box already parsed, skipping\");\n      iterator.discard(boxSize - 8);\n      return { type: \"nothing\" };\n    }\n    const box = await parseMoov({\n      offset: fileOffset,\n      size: boxSize,\n      onlyIfMoovAtomExpected,\n      iterator,\n      logLevel,\n      contentLength\n    });\n    tracks2.setIsDone(logLevel);\n    return { type: \"box\", box };\n  }\n  if (boxType === \"trak\") {\n    if (!onlyIfMoovAtomExpected) {\n      throw new Error(\"State is required\");\n    }\n    const { tracks: tracks2, onAudioTrack, onVideoTrack } = onlyIfMoovAtomExpected;\n    const trakBox = await parseTrak({\n      size: boxSize,\n      offsetAtStart: fileOffset,\n      iterator,\n      logLevel,\n      contentLength\n    });\n    const movieTimeScale = onlyIfMoovAtomExpected.movieTimeScaleState.getTrackTimescale();\n    if (movieTimeScale === null) {\n      throw new Error(\"Movie timescale is not set\");\n    }\n    const editList = findTrackStartTimeInSeconds({ movieTimeScale, trakBox });\n    const transformedTrack = makeBaseMediaTrack(trakBox, editList);\n    if (transformedTrack && transformedTrack.type === \"video\") {\n      await registerVideoTrack({\n        track: transformedTrack,\n        container: \"mp4\",\n        logLevel,\n        onVideoTrack,\n        registerVideoSampleCallback: onlyIfMoovAtomExpected.registerVideoSampleCallback,\n        tracks: tracks2\n      });\n    }\n    if (transformedTrack && transformedTrack.type === \"audio\") {\n      await registerAudioTrack({\n        track: transformedTrack,\n        container: \"mp4\",\n        registerAudioSampleCallback: onlyIfMoovAtomExpected.registerAudioSampleCallback,\n        tracks: tracks2,\n        logLevel,\n        onAudioTrack\n      });\n    }\n    return { type: \"box\", box: trakBox };\n  }\n  if (boxType === \"stts\") {\n    return {\n      type: \"box\",\n      box: parseStts({\n        data: iterator,\n        size: boxSize,\n        fileOffset\n      })\n    };\n  }\n  if (boxType === \"avcC\") {\n    return {\n      type: \"box\",\n      box: parseAvcc({\n        data: iterator,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"vpcC\") {\n    return {\n      type: \"box\",\n      box: parseVpcc({ data: iterator, size: boxSize })\n    };\n  }\n  if (boxType === \"av1C\") {\n    return {\n      type: \"box\",\n      box: parseAv1C({\n        data: iterator,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"hvcC\") {\n    return {\n      type: \"box\",\n      box: parseHvcc({\n        data: iterator,\n        size: boxSize,\n        offset: fileOffset\n      })\n    };\n  }\n  if (boxType === \"tfhd\") {\n    return {\n      type: \"box\",\n      box: getTfhd({\n        iterator,\n        offset: fileOffset,\n        size: boxSize\n      })\n    };\n  }\n  if (boxType === \"mdhd\") {\n    return {\n      type: \"box\",\n      box: parseMdhd({\n        data: iterator,\n        size: boxSize,\n        fileOffset\n      })\n    };\n  }\n  if (boxType === \"esds\") {\n    return {\n      type: \"box\",\n      box: parseEsds({\n        data: iterator,\n        size: boxSize,\n        fileOffset\n      })\n    };\n  }\n  if (boxType === \"trex\") {\n    return {\n      type: \"box\",\n      box: parseTrex({ iterator, offset: fileOffset, size: boxSize })\n    };\n  }\n  if (boxType === \"moof\") {\n    await onlyIfMoovAtomExpected?.isoState?.mfra.triggerLoad();\n  }\n  if (boxType === \"mdia\" || boxType === \"minf\" || boxType === \"stbl\" || boxType === \"udta\" || boxType === \"moof\" || boxType === \"dims\" || boxType === \"meta\" || boxType === \"wave\" || boxType === \"traf\" || boxType === \"mfra\" || boxType === \"edts\" || boxType === \"mvex\" || boxType === \"stsb\") {\n    const children = await getIsoBaseMediaChildren({\n      iterator,\n      size: boxSize - 8,\n      logLevel,\n      onlyIfMoovAtomExpected,\n      contentLength\n    });\n    return {\n      type: \"box\",\n      box: {\n        type: \"regular-box\",\n        boxType,\n        boxSize,\n        children,\n        offset: fileOffset\n      }\n    };\n  }\n  iterator.discard(boxSize - 8);\n  Log.verbose(logLevel, \"Unknown ISO Base Media Box:\", boxType);\n  return {\n    type: \"box\",\n    box: {\n      type: \"regular-box\",\n      boxType,\n      boxSize,\n      children: [],\n      offset: fileOffset\n    }\n  };\n};\n\n// src/containers/iso-base-media/get-moov-atom.ts\nvar getMoovAtom = async ({\n  endOfMdat,\n  state\n}) => {\n  const headerSegment = state.m3uPlaylistContext?.mp4HeaderSegment;\n  if (headerSegment) {\n    const segment = getMoovFromFromIsoStructure(headerSegment);\n    if (!segment) {\n      throw new Error(\"No moov box found in header segment\");\n    }\n    return segment;\n  }\n  const start = Date.now();\n  Log.verbose(state.logLevel, \"Starting second fetch to get moov atom\");\n  const { reader } = await state.readerInterface.read({\n    src: state.src,\n    range: endOfMdat,\n    controller: state.controller,\n    logLevel: state.logLevel,\n    prefetchCache: state.prefetchCache\n  });\n  const onAudioTrack = state.onAudioTrack ? async ({ track, container }) => {\n    await registerAudioTrack({\n      track,\n      container,\n      logLevel: state.logLevel,\n      onAudioTrack: state.onAudioTrack,\n      registerAudioSampleCallback: state.callbacks.registerAudioSampleCallback,\n      tracks: state.callbacks.tracks\n    });\n    return null;\n  } : null;\n  const onVideoTrack = state.onVideoTrack ? async ({ track, container }) => {\n    await registerVideoTrack({\n      track,\n      container,\n      logLevel: state.logLevel,\n      onVideoTrack: state.onVideoTrack,\n      registerVideoSampleCallback: state.callbacks.registerVideoSampleCallback,\n      tracks: state.callbacks.tracks\n    });\n    return null;\n  } : null;\n  const iterator = getArrayBufferIterator({\n    initialData: new Uint8Array([]),\n    maxBytes: state.contentLength - endOfMdat,\n    logLevel: \"error\"\n  });\n  while (true) {\n    const result = await reader.reader.read();\n    if (result.value) {\n      iterator.addData(result.value);\n    }\n    if (result.done) {\n      break;\n    }\n  }\n  const boxes = [];\n  const canSkipTracksState = makeCanSkipTracksState({\n    hasAudioTrackHandlers: false,\n    fields: { slowStructure: true },\n    hasVideoTrackHandlers: false,\n    structure: structureState()\n  });\n  const tracksState = makeTracksSectionState(canSkipTracksState, state.src);\n  while (true) {\n    const box = await processBox({\n      iterator,\n      logLevel: state.logLevel,\n      onlyIfMoovAtomExpected: {\n        tracks: tracksState,\n        isoState: null,\n        movieTimeScaleState: state.iso.movieTimeScale,\n        onAudioTrack,\n        onVideoTrack,\n        registerVideoSampleCallback: () => Promise.resolve(),\n        registerAudioSampleCallback: () => Promise.resolve()\n      },\n      onlyIfMdatAtomExpected: null,\n      contentLength: state.contentLength - endOfMdat\n    });\n    if (box.type === \"box\") {\n      boxes.push(box.box);\n    }\n    if (iterator.counter.getOffset() + endOfMdat > state.contentLength) {\n      throw new Error(\"Read past end of file\");\n    }\n    if (iterator.counter.getOffset() + endOfMdat === state.contentLength) {\n      break;\n    }\n  }\n  const moov = boxes.find((b) => b.type === \"moov-box\");\n  if (!moov) {\n    throw new Error(\"No moov box found\");\n  }\n  Log.verbose(state.logLevel, `Finished fetching moov atom in ${Date.now() - start}ms`);\n  return moov;\n};\n\n// src/containers/iso-base-media/mdat/postprocess-bytes.ts\nvar postprocessBytes = ({\n  bytes,\n  bigEndian,\n  chunkSize\n}) => {\n  if (!bigEndian) {\n    return bytes;\n  }\n  if (chunkSize === null) {\n    return bytes;\n  }\n  const newBuffer = new Uint8Array(bytes);\n  for (let i = 0;i < newBuffer.length; i += chunkSize) {\n    const slice = newBuffer.slice(i, i + chunkSize);\n    slice.reverse();\n    newBuffer.set(slice, i);\n  }\n  return newBuffer;\n};\n\n// src/containers/iso-base-media/mdat/mdat.ts\nvar parseMdatSection = async (state) => {\n  const mediaSection = getCurrentMediaSection({\n    offset: state.iterator.counter.getOffset(),\n    mediaSections: state.mediaSection.getMediaSections()\n  });\n  if (!mediaSection) {\n    throw new Error(\"No video section defined\");\n  }\n  const endOfMdat = mediaSection.size + mediaSection.start;\n  if (maySkipVideoData({ state })) {\n    const mfra = state.iso.mfra.getIfAlreadyLoaded();\n    if (mfra) {\n      const lastMoof = getLastMoofBox(mfra);\n      if (lastMoof && lastMoof > endOfMdat) {\n        Log.verbose(state.logLevel, \"Skipping to last moof\", lastMoof);\n        return makeSkip(lastMoof);\n      }\n    }\n    return makeSkip(endOfMdat);\n  }\n  if (maySkipOverSamplesInTheMiddle({ state })) {\n    const mfra = state.iso.mfra.getIfAlreadyLoaded();\n    if (mfra) {\n      const lastMoof = getLastMoofBox(mfra);\n      const firstMax = getMaxFirstMoofOffset(mfra);\n      const mediaSectionsBiggerThanMoof = state.mediaSection.getMediaSections().filter((m) => m.start > firstMax).length;\n      if (mediaSectionsBiggerThanMoof > 1 && lastMoof && lastMoof > endOfMdat) {\n        Log.verbose(state.logLevel, \"Skipping to last moof because only first and last samples are needed\");\n        return makeSkip(lastMoof);\n      }\n    }\n  }\n  const alreadyHasMoov = getHasTracks(state, true);\n  if (!alreadyHasMoov) {\n    const moov = await getMoovAtom({\n      endOfMdat,\n      state\n    });\n    const tracksFromMoov = getTracksFromMoovBox(moov);\n    state.iso.moov.setMoovBox({\n      moovBox: moov,\n      precomputed: false\n    });\n    const existingTracks = state.callbacks.tracks.getTracks();\n    for (const trackFromMoov of tracksFromMoov) {\n      if (existingTracks.find((t) => t.trackId === trackFromMoov.trackId)) {\n        continue;\n      }\n      if (trackFromMoov.type === \"other\") {\n        continue;\n      }\n      state.callbacks.tracks.addTrack(trackFromMoov);\n    }\n    state.callbacks.tracks.setIsDone(state.logLevel);\n    state.structure.getIsoStructure().boxes.push(moov);\n    return parseMdatSection(state);\n  }\n  const tracks2 = state.callbacks.tracks.getTracks();\n  if (!state.iso.flatSamples.getSamples(mediaSection.start)) {\n    const samplePosition = calculateSamplePositions({\n      state,\n      mediaSectionStart: mediaSection.start,\n      trackIds: tracks2.map((t) => t.trackId)\n    });\n    state.iso.flatSamples.setSamples(mediaSection.start, samplePosition);\n  }\n  const samplePositions = state.iso.flatSamples.getSamples(mediaSection.start);\n  const sampleIndices = state.iso.flatSamples.getCurrentSampleIndices(mediaSection.start);\n  const nextSampleArray = getSampleWithLowestDts(samplePositions, sampleIndices);\n  if (nextSampleArray.length === 0) {\n    Log.verbose(state.logLevel, \"Iterated over all samples.\", endOfMdat);\n    return makeSkip(endOfMdat);\n  }\n  const exactMatch = nextSampleArray.find((s) => s.samplePosition.offset === state.iterator.counter.getOffset());\n  const nextSample = exactMatch ?? nextSampleArray[0];\n  if (nextSample.samplePosition.offset !== state.iterator.counter.getOffset()) {\n    return makeSkip(nextSample.samplePosition.offset);\n  }\n  if (nextSample.samplePosition.offset + nextSample.samplePosition.size > state.contentLength) {\n    Log.verbose(state.logLevel, \"Sample is beyond the end of the file. Don't process it.\", nextSample.samplePosition.offset + nextSample.samplePosition.size, endOfMdat);\n    return makeSkip(endOfMdat);\n  }\n  const { iterator } = state;\n  if (iterator.bytesRemaining() < nextSample.samplePosition.size) {\n    return makeFetchMoreData(nextSample.samplePosition.size - iterator.bytesRemaining());\n  }\n  const {\n    timestamp: rawCts,\n    decodingTimestamp: rawDts,\n    duration: duration2,\n    isKeyframe,\n    offset,\n    bigEndian,\n    chunkSize\n  } = nextSample.samplePosition;\n  const track = tracks2.find((t) => t.trackId === nextSample.trackId);\n  const {\n    originalTimescale,\n    startInSeconds,\n    trackMediaTimeOffsetInTrackTimescale,\n    timescale: trackTimescale\n  } = track;\n  const cts = rawCts + startInSeconds * originalTimescale - trackMediaTimeOffsetInTrackTimescale / trackTimescale * WEBCODECS_TIMESCALE;\n  const dts = rawDts + startInSeconds * originalTimescale - trackMediaTimeOffsetInTrackTimescale / trackTimescale * WEBCODECS_TIMESCALE;\n  const bytes = postprocessBytes({\n    bytes: iterator.getSlice(nextSample.samplePosition.size),\n    bigEndian,\n    chunkSize\n  });\n  if (track.type === \"audio\") {\n    const audioSample = convertAudioOrVideoSampleToWebCodecsTimestamps({\n      sample: {\n        data: bytes,\n        timestamp: cts,\n        duration: duration2,\n        decodingTimestamp: dts,\n        type: isKeyframe ? \"key\" : \"delta\",\n        offset\n      },\n      timescale: originalTimescale\n    });\n    await state.callbacks.onAudioSample({\n      audioSample,\n      trackId: track.trackId\n    });\n  }\n  if (track.type === \"video\") {\n    const nalUnitType = bytes[4] & 31;\n    let isRecoveryPoint = false;\n    if (nalUnitType === 6) {\n      const seiType = bytes[5];\n      isRecoveryPoint = seiType === 6;\n    }\n    const videoSample = convertAudioOrVideoSampleToWebCodecsTimestamps({\n      sample: {\n        data: bytes,\n        timestamp: cts,\n        duration: duration2,\n        decodingTimestamp: dts,\n        type: isKeyframe && !isRecoveryPoint ? \"key\" : \"delta\",\n        offset\n      },\n      timescale: originalTimescale\n    });\n    await state.callbacks.onVideoSample({\n      videoSample,\n      trackId: track.trackId\n    });\n  }\n  state.iso.flatSamples.setCurrentSampleIndex(mediaSection.start, nextSample.trackId, nextSample.index + 1);\n  return null;\n};\n\n// src/containers/iso-base-media/parse-boxes.ts\nvar parseIsoBaseMedia = async (state) => {\n  const mediaSectionState2 = state.mediaSection.isCurrentByteInMediaSection(state.iterator);\n  if (mediaSectionState2 === \"in-section\") {\n    const skipTo = await parseMdatSection(state);\n    return skipTo;\n  }\n  const result = await processBox({\n    iterator: state.iterator,\n    logLevel: state.logLevel,\n    onlyIfMoovAtomExpected: {\n      tracks: state.callbacks.tracks,\n      isoState: state.iso,\n      movieTimeScaleState: state.iso.movieTimeScale,\n      onAudioTrack: state.onAudioTrack,\n      onVideoTrack: state.onVideoTrack,\n      registerAudioSampleCallback: state.callbacks.registerAudioSampleCallback,\n      registerVideoSampleCallback: state.callbacks.registerVideoSampleCallback\n    },\n    onlyIfMdatAtomExpected: {\n      mediaSectionState: state.mediaSection\n    },\n    contentLength: state.contentLength\n  });\n  if (result.type === \"fetch-more-data\") {\n    return result.bytesNeeded;\n  }\n  if (result.type === \"box\") {\n    state.structure.getIsoStructure().boxes.push(result.box);\n  }\n  return null;\n};\n\n// src/containers/m3u/parse-stream-inf.ts\nfunction splitRespectingQuotes(input) {\n  const result = [];\n  let currentPart = \"\";\n  let insideQuote = false;\n  for (let i = 0;i < input.length; i++) {\n    const char = input[i];\n    if (char === '\"') {\n      insideQuote = !insideQuote;\n      currentPart += char;\n    } else if (char === \",\" && !insideQuote) {\n      result.push(currentPart);\n      currentPart = \"\";\n    } else {\n      currentPart += char;\n    }\n  }\n  if (currentPart) {\n    result.push(currentPart);\n  }\n  return result;\n}\nvar parseStreamInf = (str) => {\n  const quotes = splitRespectingQuotes(str);\n  const map = {};\n  for (const quote of quotes) {\n    const firstColon = quote.indexOf(\"=\");\n    const key = firstColon === -1 ? quote : quote.slice(0, firstColon);\n    const value = firstColon === -1 ? null : quote.slice(firstColon + 1);\n    if (value === null) {\n      throw new Error(\"Value is null\");\n    }\n    const actualValue = value?.startsWith('\"') && value?.endsWith('\"') ? value.slice(1, -1) : value;\n    map[key] = actualValue;\n  }\n  return {\n    type: \"m3u-stream-info\",\n    averageBandwidthInBitsPerSec: map[\"AVERAGE-BANDWIDTH\"] ? parseInt(map[\"AVERAGE-BANDWIDTH\"], 10) : null,\n    bandwidthInBitsPerSec: map.BANDWIDTH ? parseInt(map.BANDWIDTH, 10) : null,\n    codecs: map.CODECS ? map.CODECS.split(\",\") : null,\n    dimensions: map.RESOLUTION ? {\n      width: parseInt(map.RESOLUTION.split(\"x\")[0], 10),\n      height: parseInt(map.RESOLUTION.split(\"x\")[1], 10)\n    } : null,\n    audio: map.AUDIO || null\n  };\n};\n\n// src/containers/m3u/parse-m3u-media-directive.ts\nvar parseM3uKeyValue = (str) => {\n  const quotes = splitRespectingQuotes(str);\n  const map = {};\n  for (const quote of quotes) {\n    const firstColon = quote.indexOf(\"=\");\n    const key = firstColon === -1 ? quote : quote.slice(0, firstColon);\n    const value = firstColon === -1 ? null : quote.slice(firstColon + 1);\n    if (value === null) {\n      throw new Error(\"Value is null\");\n    }\n    const actualValue = value?.startsWith('\"') && value?.endsWith('\"') ? value.slice(1, -1) : value;\n    map[key] = actualValue;\n  }\n  return map;\n};\nvar parseM3uMediaDirective = (str) => {\n  const map = parseM3uKeyValue(str);\n  return {\n    type: \"m3u-media-info\",\n    autoselect: map.AUTOSELECT === \"YES\",\n    channels: map.CHANNELS ? parseInt(map.CHANNELS, 10) : null,\n    default: map.DEFAULT === \"YES\",\n    groupId: map[\"GROUP-ID\"],\n    language: map.LANGUAGE || null,\n    name: map.NAME || null,\n    uri: map.URI,\n    mediaType: map.TYPE || null\n  };\n};\n\n// src/containers/m3u/parse-directive.ts\nvar parseM3uDirective = (str) => {\n  const firstColon = str.indexOf(\":\");\n  const directive = (firstColon === -1 ? str : str.slice(0, firstColon)).trim();\n  const value = firstColon === -1 ? null : str.slice(firstColon + 1);\n  if (directive === \"#EXT-X-VERSION\") {\n    if (!value) {\n      throw new Error(\"EXT-X-VERSION directive must have a value\");\n    }\n    return {\n      type: \"m3u-version\",\n      version: value\n    };\n  }\n  if (directive === \"#EXT-X-INDEPENDENT-SEGMENTS\") {\n    return {\n      type: \"m3u-independent-segments\"\n    };\n  }\n  if (directive === \"#EXT-X-MEDIA\") {\n    if (!value) {\n      throw new Error(\"EXT-X-MEDIA directive must have a value\");\n    }\n    const parsed = parseM3uMediaDirective(value);\n    return parsed;\n  }\n  if (directive === \"#EXT-X-TARGETDURATION\") {\n    if (!value) {\n      throw new Error(\"EXT-X-TARGETDURATION directive must have a value\");\n    }\n    return {\n      type: \"m3u-target-duration\",\n      duration: parseFloat(value)\n    };\n  }\n  if (directive === \"#EXTINF\") {\n    if (!value) {\n      throw new Error(\"EXTINF has no value\");\n    }\n    return {\n      type: \"m3u-extinf\",\n      value: parseFloat(value)\n    };\n  }\n  if (directive === \"#EXT-X-ENDLIST\") {\n    return {\n      type: \"m3u-endlist\"\n    };\n  }\n  if (directive === \"#EXT-X-PLAYLIST-TYPE\") {\n    if (!value) {\n      throw new Error(\"#EXT-X-PLAYLIST-TYPE. directive must have a value\");\n    }\n    return {\n      type: \"m3u-playlist-type\",\n      playlistType: value\n    };\n  }\n  if (directive === \"#EXT-X-MEDIA-SEQUENCE\") {\n    if (!value) {\n      throw new Error(\"#EXT-X-MEDIA-SEQUENCE directive must have a value\");\n    }\n    return {\n      type: \"m3u-media-sequence\",\n      value: Number(value)\n    };\n  }\n  if (directive === \"#EXT-X-DISCONTINUITY-SEQUENCE\") {\n    if (!value) {\n      throw new Error(\"#EXT-X-DISCONTINUITY-SEQUENCE directive must have a value\");\n    }\n    return {\n      type: \"m3u-discontinuity-sequence\",\n      value: Number(value)\n    };\n  }\n  if (directive === \"#EXT-X-STREAM-INF\") {\n    if (!value) {\n      throw new Error(\"EXT-X-STREAM-INF directive must have a value\");\n    }\n    const res = parseStreamInf(value);\n    return res;\n  }\n  if (directive === \"#EXT-X-I-FRAME-STREAM-INF\") {\n    return {\n      type: \"m3u-i-frame-stream-info\"\n    };\n  }\n  if (directive === \"#EXT-X-ALLOW-CACHE\") {\n    if (!value) {\n      throw new Error(\"#EXT-X-ALLOW-CACHE directive must have a value\");\n    }\n    return {\n      type: \"m3u-allow-cache\",\n      allowsCache: value === \"YES\"\n    };\n  }\n  if (directive === \"#EXT-X-MAP\") {\n    if (!value) {\n      throw new Error(\"#EXT-X-MAP directive must have a value\");\n    }\n    const p = parseM3uKeyValue(value);\n    if (!p.URI) {\n      throw new Error(\"EXT-X-MAP directive must have a URI\");\n    }\n    return {\n      type: \"m3u-map\",\n      value: p.URI\n    };\n  }\n  throw new Error(`Unknown directive ${directive}. Value: ${value}`);\n};\n\n// src/containers/m3u/parse-m3u8-text.ts\nvar parseM3u8Text = (line, boxes) => {\n  if (line === \"#EXTM3U\") {\n    boxes.push({\n      type: \"m3u-header\"\n    });\n    return;\n  }\n  if (line.startsWith(\"#\")) {\n    boxes.push(parseM3uDirective(line));\n    return;\n  }\n  if (line.trim()) {\n    boxes.push({\n      type: \"m3u-text-value\",\n      value: line\n    });\n  }\n};\n\n// src/containers/m3u/fetch-m3u8-stream.ts\nvar fetchM3u8Stream = async ({\n  url,\n  readerInterface\n}) => {\n  const text = await readerInterface.readWholeAsText(url);\n  const lines = text.split(`\n`);\n  const boxes = [];\n  for (const line of lines) {\n    parseM3u8Text(line.trim(), boxes);\n  }\n  return boxes;\n};\n\n// src/containers/m3u/after-manifest-fetch.ts\nvar afterManifestFetch = async ({\n  structure,\n  m3uState,\n  src,\n  selectM3uStreamFn,\n  logLevel,\n  selectAssociatedPlaylistsFn,\n  readerInterface,\n  onAudioTrack,\n  canSkipTracks\n}) => {\n  const independentSegments = isIndependentSegments(structure);\n  if (!independentSegments) {\n    if (!src) {\n      throw new Error(\"No src\");\n    }\n    m3uState.setSelectedMainPlaylist({\n      type: \"initial-url\",\n      url: src\n    });\n    return m3uState.setReadyToIterateOverM3u();\n  }\n  const streams = getM3uStreams({ structure, originalSrc: src, readerInterface });\n  if (streams === null) {\n    throw new Error(\"No streams found\");\n  }\n  const selectedPlaylist = await selectStream({ streams, fn: selectM3uStreamFn });\n  if (!selectedPlaylist.dimensions) {\n    throw new Error(\"Stream does not have a resolution\");\n  }\n  m3uState.setSelectedMainPlaylist({\n    type: \"selected-stream\",\n    stream: selectedPlaylist\n  });\n  const skipAudioTracks = onAudioTrack === null && canSkipTracks.doFieldsNeedTracks() === false;\n  const associatedPlaylists = await selectAssociatedPlaylists({\n    playlists: selectedPlaylist.associatedPlaylists,\n    fn: selectAssociatedPlaylistsFn,\n    skipAudioTracks\n  });\n  m3uState.setAssociatedPlaylists(associatedPlaylists);\n  const playlistUrls = [\n    selectedPlaylist.src,\n    ...associatedPlaylists.map((p) => p.src)\n  ];\n  const struc = await Promise.all(playlistUrls.map(async (url) => {\n    Log.verbose(logLevel, `Fetching playlist ${url}`);\n    const boxes = await fetchM3u8Stream({ url, readerInterface });\n    return {\n      type: \"m3u-playlist\",\n      boxes,\n      src: url\n    };\n  }));\n  structure.boxes.push(...struc);\n  m3uState.setReadyToIterateOverM3u();\n};\n\n// src/containers/m3u/parse-m3u-manifest.ts\nvar parseM3uManifest = ({\n  iterator,\n  structure,\n  contentLength\n}) => {\n  const start = iterator.startCheckpoint();\n  const line = iterator.readUntilLineEnd();\n  if (iterator.counter.getOffset() > contentLength) {\n    throw new Error(\"Unexpected end of file\");\n  }\n  if (line === null) {\n    start.returnToCheckpoint();\n    return Promise.resolve(null);\n  }\n  parseM3u8Text(line.trim(), structure.boxes);\n  return Promise.resolve(null);\n};\n\n// src/forward-controller-pause-resume-abort.ts\nvar forwardMediaParserControllerPauseResume = ({\n  parentController,\n  childController\n}) => {\n  const onAbort = ({ detail }) => {\n    childController.abort(detail.reason);\n  };\n  const onResume = () => {\n    childController.resume();\n  };\n  const onPause = () => {\n    childController.pause();\n  };\n  parentController.addEventListener(\"abort\", onAbort);\n  parentController.addEventListener(\"resume\", onResume);\n  parentController.addEventListener(\"pause\", onPause);\n  return {\n    cleanup: () => {\n      parentController.removeEventListener(\"abort\", onAbort);\n      parentController.removeEventListener(\"resume\", onResume);\n      parentController.removeEventListener(\"pause\", onPause);\n    }\n  };\n};\n// src/parse-media.ts\nvar parseMedia = (options) => {\n  if (!options) {\n    return Promise.reject(new Error(\"No options provided. See https://www.remotion.dev/media-parser for how to get started.\"));\n  }\n  return internalParseMedia({\n    fields: options.fields ?? null,\n    logLevel: options.logLevel ?? \"info\",\n    onAudioCodec: options.onAudioCodec ?? null,\n    onAudioTrack: options.onAudioTrack ?? null,\n    onContainer: options.onContainer ?? null,\n    onDimensions: options.onDimensions ?? null,\n    onDurationInSeconds: options.onDurationInSeconds ?? null,\n    onFps: options.onFps ?? null,\n    onImages: options.onImages ?? null,\n    onInternalStats: options.onInternalStats ?? null,\n    onIsHdr: options.onIsHdr ?? null,\n    onKeyframes: options.onKeyframes ?? null,\n    onLocation: options.onLocation ?? null,\n    onMetadata: options.onMetadata ?? null,\n    onMimeType: options.onMimeType ?? null,\n    onName: options.onName ?? null,\n    onNumberOfAudioChannels: options.onNumberOfAudioChannels ?? null,\n    onParseProgress: options.onParseProgress ?? null,\n    onRotation: options.onRotation ?? null,\n    onSampleRate: options.onSampleRate ?? null,\n    onSize: options.onSize ?? null,\n    onSlowAudioBitrate: options.onSlowAudioBitrate ?? null,\n    onSlowDurationInSeconds: options.onSlowDurationInSeconds ?? null,\n    onSlowFps: options.onSlowFps ?? null,\n    onSlowKeyframes: options.onSlowKeyframes ?? null,\n    onSlowNumberOfFrames: options.onSlowNumberOfFrames ?? null,\n    onSlowVideoBitrate: options.onSlowVideoBitrate ?? null,\n    onSlowStructure: options.onSlowStructure ?? null,\n    onM3uStreams: options.onM3uStreams ?? null,\n    onTracks: options.onTracks ?? null,\n    onUnrotatedDimensions: options.onUnrotatedDimensions ?? null,\n    onVideoCodec: options.onVideoCodec ?? null,\n    onVideoTrack: options.onVideoTrack ?? null,\n    progressIntervalInMs: options.progressIntervalInMs ?? null,\n    reader: options.reader ?? webReader,\n    controller: options.controller ?? undefined,\n    selectM3uStream: options.selectM3uStream ?? defaultSelectM3uStreamFn,\n    selectM3uAssociatedPlaylists: options.selectM3uAssociatedPlaylists ?? defaultSelectM3uAssociatedPlaylists,\n    m3uPlaylistContext: options.m3uPlaylistContext ?? null,\n    src: options.src,\n    mode: \"query\",\n    onDiscardedData: null,\n    onError: () => ({ action: \"fail\" }),\n    acknowledgeRemotionLicense: Boolean(options.acknowledgeRemotionLicense),\n    apiName: \"parseMedia()\",\n    makeSamplesStartAtZero: options.makeSamplesStartAtZero ?? true,\n    seekingHints: options.seekingHints ?? null\n  });\n};\n\n// src/containers/m3u/first-sample-in-m3u-chunk.ts\nvar considerSeekBasedOnChunk = async ({\n  sample,\n  parentController,\n  childController,\n  callback,\n  m3uState,\n  playlistUrl,\n  subtractChunks,\n  chunkIndex\n}) => {\n  const pendingSeek = m3uState.getSeekToSecondsToProcess(playlistUrl);\n  if (pendingSeek === null) {\n    await callback(sample);\n    return;\n  }\n  const timestamp = Math.min(sample.decodingTimestamp / WEBCODECS_TIMESCALE, sample.timestamp / WEBCODECS_TIMESCALE);\n  if (timestamp > pendingSeek.targetTime && chunkIndex !== null && chunkIndex > 0) {\n    m3uState.setNextSeekShouldSubtractChunks(playlistUrl, subtractChunks + 1);\n    parentController.seek(pendingSeek.targetTime);\n    return;\n  }\n  childController.seek(pendingSeek.targetTime);\n  m3uState.setNextSeekShouldSubtractChunks(playlistUrl, 0);\n  m3uState.setSeekToSecondsToProcess(playlistUrl, null);\n};\n\n// src/containers/m3u/get-chunks.ts\nvar getChunks = (playlist) => {\n  const chunks = [];\n  for (let i = 0;i < playlist.boxes.length; i++) {\n    const box = playlist.boxes[i];\n    if (box.type === \"m3u-map\") {\n      chunks.push({ duration: 0, url: box.value, isHeader: true });\n      continue;\n    }\n    if (box.type === \"m3u-extinf\") {\n      const nextBox = playlist.boxes[i + 1];\n      i++;\n      if (nextBox.type !== \"m3u-text-value\") {\n        throw new Error(\"Expected m3u-text-value\");\n      }\n      chunks.push({ duration: box.value, url: nextBox.value, isHeader: false });\n    }\n    continue;\n  }\n  return chunks;\n};\n\n// src/containers/m3u/seek/get-chunk-to-seek-to.ts\nvar getChunkToSeekTo = ({\n  chunks,\n  seekToSecondsToProcess\n}) => {\n  let duration2 = 0;\n  for (let i = 0;i < chunks.length; i++) {\n    if (duration2 >= seekToSecondsToProcess) {\n      return Math.max(0, i - 1);\n    }\n    duration2 += chunks[i].duration;\n  }\n  return Math.max(0, chunks.length - 1);\n};\n\n// src/containers/m3u/process-m3u-chunk.ts\nvar processM3uChunk = ({\n  playlistUrl,\n  state,\n  structure,\n  audioDone,\n  videoDone\n}) => {\n  const { promise, reject, resolve } = withResolvers();\n  const onGlobalAudioTrack = audioDone ? null : async (track) => {\n    const existingTracks = state.callbacks.tracks.getTracks();\n    let { trackId } = track;\n    while (existingTracks.find((t) => t.trackId === trackId)) {\n      trackId++;\n    }\n    const onAudioSample = await registerAudioTrack({\n      container: \"m3u8\",\n      track: {\n        ...track,\n        trackId\n      },\n      registerAudioSampleCallback: state.callbacks.registerAudioSampleCallback,\n      tracks: state.callbacks.tracks,\n      logLevel: state.logLevel,\n      onAudioTrack: state.onAudioTrack\n    });\n    state.m3u.sampleSorter.addToStreamWithTrack(playlistUrl);\n    if (onAudioSample === null) {\n      return null;\n    }\n    state.m3u.sampleSorter.addAudioStreamToConsider(playlistUrl, onAudioSample);\n    return async (sample) => {\n      await state.m3u.sampleSorter.addAudioSample(playlistUrl, sample);\n    };\n  };\n  const onGlobalVideoTrack = videoDone ? null : async (track) => {\n    const existingTracks = state.callbacks.tracks.getTracks();\n    let { trackId } = track;\n    while (existingTracks.find((t) => t.trackId === trackId)) {\n      trackId++;\n    }\n    const onVideoSample = await registerVideoTrack({\n      container: \"m3u8\",\n      track: {\n        ...track,\n        trackId\n      },\n      logLevel: state.logLevel,\n      onVideoTrack: state.onVideoTrack,\n      registerVideoSampleCallback: state.callbacks.registerVideoSampleCallback,\n      tracks: state.callbacks.tracks\n    });\n    state.m3u.sampleSorter.addToStreamWithTrack(playlistUrl);\n    if (onVideoSample === null) {\n      return null;\n    }\n    state.m3u.sampleSorter.addVideoStreamToConsider(playlistUrl, onVideoSample);\n    return async (sample) => {\n      await state.m3u.sampleSorter.addVideoSample(playlistUrl, sample);\n    };\n  };\n  const pausableIterator = async () => {\n    const playlist = getPlaylist(structure, playlistUrl);\n    const chunks = getChunks(playlist);\n    const seekToSecondsToProcess = state.m3u.getSeekToSecondsToProcess(playlistUrl);\n    const chunksToSubtract = state.m3u.getNextSeekShouldSubtractChunks(playlistUrl);\n    let chunkIndex = null;\n    if (seekToSecondsToProcess !== null) {\n      chunkIndex = Math.max(0, getChunkToSeekTo({\n        chunks,\n        seekToSecondsToProcess: seekToSecondsToProcess.targetTime\n      }) - chunksToSubtract);\n    }\n    const currentPromise = {\n      resolver: () => {\n        return;\n      },\n      rejector: reject\n    };\n    const requiresHeaderToBeFetched = chunks[0].isHeader;\n    for (const chunk of chunks) {\n      const mp4HeaderSegment = state.m3u.getMp4HeaderSegment(playlistUrl);\n      if (requiresHeaderToBeFetched && mp4HeaderSegment && chunk.isHeader) {\n        continue;\n      }\n      if (chunkIndex !== null && chunks.indexOf(chunk) < chunkIndex && !chunk.isHeader) {\n        continue;\n      }\n      currentPromise.resolver = (newRun) => {\n        state.m3u.setM3uStreamRun(playlistUrl, newRun);\n        resolve();\n      };\n      currentPromise.rejector = reject;\n      const childController = mediaParserController();\n      const forwarded = forwardMediaParserControllerPauseResume({\n        childController,\n        parentController: state.controller\n      });\n      const nextChunk = chunks[chunks.indexOf(chunk) + 1];\n      if (nextChunk) {\n        const nextChunkSource = state.readerInterface.createAdjacentFileSource(nextChunk.url, playlistUrl);\n        state.readerInterface.preload({\n          logLevel: state.logLevel,\n          range: null,\n          src: nextChunkSource,\n          prefetchCache: state.prefetchCache\n        });\n      }\n      const makeContinuationFn = () => {\n        return {\n          continue() {\n            const resolver = withResolvers();\n            currentPromise.resolver = resolver.resolve;\n            currentPromise.rejector = resolver.reject;\n            childController.resume();\n            return resolver.promise;\n          },\n          abort() {\n            childController.abort();\n          }\n        };\n      };\n      const isLastChunk = chunk === chunks[chunks.length - 1];\n      await childController._internals.checkForAbortAndPause();\n      const src = state.readerInterface.createAdjacentFileSource(chunk.url, playlistUrl);\n      try {\n        const data = await parseMedia({\n          src,\n          acknowledgeRemotionLicense: true,\n          logLevel: state.logLevel,\n          controller: childController,\n          progressIntervalInMs: 0,\n          onParseProgress: () => {\n            childController.pause();\n            currentPromise.resolver(makeContinuationFn());\n          },\n          fields: chunk.isHeader ? { slowStructure: true } : undefined,\n          onTracks: () => {\n            if (!state.m3u.hasEmittedDoneWithTracks(playlistUrl)) {\n              state.m3u.setHasEmittedDoneWithTracks(playlistUrl);\n              const allDone = state.m3u.setTracksDone(playlistUrl);\n              if (allDone) {\n                state.callbacks.tracks.setIsDone(state.logLevel);\n              }\n              return null;\n            }\n          },\n          onAudioTrack: onGlobalAudioTrack === null ? null : async ({ track }) => {\n            const callbackOrFalse = state.m3u.hasEmittedAudioTrack(playlistUrl);\n            if (callbackOrFalse === false) {\n              const callback = await onGlobalAudioTrack(track);\n              if (!callback) {\n                state.m3u.setHasEmittedAudioTrack(playlistUrl, null);\n                return null;\n              }\n              state.m3u.setHasEmittedAudioTrack(playlistUrl, callback);\n              return async (sample) => {\n                await considerSeekBasedOnChunk({\n                  sample,\n                  callback,\n                  parentController: state.controller,\n                  childController,\n                  m3uState: state.m3u,\n                  playlistUrl,\n                  subtractChunks: chunksToSubtract,\n                  chunkIndex\n                });\n              };\n            }\n            if (callbackOrFalse === null) {\n              return null;\n            }\n            return async (sample) => {\n              await considerSeekBasedOnChunk({\n                sample,\n                m3uState: state.m3u,\n                playlistUrl,\n                callback: callbackOrFalse,\n                parentController: state.controller,\n                childController,\n                subtractChunks: chunksToSubtract,\n                chunkIndex\n              });\n            };\n          },\n          onVideoTrack: onGlobalVideoTrack === null ? null : async ({ track }) => {\n            const callbackOrFalse = state.m3u.hasEmittedVideoTrack(playlistUrl);\n            if (callbackOrFalse === false) {\n              const callback = await onGlobalVideoTrack({\n                ...track,\n                m3uStreamFormat: chunk.isHeader || mp4HeaderSegment ? \"mp4\" : \"ts\"\n       ","size_bytes":360000},"app/api/download/route.ts":{"content":"import { NextRequest, NextResponse } from 'next/server'\nimport { generateSASUrl } from '@/lib/azure-blob'\n\nexport const dynamic = 'force-dynamic'\nexport const runtime = 'nodejs'\n\nfunction validateBlobName(input: unknown): string | null {\n  if (typeof input !== 'string') return null\n  const name = input.trim()\n  if (!name || name.includes('..')) return null\n  return name\n}\n\nexport async function GET(req: NextRequest) {\n  try {\n    const url = new URL(req.url)\n    const blobName = validateBlobName(url.searchParams.get('blobName'))\n    const filename = (url.searchParams.get('filename') || 'chat-video.mp4').replace(/[^A-Za-z0-9_.-]/g, '')\n    const expParam = url.searchParams.get('exp')\n    let expiryMinutes = 60\n    if (expParam) {\n      const n = Number(expParam)\n      if (Number.isFinite(n)) expiryMinutes = Math.min(1440, Math.max(1, Math.trunc(n)))\n    }\n    if (!blobName) {\n      return NextResponse.json({ error: 'Missing or invalid blobName' }, { status: 400, headers: { 'Cache-Control': 'no-store' } })\n    }\n\n    const sas = generateSASUrl(blobName, expiryMinutes)\n    const azureResp = await fetch(sas, { cache: 'no-store' })\n    if (!azureResp.ok || !azureResp.body) {\n      const txt = await azureResp.text().catch(() => '')\n      return NextResponse.json({ error: 'Blob fetch failed', status: azureResp.status, details: txt.slice(0, 200) }, { status: 502, headers: { 'Cache-Control': 'no-store' } })\n    }\n\n    const headers = new Headers()\n    headers.set('Content-Type', azureResp.headers.get('content-type') || 'video/mp4')\n    const len = azureResp.headers.get('content-length')\n    if (len) headers.set('Content-Length', len)\n    headers.set('Cache-Control', 'no-store')\n    headers.set('Content-Disposition', `attachment; filename=\"${filename}\"`)\n\n    return new Response(azureResp.body, { status: 200, headers })\n  } catch (e: any) {\n    return NextResponse.json({ error: e?.message || 'Download failed' }, { status: 500, headers: { 'Cache-Control': 'no-store' } })\n  }\n}\n","size_bytes":2001},"app/api/get-download-url/route.ts":{"content":"import { NextRequest, NextResponse } from 'next/server';\nimport { generateSASUrl } from '@/lib/azure-blob';\n\nexport const dynamic = 'force-dynamic';\nexport const runtime = 'nodejs';\n\nfunction validateBlobName(input: unknown): string | null {\n  if (typeof input !== 'string') return null;\n  const name = input.trim();\n  if (!name) return null;\n  // Basic safety: disallow parent directory segments\n  if (name.includes('..')) return null;\n  return name;\n}\n\nexport async function GET(req: NextRequest) {\n  if (req.method !== 'GET') {\n    return NextResponse.json({ error: 'Method Not Allowed' }, { status: 405, headers: { Allow: 'GET' } });\n  }\n\n  try {\n    const url = new URL(req.url);\n    const blobNameRaw = url.searchParams.get('blobName');\n    const blobName = validateBlobName(blobNameRaw);\n    if (!blobName) {\n      return NextResponse.json({ error: 'Missing or invalid blobName' }, { status: 400, headers: { 'Cache-Control': 'no-store' } });\n    }\n\n    // Optional expiry in minutes (default 60). Bound between 1 and 1440.\n    const exp = url.searchParams.get('exp');\n    let expiryMinutes = 60;\n    if (exp) {\n      const n = Number(exp);\n      if (Number.isFinite(n)) expiryMinutes = Math.min(1440, Math.max(1, Math.trunc(n)));\n    }\n\n    const signed = generateSASUrl(blobName, expiryMinutes);\n    return NextResponse.json({ url: signed }, { headers: { 'Cache-Control': 'no-store' } });\n  } catch (e: any) {\n    return NextResponse.json({ error: e?.message || 'Failed to generate download URL' }, { status: 500, headers: { 'Cache-Control': 'no-store' } });\n  }\n}\n","size_bytes":1573}},"version":1}